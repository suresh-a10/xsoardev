category: Analytics & SIEM
commonfields:
  id: Microsoft Graph Test
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Host URL
  name: host
  required: true
  section: Connect
  type: 0
- defaultvalue: Alerts v2
  display: MS graph security alert API Version
  name: api_version
  options:
  - Legacy Alerts
  - Alerts v2
  required: false
  section: Connect
  type: 15
- display: ""
  displaypassword: Application ID or Client ID
  hiddenusername: true
  name: creds_auth_id
  required: false
  section: Connect
  type: 9
- display: ""
  displaypassword: Token or Tenant ID
  hiddenusername: true
  name: creds_tenant_id
  required: false
  section: Connect
  type: 9
- display: ""
  displaypassword: Key or Client Secret
  hiddenusername: true
  name: creds_enc_key
  required: false
  section: Connect
  type: 9
- additionalinfo: See the Help tab.
  display: Application ID or Client ID
  hidden: true
  name: auth_id
  required: false
  section: Connect
  type: 4
- additionalinfo: See the Help tab.
  display: Token or Tenant ID
  hidden: true
  name: tenant_id
  required: false
  section: Connect
  type: 4
- additionalinfo: See the Help tab.
  display: Key or Client Secret
  hidden: true
  name: enc_key
  required: false
  section: Connect
  type: 4
- display: Certificate Thumbprint
  displaypassword: Private Key
  name: creds_certificate
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication as it appears in the "Certificates
    & secrets" page of the app.
  display: Certificate Thumbprint
  hidden: true
  name: certificate_thumbprint
  required: false
  section: Connect
  type: 4
- additionalinfo: Used for certificate authentication. The private key of the registered
    certificate.
  display: Private Key
  hidden: true
  name: private_key
  required: false
  section: Connect
  type: 14
- display: Application redirect URI (for self-deployed mode)
  name: redirect_uri
  required: false
  section: Connect
  type: 0
- additionalinfo: Get the authorization code from steps 3-5 in the self deployed authorization
    process.
  display: Authorization code
  displaypassword: Authorization code
  hiddenusername: true
  name: auth_code
  required: false
  section: Connect
  type: 9
- additionalinfo: Relevant only if the integration is running on Azure VM. If selected,
    authenticates based on the value provided for the Azure Managed Identities Client
    ID field. If no value is provided for the Azure Managed Identities Client ID field,
    authenticates based on the System Assigned Managed Identity. For additional information,
    see the Help tab.
  display: Use Azure Managed Identities
  name: use_managed_identities
  required: false
  section: Connect
  type: 8
- additionalinfo: The Managed Identities client ID for authentication - relevant only
    if the integration is running on Azure VM.
  display: ""
  displaypassword: Azure Managed Identities Client ID
  hiddenusername: true
  name: managed_identities_client_id
  required: false
  section: Connect
  type: 9
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- additionalinfo: Select this checkbox if you are using a self-deployed Azure application.
  advanced: true
  display: Use a self-deployed Azure application
  name: self_deployed
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  section: Collect
  type: 19
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: <number> <time unit>, for example 1 hour, 30 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  section: Collect
  type: 0
- defaultvalue: "10"
  display: Max incidents per fetch
  name: fetch_limit
  required: false
  section: Collect
  type: 0
- additionalinfo: Relevant only for Legacy Alerts. Multiple providers can be inserted
    separated by a comma, for example "{first_provider},{second_provider}". If empty,
    incidents of all providers will be fetched.
  advanced: true
  display: Fetch incidents of the given providers only.
  name: fetch_providers
  required: false
  section: Collect
  type: 0
- additionalinfo: Relevant only for Alerts v2. Multiple serviceSource can be inserted
    separated by a comma, for example "microsoftDefenderForEndpoint,microsoftDefenderForIdentity",.
    If empty, incidents of all providers will be fetched.
  advanced: true
  display: Fetch incidents of the given service sources only.
  name: fetch_service_sources
  required: false
  section: Collect
  type: 0
- additionalinfo: Use this field to filter fetched incidents according to any of the
    alert properties. Overrides the providers list, if given. Filter should be in
    the format "{property} eq '{property-value}'". Multiple filters can be applied
    separated with " and ", for example "createdDateTime eq YYYY-MM-DD and severity
    eq 'high'".
  advanced: true
  display: Fetched incidents filter
  name: fetch_filter
  required: false
  section: Collect
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Unified gateway to security insights - all from a unified Microsoft Graph
  Security API.
detaileddescription: |-
  # Authentication
  You can authenticate either by Azure Active Directory applications or by Azure Managed Identities.
  ### Important
  1. eDiscovery commands only support the `Delegated (work or school account)` (Authorization Code Flow) permission type.
  2. When using Authorization Code Flow, the connection should be tested using the `!msg-auth-test` command.

  ## Authentication Using the Authorization Code Flow(recommended)

  For instructions on how to do this, see [here](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#authorize-on-behalf-of-a-user).


  ### Authentication Based on Azure Active Directory Applications

  Microsoft integrations (Graph and Azure) in Cortex XSOAR use Azure Active Directory applications to authenticate with Microsoft APIs. These integrations use OAuth 2.0 and OpenID Connect standard compliant authentication services, which use an application to sign in or delegate authentication. For more information, see the Microsoft identity platform overview.

  There are two application authentication methods available:

   * [Cortex XSOAR Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#cortex-xsoar-application)
   * [Self-Deployed Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#self-deployed-application)

  Depending on the authentication method that you use, the integration parameters might change.

  To allow us to access to Microsoft Graph Security, an admin has to approve our app using an admin consent flow, by clicking this [link](https://oproxy.demisto.ninja/ms-graph-security).
  After authorizing the Cortex XSOAR app, you will get an ID, Token, and Key which should be inserted in the integration instance settings fields.
  If you previously had an API V1 configured based on the credentials obtained from this method, refer to the link above to gain new credentials with the relevant permissions.

  ### Authentication Based on Azure Managed Identities
  ##### Note: This option is relevant only if the integration is running on Azure VM.
  Follow one of these steps for authentication based on Azure Managed Identities:

  - ##### To use System Assigned Managed Identity
     - Select the **Use Azure Managed Identities** checkbox and leave the **Azure Managed Identities Client ID** field empty.

  - ##### To use User Assigned Managed Identity
     1. Go to [Azure Portal](https://portal.azure.com/) -> **Managed Identities**.
     2. Select your User Assigned Managed Identity -> copy the Client ID -> paste it in the **Azure Managed Identities Client ID** field in the instance settings.
     3. Select the **Use Azure Managed Identities** checkbox.

  For more information, see [Managed identities for Azure resources](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview).


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/microsoft-graph-test)
display: Microsoft Graph Security Test
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAC+9JREFUeAHtWXtwVNUZP+c+du9udiGB8DBjImkFWrRTpB1ardToQAVEyggZx9ZSBOQ5FAgJFGw1UssrD94BeQz4oB3hj7ZDBdERqUPRGW1x6kyAgI0ELIRHXvu+ex/9fQub7i7ZZBXoxJlzmMve+53vO4/f9zwnjIkmEBAICAQEAgIBgYBAQCAgEBAICAQEAgIBgYBAQCAgEBAICAQEAgIBgYBA4CYQ4JnInnrcm+tUXOWyxBxWJwJOzrnpZ4e3L22MuCw2Ro8wOx07p5k5M7nGlj/3Y3YhHZ+g3xwCSibi3JJ6MJvPcckSt+z0NuGSOQvIhmXbzO90s+lSelZGCo5GGYuE2GasQSg4E0V8BZ6MFGy54YlRFgyZdhZpL32TmG1Zum1Cd2HG4MFpGynYspjOLPwT7bYhkJGCb9vsYuAOEVi6dGlvy7LyWluVpq1bf/9Fh0wZEruNgouLix35+YU/kmVb1XU9vH79+qPYQ4fevXjx4sG2bd9Fe7xy5crxXbt2XYa8q6CgAOFevlNR+PTVq1c3ZIhBd2KTysrKSg3DXKiqan+PJ/IBFvfAzSxQuhnhWyk7cODAHEmy/yTLyiGnU3uvpKRkeEfjz5gxQ4V1v64o6iF6cnJyfkB8hYWFOZzLT7nd2qhw2BjckWx3p8Fwx2FPq2G8qmkay7HPXVgz6Yhj33csWLBgGL1/mX10Gw+mRWNDZjQatR0Oh4QN/hKkD1M3k52d/SDKgO/Dy01FUWTIxIqCNWvW/GfhwoWj/f5or1AocCRV7uvwjZrkYU1TWSQS3lhZWfFifM3Y13AY/V8NI1oH2oNxeia/3UrBOGWRtV6MRKIK3ieVlpa+UFlZeSlxIwhfz0qShPLNPovfQYl9a9eu/Vvid8q7NG3atOzc3FwT4bs1pa/9E57i3rZtW7CdgBeieb1et8/nC6b2JfJNmTIlu3///nzVqlU0/g3pZcyYMc6hQ4d6WltbIzU1Nf5EWXq3LCOmD1mWk/aMcO0FrU80qp9IlenqOyN3P1ncs1CLap/KMkcVnX5IHKOY6Y9u2lJ6OeBV2BIdlXS6Fq+iDYvdVz6W1S5btqyfrkdPwYobZJl9oGmuGYGAf1Z1dfXL8THmzp17V1aWp9YwrMOcWyqs+tFgMDBu3bp1bwJcrXfv3Fdsm/dDCf/0xo0bz5Mc5eb8/Py5AOgpOPs3YDg4CPCPkKefRCi0TJP9kaCVZQkh0V6JiHB3OBwaBQWcgYHdi5xexpj5MKIGUgC/inW/i2FXVFRUfBZfF0LnJEVxzuPc/g5oEoY9iwgzacOGDaeJZ968eXe6XK4yy+JjMVc/zOtH8DkWDodXo9b4aM6cOfkul+cPkB8Eo+2L/TVAqZewj/VY6z1Op/qEaVqDIOfDGk6Zpl3v97f+HMaGg2bnLaMcLAUZtzlXVXCrONymexT028yW4YdIpYCmiwfZRJW05JyCTcoI07sjcGM49DN79+6V41sASD9D+HbbtrEDG00yNQrraA/ACB+CktwkU1RUrqHwet3t9lSQckF6C4o6CKAKgsGgF0rA2NYI0B8xDPtVjHkvHr/T6WSU72AUhx0OZTL46wH0XiiuBUY1Fd9vLVmypIDmQN6cANpejDME/a8Agc22LbVhPb2on/jQ/47D4fwV5HxQMsbhZwDQRE3TDi1a9OvvZWVlQVEmKeu614OLW9g/RxqSDKzdpLEgDzUwA2x4MmuxkNAVq8vdGlHCkX9y03LhwiMtu6TITDODDVhpKBRh/8KSk5SQKohoEMWWQsl02wHwP5Yk+QiseOTRo/+gIuoYeSL2NzUUCtWfP3/+7fz8gvnJcti2ZesEABQTm3fYsLZfuFxZT8AjTyK8jY97FIXSxsbGEIVLRI0wlNFX141/NzVdnQxZX3NzM4dhHFJVR59wOPK7qqqq52kuihJ9+khvuN1Z40Oh4AKQSgyDjfN6Ne7zta1GtKmMr6m4uNxB76Zp/gb830I02tPQ0DB13759OtFRLa9DlJofjYaWIxo8BtIjKCw3uN3ueT5foAphfhPxUYMRHUa9cRg5+DhqjaIYMcP/MlLwhJH7m/PYHS9ItqFw6Rp4HY0vWwoPMsfnb7TdY4a97LRppVcwuaUBd29uYpfKkwbjjEIPwuMOADzKNINT0H0sL69wlMvlvBshuRwghUpKytJGn7iC4QHFNDTC26q4cul79+7dLfQ7ZMgQL7yNQwmWYURe3LlzZxPRMXchPP1+hNCr8MoNRKMGufCiRYtqEGHGQ6SIaOj/BBEDN3PyXCjC39bWtn/r1q1f7NtXrmOcLBjlKBiliWhRFVcuycGIa1AQz0YgGk7n3pUrV14FOeY9shyrnIkt3mJ7xTzpvSvOmfKbkYJ7SwP7RRyOP0uSAi+6oXZoH1J2uFgooG6G6UadMltgtQfXdpb2F8rBMACjt4N9F8Ta9g680JkYABwAyGfBNxGgLkPImgqQIuGwvSeRt6N3hPcYGVEgD8qg4iVp/EQZAMwNw/DDi8/F6ZDJRVh1QvGfobBKKsigsIvgZ5LEe1DR1Nx8ZYck9RmAHD4ToX2L18tfgiduHDx48Ira2loPjDQHMkGs6WJ8fPpFeG6CwtrwmoWI4cUvKfiWt7RecMNMNtRhmYx38lC/hRoGYTd2AQkJUmLaB7ZixeJVymTISRJVmQDxNQDdC7l1GYx7JIA9WFOz9kwKe9pPeFkI3gzv4n3TMqED/UlWi28/lGvCuHoFAnmuRFnLknIQLmE0vNXj8Rjk1VVVFaUw/KGBQKjMtk0dIbn85MnTM+vq6hApbEpBGkJvduI4mMOLGsMDWgBneV9iX7p34NBpyutILnMFdyR9m2nBoPIaLD8AFcyDorIA1vZMpoQCYqFMktj7pGBZdsxHVCAwY23GjHI3jj4qvLZDwFpaWupRztSiMOrft69/clyOfqHbZ1AbwCisdxFyTVTIPYhOVXV1dUUlvPV5KAIebo84ePBgBN8fojiEiDqT+OIN3vu0y6VpMKK/IzzHUkO8L/UXESW2H8jEisfU/s6+MwrRnQ1wK/tQJKmw7PY1bd68sq6kZNE78OgJCNm1TU1Nh+PzAUDlGpD/+5sVPF4BoAo5H/EFg9Y61Hs/BZCjCgoKj6KweRP9DpxSHpLl7Al4J++i+VTijzfySlwu/NYwpH2qKm9ELr0f4NZhvh8iooxGTj0Bw8HYjMFIVqJSzoYS3sfaNRjjdPDCw633qB+KXY5CbQRC9XzUDd9EPPsY54tvozp/EinnMmTKwRY3NJn2BPEkx8NcF8GLCloahj28jLHPIvxXkQHRHJ21pIE6Y7zdffBUOgogV/LTqHDjG4b3SVsQmgEuryHgE9ZRD1BPY7OxCwMAgPOtVYeH8m1s4zU11eeQtscA4L04PhVgbAr1c+GdjX6/vw0KRmiWTiLXn8A4SUcPXJr8BVXrBHjYUchMxLGmHL/DcXp71efTx9LNGa0FCjkLJT0K8Lfgqca3ExVz6fHjx3dQP6rh47haH4Mq/gD2UETjIO8/hqn348ZqNDz/E+K73i5gr9iTlJSPcdlTi7Ffwjyg82ex3sdxtsfau24xS++K7SfbTxYyVf4UDpKFvwemZZdQZPnDjk1v5+TqPJuV0J8M0zUAR0Ppts7u806IFVkcRYsDec1OrDZJvqioSDty5EjSaFSIUa6G0imNxxZFNCiOw7KJ1m4kNAZCaR9N69lDVS3/ihUrGomGFpuTXjqSIToanzXruTyvV9cQQZrjlfa1rmv/z549O6dnz545Pl/UDASuNqYYYjsrXea0tIS8brfclnpDR0zYpzJgwAAlEAhEKfy3C15/oT1gHk99ff3VPXv2UIHWZetOCu5ysYLhyyPQbUL0l1+6kMgEAaHgTFD6GvO0V6yd7cGSdZSnboXjjNBpDsblM47BdA+D22iUp3jSNcrBURsVbMpddDp+Qf9qCGSk4IAn54K3NUB/CelEZTgAYA26qZ7Tcd/h0NmBcMotc+ISFRwo0KwAZ5/H3sR/AgGBgEBAICAQEAgIBAQCAgGBgEBAICAQEAgIBAQCAgGBgEBAICAQEAgIBAQCAgGBwP8Zgf8CqLeLzH1CkPwAAAAASUVORK5CYII=
name: Microsoft Graph Test
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: When the alert was last modified in the following string format
        - YYYY-MM-DD.
      name: last_modified
      predefined:
      - Last24Hours
      - Last48Hours
      - LastWeek
    - auto: PREDEFINED
      description: Alert severity - set by vendor/provider.
      name: severity
      predefined:
      - unknown
      - informational
      - low
      - medium
      - high
    - description: Category of the alert, e.g. credentialTheft, ransomware (Categories
        can be added or removed by vendors.)
      name: category
    - description: The start time (creation time of alert) for the search in the following
        string format - YYYY-MM-DD.
      name: time_from
    - description: The end time (creation time of alert) for the search in the following
        string format -  YYYY-MM-DD.
      name: time_to
    - description: Use this field to filter on any of the alert properties in the
        format "{property} eq '{property-value}'", e.g. "category eq 'ransomware'".
      name: filter
    - auto: PREDEFINED
      description: Relevant only for Alerts v2. Use this field to filter by an alert's
        classification.
      name: classification
      predefined:
      - unknown
      - truePositive
      - falsePositive
      - benignPositive
    - auto: PREDEFINED
      description: Relevant only for Alerts v2. Use this field to filter the alerts
        by the service or product that created this alert.
      name: service_source
      predefined:
      - microsoftDefenderForEndpoint
      - microsoftDefenderForIdentity
      - microsoftDefenderForOffice365
      - microsoft365Defender
      - microsoftAppGovernance
      - microsoftDefenderForCloudApps
    - auto: PREDEFINED
      description: Relevant only for Alerts v2. Use this field to filter by alert's
        status.
      name: status
      predefined:
      - unknown
      - new
      - inProgress
      - resolved
    - description: Page number to return, zero indexed. The maximum number of alerts
        that can be skipped for Legacy Alerts is 500 (i.e., page * page_size must
        be <= 500).
      name: page
    - description: Number of results in a page. Default is 50. The limit for Legacy
        Alerts is 1000. The limit for Alerts v2 is 2000. When using Legacy Alerts,
        the response will provide <page_size> results for each provider.
      name: page_size
    - defaultValue: "50"
      description: Number of total results to return. Default is 50.
      name: limit
    description: List alerts (security issues) within a customer's tenant that Microsoft
      or partner security solutions have identified.
    name: msg-search-alerts
    outputs:
    - contextPath: MsGraph.Alert.ID
      description: Alert ID.
      type: string
    - contextPath: MsGraph.Alert.Title
      description: Alert title.
      type: string
    - contextPath: MsGraph.Alert.Category
      description: Alert category.
      type: string
    - contextPath: MsGraph.Alert.Severity
      description: Alert severity.
      type: string
    - contextPath: MsGraph.Alert.CreatedDate
      description: Alert created date.
      type: date
    - contextPath: MsGraph.Alert.EventDate
      description: Relevant only for Legacy Alerts. Alert event time.
      type: date
    - contextPath: MsGraph.Alert.Status
      description: Alert status.
      type: string
    - contextPath: MsGraph.Alert.Vendor
      description: Relevant only for Legacy Alerts. Alert vendor.
      type: string
    - contextPath: MsGraph.Alert.MalwareStates
      description: Relevant only for Legacy Alerts. Alert malware states.
      type: string
    - contextPath: MsGraph.Alert.Provider
      description: Relevant only for Legacy Alerts. Alert provider.
      type: string
    - contextPath: MsGraph.Alert.ActorDisplayName
      description: Relevant only for Alerts v2. Alert actor name.
      type: Unknown
    - contextPath: MsGraph.Alert.AlertWebUrl
      description: Relevant only for Alerts v2. Alert web URL.
      type: String
    - contextPath: MsGraph.Alert.AssignedTo
      description: Relevant only for Alerts v2. Alert assignee.
      type: Unknown
    - contextPath: MsGraph.Alert.Classification
      description: Relevant only for Alerts v2. Alert classification.
      type: Unknown
    - contextPath: MsGraph.Alert.Description
      description: Relevant only for Alerts v2. Alert description.
      type: String
    - contextPath: MsGraph.Alert.DetectionSource
      description: Relevant only for Alerts v2. Alert detection source.
      type: String
    - contextPath: MsGraph.Alert.DetectorId
      description: Relevant only for Alerts v2. Alert detector ID.
      type: String
    - contextPath: MsGraph.Alert.Determination
      description: Relevant only for Alerts v2. Alert determination.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.@odata.Type
      description: Relevant only for Alerts v2. Alert evidence type.
      type: String
    - contextPath: MsGraph.Alert.Evidence.AzureAdDeviceId
      description: Relevant only for Alerts v2. Evidence azure device ID.
      type: String
    - contextPath: MsGraph.Alert.Evidence.CreatedDate
      description: Relevant only for Alerts v2. Evidence creation time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.DefenderAvStatus
      description: Relevant only for Alerts v2. Evidence Defender AV status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.DeviceDnsName
      description: Relevant only for Alerts v2. Evidence device DNS name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FirstSeenDateTime
      description: Relevant only for Alerts v2. Evidence first seen time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.HealthStatus
      description: Relevant only for Alerts v2. Evidence health status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.MdeDeviceId
      description: Relevant only for Alerts v2. Evidence MDE device ID.
      type: String
    - contextPath: MsGraph.Alert.Evidence.OnboardingStatus
      description: Relevant only for Alerts v2. Evidence onboarding status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.OsBuild
      description: Relevant only for Alerts v2. Evidence OS build.
      type: Number
    - contextPath: MsGraph.Alert.Evidence.OsPlatform
      description: Relevant only for Alerts v2. Evidence OS platform.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RbacGroupId
      description: Relevant only for Alerts v2. Evidence RBAC group ID.
      type: Number
    - contextPath: MsGraph.Alert.Evidence.RbacGroupName
      description: Relevant only for Alerts v2. Evidence RBAC group name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RemediationStatus
      description: Relevant only for Alerts v2. Evidence remediation status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RemediationStatusDetails
      description: Relevant only for Alerts v2. Evidence remediation status details.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.RiskScore
      description: Relevant only for Alerts v2. Evidence risk score.
      type: String
    - contextPath: MsGraph.Alert.Evidence.Tags
      description: Relevant only for Alerts v2. Evidence tags.
      type: String
    - contextPath: MsGraph.Alert.Evidence.Verdict
      description: Relevant only for Alerts v2. Evidence verdict.
      type: String
    - contextPath: MsGraph.Alert.Evidence.Version
      description: Relevant only for Alerts v2. Evidence version.
      type: String
    - contextPath: MsGraph.Alert.Evidence.VmMetadata
      description: Relevant only for Alerts v2. Evidence VM metadata.
      type: Unknown
    - contextPath: MsGraph.Alert.FirstActivityDateTime
      description: Relevant only for Alerts v2. Evidence first activity time.
      type: Date
    - contextPath: MsGraph.Alert.IncidentId
      description: Relevant only for Alerts v2. Alert incident ID.
      type: String
    - contextPath: MsGraph.Alert.IncidentWebUrl
      description: Relevant only for Alerts v2. Alert incident URL.
      type: String
    - contextPath: MsGraph.Alert.LastActivityDateTime
      description: Relevant only for Alerts v2. Alert last activity time.
      type: Date
    - contextPath: MsGraph.Alert.LastUpdateDateTime
      description: Relevant only for Alerts v2. Alert last update time.
      type: Date
    - contextPath: MsGraph.Alert.ProviderAlertId
      description: Relevant only for Alerts v2. Alert provider ID.
      type: String
    - contextPath: MsGraph.Alert.RecommendedActions
      description: Relevant only for Alerts v2. Alert recommended action.
      type: String
    - contextPath: MsGraph.Alert.ResolvedDateTime
      description: Relevant only for Alerts v2. Alert closing time.
      type: Date
    - contextPath: MsGraph.Alert.ServiceSource
      description: Relevant only for Alerts v2. Alert service source.
      type: String
    - contextPath: MsGraph.Alert.TenantId
      description: Relevant only for Alerts v2. Alert tenant ID.
      type: String
    - contextPath: MsGraph.Alert.ThreatDisplayName
      description: Relevant only for Alerts v2. Alert threat display name.
      type: Unknown
    - contextPath: MsGraph.Alert.ThreatFamilyName
      description: Relevant only for Alerts v2. Alert threat family name.
      type: Unknown
  - arguments:
    - default: true
      description: The Alert ID - Provider-generated GUID/unique identifier.
      name: alert_id
      required: true
    - defaultValue: All
      description: 'Relevant only for Legacy Alerts. Fields to fetch for a specified
        alert apart from the basic properties, given as comma separated values, e.g.,
        NetworkConnections,Processes. The possible values are: All, NetworkConnections,
        Processes, RegistryKeys, UserStates, HostStates, FileStates, CloudAppStates,
        MalwareStates, CustomerComments, Triggers, VendorInformation, VulnerabilityStates.
        Default is All.'
      name: fields_to_include
    description: Get details for a specific alert.
    name: msg-get-alert-details
    outputs:
    - contextPath: MsGraph.Alert.ID
      description: Alert ID.
      type: string
    - contextPath: MsGraph.Alert.Title
      description: Alert title.
      type: string
    - contextPath: MsGraph.Alert.Category
      description: Alert category.
      type: string
    - contextPath: MsGraph.Alert.Severity
      description: Alert severity.
      type: string
    - contextPath: MsGraph.Alert.CreatedDate
      description: Alert created date.
      type: date
    - contextPath: MsGraph.Alert.EventDate
      description: Relevant only for Legacy Alerts. Alert event time.
      type: date
    - contextPath: MsGraph.Alert.Status
      description: Alert status.
      type: string
    - contextPath: MsGraph.Alert.Vendor
      description: Relevant only for Legacy Alerts. Alert vendor/provider.
      type: string
    - contextPath: MsGraph.Alert.Provider
      description: Relevant only for Legacy Alerts. Alert provider.
      type: string
    - contextPath: MsGraph.Alert.@odata.Context
      description: Relevant only for Alerts v2. Alert odata context.
      type: String
    - contextPath: MsGraph.Alert.ActorDisplayName
      description: Relevant only for Alerts v2. Alert actor name.
      type: Unknown
    - contextPath: MsGraph.Alert.AlertWebUrl
      description: Relevant only for Alerts v2. Alert web URL.
      type: String
    - contextPath: MsGraph.Alert.AssignedTo
      description: Relevant only for Alerts v2. Alert assignee.
      type: Unknown
    - contextPath: MsGraph.Alert.Classification
      description: Relevant only for Alerts v2. Alert classification.
      type: Unknown
    - contextPath: MsGraph.Alert.Comments.Comment
      description: Relevant only for Alerts v2. Alert comment.
      type: String
    - contextPath: MsGraph.Alert.Comments.CreatedByDisplayName
      description: Relevant only for Alerts v2. Alert comment creator name.
      type: String
    - contextPath: MsGraph.Alert.Comments.CreatedDate
      description: Relevant only for Alerts v2. Alert comment creation time.
      type: Date
    - contextPath: MsGraph.Alert.Description
      description: Relevant only for Alerts v2. Alert description.
      type: String
    - contextPath: MsGraph.Alert.DetectionSource
      description: Relevant only for Alerts v2. Alert detection source.
      type: String
    - contextPath: MsGraph.Alert.DetectorId
      description: Relevant only for Alerts v2. Alert detector ID.
      type: String
    - contextPath: MsGraph.Alert.Determination
      description: Relevant only for Alerts v2. Alert determination.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.@odata.Type
      description: Relevant only for Alerts v2. Alert evidence.
      type: String
    - contextPath: MsGraph.Alert.Evidence.CreatedDate
      description: Relevant only for Alerts v2. Evidence creation time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.DetectionStatus
      description: Relevant only for Alerts v2. Evidence detection status.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ImageFile.FileName
      description: Relevant only for Alerts v2. Evidence image file name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.ImageFile.FilePath
      description: Relevant only for Alerts v2. Evidence image file path.
      type: String
    - contextPath: MsGraph.Alert.Evidence.ImageFile.FilePublisher
      description: Relevant only for Alerts v2. Evidence image file publisher.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ImageFile.FileSize
      description: Relevant only for Alerts v2. Evidence image file size.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ImageFile.Issuer
      description: Relevant only for Alerts v2. Evidence image file issuer.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ImageFile.Sha1
      description: Relevant only for Alerts v2. Evidence image file SHA1 hash.
      type: String
    - contextPath: MsGraph.Alert.Evidence.ImageFile.Sha256
      description: Relevant only for Alerts v2. Evidence image file SHA256 hash.
      type: String
    - contextPath: MsGraph.Alert.Evidence.ImageFile.Signer
      description: Relevant only for Alerts v2. Evidence image file signer.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.MdeDeviceId
      description: Relevant only for Alerts v2. Evidence MDE device ID.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ParentProcessCreationDateTime
      description: Relevant only for Alerts v2. Evidence parent process creation time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.ParentProcessId
      description: Relevant only for Alerts v2. Evidence parent process process ID.
      type: Number
    - contextPath: MsGraph.Alert.Evidence.ParentProcessImageFile
      description: Relevant only for Alerts v2. Evidence parent process image file.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.ProcessCommandLine
      description: Relevant only for Alerts v2. Evidence process command line.
      type: String
    - contextPath: MsGraph.Alert.Evidence.ProcessCreationDateTime
      description: Relevant only for Alerts v2.  Evidence process creation time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.ProcessId
      description: Relevant only for Alerts v2.  Evidence process ID.
      type: Number
    - contextPath: MsGraph.Alert.Evidence.RemediationStatus
      description: Relevant only for Alerts v2. Evidence remediation status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RemediationStatusDetails
      description: Relevant only for Alerts v2. Evidence remediation status details.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.UserAccount.AccountName
      description: Relevant only for Alerts v2. Evidence user account name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.UserAccount.AzureAdUserId
      description: Relevant only for Alerts v2. Evidence user account Azure AD user
        ID.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.UserAccount.DisplayName
      description: Relevant only for Alerts v2. Evidence user account display name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.UserAccount.DomainName
      description: Relevant only for Alerts v2. Evidence user account domain name.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.UserAccount.UserPrincipalName
      description: Relevant only for Alerts v2. Evidence user account user principal
        name.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.UserAccount.UserSid
      description: Relevant only for Alerts v2. Evidence user account user SID.
      type: String
    - contextPath: MsGraph.Alert.Evidence.Verdict
      description: Relevant only for Alerts v2. Evidence verdict.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FileDetails.FileName
      description: Relevant only for Alerts v2. Evidence file details file name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FileDetails.FilePath
      description: Relevant only for Alerts v2. Evidence file details file path.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FileDetails.FilePublisher
      description: Relevant only for Alerts v2. Evidence file details file publisher.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.FileDetails.FileSize
      description: Relevant only for Alerts v2. Evidence file details file size.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.FileDetails.Issuer
      description: Relevant only for Alerts v2. Evidence file details file issuer.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.FileDetails.Sha1
      description: Relevant only for Alerts v2. Evidence file details SHA1 hash.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FileDetails.Sha256
      description: Relevant only for Alerts v2. Evidence file details SHA256 hash.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FileDetails.Signer
      description: Relevant only for Alerts v2. Evidence file details file signer.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.CֹountryLetterCode
      description: Relevant only for Alerts v2. Evidence country letter code.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.IpAddress
      description: Relevant only for Alerts v2. Evidence IP address.
      type: String
    - contextPath: MsGraph.Alert.Evidence.AzureAdDeviceId
      description: Relevant only for Alerts v2. Evidence Azure AD device ID.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.DefenderAvStatus
      description: Relevant only for Alerts v2. Evidence Defender AV status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.DeviceDnsName
      description: Relevant only for Alerts v2. Evidence device DNS name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.FirstSeenDateTime
      description: Relevant only for Alerts v2. Evidence first seen time.
      type: Date
    - contextPath: MsGraph.Alert.Evidence.HealthStatus
      description: Relevant only for Alerts v2. Evidence health status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.OnboardingStatus
      description: Relevant only for Alerts v2. Evidence onboarding status.
      type: String
    - contextPath: MsGraph.Alert.Evidence.OsBuild
      description: Relevant only for Alerts v2. Evidence OS build.
      type: Unknown
    - contextPath: MsGraph.Alert.Evidence.OsPlatform
      description: Relevant only for Alerts v2. Evidence OS platform.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RbacGroupId
      description: Relevant only for Alerts v2. Evidence RBAC group ID.
      type: Number
    - contextPath: MsGraph.Alert.Evidence.RbacGroupName
      description: Relevant only for Alerts v2. Evidence RBAC group name.
      type: String
    - contextPath: MsGraph.Alert.Evidence.RiskScore
      description: Relevant only for Alerts v2. Evidence risk score.
      type: String
    - contextPath: MsGraph.Alert.Evidence.Version
      description: Relevant only for Alerts v2. Evidence version.
      type: String
    - contextPath: MsGraph.Alert.Evidence.VmMetadata
      description: Relevant only for Alerts v2. Evidence VM metadata.
      type: Unknown
    - contextPath: MsGraph.Alert.FirstActivityDateTime
      description: Relevant only for Alerts v2. Evidence first activity time.
      type: Date
    - contextPath: MsGraph.Alert.IncidentId
      description: Relevant only for Alerts v2. Alert incident ID.
      type: String
    - contextPath: MsGraph.Alert.IncidentWebUrl
      description: Relevant only for Alerts v2. Alert incident URL.
      type: String
    - contextPath: MsGraph.Alert.LastActivityDateTime
      description: Relevant only for Alerts v2. Alert last activity time.
      type: Date
    - contextPath: MsGraph.Alert.LastUpdateDateTime
      description: Relevant only for Alerts v2. Alert last update time.
      type: Date
    - contextPath: MsGraph.Alert.ProviderAlertId
      description: Relevant only for Alerts v2. Alert provider ID.
      type: String
    - contextPath: MsGraph.Alert.RecommendedActions
      description: Relevant only for Alerts v2. Alert recommended action.
      type: String
    - contextPath: MsGraph.Alert.ResolvedDateTime
      description: Relevant only for Alerts v2. Alert closing time.
      type: Date
    - contextPath: MsGraph.Alert.ServiceSource
      description: Relevant only for Alerts v2. Alert service source.
      type: String
    - contextPath: MsGraph.Alert.TenantId
      description: Relevant only for Alerts v2. Alert tenant ID.
      type: String
    - contextPath: MsGraph.Alert.ThreatDisplayName
      description: Relevant only for Alerts v2. Alert threat display name.
      type: Unknown
    - contextPath: MsGraph.Alert.ThreatFamilyName
      description: Relevant only for Alerts v2. Alert threat family name.
      type: Unknown
  - arguments:
    - description: The Alert ID. Provider-generated GUID/unique identifier.
      name: alert_id
      required: true
    - description: Name of the analyst the alert is assigned to for triage, investigation,
        or remediation.
      name: assigned_to
    - description: Relevant only for Legacy Alerts. Time the alert was closed in the
        string format MM/DD/YYYY.
      name: closed_date_time
    - description: Relevant only for Legacy Alerts. Analyst comments on the alert
        (for customer alert management).
      name: comments
    - auto: PREDEFINED
      description: Relevant only for Legacy Alerts. Analyst feedback on the alert.
      name: feedback
      predefined:
      - unknown
      - truePositive
      - falsePositive
      - benignPositive
    - auto: PREDEFINED
      description: Alert lifecycle status (stage).
      name: status
      predefined:
      - unknown
      - newAlert
      - inProgress
      - resolved
    - description: Relevant only for Legacy Alerts. User-definable labels that can
        be applied to an alert and can serve as filter conditions, for example "HVA",
        "SAW).
      name: tags
    - description: Relevant only for Legacy Alerts. Details about the security service
        vendor, for example Microsoft.
      name: vendor_information
    - description: Relevant only for Legacy Alerts. Details about the security service
        vendor, for example Windows Defender ATP.
      name: provider_information
    - auto: PREDEFINED
      description: Relevant only for Alerts v2. Use this field to update the alert's
        classification.
      name: classification
      predefined:
      - unknown
      - truePositive
      - falsePositive
      - benignPositive
    - auto: PREDEFINED
      description: Relevant only for Alerts v2. Use this field to update the alert's
        determination.
      name: determination
      predefined:
      - unknown
      - apt
      - malware
      - phishing
      - other
      - securityPersonnel
      - securityTesting
      - multiStagedAttack
      - maliciousUserActivity
      - lineOfBusinessApplication
      - unwantedSoftware
    description: Update an editable alert property within any integrated solution
      to keep alert status and assignments in sync across solutions using its reference
      ID.
    name: msg-update-alert
    outputs:
    - contextPath: MsGraph.Alert.ID
      description: Alert ID.
      type: string
    - contextPath: MsGraph.Alert.Status
      description: Alert status, will appear only if changed.
      type: string
  - arguments:
    - default: true
      description: The alert ID - Provider-generated GUID/unique identifier.
      name: alert_id
      required: true
    - description: The comment to add to each alert.
      isArray: true
      name: comment
      required: true
      type: string
    description: Relevant only for Alerts v2. create a comment for an existing alert.
    name: msg-create-alert-comment
    outputs:
    - contextPath: MsGraph.AlertComment.ID
      description: The alert ID that the comment was added to.
      type: String
    - contextPath: MsGraph.AlertComment.Comments.Comment
      description: The comment itself.
      type: String
    - contextPath: MsGraph.AlertComment.Comments.CreatedByDisplayName
      description: The comment's creator display name.
      type: String
    - contextPath: MsGraph.AlertComment.Comments.CreatedDate
      description: The comment's creation time.
      type: Date
  - arguments: []
    deprecated: true
    description: Deprecated. Use the Azure Active Directory Users integration instead.
    name: msg-get-users
    outputs:
    - contextPath: MsGraph.User.Email
      description: User email address.
      type: string
    - contextPath: MsGraph.User.ID
      description: User ID.
      type: string
    - contextPath: MsGraph.User.Title
      description: User job title.
      type: string
    - contextPath: MsGraph.User.Name
      description: User name.
      type: string
  - arguments:
    - default: true
      description: User ID of user to retreive.
      name: user_id
      required: true
    deprecated: true
    description: Deprecated. Use the Azure Active Directory Users integration instead.
    name: msg-get-user
    outputs:
    - contextPath: MsGraph.User.Email
      description: User email address.
      type: string
    - contextPath: MsGraph.User.ID
      description: User ID.
      type: string
    - contextPath: MsGraph.User.Title
      description: User job title.
      type: string
    - contextPath: MsGraph.User.Name
      description: User name.
      type: string
  - arguments: []
    description: Run this command if for some reason you need to rerun the authentication
      process.
    name: ms-graph-security-auth-reset
  - arguments:
    - auto: PREDEFINED
      defaultValue: all
      description: Which permissions the integration should have.
      isArray: true
      name: permission_type
      predefined:
      - ediscovery
      - alerts
      - threat assessment
      - all
    description: Tests connectivity to Microsoft Graph Security.
    name: msg-auth-test
  - arguments: []
    description: Generate the login URL used for authorization code flow.
    name: msg-generate-login-url
  - arguments:
    - description: The name of the eDiscovery case.
      name: display_name
      required: true
    - description: The case description.
      name: description
    - description: The external case number for customer reference.
      name: external_id
    description: Create a new eDiscovery case. This command only creates an eDiscovery
      (Premium) case using the new case format. To learn more about the new case format
      in eDiscovery, see https://learn.microsoft.com/en-us/microsoft-365/compliance/advanced-ediscovery-new-case-format.
    name: msg-create-ediscovery-case
    outputs:
    - contextPath: MsGraph.eDiscoveryCase.CaseId
      description: The ID of the eDiscovery case.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.CaseStatus
      description: 'The case status. Possible values are: unknown, active, pendingDelete,
        closing, closed, and closedWithError.'
      type: String
    - contextPath: MsGraph.eDiscoveryCase.CreatedDateTime
      description: The date and time when the entity was created. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
      type: Date
    - contextPath: MsGraph.eDiscoveryCase.Description
      description: The case description.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.DisplayName
      description: The case name.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.ExternalId
      description: The external case number for customer reference.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.LastModifiedDateTime
      description: The latest date and time when the case was modified. The Timestamp
        type represents date and time information using ISO 8601 format and is always
        in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    description: |-
      Close an eDiscovery case. When the legal case or investigation supported by a eDiscovery (Standard) case is completed, you can close the case. Here's what happens when you close a case:
      If the case contains any eDiscovery holds, they'll be turned off. After the hold is turned off, a 30-day grace period (called a delay hold) is applied to content locations that were on hold. This helps prevent content from being immediately deleted and provides admins the opportunity to search for and restore content before it may be permanently deleted after the delay hold period expires. For more information, see Removing content locations from an eDiscovery hold.
      Closing a case only turns off the holds that are associated with that case. If other holds are placed on a content location (such as a Litigation Hold, a retention policy, or a hold from a different eDiscovery (Standard) case) those holds will still be maintained.
      The case is still listed on the eDiscovery (Standard) page in the Microsoft Purview compliance portal. The details, holds, searches, and members of a closed case are retained.
      You can edit a case after it's closed. For example, you can add or remove members, create searches, and export search results. The primary difference between active and closed cases is that eDiscovery holds are turned off when a case is closed.
    name: msg-close-ediscovery-case
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    description: Reopen an eDiscovery case. When you reopen an eDiscovery (Premium)
      case, any holds that were in place when the case was closed won't be automatically
      reinstated. After the case is reopened, you'll have to go to the Holds tab and
      turn on the previous holds. To turn on a hold, select it to display the flyout
      page, and then set the Status toggle to On.
    name: msg-reopen-ediscovery-case
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    description: Delete an eDiscovery case. Before you can delete a case, you must
      first delete all holds listed on the holds page of the case. That includes deleting
      holds with a status of Off. Default hold policies can only be deleted when the
      hold is turned off. You must close an active case to turn off any default hold
      policies in the case. Once the holds are turned off for default hold policies,
      they can be deleted.
    name: msg-delete-ediscovery-case
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The name of the eDiscovery case.
      name: display_name
      required: true
    - description: The case description.
      name: description
    - description: The external case number for customer reference.
      name: external_id
    description: Update an eDiscovery case.
    name: msg-update-ediscovery-case
  - arguments:
    - description: The ID of the eDiscovery case. If provided, only this ID will be
        returned.
      name: case_id
    - defaultValue: "50"
      description: The maximum number of results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Lists edicovery cases.
    name: msg-list-ediscovery-cases
    outputs:
    - contextPath: MsGraph.eDiscoveryCase.CaseId
      description: The ID of the eDiscovery case.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.CaseStatus
      description: 'The case status. Possible values are: unknown, active, pendingDelete,
        closing, closed, and closedWithError.'
      type: String
    - contextPath: MsGraph.eDiscoveryCase.CreatedDateTime
      description: The date and time when the entity was created. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
      type: Date
    - contextPath: MsGraph.eDiscoveryCase.Description
      description: The case description.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.DisplayName
      description: The case name.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.ExternalId
      description: The external case number for customer reference.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.LastModifiedDateTime
      description: The latest date and time when the case was modified. The Timestamp
        type represents date and time information using ISO 8601 format and is always
        in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
      type: Date
    - contextPath: MsGraph.eDiscoveryCase.ClosedBy.User.DisplayName
      description: The user who closed the case.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.LastModifiedBy.User.DisplayName
      description: The user who last modified the case.
      type: String
    - contextPath: MsGraph.eDiscoveryCase.ClosedDateTime
      description: The date and time when the case was closed. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: Custodian's primary SMTP address.
      name: email
      required: true
    description: Create a new ediscoveryCustodian object. After the custodian object
      is created, you will need to create the custodian's userSource to reference
      their mailbox and OneDrive for Business site.
    name: msg-create-ediscovery-custodian
    outputs:
    - contextPath: MsGraph.eDiscoveryCustodian.CreatedDateTime
      description: Date and time when the custodian was added to the case.
      type: Date
    - contextPath: MsGraph.eDiscoveryCustodian.CustodianId
      description: The ID for the custodian in the specified case. Read-only.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.CustodianStatus
      description: 'Status of the custodian. Possible values are: active, released.'
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.DisplayName
      description: Display name of the custodian.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.Email
      description: Email address of the custodian.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.HoldStatus
      description: 'The hold status of the custodian.The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.LastModifiedDateTime
      description: Date and time the custodian object was last modified.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case. If provided,
        only this ID will be returned.
      name: custodian_id
    - defaultValue: "50"
      description: Number of total results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: List custodians on a given eDiscovery case.
    name: msg-list-ediscovery-custodians
    outputs:
    - contextPath: MsGraph.eDiscoveryCustodian.CreatedDateTime
      description: Date and time when the custodian was added to the case.
      type: Date
    - contextPath: MsGraph.eDiscoveryCustodian.CustodianId
      description: The ID for the custodian in the specified case. Read-only.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.CustodianStatus
      description: 'Status of the custodian. Possible values are: active, released.'
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.DisplayName
      description: Display name of the custodian.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.Email
      description: Email address of the custodian.
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.HoldStatus
      description: 'The hold status of the custodian. The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.eDiscoveryCustodian.LastModifiedDateTime
      description: Date and time the custodian object was last modified.
      type: Date
    - contextPath: MsGraph.eDiscoveryCustodian.ReleasedDateTime
      description: Date and time the custodian was released from the case.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    description: Release a custodian from a case. For details, see https://learn.microsoft.com/en-us/microsoft-365/compliance/manage-new-custodians#release-a-custodian-from-a-case.
    name: msg-release-ediscovery-custodian
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    description: Activate a custodian that has been released from a case to make them
      part of the case again. For details, see https://learn.microsoft.com/en-us/microsoft-365/compliance/ediscovery-manage-new-custodians?view=o365-worldwide#re-activate-custodian.
    name: msg-activate-ediscovery-custodian
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    - description: SMTP address of the user.
      name: email
      required: true
    - auto: PREDEFINED
      description: Specifies which sources are included in this group.
      isArray: true
      name: included_sources
      predefined:
      - mailbox
      - site
      - mailbox, site
      required: true
    description: Create a new userSource object associated with an eDiscovery custodian.
      Use the msg-list-ediscovery-custodians command in order to get all available
      custodians.
    name: msg-create-ediscovery-custodian-user-source
    outputs:
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.Application.DisplayName
      description: The name of the application who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.Application.ID
      description: The ID of the application who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.DisplayName
      description: The name of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.ID
      description: The ID of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedDateTime
      description: The date and time the userSource was created.
      type: Date
    - contextPath: MsGraph.CustodianUserSource.DisplayName
      description: The display name associated with the mailbox and site.
      type: String
    - contextPath: MsGraph.CustodianUserSource.Email
      description: Email address of the user's mailbox.
      type: String
    - contextPath: MsGraph.CustodianUserSource.HoldStatus
      description: 'The hold status of the userSource. The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.CustodianUserSource.IncludedSources
      description: 'Specifies which sources are included in this group. Possible values
        are: mailbox, site.'
      type: String
    - contextPath: MsGraph.CustodianUserSource.UserSourceId
      description: The ID of the userSource. This is not the ID of the actual group.
      type: String
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    - description: URL of the site, for example, https://contoso.sharepoint.com/sites/HumanResources.
      name: site
      required: true
    description: Create a new siteSource object associated with an eDiscovery custodian.
      Use the msg-list-ediscovery-custodians command in order to get all available
      custodians.
    name: msg-create-ediscovery-custodian-site-source
    outputs:
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.Application.DisplayName
      description: The name of the application who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.Application.ID
      description: The ID of the application who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.DisplayName
      description: The name of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.ID
      description: The ID of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedDateTime
      description: The date and time the siteSource was created.
      type: Date
    - contextPath: MsGraph.CustodianSiteSource.DisplayName
      description: The display name of the siteSource. This will be the name of the
        SharePoint site.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.HoldStatus
      description: 'The hold status of the siteSource. The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.CustodianSiteSource.SiteSourceId
      description: The ID of the siteSource.
      type: String
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    - description: The ID of the userSource. If provided, only this ID will be returned.
      name: user_source_id
    - defaultValue: "50"
      description: Number of total results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Get a list of the userSource objects associated with an eDiscoveryCustodian.
      Use the msg-list-ediscovery-custodians command in order to get all available
      custodians.
    name: msg-list-ediscovery-custodian-user-sources
    outputs:
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.Application.DisplayName
      description: The name of the application who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.Application.ID
      description: The ID of the application who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.DisplayName
      description: The name of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.ID
      description: The ID of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the userSource.
      type: String
    - contextPath: MsGraph.CustodianUserSource.CreatedDateTime
      description: The date and time the userSource was created.
      type: Date
    - contextPath: MsGraph.CustodianUserSource.DisplayName
      description: The display name associated with the mailbox and site.
      type: String
    - contextPath: MsGraph.CustodianUserSource.Email
      description: Email address of the user's mailbox.
      type: String
    - contextPath: MsGraph.CustodianUserSource.HoldStatus
      description: 'The hold status of the userSource. The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.CustodianUserSource.IncludedSources
      description: 'Specifies which sources are included in this group. Possible values
        are: mailbox, site.'
      type: String
    - contextPath: MsGraph.CustodianUserSource.SiteWebUrl
      description: The URL of the user's OneDrive for Business site. Read-only.
      type: String
    - contextPath: MsGraph.CustodianUserSource.UserSourceId
      description: The ID of the userSource. This is not the ID of the actual group.
      type: String
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the custodian on the given eDiscovery case.
      name: custodian_id
      required: true
    - description: The ID of the siteSource. If provided, only this ID will be returned.
      name: site_source_id
    - defaultValue: "50"
      description: Number of total results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Get a list of the siteSource objects associated with an eDiscoveryCustodian.
      Use the msg-list-ediscovery-custodians command in order to get all available
      custodians.
    name: msg-list-ediscovery-custodian-site-sources
    outputs:
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.Application.DisplayName
      description: The name of the application who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.Application.ID
      description: The ID of the application who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.DisplayName
      description: The name of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.ID
      description: The ID of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.CreatedDateTime
      description: The date and time the siteSource was created.
      type: Date
    - contextPath: MsGraph.CustodianSiteSource.DisplayName
      description: The display name of the siteSource. This will be the name of the
        SharePoint site.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.HoldStatus
      description: 'The hold status of the siteSource. The possible values are: notApplied,
        applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.CustodianSiteSource.SiteSourceId
      description: The ID of the siteSource.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.Site.ID
      description: The unique identifier of the item. Read-only.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.Site.WebUrl
      description: URL that displays the item in the browser. Read-only.
      type: String
    - contextPath: MsGraph.CustodianSiteSource.Site.CreatedDate
      description: The date and time the siteSource was created.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: URL of the site, for example, https://contoso.sharepoint.com/sites/HumanResources.
      name: site
    - description: Email address of the user's mailbox.
      name: email
    description: Create a new eDiscoveryNoncustodialDataSource object.
    name: msg-create-ediscovery-non-custodial-data-source
    outputs:
    - contextPath: MsGraph.NoncustodialDataSource.CreatedDateTime
      description: Created date and time of the nonCustodialDataSource.
      type: Date
    - contextPath: MsGraph.NoncustodialDataSource.DataSourceId
      description: Unique identifier of the nonCustodialDataSource.
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.DataSourceStatus
      description: 'Latest status of the nonCustodialDataSource. Possible values are:
        Active, Released.'
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.DisplayName
      description: Display name of the noncustodialDataSource.
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.HoldStatus
      description: 'The hold status of the nonCustodialDataSource.The possible values
        are: notApplied, applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.LastModifiedDateTime
      description: Last modified date and time of the nonCustodialDataSource.
      type: Date
    - contextPath: MsGraph.NoncustodialDataSource.ReleasedDateTime
      description: Date and time that the nonCustodialDataSource was released from
        the case.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the dataSource. If provided, only this ID will be returned.
      name: data_source_id
    - defaultValue: "50"
      description: The maximum number of results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Get a list of the non-custodial data sources and their properties.
    name: msg-list-ediscovery-non-custodial-data-sources
    outputs:
    - contextPath: MsGraph.NoncustodialDataSource.CreatedDateTime
      description: Created date and time of the nonCustodialDataSource.
      type: Date
    - contextPath: MsGraph.NoncustodialDataSource.DataSourceId
      description: Unique identifier of the nonCustodialDataSource.
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.DataSourceStatus
      description: 'Latest status of the nonCustodialDataSource. Possible values are:
        Active, Released.'
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.DisplayName
      description: Display name of the noncustodialDataSource.
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.HoldStatus
      description: 'The hold status of the nonCustodialDataSource.The possible values
        are: notApplied, applied, applying, removing, partial.'
      type: String
    - contextPath: MsGraph.NoncustodialDataSource.LastModifiedDateTime
      description: Last modified date and time of the nonCustodialDataSource.
      type: Date
    - contextPath: MsGraph.NoncustodialDataSource.ReleasedDateTime
      description: Date and time that the nonCustodialDataSource was released from
        the case.
      type: Date
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: A comma-separated list of custodians IDs to apply a hold to.
      isArray: true
      name: custodian_id
      required: true
    description: "Start the process of applying hold on eDiscovery custodians.\nAvailable
      return statuses: \nnotApplied - The custodian is not on hold (all sources in
      it are not on hold).\napplied - The custodian is on hold (all sources are on
      hold).\napplying - The custodian is in applying the hold state (applyHold operation
      triggered).\nremoving - The custodian is in removing the hold state(removeHold
      operation triggered).\npartial - The custodian is in a mixed state where some
      sources are on hold and some not on hold or error state."
    name: msg-apply-hold-ediscovery-custodian
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: A comma-separated list of custodians IDs to remove a hold from.
      isArray: true
      name: custodian_id
      required: true
    description: Start the process of removing a hold from eDiscovery custodians.
    name: msg-remove-hold-ediscovery-custodian
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The display name of the search.
      name: display_name
      required: true
    - description: The description of the search.
      name: description
    - description: The query string used for the search. The query string format is
        KQL (Keyword Query Language). For details, see Keyword queries and search
        conditions for Content Search and eDiscovery. You can refine searches by using
        fields paired with values, for example, subject:"Quarterly Financials" AND
        Date>=06/01/2016 AND Date<=07/01/2016.
      name: content_query
    - auto: PREDEFINED
      description: When specified, the collection will span across a service for an
        entire workload.
      name: data_source_scopes
      predefined:
      - none
      - allTenantMailboxes
      - allTenantSites
      - allCaseCustodians
      - allCaseNoncustodialDataSources
    description: Create a new eDiscoverySearch object.
    name: msg-create-ediscovery-search
    outputs:
    - contextPath: MsGraph.eDiscoverySearch.ContentQuery
      description: The query string in KQL (Keyword Query Language) query. For details,
        see https://learn.microsoft.com/en-us/microsoft-365/compliance/keyword-queries-and-search-conditions.
        You can refine searches by using fields paired with values; for example, subject:"Quarterly
        Financials" AND Date>=06/01/2016 AND Date<=07/01/2016.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.Application.DisplayName
      description: Name of the application who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.Application.ID
      description: ID of the application who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.DisplayName
      description: Name of the user who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.ID
      description: ID of the user who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the eDiscovery
        search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedDateTime
      description: The date and time the eDiscovery search was created.
      type: Date
    - contextPath: MsGraph.eDiscoverySearch.DataSourceScopes
      description: 'When specified, the collection will span across a service for
        an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites,
        allCaseCustodians, allCaseNoncustodialDataSources.'
      type: String
    - contextPath: MsGraph.eDiscoverySearch.Description
      description: The description of the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.DisplayName
      description: The display name of the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedDateTime
      description: The last date and time the eDiscovery search was modified.
      type: Date
    - contextPath: MsGraph.eDiscoverySearch.SearchId
      description: The ID for the eDiscovery search.
      type: String
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the eDiscovery search.
      name: search_id
      required: true
    - description: The display name of the search.
      name: display_name
      required: true
    - description: The description of the search.
      name: description
    - description: The query string used for the search. The format of the query string
        is KQL (Keyword Query Language). For details, see Keyword queries and search
        conditions for Content Search and eDiscovery. You can refine searches by using
        fields paired with values, for example, subject:"Quarterly Financials" AND
        Date>=06/01/2016 AND Date<=07/01/2016.
      name: content_query
    - auto: PREDEFINED
      description: When specified, the collection will span across a service for an
        entire workload.
      name: data_source_scopes
      predefined:
      - none
      - allTenantMailboxes
      - allTenantSites
      - allCaseCustodians
      - allCaseNoncustodialDataSources
    description: Update an eDiscoverySearch object.
    name: msg-update-ediscovery-search
  - arguments:
    - description: The id of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the eDiscovery search. If provided, only this ID will
        be returned.
      name: search_id
    - defaultValue: "50"
      description: The maximum number of results to return.
      name: limit
    - auto: PREDEFINED
      description: Show all results if true.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Get the list of eDiscoverySearch resources from an eDiscovery case.
    name: msg-list-ediscovery-searchs
    outputs:
    - contextPath: MsGraph.eDiscoverySearch.ContentQuery
      description: The query string in KQL (Keyword Query Language) query. For details,
        see Keyword queries and search conditions for Content Search and eDiscovery.
        You can refine searches by using fields paired with values, for example, subject:"Quarterly
        Financials" AND Date>=06/01/2016 AND Date<=07/01/2016.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.Application.DisplayName
      description: Name of the application who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.Application.ID
      description: ID of the application who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.DisplayName
      description: Name of the user who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.ID
      description: ID of the user who created the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedBy.User.UserPrincipalName
      description: Internet-style login name of the user who created the eDiscovery
        search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.CreatedDateTime
      description: The date and time the eDiscovery search was created.
      type: Date
    - contextPath: MsGraph.eDiscoverySearch.DataSourceScopes
      description: 'When specified, the collection will span across a service for
        an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites,
        allCaseCustodians, allCaseNoncustodialDataSources.'
      type: String
    - contextPath: MsGraph.eDiscoverySearch.Description
      description: The description of the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.DisplayName
      description: The display name of the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.SearchId
      description: The ID for the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedDateTime
      description: The last date and time the eDiscovery search was modified.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedBy.Application.DisplayName
      description: Name of the application who last modified the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedBy.Application.ID
      description: ID of the application who last modified the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedBy.User.DisplayName
      description: Name of the user who last modified the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedBy.User.ID
      description: ID of the user who last modified the eDiscovery search.
      type: String
    - contextPath: MsGraph.eDiscoverySearch.LastModifiedBy.User.UserPrincipalName
      description: Internet-style login name of the user who last modified the eDiscovery
        search.
      type: String
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the eDiscovery search.
      name: search_id
    description: Delete an eDiscoverySearch object.
    execution: true
    name: msg-delete-ediscovery-search
  - arguments:
    - description: The ID of the eDiscovery case.
      name: case_id
      required: true
    - description: The ID of the eDiscovery search.
      name: search_id
      required: true
    - auto: PREDEFINED
      description: The ID of the eDiscovery search.
      name: purge_type
      predefined:
      - permanentlyDelete
    - auto: PREDEFINED
      description: The ID of the eDiscovery search.
      name: purge_areas
      predefined:
      - teamsMessages
    description: |-
      Delete Microsoft Teams messages contained in an eDiscovery search.
      Note: This request purges Teams data only. It does not purge other types of data such as mailbox items.

      You can collect and purge the following categories of Teams content:

      Teams 1:1 chats - Chat messages, posts, and attachments shared in a Teams conversation between two people. Teams 1:1 chats are also called conversations.
      Teams group chats - Chat messages, posts, and attachments shared in a Teams conversation between three or more people. Also called 1:N chats or group conversations.
      Teams channels - Chat messages, posts, replies, and attachments shared in a standard Teams channel.
      Private channels - Message posts, replies, and attachments shared in a private Teams channel.
      Shared channels - Message posts, replies, and attachments shared in a shared Teams channel.
    name: msg-purge-ediscovery-data
  - arguments:
    - description: The email address of the user who received the email.
      name: recipient_email
      required: true
    - auto: PREDEFINED
      description: The expected assessment.
      name: expected_assessment
      predefined:
      - block
      - unblock
      required: true
    - auto: PREDEFINED
      defaultValue: all
      description: The category of the threat.
      name: category
      predefined:
      - spam
      - phishing
      - malware
      required: true
    - description: Message user. Could be the user's ID or the user's email.
      name: message_user
      required: true
    - description: Message ID. Message has to contain the 'X-MS-Exchange-Organization-Network-Message-Id'
        header in the message or the 'X-MS-Office365-Filtering-Correlation-Id' header
        in quarantined messages. Use the msgraph-mail-list-emails command from the
        Microsoft Graph Mail pack  with the proper user_id in order to get all available
        messages.
      name: message_id
      required: true
    - deprecated: true
      description: The ID of the request (generated in the polling command).
      name: request_id
    - defaultValue: "720"
      deprecated: true
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Create and retrieve a mail threat assessment.
    name: msg-create-mail-assessment-request
    outputs:
    - contextPath: MSGraphMail.MailAssessment.ID
      description: Mail assessment ID.
      type: String
    - contextPath: MSGraphMail.MailAssessment.CreatedDateTime
      description: The datetime the mail assessment was created.
      type: String
    - contextPath: MSGraphMail.MailAssessment.ContentType
      description: The content type.
      type: String
    - contextPath: MSGraphMail.MailAssessment.ExpectedAssessment
      description: The expected assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.Category
      description: The category of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.Status
      description: The status of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.RequestSource
      description: The request source of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.RecipientEmail
      description: The email recipient of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.DestinationRoutingReason
      description: The destination routing reason for the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.MessageID
      description: The message ID of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.CreatedUserID
      description: The user ID that was created for the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.CreatedUsername
      description: The user name that was created for the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.ResultType
      description: The result type of the mail assessment.
      type: String
    - contextPath: MSGraphMail.MailAssessment.ResultMessage
      description: The result message of the mail assessment.
      type: String
    polling: true
  - arguments:
    - description: The email of the user who recieved the mail.
      name: recipient_email
      required: true
    - auto: PREDEFINED
      defaultValue: all
      description: The expected assessment.
      name: expected_assessment
      predefined:
      - block
      - unblock
      required: true
    - auto: PREDEFINED
      defaultValue: all
      description: The category of the threat.
      name: category
      predefined:
      - spam
      - phishing
      - malware
      required: true
    - description: Base 64 encoded eml file.
      name: content_data
    - description: Entry ID.
      name: entry_id
    - deprecated: true
      description: The ID of the request (generated in the polling command).
      name: request_id
    - defaultValue: "720"
      deprecated: true
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Create email file assessment request.
    name: msg-create-email-file-assessment-request
    outputs:
    - contextPath: MSGraphMail.EmailAssessment.ID
      description: The mail assessment ID.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.CreatedDateTime
      description: The datetime the mail assessment was created.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.ContentType
      description: The content type.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.ExpectedAssessment
      description: The expected assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.Category
      description: The category of the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.Status
      description: The status of the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.RequestSource
      description: The request source of the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.RecipientEmail
      description: The email recipient of the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.DestinationRoutingReason
      description: The destination routing reason for the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.CreatedUserID
      description: The user ID that was created for the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.CreatedUsername
      description: The user name that was created for the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.ResultType
      description: The result type of the mail assessment.
      type: String
    - contextPath: MSGraphMail.EmailAssessment.ResultMessage
      description: The result message of the mail assessment.
      type: String
    polling: true
  - arguments:
    - auto: PREDEFINED
      defaultValue: all
      description: The expected assessment.
      name: expected_assessment
      predefined:
      - block
      - unblock
      required: true
    - auto: PREDEFINED
      defaultValue: all
      description: The category of the threat.
      name: category
      predefined:
      - phishing
      - malware
      required: true
    - description: The file name.
      name: file_name
      required: true
    - description: Base 64 encoded text file.
      name: content_data
    - description: Entry ID.
      name: entry_id
    - deprecated: true
      description: Whether to hide the polling result (automatically filled by polling).
      name: hide_polling_output
    - deprecated: true
      description: The ID of the request (generated in the polling command).
      name: request_id
    description: Create file assessment request.
    name: msg-create-file-assessment-request
    outputs:
    - contextPath: MSGraphMail.FileAssessment.ID
      description: The mail assessment ID.
      type: String
    - contextPath: MSGraphMail.FileAssessment.CreatedDateTime
      description: The datetime the file assessment was created.
      type: String
    - contextPath: MSGraphMail.FileAssessment.ContentType
      description: The content type.
      type: String
    - contextPath: MSGraphMail.FileAssessment.ExpectedAssessment
      description: The expected assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.Category
      description: The category of the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.Status
      description: The status of the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.RequestSource
      description: The request source of the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.FileName
      description: The file name of the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.CreatedUserID
      description: The user ID that was created for the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.CreatedUsername
      description: The user name that was created for the mail assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.ResultType
      description: The result type of the file assessment.
      type: String
    - contextPath: MSGraphMail.FileAssessment.ResultMessage
      description: The result message of the file assessment.
      type: String
    polling: true
  - arguments:
    - auto: PREDEFINED
      defaultValue: all
      description: The expected assessment.
      name: expected_assessment
      predefined:
      - block
      - unblock
      required: true
    - auto: PREDEFINED
      defaultValue: all
      description: The category of the threat.
      name: category
      predefined:
      - phishing
      - malware
      required: true
    - description: The URL of the threat.
      name: url
      required: true
    - deprecated: true
      description: The request_id (generated in the polling command).
      name: request_id
    - defaultValue: "720"
      deprecated: true
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Create the URL assessment request.
    name: msg-create-url-assessment-request
    outputs:
    - contextPath: MSGraphMail.UrlAssessment.ID
      description: The mail assessment ID.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.Url
      description: The URL of the URL assessment.
      type: string
    - contextPath: MSGraphMail.UrlAssessment.CreatedDateTime
      description: The datetime the URL assessment was created.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.ContentType
      description: The content type of the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.ExpectedAssessment
      description: The expected assessment of the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.Category
      description: The category of the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.Status
      description: The status of the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.RequestSource
      description: The request source for the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.RecipientEmail
      description: The recipient email for the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.DestinationRoutingReason
      description: The destination routing reason for the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.CreatedUserID
      description: The user ID created for the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.CreatedUsername
      description: The user name created for the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.ResultType
      description: The result type of the URL assessment.
      type: String
    - contextPath: MSGraphMail.UrlAssessment.ResultMessage
      description: The result message of the URL assessment.
      type: String
    polling: true
  - arguments:
    - description: The request ID.
      name: request_id
    - description: The filter for the request. Example category eq 'malware’ and ContentType
        eq 'file'. Available fields are expectedAssessment, ContentType, status, requestSource.
      name: filter
    - auto: PREDEFINED
      description: The order by which to retrieve the results.
      name: order_by
      predefined:
      - id
      - createdDateTime
      - ContentType
      - expectedAssessment
      - category
      - status
      - requestSource
    - auto: PREDEFINED
      description: The sort order.
      name: sort_order
      predefined:
      - asc
      - desc
    - description: The maximum number of results to retrieve.
      name: limt
    - description: The next token.
      name: next_token
    description: Create URL assessment request.
    name: msg-list-threat-assessment-requests
    outputs:
    - contextPath: MsGraph.AssessmentRequestNextToken.next_token
      description: The next token for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.ID
      description: The assessment request ID.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.CreatedDateTime
      description: The datetime the assessment request was created.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.ContentType
      description: The content type of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.ExpectedAssessment
      description: The expected assessment of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.Category
      description: The category of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.Status
      description: The status of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.URL
      description: The URL of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.RequestSource
      description: The request source for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.RecipientEmail
      description: The email recipient for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.FileName
      description: The file name of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.DestinationRoutingReason
      description: The destination routing reason for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.CreatedUserID
      description: The user ID create for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.CreatedUsername
      description: The user name created for the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.ResultType
      description: The result type of the assessment request.
      type: String
    - contextPath: MSGraphMail.AssessmentRequest.ResultMessage
      description: The result message of the assessment request.
      type: String
    polling: true
  dockerimage: demisto/crypto:1.0.0.79610
  isfetch: true
  runonce: false
  script: |
    register_module_line('Microsoft Graph Test', 'start', __line__())
    ### pack version: 2.2.6
    from requests import Response



    from enum import Enum

    import urllib3
    import re


    from typing import Any

    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)


    # pylint: disable=E9010, E9011
    import traceback


    import requests
    import re
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM


    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'  # resource_manager


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        management_azure = 'https://management.azure.com/'  # resource_manager
        manage_office = 'https://manage.office.com/'


    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line
    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'
    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'
    REGEX_SEARCH_ERROR_DESC = r"^.*?:\s(?P<desc>.*?\.)"
    SESSION_STATE = 'session_state'

    # Deprecated, prefer using AZURE_CLOUDS
    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.us',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"
    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"


    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris
    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api
    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'geo-us': 'https://login.microsoftonline.com',
        'geo-eu': 'https://login.microsoftonline.com',
        'geo-uk': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
    }

    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'geo-us': 'https://graph.microsoft.com',
        'geo-eu': 'https://graph.microsoft.com',
        'geo-uk': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        'com': 'https://securitycenter.onmicrosoft.com',
        'geo-us': 'https://securitycenter.onmicrosoft.com',
        'geo-eu': 'https://securitycenter.onmicrosoft.com',
        'geo-uk': 'https://securitycenter.onmicrosoft.com',
        'gcc': 'https://securitycenter.onmicrosoft.us',
        'gcc-high': 'https://securitycenter.onmicrosoft.us',
        'dod': 'https://securitycenter.onmicrosoft.us',
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
    }

    # Azure Managed Identities
    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'
    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'
    TOKEN_EXPIRED_ERROR_CODES = {50173, 700082, 70008, 54005, 7000222,
                                 }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism
    MAX_DELAY_REQUEST_COUNTER = 6


    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     management=None,
                     resource_manager=None,
                     sql_management=None,
                     batch_resource_id=None,
                     gallery=None,
                     active_directory=None,
                     active_directory_resource_id=None,
                     active_directory_graph_resource_id=None,
                     microsoft_graph_resource_id=None,
                     active_directory_data_lake_resource_id=None,
                     vm_image_alias_doc=None,
                     media_resource_id=None,
                     ossrdbms_resource_id=None,
                     log_analytics_resource_id=None,
                     app_insights_resource_id=None,
                     app_insights_telemetry_channel_resource_id=None,
                     synapse_analytics_resource_id=None,
                     attestation_resource_id=None,
                     portal=None,
                     keyvault=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     storage_endpoint=None,
                     storage_sync_endpoint=None,
                     keyvault_dns=None,
                     mhsm_dns=None,
                     sql_server_hostname=None,
                     azure_datalake_store_file_system_endpoint=None,
                     azure_datalake_analytics_catalog_and_job_endpoint=None,
                     acr_login_server_endpoint=None,
                     mysql_server_endpoint=None,
                     postgresql_server_endpoint=None,
                     mariadb_server_endpoint=None,
                     synapse_analytics_endpoint=None,
                     attestation_endpoint=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """ Represents an Azure Cloud instance """

        def __init__(self,
                     origin,
                     name,
                     abbreviation,
                     endpoints=None,
                     suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        'Embedded',
        'AzureCloud',
        'com',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.windows.net/',
            resource_manager='https://management.azure.com/',
            sql_management='https://management.core.windows.net:8443/',
            batch_resource_id='https://batch.core.windows.net/',
            gallery='https://gallery.azure.com/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.windows.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.com/',
            active_directory_data_lake_resource_id='https://datalake.azure.net/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.azure.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.windows.net',
            app_insights_resource_id='https://api.applicationinsights.io',
            log_analytics_resource_id='https://api.loganalytics.io',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.com/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.net',
            attestation_resource_id='https://attest.azure.net',
            portal='https://portal.azure.com',
            keyvault='https://vault.azure.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.windows.net',
            storage_sync_endpoint='afs.azure.net',
            keyvault_dns='.vault.azure.net',
            mhsm_dns='.managedhsm.azure.net',
            sql_server_hostname='.database.windows.net',
            mysql_server_endpoint='.mysql.database.azure.com',
            postgresql_server_endpoint='.postgres.database.azure.com',
            mariadb_server_endpoint='.mariadb.database.azure.com',
            azure_datalake_store_file_system_endpoint='azuredatalakestore.net',
            azure_datalake_analytics_catalog_and_job_endpoint='azuredatalakeanalytics.net',
            acr_login_server_endpoint='.azurecr.io',
            synapse_analytics_endpoint='.dev.azuresynapse.net',
            attestation_endpoint='.attest.azure.net'))

    AZURE_US_GCC_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc-high',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_DOD_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'dod',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://dod-graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))


    AZURE_GERMAN_CLOUD = AzureCloud(
        'Embedded',
        'AzureGermanCloud',
        'de',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.cloudapi.de/',
            resource_manager='https://management.microsoftazure.de',
            sql_management='https://management.core.cloudapi.de:8443/',
            batch_resource_id='https://batch.cloudapi.de/',
            gallery='https://gallery.cloudapi.de/',
            active_directory='https://login.microsoftonline.de',
            active_directory_resource_id='https://management.core.cloudapi.de/',
            active_directory_graph_resource_id='https://graph.cloudapi.de/',
            microsoft_graph_resource_id='https://graph.microsoft.de',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.cloudapi.de',
            ossrdbms_resource_id='https://ossrdbms-aad.database.cloudapi.de',
            portal='https://portal.microsoftazure.de',
            keyvault='https://vault.microsoftazure.de'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.cloudapi.de',
            keyvault_dns='.vault.microsoftazure.de',
            mhsm_dns='.managedhsm.microsoftazure.de',
            sql_server_hostname='.database.cloudapi.de',
            mysql_server_endpoint='.mysql.database.cloudapi.de',
            postgresql_server_endpoint='.postgres.database.cloudapi.de',
            mariadb_server_endpoint='.mariadb.database.cloudapi.de'))

    AZURE_CHINA_CLOUD = AzureCloud(
        'Embedded',
        'AzureChinaCloud',
        'cn',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.chinacloudapi.cn/',
            resource_manager='https://management.chinacloudapi.cn',
            sql_management='https://management.core.chinacloudapi.cn:8443/',
            batch_resource_id='https://batch.chinacloudapi.cn/',
            gallery='https://gallery.chinacloudapi.cn/',
            active_directory='https://login.chinacloudapi.cn',
            active_directory_resource_id='https://management.core.chinacloudapi.cn/',
            active_directory_graph_resource_id='https://graph.chinacloudapi.cn/',
            microsoft_graph_resource_id='https://microsoftgraph.chinacloudapi.cn',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.chinacloudapi.cn',
            ossrdbms_resource_id='https://ossrdbms-aad.database.chinacloudapi.cn',
            app_insights_resource_id='https://api.applicationinsights.azure.cn',
            log_analytics_resource_id='https://api.loganalytics.azure.cn',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.cn/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.azure.cn',
            portal='https://portal.azure.cn',
            keyvault='https://vault.azure.cn',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.chinacloudapi.cn',
            keyvault_dns='.vault.azure.cn',
            mhsm_dns='.managedhsm.azure.cn',
            sql_server_hostname='.database.chinacloudapi.cn',
            mysql_server_endpoint='.mysql.database.chinacloudapi.cn',
            postgresql_server_endpoint='.postgres.database.chinacloudapi.cn',
            mariadb_server_endpoint='.mariadb.database.chinacloudapi.cn',
            acr_login_server_endpoint='.azurecr.cn',
            synapse_analytics_endpoint='.dev.azuresynapse.azure.cn'))


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    AZURE_CLOUD_NAME_CUSTOM = "Custom"

    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }


    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(origin: str,
                                  name: str | None = None,
                                  abbreviation: str | None = None,
                                  defaults: AzureCloud | None = None,
                                  endpoints: dict | None = None,
                                  suffixes: dict | None = None):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get('management', defaults.endpoints.management),
                resource_manager=endpoints.get('resource_manager', defaults.endpoints.resource_manager),
                sql_management=endpoints.get('sql_management', defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get('batch_resource_id', defaults.endpoints.batch_resource_id),
                gallery=endpoints.get('gallery', defaults.endpoints.gallery),
                active_directory=endpoints.get('active_directory', defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get('active_directory_resource_id',
                                                           defaults.endpoints.active_directory_resource_id),
                active_directory_graph_resource_id=endpoints.get(
                    'active_directory_graph_resource_id', defaults.endpoints.active_directory_graph_resource_id),
                microsoft_graph_resource_id=endpoints.get('microsoft_graph_resource_id',
                                                          defaults.endpoints.microsoft_graph_resource_id),
                active_directory_data_lake_resource_id=endpoints.get(
                    'active_directory_data_lake_resource_id', defaults.endpoints.active_directory_data_lake_resource_id),
                vm_image_alias_doc=endpoints.get('vm_image_alias_doc', defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get('media_resource_id', defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get('ossrdbms_resource_id', defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get('app_insights_resource_id', defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get('log_analytics_resource_id', defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    'app_insights_telemetry_channel_resource_id', defaults.endpoints.app_insights_telemetry_channel_resource_id),
                synapse_analytics_resource_id=endpoints.get(
                    'synapse_analytics_resource_id', defaults.endpoints.synapse_analytics_resource_id),
                attestation_resource_id=endpoints.get('attestation_resource_id', defaults.endpoints.attestation_resource_id),
                portal=endpoints.get('portal', defaults.endpoints.portal),
                keyvault=endpoints.get('keyvault', defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get('storage_endpoint', defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get('storage_sync_endpoint', defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get('keyvault_dns', defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get('mhsm_dns', defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get('sql_server_hostname', defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get('mysql_server_endpoint', defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get('postgresql_server_endpoint', defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get('mariadb_server_endpoint', defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    'azure_datalake_store_file_system_endpoint', defaults.suffixes.azure_datalake_store_file_system_endpoint),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    'azure_datalake_analytics_catalog_and_job_endpoint',
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint),
                acr_login_server_endpoint=suffixes.get('acr_login_server_endpoint', defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get('synapse_analytics_endpoint', defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get('attestation_endpoint', defaults.suffixes.attestation_endpoint),
            ))


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, 'com')
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get('azure_cloud')
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if 'server_url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'resource_manager': params.get('server_url')
                                                            or 'https://management.azure.com'})
            if 'azure_ad_endpoint' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={
                                                     'active_directory': params.get('azure_ad_endpoint')
                                                     or 'https://login.microsoftonline.com'
                                                 })
            # in multiple Graph integrations, the url is called 'url' instead of 'server_url' and the default url is different.
            if 'url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'microsoft_graph_resource_id': params.get('url')
                                                            or 'https://graph.microsoft.com'})

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str | None = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str | None = '',
                     multi_resource: bool = False,
                     resources: list[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: int | None = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
                     endpoint: str = "__NA__",  # Deprecated
                     certificate_thumbprint: str | None = None,
                     retry_on_rate_limit: bool = False,
                     private_key: str | None = None,
                     managed_identities_client_id: str | None = None,
                     managed_identities_resource_uri: str | None = None,
                     base_url: str | None = None,
                     command_prefix: str | None = "command_prefix",
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=self.azure_cloud.endpoints.active_directory
                                                                      .rstrip("/"))
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(
                endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: str | None = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    try:
                        import defusedxml.ElementTree as defused_ET
                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug('defused_ET is not supported, using ET instead.')
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f'Failed to parse json object from response: {response.content}', exception)

        def get_access_token(self, resource: str = '', scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else \
                            min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug('Set integration context successfully.')

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in Microsoft authorization.'
            try:
                demisto.info(
                    f'Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} '
                    f'{oproxy_response.text}'
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r'{.*}', oproxy_response.text)
                microsoft_response = self.extract_microsoft_error(json.loads(search_microsoft_response.group())) \
                    if search_microsoft_response else ""
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f' body: {err_str}'
                err_response = oproxy_response.json()
                server_msg = err_response.get('message', '') or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f' Server message: {server_msg}'
            except Exception as ex:
                demisto.error(f'Failed parsing error response - Exception: {ex}')
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: dict[str, str], content: str,
                                            scope: str | None = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get('delay_request_counter', 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(next_request_time=next_request_time, delay_request_counter=delay_request_counter,
                                              context=context)
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: str | None = None,
                                     integration_context: dict | None = None
                                     ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                      resource)
                    self.resource_to_access_token[resource] = access_token

                return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: str | None = None,
                                                        resource: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope or self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')
            return None

        def _get_token_device_code(
            self, refresh_token: str = '', scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run))

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get('error', {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get('error_description', '')

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += f"\nYou can run the ***{self.command_prefix}-auth-reset*** command " \
                               f"to reset the authentication process."
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f'Failed getting integration info: {str(e)}')

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search['url'] if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
            Calculates the next request time based on the delay_request_counter.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2 ** delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
            Sets the next_request_time in the integration context.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context['next_request_time'] = next_request_time
        context['delay_request_counter'] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context['delay_request_counter'] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
            Checks if the request should be delayed based on context variables.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient,
                           login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException("Please make sure you entered the Authorization configuration correctly. "
                                   f"Missing:{','.join(missing)}")

        login_url = urljoin(login_url, f'{client.tenant_id}/oauth2/v2.0/authorize?'
                                       f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
                                       f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}')

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.
    You will be automatically redirected to a link with the following structure:
    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```
    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)
    and paste it in your instance configuration under the **Authorization code** parameter.
        """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f'No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.')


    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(readable_output='Authorization was reset successfully. Please regenerate the credentials, '
                                              'and then click **Test** to validate the credentials and connection.')

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    # disable insecure warnings
    DEFAULT_KEYS_TO_REPLACE = {'createdDateTime': 'CreatedDate'}
    urllib3.disable_warnings()

    APP_NAME = 'ms-graph-security'
    API_V2 = "Alerts v2"
    API_V1 = "Legacy Alerts"
    LEGACY_API_ENDPOINT = 'security/alerts'
    API_V2_ENDPOINT = 'security/alerts_v2'
    CMD_URL = API_V2_ENDPOINT
    API_VER = API_V2
    PAGE_SIZE_LIMIT_DICT = {API_V2: 2000, API_V1: 1000}
    API_V1_PAGE_LIMIT = 500

    DataSourceType = {
        'USER': {
            'type': 'User',
            'url_suffix': 'userSources',
            'unique_table_headers': ['IncludedSources'],
            'outputs_prefix': 'CustodianUserSource'
        },
        'SITE': {
            'type': 'Site',
            'url_suffix': 'siteSources',
            'unique_table_headers': [],
            'outputs_prefix': 'CustodianSiteSource'
        },
        'NON_CUSTODIAL': {
            'type': 'Data',
            'url_suffix': 'noncustodialDataSources',
            'unique_table_headers': ['LastModifiedDateTime', 'ReleasedDateTime', 'Status'],
            'outputs_prefix': 'NoncustodialDataSource'
        }
    }

    EMAIL_REGEX = r"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+"


    class HoldAction(Enum):
        APPLY = 'apply'
        REMOVE = 'remove'


    POSSIBLE_FIELDS_TO_INCLUDE = ["All", "NetworkConnections", "Processes", "RegistryKeys", "UserStates", "HostStates",
                                  "FileStates",
                                  "CloudAppStates", "MalwareStates", "CustomerComments", "Triggers", "VendorInformation",
                                  "VulnerabilityStates"]

    RELEVANT_DATA_TO_UPDATE_PER_VERSION = {API_V1: {'assigned_to': 'assignedTo', 'closed_date_time': 'closedDateTime',
                                                    'comments': 'comments', 'feedback': 'feedback', 'status': 'status',
                                                    'tags': 'tags'},
                                           API_V2: {'assigned_to': 'assignedTo', 'determination': 'determination',
                                                    'classification': 'classification', 'status': 'status'}
                                           }


    class MsGraphClient:
        """
        Microsoft Graph Mail Client enables authorized access to a user's Office 365 mail data in a personal account.
        """

        def __init__(self, tenant_id, proxy,
                     certificate_thumbprint: str | None = None, api_version: str = "", **kwargs):
            self.ms_client = MicrosoftClient(
                tenant_id=tenant_id,
                proxy=proxy, certificate_thumbprint=certificate_thumbprint,
                managed_identities_resource_uri=Resources.graph,
                command_prefix=APP_NAME, **kwargs
            )
            if api_version == API_V1:
                global CMD_URL, API_VER
                API_VER = API_V1
                CMD_URL = LEGACY_API_ENDPOINT

        def get(self, url, **kwargs):
            return self.ms_client.http_request(method='GET', url_suffix=url, **kwargs)

        def search_alerts(self, params):
            cmd_url = CMD_URL
            demisto.debug(f'Fetching MS Graph Security incidents with params: {params}')
            response = self.ms_client.http_request(method='GET', url_suffix=cmd_url, params=params)
            return response

        def get_alert_details(self, alert_id):
            cmd_url = f'{CMD_URL}/{alert_id}'
            response = self.ms_client.http_request(method='GET', url_suffix=cmd_url)
            return response

        def update_alert(self, alert_id, params):
            cmd_url = f'{CMD_URL}/{alert_id}'
            self.ms_client.http_request(method='PATCH', url_suffix=cmd_url, json_data=params, resp_type="text")

        def get_users(self):
            cmd_url = 'users'
            response = self.ms_client.http_request(method='GET', url_suffix=cmd_url)
            return response

        def get_user(self, user_id):
            cmd_url = f'users/{user_id}'
            response = self.ms_client.http_request(method='GET', url_suffix=cmd_url)
            return response

        def create_alert_comment(self, alert_id, params):
            cmd_url = f'{CMD_URL}/{alert_id}/comments'
            response = self.ms_client.http_request(method='POST', url_suffix=cmd_url, json_data=params)
            return response

        def list_ediscovery_cases(self, case_id: str | None):
            url = 'security/cases/ediscoveryCases'
            if case_id:
                url += f'/{case_id}'
            return self.ms_client.http_request(method='GET', url_suffix=url)

        def create_edsicovery_case(self, display_name, description, external_id):
            url = 'security/cases/ediscoveryCases'
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data={
                'displayName': display_name,
                'description': description,
                'externalId': external_id
            })

        def update_edsicovery_case(self, case_id, display_name, description, external_id):
            url = f'security/cases/ediscoveryCases/{case_id}'
            req = {'displayName': display_name,
                   'description': description,
                   'externalId': external_id}

            remove_nulls_from_dictionary(req)
            self.ms_client.http_request(ok_codes=[204], method='PATCH', url_suffix=url, json_data=req, resp_type='text')

        def close_edsicovery_case(self, case_id):
            url = f'security/cases/ediscoveryCases/{case_id}/close'
            self.ms_client.http_request(ok_codes=[204], method='POST', url_suffix=url, resp_type='text')

        def reopen_edsicovery_case(self, case_id):
            url = f'security/cases/ediscoveryCases/{case_id}/reopen'
            self.ms_client.http_request(ok_codes=[204], method='POST', url_suffix=url, resp_type='text')

        def release_edsicovery_custodian(self, case_id, custodian_id):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{custodian_id}/release'
            self.ms_client.http_request(ok_codes=[202], method='POST', url_suffix=url, resp_type='text')

        def activate_edsicovery_custodian(self, case_id, custodian_id):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{custodian_id}/activate'
            self.ms_client.http_request(ok_codes=[202], method='POST', url_suffix=url, resp_type='text')

        def delete_edsicovery_case(self, case_id):
            url = f'security/cases/ediscoveryCases/{case_id}'
            self.ms_client.http_request(ok_codes=[204], method='DELETE', url_suffix=url, resp_type='text')

        def create_edsicovery_custodian(self, case_id, email):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians'
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data={'email': email})

        def list_ediscovery_custodians(self, case_id, custodian_id):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians'
            if custodian_id:
                url += f'/{custodian_id}'
            return self.ms_client.http_request(method='GET', url_suffix=url)

        def create_edsicovery_custodian_user_source(self, case_id, custodian_id, email, included_sources):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{custodian_id}/userSources'
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data={
                'email': email,
                'includedSources': included_sources
            })

        def create_edsicovery_custodian_site_source(self, case_id, custodian_id, site):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{custodian_id}/siteSources'
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data={
                'site': {
                    'webUrl': site,
                }
            })

        def list_ediscovery_custodians_sources(self, case_id, custodian_id, source_id, source_type):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{custodian_id}/{source_type["url_suffix"]}'
            if source_id:
                url += f'/{source_id}'
            return self.ms_client.http_request(method='GET', url_suffix=url)

        def create_ediscovery_non_custodial_data_source(self, case_id, site, email):
            url = f'security/cases/ediscoveryCases/{case_id}/noncustodialDataSources'
            body = {
                "dataSource": {"@odata.type": "microsoft.graph.security.userSource", "email": email}
            } if email else {
                "dataSource": {"@odata.type": "microsoft.graph.security.siteSource",
                               "site": {"webUrl": site}}}
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body)

        def list_ediscovery_noncustodial_datasources(self, case_id, source_id):
            url = f'security/cases/ediscoveryCases/{case_id}/noncustodialDataSources'
            if source_id:
                url += f'/{source_id}'
            return self.ms_client.http_request(method='GET', url_suffix=url)

        def update_hold_ediscovery_custodian(self, case_id: str, custodian_id: str, hold_action: HoldAction):
            url = f'security/cases/ediscoveryCases/{case_id}/custodians/{hold_action.value}Hold'
            body = {
                'ids': custodian_id.split(',')
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, resp_type='response', json_data=body)

        def create_ediscovery_search(self, case_id, display_name, description, query, data_source_scopes):
            url = f'/security/cases/ediscoveryCases/{case_id}/searches'
            body = {
                'displayName': display_name,
                'description': description,
                'contentQuery': query,
                'dataSourceScopes': data_source_scopes
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body)

        def update_ediscovery_search(self, case_id, search_id, display_name, description, query, data_source_scopes):
            url = f'/security/cases/ediscoveryCases/{case_id}/searches/{search_id}'
            body = {
                'displayName': display_name,
                'description': description,
                'contentQuery': query,
                'dataSourceScopes': data_source_scopes
            }
            remove_nulls_from_dictionary(body)
            self.ms_client.http_request(ok_codes=[204], method='PATCH', url_suffix=url, json_data=body, resp_type='text')

        def list_ediscovery_search(self, case_id, search_id):
            url = f'security/cases/ediscoveryCases/{case_id}/searches'
            if search_id:
                url += f'/{search_id}'
            return self.ms_client.http_request(method='GET', url_suffix=url)

        def delete_ediscovery_search(self, case_id, search_id):
            url = f'security/cases/ediscoveryCases/{case_id}/searches/{search_id}'
            self.ms_client.http_request(ok_codes=[204], method='DELETE', url_suffix=url, resp_type='text')

        def purge_ediscovery_data(self, case_id, search_id, purge_type, purge_areas):
            url = f'security/cases/ediscoveryCases/{case_id}/searches/{search_id}/purgeData'
            body = {
                'purgeType': purge_type,
                'purgeAreas': purge_areas
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body, resp_type='response')

        def create_mail_assessment_request(self, recipient_email, expected_assessment, category, user_id, message_id):
            url = 'informationProtection/threatAssessmentRequests'
            body = {
                "@odata.type": "#microsoft.graph.mailAssessmentRequest",
                "recipientEmail": recipient_email,
                "expectedAssessment": expected_assessment,
                "category": category,
                "messageUri": f"https://graph.microsoft.com/v1.0/users/{user_id}/messages/{message_id}"
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body)

        def get_user_id(self, email):
            return self.ms_client.http_request(method='GET', url_suffix='users', params={'$filter': f'mail eq {email}'})

        def get_threat_assessment_request(self, request_id):
            return self.ms_client.http_request(method='GET',
                                               url_suffix=f'informationProtection/threatAssessmentRequests/{request_id}',
                                               params={'$expand': 'results'})

        def get_threat_assessment_request_status(self, request_id):
            return self.ms_client.http_request(method='GET',
                                               url_suffix=f'informationProtection/threatAssessmentRequests/{request_id}',
                                               params={'$select': 'status'})

        def create_email_file_assessment_request(self, recipient_email, expected_assessment, category, content_data):
            url = 'informationProtection/threatAssessmentRequests'
            body = {
                "@odata.type": "#microsoft.graph.emailFileAssessmentRequest",
                "recipientEmail": recipient_email,
                "expectedAssessment": expected_assessment,
                "category": category,
                "contentData": content_data
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body)

        def create_file_assessment_request(self, expected_assessment, category, file_name, content_data):
            url = 'informationProtection/threatAssessmentRequests'
            body = {
                "@odata.type": "#microsoft.graph.fileAssessmentRequest",
                "expectedAssessment": expected_assessment,
                "category": category,
                "fileName": file_name,
                "contentData": content_data
            }
            return self.ms_client.http_request(method='POST', url_suffix=url, json_data=body)

        def create_url_assessment_request(self, expected_assessment, category, url):
            url_suffix = 'informationProtection/threatAssessmentRequests'
            body = {
                "@odata.type": "#microsoft.graph.urlAssessmentRequest",
                "expectedAssessment": expected_assessment,
                "category": category,
                "url": url,
            }
            return self.ms_client.http_request(method='POST', url_suffix=url_suffix, json_data=body)

        def list_threat_assessment_requests(self, filters=None, order_by=None, sort_order=None, next_token=None):
            url = 'informationProtection/threatAssessmentRequests'
            params = {}
            if next_token:
                return self.ms_client.http_request(method='GET', url_suffix=url,
                                                   params={'$skipToken': next_token}, retries=1, status_list_to_retry=[405])
            if filters:
                params['$filter'] = filters
            if order_by:
                params['$orderby'] = order_by
                if sort_order:
                    params['$orderby'] = f"{order_by} {sort_order}"

            return self.ms_client.http_request(method='GET', url_suffix=url,
                                               params=params, retries=1, status_list_to_retry=[405])


    ''' HELPER FUNCTIONS '''


    def get_status_of_operation(client: MsGraphClient, res: Response) -> str:
        """
        Some responses from MSG where an action is called return a url in the headers that we can use to retrieve the status
        Args:
            client: Microsoft
            GraphClient
            res: the response from the api

        Returns:
            The status
        """
        location = res.headers.get('Location')
        status = 'success'  # if no location is returned then the custodian is already in this state/theres no data sources
        if location:
            location = 'security' + location.split('/security')[1]  # chop off the baseurl
            resp = client.get(location)
            demisto.debug(f'response from location get: {resp}')
            status = resp.get('status')
        return status


    def create_search_alerts_filters(args, is_fetch=False):
        """
        Creates the relevant filters for the search_alerts function.
        Args:
            args (Dict): The command's arguments dictionary.
            is_fetch (bool): wether the search_alerts function is being called from fetch incidents or not.
        Returns:
            Dict: The filter dictionary to use
        """
        last_modified = args.get('last_modified')
        severity = args.get('severity')
        category = args.get('category')
        time_from = args.get('time_from')
        time_to = args.get('time_to')
        filter_query = args.get('filter')
        page = args.get('page')
        page_size = int(args.get('page_size', 50)) if is_fetch and args.get('page_size') or not is_fetch else 0
        filters = []
        params: dict[str, str] = {}
        if last_modified:
            last_modified_query_key: str = "lastModifiedDateTime" if API_VER == API_V1 else "lastUpdateDateTime"
            filters.append(f"{last_modified_query_key} gt {get_timestamp(last_modified)}")
        if category:
            filters.append(f"category eq '{category}'")
        if severity:
            filters.append(f"severity eq '{severity}'")
        if time_from:  # changed to ge and le in order to solve issue #27884
            filters.append(f"createdDateTime ge {time_from}")
        if time_to:
            filters.append(f"createdDateTime le {time_to}")
        if filter_query:
            filters.append(f"{filter_query}")
        if page_size:
            if PAGE_SIZE_LIMIT_DICT.get(API_VER, 1000) < page_size:
                raise DemistoException(
                    f"Please note that the page size limit for {API_VER} is {PAGE_SIZE_LIMIT_DICT.get(API_VER)}")
            params['$top'] = str(page_size)
        if page and page_size:
            page = int(page)
            page = page * page_size
            if API_VER == API_V1 and page > API_V1_PAGE_LIMIT:
                raise DemistoException(f"Please note that the maximum amount of alerts you can skip in {API_VER} is"
                                       f" {API_V1_PAGE_LIMIT}")
            params['$skip'] = page
        if API_VER == API_V2:
            relevant_filters_v2 = ['classification', 'serviceSource', 'status']
            for key in relevant_filters_v2:
                if val := args.get(key):
                    filters.append(f"{key} eq '{val}'")
        filters = " and ".join(filters)
        params['$filter'] = filters
        return params


    def created_by_fields_to_hr(ret_context: dict):
        hr = ret_context.copy()
        hr['CreatedByName'] = dict_safe_get(ret_context, ['CreatedBy', "User", "DisplayName"])
        hr['CreatedByUPN'] = dict_safe_get(ret_context, ['CreatedBy', "User", "UserPrincipalName"])
        hr['CreatedByAppName'] = dict_safe_get(ret_context, ['CreatedBy', "Application", "DisplayName"])
        hr.pop("CreatedBy", None)
        return hr


    def create_data_to_update(args):
        """
        Creates the data dictionary to update alert for the update_alert function according to the configured API version.
        Args:
            args (Dict): The command's arguments dictionary.
        Returns:
            Dict: A dictionary object containing the alert's fields to update.
        """
        relevant_data_to_update_per_version_dict: dict = RELEVANT_DATA_TO_UPDATE_PER_VERSION.get(API_VER, {})
        if all(not args.get(key) for key in list(relevant_data_to_update_per_version_dict.keys())):
            raise DemistoException(
                f"No data relevant for {API_VER} to update was provided, please provide at least one of the"
                f" following: {(', ').join(list(relevant_data_to_update_per_version_dict.keys()))}.")
        data: dict[str, Any] = {}
        if API_VER == API_V1:
            vendor_information = args.get('vendor_information')
            provider_information = args.get('provider_information')
            if not vendor_information or not provider_information:
                raise DemistoException(
                    "When using Legacy Alerts, both vendor_information and provider_information must be provided.")
            data['vendorInformation'] = {
                'provider': provider_information,
                'vendor': vendor_information
            }
        if assigned_to := args.get('assigned_to'):
            data['assignedTo'] = assigned_to
        for relevant_args_key, relevant_data_key in relevant_data_to_update_per_version_dict.items():
            if val := args.get(relevant_args_key):
                if relevant_args_key == 'tags' or relevant_args_key == 'comments':
                    data[relevant_data_key] = [val]
                else:
                    data[relevant_data_key] = val
        return data


    def validate_fields_list(fields_list):
        if unsupported_fields := (set(fields_list) - set(POSSIBLE_FIELDS_TO_INCLUDE)):
            raise DemistoException(f"The following fields are not supported by the commands as fields to include: "
                                   f"{(', ').join(unsupported_fields)}.\nPlease make sure to enter only fields from the "
                                   f"following list: {(', ').join(POSSIBLE_FIELDS_TO_INCLUDE)}.")


    def get_timestamp(time_description):
        if time_description == 'Last24Hours':
            time_delta = 1
        elif time_description == 'Last48Hours':
            time_delta = 2
        else:
            time_delta = 7
        return datetime.strftime(datetime.now() - timedelta(time_delta), '%Y-%m-%d')


    def capitalize_dict_keys_first_letter(response, keys_to_replace: dict = DEFAULT_KEYS_TO_REPLACE):
        """
        Recursively creates a data dictionary where all key starts with capital letters.
        Args:
            keys_to_replace: keys that should have custom replacements not according to capitalize_first_letter
            response (Dict / str): The dictionary to update.
        Returns:
            Dict: The updated dictionary.
        """
        if isinstance(response, str):
            return response
        parsed_dict: dict = {}
        if isinstance(response, dict):
            for key, value in response.items():
                if keys_to_replace and key in keys_to_replace:
                    parsed_dict[keys_to_replace[key]] = value
                elif key == 'id':
                    parsed_dict['ID'] = value
                elif isinstance(value, dict):
                    parsed_dict[capitalize_first_letter(key)] = capitalize_dict_keys_first_letter(value)
                elif isinstance(value, list):
                    parsed_dict[capitalize_first_letter(key)] = [capitalize_dict_keys_first_letter(list_item) for list_item
                                                                 in value]
                else:
                    parsed_dict[capitalize_first_letter(key)] = value
        return parsed_dict


    def capitalize_first_letter(string):
        return string[:1].upper() + string[1:]


    def list_ediscovery_custodian_sources(client: MsGraphClient, args, source_type):
        raw_res = client.list_ediscovery_custodians_sources(args.get('case_id'), args.get('custodian_id'),
                                                            args.get(f"{source_type['type']}_source_id".lower()),
                                                            source_type)
        if source_list := raw_res.get('value'):
            demisto.info(f'returned {len(source_list)} results from the api')
        else:
            source_list = [raw_res]  # api doesnt return a list if only 1 result

        if not argToBoolean(args.get('all_results', 'false')):
            source_list = source_list[:arg_to_number(args.get('limit', 50))]
        return ediscovery_source_command_results(source_list, source_type, raw_res)


    def create_filter_query(filter_param: str, providers_param: str, service_sources_param: str):
        """
        Creates the relevant filters to the query filter according to the used API ver and the user's configured filter.
        Args:
            filter_param (str): configured user filter.
            providers_param (str): comma separated list of providers to fetch alerts by.
            service_sources_param (str): comma separated list of service_sources to fetch alerts by.
        Returns:
            str: filter query to use
        """
        filter_query = ""
        if filter_param:
            filter_query = filter_param
        else:
            if API_VER == API_V1 and providers_param:
                providers_query = []
                providers_lst = providers_param.split(',')
                for provider in providers_lst:
                    providers_query.append(f"vendorInformation/provider eq '{provider}'")
                filter_query = (" or ".join(providers_query))
            elif API_VER == API_V2 and service_sources_param:
                service_sources_query = []
                service_sources_lst = service_sources_param.split(',')
                for service_source in service_sources_lst:
                    service_sources_query.append(f"serviceSource eq '{service_source}'")
                filter_query = (" or ".join(service_sources_query))
        return filter_query


    def to_cases_hr(ret_context: dict):
        hr = ret_context.copy()
        hr['LastModifiedByName'] = dict_safe_get(ret_context, ['LastModifiedBy', "User", "DisplayName"])
        hr['ClosedByName'] = dict_safe_get(ret_context, ['ClosedBy', "User", "DisplayName"])
        return hr


    def ediscovery_cases_command_results(raw_case_list: list, raw_res=None) -> CommandResults:
        """
        Returns the CommandResults for a list of eDiscoveryCases from the API
        Args:
            raw_res: the raw_response to be used. If not provided assumed response==raw_res
            limit: max number of entries to return. Does not affect raw_result
            raw_case_list: the raw response from the api, as a list


        Returns: A CommandResults object

        """
        return to_msg_command_results(raw_object_list=raw_case_list,
                                      raw_res=raw_res,
                                      outputs_prefix='MsGraph.eDiscoveryCase',
                                      output_key_field='CaseId',
                                      raw_keys_to_replace={'status': 'CaseStatus', 'id': 'CaseId'},
                                      table_headers=['DisplayName', 'Description', 'ExternalId', 'CaseStatus', 'CaseId',
                                                     'CreatedDateTime', 'LastModifiedDateTime', 'LastModifiedByName',
                                                     'ClosedByName'],
                                      to_hr=to_cases_hr)


    def custodian_to_hr(ret_context: dict):
        hr = ret_context.copy()
        hr['LastModifiedByName'] = dict_safe_get(ret_context, ['LastModifiedBy', "User", "DisplayName"])
        hr['ClosedByName'] = dict_safe_get(ret_context, ['ClosedBy', "User", "DisplayName"])
        return hr


    def ediscovery_custodian_command_results(raw_custodian_list, raw_res=None):
        return to_msg_command_results(raw_object_list=raw_custodian_list,
                                      raw_res=raw_res,
                                      outputs_prefix='MsGraph.eDiscoveryCustodian',
                                      output_key_field='CustodianId',
                                      raw_keys_to_replace={'status': 'CustodianStatus', 'id': 'CustodianId'},
                                      table_headers=['DisplayName', 'Email', 'CustodianStatus', 'CustodianId',
                                                     'CreatedDateTime', 'LastModifiedDateTime', 'LastModifiedByName',
                                                     'ClosedByName', 'AcknowledgedDateTime',
                                                     'HoldStatus', 'ReleasedDateTime'],
                                      to_hr=custodian_to_hr)


    def to_msg_command_results(raw_object_list, outputs_prefix, output_key_field, raw_keys_to_replace, raw_res=None,
                               table_headers=[], to_hr=lambda x: x):
        """
        General function to return command results for Microsoft Graph.

        Keys beginning with @ will be stripped from the response.
        Keys will be converted to CapitalCaseFormat
        Empty elements will be removed

        Args:
            raw_object_list: the list of objects from the api. One item will be converted to a list of one
            outputs_prefix: The outputs prefix for the command
            output_key_field: The key field for the CommandResults
            raw_keys_to_replace: Keys to replace with a specific alternative. EG { 'id' : 'CustomID' }
            raw_res: The raw response exactly as received from the API. Will assume same as raw_object_list if not provided
            table_headers: Headers to show in the human readable output
            to_hr: A function that will take a context dictionary as input and convert it to a human readable dictionary.
            Default is identity function

        Returns:
            A CommandResults object
        """
        raw_res = raw_res or raw_object_list
        if not isinstance(raw_object_list, list):
            raw_object_list = [raw_object_list]
        context_list = []
        human_readable_list = []
        for res in raw_object_list:
            context = capitalize_dict_keys_first_letter(res, keys_to_replace=raw_keys_to_replace)
            keys_to_del = [key for key in context if key.startswith('@')]
            for key in keys_to_del:
                del context[key]
            context = remove_empty_elements(context)
            context_list.append(context)
            human_readable_list.append(to_hr(context))
        return CommandResults(
            outputs_prefix=outputs_prefix,
            outputs_key_field=output_key_field,
            raw_response=raw_res,
            outputs=context_list,
            readable_output=tableToMarkdown('Results:', human_readable_list,
                                            headers=table_headers,
                                            headerTransform=pascalToSpace, removeNull=True))


    def to_ediscovery_search_command_results(resp, raw_res=None):
        return to_msg_command_results(resp,
                                      raw_res=raw_res,
                                      output_key_field='SearchId',
                                      outputs_prefix='MsGraph.eDiscoverySearch',
                                      raw_keys_to_replace={'id': 'SearchId'},
                                      table_headers=['DisplayName', 'Description', 'DataSourceScopes', 'SearchId',
                                                     'CreatedByName', 'CreatedByAppName', 'CreatedByUPN', 'CreatedDateTime',
                                                     'LastModifiedDateTime', 'AdditionalSources'],
                                      to_hr=created_by_fields_to_hr)


    def ediscovery_source_command_results(raw_case_list: list, source_type, raw_res=None):
        type_name = source_type["type"]
        demisto.debug(f'Returning command results for source {type_name}')

        output_key_field = f'{type_name}SourceId'
        return to_msg_command_results(raw_object_list=raw_case_list,
                                      raw_res=raw_res,
                                      outputs_prefix=f'MsGraph.{source_type["outputs_prefix"]}',
                                      output_key_field=output_key_field,
                                      raw_keys_to_replace={'id': output_key_field},
                                      table_headers=['DisplayName', 'Email', output_key_field, 'HoldStatus',
                                                     'CreatedDateTime', 'CreatedByName', 'CreatedByUPN', 'CreatedByAppName',
                                                     'SiteWebUrl'] + source_type['unique_table_headers'],
                                      to_hr=created_by_fields_to_hr)


    ''' COMMAND FUNCTIONS '''


    def fetch_incidents(client: MsGraphClient, fetch_time: str, fetch_limit: int, filter: str, providers: str,
                        service_sources: str) -> list:
        """
        This function will execute each interval (default is 1 minute).
        This function will return up to the given limit alerts according to the given filters using the search_alerts function.
        Args:
            client (MsGraphClient): MsGraphClient client object.
            fetch_time (str): time interval for fetch alerts.
            fetch_limit (int): limit for number of fetch alerts per fetch.
            filter (str): configured user filter.
            providers (str): comma separated list of providers to fetch alerts by.
            service_sources (str): comma separated list of service_sources to fetch alerts by.
        Returns:
            List: list of fetched alerts.
        """
        filter_query = create_filter_query(filter, providers, service_sources)
        severity_map = {'low': 1, 'medium': 2, 'high': 3, 'unknown': 0, 'informational': 0}

        last_run = demisto.getLastRun()
        timestamp_format = '%Y-%m-%dT%H:%M:%S.%fZ'
        new_last_run = last_run if last_run else {'time': parse_date_range(fetch_time, date_format=timestamp_format)[0]}
        demisto_incidents: list = []
        time_from = new_last_run.get('time')
        time_to = datetime.now().strftime(timestamp_format)

        # Get incidents from MS Graph Security
        demisto.debug(f'Fetching MS Graph Security incidents. From: {time_from}. To: {time_to}. Filter: {filter_query}')
        args = {'time_to': time_to, 'time_from': time_from, 'filter': filter_query}
        params = create_search_alerts_filters(args, is_fetch=True)
        incidents = client.search_alerts(params)['value']

        if incidents:
            count = 0
            incidents = sorted(incidents, key=lambda k: k['createdDateTime'])  # sort the incidents by time-increasing order
            last_incident_time = last_run.get('time', '0')
            demisto.debug(f'Incidents times: {[incidents[i]["createdDateTime"] for i in range(len(incidents))]}\n')
            for incident in incidents:
                incident_time = incident.get('createdDateTime')
                if incident_time > last_incident_time and count < fetch_limit:
                    demisto_incidents.append({
                        'name': incident.get('title') + " - " + incident.get('id'),
                        'occurred': incident.get('createdDateTime'),
                        'severity': severity_map.get(incident.get('severity', ''), 0),
                        'rawJSON': json.dumps(incident)
                    })
                    count += 1
            if demisto_incidents:
                last_incident_time = demisto_incidents[-1].get('occurred')
                new_last_run.update({'time': last_incident_time})

        demisto.setLastRun(new_last_run)
        return demisto_incidents


    def search_alerts_command(client: MsGraphClient, args):
        """
        Retrieve a list of alerts filtered by the given filter arguments.

        Args:
            client (MsGraphClient): MsGraphClient client object.
            args (Dict): The command's arguments dictionary.

        Returns:
            str, Dict, Dict: table of returned alerts, parsed outputs and request's response.
        """
        params = create_search_alerts_filters(args, is_fetch=False)
        alerts = client.search_alerts(params)['value']
        limit = int(args.get('limit'))
        if limit < len(alerts):
            alerts = alerts[:limit]
        outputs, table_headers = [], []
        if API_VER == API_V1:
            for alert in alerts:
                outputs.append({
                    'ID': alert['id'],
                    'Title': alert['title'],
                    'Category': alert['category'],
                    'Severity': alert['severity'],
                    'CreatedDate': alert['createdDateTime'],
                    'EventDate': alert['eventDateTime'],
                    'Status': alert['status'],
                    'Vendor': alert['vendorInformation']['vendor'],
                    'Provider': alert['vendorInformation']['provider']
                })
            table_headers = ['ID', 'Vendor', 'Provider', 'Title', 'Category', 'Severity', 'CreatedDate', 'EventDate',
                             'Status']
        else:
            outputs = [capitalize_dict_keys_first_letter(alert) for alert in alerts]
            table_headers = ['ID', 'DetectionSource', 'ServiceSource', 'Title', 'Category', 'Severity', 'CreatedDate',
                             'LastUpdateDateTime', 'Status', 'IncidentId']
        ec = {
            'MsGraph.Alert(val.ID && val.ID === obj.ID)': outputs
        }
        human_readable = tableToMarkdown('Microsoft Security Graph Alerts', outputs, table_headers, removeNull=True)
        return human_readable, ec, alerts


    def get_alert_details_command(client: MsGraphClient, args):
        """
        Retrieve information about an alert with the given id.

        Args:
            client (MsGraphClient): MsGraphClient client object.
            args (Dict): The command's arguments dictionary.

        Returns:
            str, Dict, Dict: Human readable output with information about the alert, parsed outputs and request's response.
        """
        alert_id = args.get('alert_id')

        alert_details = client.get_alert_details(alert_id)

        hr = f'## Microsoft Security Graph Alert Details - {alert_id}\n'
        if API_VER == API_V2:
            outputs = capitalize_dict_keys_first_letter(alert_details)
            table_headers = ['ID', 'DetectionSource', 'ServiceSource', 'Title', 'Category', 'Severity', 'CreatedDate',
                             'LastUpdateDateTime', 'Status', 'IncidentId']
            ec = {
                'MsGraph.Alert(val.ID && val.ID === obj.ID)': outputs
            }
            hr += tableToMarkdown('', outputs, table_headers, removeNull=True)
        else:
            fields_to_include = args.get('fields_to_include')
            if fields_to_include:
                fields_list = fields_to_include.split(',')
                validate_fields_list(fields_list)
            else:
                fields_list = []
            show_all_fields = 'All' in fields_list

            basic_properties_title = 'Basic Properties'
            basic_properties = {
                'ActivityGroupName': alert_details['activityGroupName'],
                'AssignedTo': alert_details['assignedTo'],
                'AzureTenantID': alert_details['azureTenantId'],
                'Category': alert_details['category'],
                'ClosedDate': alert_details['closedDateTime'],
                'Confidence': alert_details['confidence'],
                'CreatedDate': alert_details['createdDateTime'],
                'Description': alert_details['description'],
                'EventDate': alert_details['eventDateTime'],
                'LastModifiedDate': alert_details['eventDateTime'],
                'Severity': alert_details['severity'],
                'Status': alert_details['status'],
                'Title': alert_details['title']
            }
            hr += tableToMarkdown(basic_properties_title, basic_properties, removeNull=True)

            if 'CloudAppStates' in fields_list or show_all_fields:
                cloud_apps_states = alert_details['cloudAppStates']
                if cloud_apps_states:
                    cloud_apps_hr = []
                    for state in cloud_apps_states:
                        cloud_apps_hr.append({
                            'DestinationSerivceIP': state['destinationServiceIp'],
                            'DestinationSerivceName': state['destinationServiceName'],
                            'RiskScore': state['riskScore']
                        })
                    cloud_apps_title = 'Cloud Application States for Alert'
                    hr += tableToMarkdown(cloud_apps_title, cloud_apps_hr, removeNull=True)

            if 'CustomerComments' in fields_list or show_all_fields:
                comments = alert_details['comments']
                if comments:
                    comments_hr = '### Customer Provided Comments for Alert\n'
                    for comment in comments:
                        comments_hr += f'- {comment}\n'
                    hr += comments_hr

            if 'FileStates' in fields_list or show_all_fields:
                file_states = alert_details['fileStates']
                if file_states:
                    file_states_hr = []
                    for state in file_states:
                        file_state = {
                            'Name': state['name'],
                            'Path': state['path'],
                            'RiskScore': state['riskScore']
                        }
                        file_hash = state.get('fileHash')
                        if file_hash:
                            file_state['FileHash'] = file_hash['hashValue']
                        file_states_hr.append(file_state)
                    file_states_title = 'File Security States for Alert'
                    hr += tableToMarkdown(file_states_title, file_states_hr, removeNull=True)

            if 'HostStates' in fields_list or show_all_fields:
                host_states = alert_details['hostStates']
                if host_states:
                    host_states_hr = []
                    for state in host_states:
                        host_state = {
                            'Fqdn': state['fqdn'],
                            'NetBiosName': state['netBiosName'],
                            'OS': state['os'],
                            'PrivateIPAddress': state['privateIpAddress'],
                            'PublicIPAddress': state['publicIpAddress']
                        }
                        aad_joined = state.get('isAzureAadJoined')
                        if aad_joined:
                            host_state['IsAsureAadJoined'] = aad_joined
                        aad_registered = state.get('isAzureAadRegistered')
                        if aad_registered:
                            host_state['IsAsureAadRegistered'] = aad_registered
                        risk_score = state.get('riskScore')
                        if risk_score:
                            host_state['RiskScore'] = risk_score
                        host_states_hr.append(host_state)
                    host_states_title = 'Host Security States for Alert'
                    hr += tableToMarkdown(host_states_title, host_states_hr, removeNull=True)

            if 'MalwareStates' in fields_list or show_all_fields:
                malware_states = alert_details['malwareStates']
                if malware_states:
                    malware_states_hr = []
                    for state in malware_states:
                        malware_states_hr.append({
                            'Category': state['category'],
                            'Familiy': state['family'],
                            'Name': state['name'],
                            'Severity': state['severity'],
                            'WasRunning': state['wasRunning']
                        })
                    malware_states_title = 'Malware States for Alert'
                    hr += tableToMarkdown(malware_states_title, malware_states_hr, removeNull=True)

            if 'NetworkConnections' in fields_list or show_all_fields:
                network_connections = alert_details['networkConnections']
                if network_connections:
                    network_connections_hr = []
                    for connection in network_connections:
                        connection_hr = {}
                        for key, value in connection.items():
                            if value or value is False:
                                connection_hr[capitalize_first_letter(key)] = value
                        network_connections_hr.append(connection_hr)
                    network_connections_title = 'Network Connections for Alert'
                    hr += tableToMarkdown(network_connections_title, network_connections_hr, removeNull=True)

            if 'Processes' in fields_list or show_all_fields:
                processes = alert_details['processes']
                if processes:
                    processes_hr = []
                    for process in processes:
                        process_hr = {}
                        for key, value in process.items():
                            if value or value is False:
                                process_hr[capitalize_first_letter(key)] = value
                        processes_hr.append(process_hr)
                    processes_title = 'Processes for Alert'
                    hr += tableToMarkdown(processes_title, processes_hr, removeNull=True)

            if 'Triggers' in fields_list or show_all_fields:
                triggers = alert_details['triggers']
                if triggers:
                    triggers_hr = []
                    for trigger in triggers:
                        triggers_hr.append({
                            'Name': trigger['name'],
                            'Type': trigger['type'],
                            'Value': trigger['value']
                        })
                    triggers_title = 'Triggers for Alert'
                    hr += tableToMarkdown(triggers_title, triggers_hr, removeNull=True)

            if 'UserStates' in fields_list or show_all_fields:
                user_states = alert_details['userStates']
                if user_states:
                    user_states_hr = []
                    for state in user_states:
                        state_hr = {}
                        for key, value in state.items():
                            if value or value is False:
                                state_hr[capitalize_first_letter(key)] = value
                        user_states_hr.append(state_hr)
                    user_states_title = 'User Security States for Alert'
                    hr += tableToMarkdown(user_states_title, user_states_hr, removeNull=True)

            if 'VendorInformation' in fields_list or show_all_fields:
                vendor_information = alert_details['vendorInformation']
                if vendor_information:
                    vendor_info_hr = {
                        'Provider': vendor_information['provider'],
                        'ProviderVersion': vendor_information['providerVersion'],
                        'SubProvider': vendor_information['subProvider'],
                        'Vendor': vendor_information['vendor']
                    }
                    vendor_info_title = 'Vendor Information for Alert'
                    hr += tableToMarkdown(vendor_info_title, vendor_info_hr, removeNull=True)

            if 'VulnerabilityStates' in fields_list or show_all_fields:
                vulnerability_states = alert_details['vulnerabilityStates']
                if vulnerability_states:
                    vulnerability_states_hr = []
                    for state in vulnerability_states:
                        vulnerability_states_hr.append({
                            'CVE': state['cve'],
                            'Severity': state['severity'],
                            'WasRunning': state['wasRunning']
                        })
                    vulnerability_states_title = 'Vulnerability States for Alert'
                    hr += tableToMarkdown(vulnerability_states_title, vulnerability_states_hr, removeNull=True)

            if 'RegistryKeys' in fields_list or show_all_fields:
                registry_keys = alert_details['registryKeyStates']
                if registry_keys:
                    registry_keys_hr = []
                    for r_key in registry_keys:
                        r_key_hr = {}
                        for key, value in r_key.items():
                            if value or value is False:
                                r_key_hr[capitalize_first_letter(key)] = value
                        registry_keys_hr.append(r_key_hr)
                    registry_keys_title = 'Registry Keys for Alert'
                    hr += tableToMarkdown(registry_keys_title, registry_keys_hr, removeNull=True)
            context = {
                'ID': alert_details['id'],
                'Title': alert_details['title'],
                'Category': alert_details['category'],
                'Severity': alert_details['severity'],
                'CreatedDate': alert_details['createdDateTime'],
                'EventDate': alert_details['eventDateTime'],
                'Status': alert_details['status'],
                'Vendor': alert_details['vendorInformation']['vendor'],
                'Provider': alert_details['vendorInformation']['provider']
            }
            ec = {
                'MsGraph.Alert(val.ID && val.ID === obj.ID)': context
            }
        return hr, ec, alert_details


    def update_alert_command(client: MsGraphClient, args):
        alert_id = args.get('alert_id')
        status: str = args.get('status', "")
        if status == "newAlert" and API_VER == API_V2:
            args["status"] = "new"
            status = "new"
        provider_information = args.get('provider_information')
        params = create_data_to_update(args)
        client.update_alert(alert_id, params)
        context = {
            'ID': alert_id
        }
        if status:
            context['Status'] = status
        ec = {
            'MsGraph.Alert(val.ID && val.ID === obj.ID)': context
        }
        human_readable = f'Alert {alert_id} has been successfully updated.'
        if status and API_VER == API_V1 and provider_information in {'IPC', 'MCAS', 'Azure Sentinel'}:
            human_readable += f'\nUpdating status for alerts from provider {provider_information} gets updated across \
    Microsoft Graph Security API integrated applications but not reflected in the provider`s management experience.\n \
            For more details, see the \
    [Microsoft documentation](https://docs.microsoft.com/en-us/graph/api/resources/security-api-overview?view=graph-rest-1.0#alerts)'
        return human_readable, ec, context


    def get_users_command(client: MsGraphClient, args):
        users = client.get_users()['value']
        outputs = []
        for user in users:
            outputs.append({
                'Name': user['displayName'],
                'Title': user['jobTitle'],
                'Email': user['mail'],
                'ID': user['id']
            })
        ec = {
            'MsGraph.User(val.ID && val.ID === obj.ID)': outputs
        }
        table_headers = ['Name', 'Title', 'Email', 'ID']
        human_readable = tableToMarkdown('Microsoft Graph Users', outputs, table_headers, removeNull=True)
        return human_readable, ec, users


    def get_user_command(client: MsGraphClient, args):
        user_id = args.get('user_id')
        raw_user = client.get_user(user_id)
        user = {
            'Name': raw_user['displayName'],
            'Title': raw_user['jobTitle'],
            'Email': raw_user['mail'],
            'ID': raw_user['id']
        }
        ec = {
            'MsGraph.User(val.ID && val.ID === obj.ID)': user
        }
        table_headers = ['Name', 'Title', 'Email', 'ID']
        human_readable = tableToMarkdown('Microsoft Graph User ' + user_id, user, table_headers, removeNull=True)
        return human_readable, ec, raw_user


    def create_alert_comment_command(client: MsGraphClient, args):
        """
        Adds a comment to an alert with the given id

        Args:
            client (MsGraphClient): MsGraphClient client object.
            args (Dict): The command's arguments dictionary.

        Returns:
            str, Dict, Dict: the human readable, parsed outputs and request's response.
        """
        if API_VER == API_V1:
            raise DemistoException("This command is available only for Alerts v2. If you"
                                   " wish to add a comment to an alert with Legacy Alerts please use 'msg-update-alert' command.")
        alert_id = args.get('alert_id', '')
        comment = args.get('comment', '')
        params = {"comment": comment}
        res = client.create_alert_comment(alert_id, params)
        comments = [capitalize_dict_keys_first_letter(comment) for comment in res.get('value', [])]
        context = {
            'ID': alert_id,
            'Comments': comments
        }
        ec = {
            'MsGraph.AlertComment(val.ID && val.ID == obj.ID)': context
        }
        header = f'Microsoft Security Graph Create Alert Comment - {alert_id}\n'
        human_readable = tableToMarkdown(header, comments, removeNull=True)
        return human_readable, ec, res


    def create_ediscovery_case_command(client: MsGraphClient, args: dict):
        """
        """
        res = client.create_edsicovery_case(args.get('display_name'), args.get('description'), args.get('external_id'))
        return ediscovery_cases_command_results([res], res)


    def close_ediscovery_case_command(client: MsGraphClient, args):
        """
        """
        client.close_edsicovery_case(args.get('case_id'))
        return CommandResults(readable_output=f'Case with id {args.get("case_id")} was closed successfully.')


    def reopen_ediscovery_case_command(client: MsGraphClient, args):
        """
        """
        client.reopen_edsicovery_case(args.get('case_id'))
        return CommandResults(readable_output=f'Case with id {args.get("case_id")} was reopened successfully.')


    def update_ediscovery_case_command(client: MsGraphClient, args):
        """
        """
        client.update_edsicovery_case(args.get('case_id'), args.get('display_name'), args.get('description'),
                                      args.get('external_id'))
        return CommandResults(readable_output=f'Case with id {args.get("case_id")} was updated successfully.')


    def release_ediscovery_custodian_command(client: MsGraphClient, args):
        """
        """
        client.release_edsicovery_custodian(args.get('case_id'), args.get('custodian_id'))
        return CommandResults(readable_output=f'Custodian with id {args.get("custodian_id")} was released from '
                                              f'case with id {args.get("case_id")} successfully.')


    def activate_ediscovery_custodian_command(client: MsGraphClient, args):
        """
        """
        client.activate_edsicovery_custodian(args.get('case_id'), args.get('custodian_id'))
        return CommandResults(readable_output=f'Custodian with id {args.get("custodian_id")} Case was reactivated on '
                                              f'case with id {args.get("case_id")} successfully.')


    def create_ediscovery_custodian_user_source_command(client: MsGraphClient, args):
        """
        """
        resp = client.create_edsicovery_custodian_user_source(args.get('case_id'), args.get('custodian_id'),
                                                              args.get('email'), args.get('included_sources'))
        return ediscovery_source_command_results(resp, DataSourceType['USER'])


    def create_ediscovery_custodian_site_source_command(client: MsGraphClient, args):
        resp = client.create_edsicovery_custodian_site_source(args.get('case_id'), args.get('custodian_id'),
                                                              args.get('site'))
        return ediscovery_source_command_results(resp, DataSourceType['SITE'])


    def create_ediscovery_non_custodial_data_source_command(client: MsGraphClient, args):
        site = args.get('site')
        email = args.get('email')
        if not (bool(site) ^ bool(email)):
            raise ValueError('One of either the site argument or the email argument must be provided, not both')

        resp = client.create_ediscovery_non_custodial_data_source(args.get('case_id'), site, email)

        return to_msg_command_results(raw_object_list=resp,
                                      outputs_prefix='MsGraph.NoncustodialDataSource',
                                      output_key_field='DataSourceId',
                                      raw_keys_to_replace={'status': 'DataSourceStatus', 'id': 'DataSourceId'})


    def delete_ediscovery_case_command(client: MsGraphClient, args):
        client.delete_edsicovery_case(args.get('case_id'))
        return CommandResults(readable_output='Case was deleted successfully.')


    def create_ediscovery_custodian_command(client: MsGraphClient, args):
        res = client.create_edsicovery_custodian(args.get('case_id'), args.get('email'))
        return ediscovery_custodian_command_results(res)


    def list_ediscovery_case_command(client: MsGraphClient, args):
        raw_res = client.list_ediscovery_cases(args.get('case_id'))
        if case_list := raw_res.get('value'):
            demisto.info(f'returned {raw_res.get("@odata.count")} results from the api')
        else:
            case_list = [raw_res]  # api doesnt return a list if only 1 result
        if not argToBoolean(args.get('all_results', 'false')):
            case_list = case_list[:arg_to_number(args.get('limit', 50))]
        return ediscovery_cases_command_results(case_list, raw_res)


    def list_ediscovery_custodian_command(client: MsGraphClient, args):
        raw_res = client.list_ediscovery_custodians(args.get('case_id'), args.get('custodian_id'))
        if custodian_list := raw_res.get('value'):
            demisto.info(f'returned {raw_res.get("@odata.count")} results from the api')
        else:
            custodian_list = [raw_res]  # api doesnt return a list if only 1 result
        if not argToBoolean(args.get('all_results', 'false')):
            custodian_list = custodian_list[:arg_to_number(args.get('limit', 50))]
        return ediscovery_custodian_command_results(custodian_list, raw_res)


    def list_ediscovery_custodian_user_sources_command(client: MsGraphClient, args):
        return list_ediscovery_custodian_sources(client, args, DataSourceType['USER'])


    def list_ediscovery_custodian_site_sources_command(client: MsGraphClient, args):
        return list_ediscovery_custodian_sources(client, args, DataSourceType['SITE'])


    def list_ediscovery_non_custodial_data_source_command(client: MsGraphClient, args):
        raw_res = client.list_ediscovery_noncustodial_datasources(args.get('case_id'), args.get('data_source_id'))
        if source_list := raw_res.get('value'):
            demisto.info(f'returned {len(source_list)} results from the api')
        else:
            source_list = [raw_res]  # api doesnt return a list if only 1 result
        if not argToBoolean(args.get('all_results', 'false')):
            source_list = source_list[:arg_to_number(args.get('limit'))]
        return ediscovery_source_command_results(source_list, DataSourceType['NON_CUSTODIAL'], raw_res)


    def update_hold_ediscovery_custodian_command(client: MsGraphClient, args, hold_action: HoldAction):
        demisto.debug(f'{hold_action.value=}')
        res = client.update_hold_ediscovery_custodian(args.get('case_id'), args.get('custodian_id'), hold_action)
        status = get_status_of_operation(client, res)
        return CommandResults(readable_output=f'{hold_action.value.capitalize()} hold status is {status}.')


    def apply_hold_ediscovery_custodian_command(client: MsGraphClient, args):
        return update_hold_ediscovery_custodian_command(client, args, HoldAction.APPLY)


    def remove_hold_ediscovery_custodian_command(client: MsGraphClient, args):
        return update_hold_ediscovery_custodian_command(client, args, HoldAction.REMOVE)


    def update_ediscovery_search_command(client: MsGraphClient, args):
        client.update_ediscovery_search(args.get('case_id'), args.get('search_id'), args.get('display_name'),
                                        args.get('description'),
                                        args.get('query'), args.get('data_source_scopes'))

        return CommandResults(readable_output=f'eDiscovery search {args.get("search_id")} was updated successfully.')


    def delete_ediscovery_search_command(client: MsGraphClient, args):
        client.delete_ediscovery_search(args.get('case_id'), args.get('search_id'))

        return CommandResults(readable_output=f'eDiscovery search {args.get("search_id")} was deleted successfully.')


    def purge_ediscovery_data_command(client: MsGraphClient, args):
        resp = client.purge_ediscovery_data(args.get('case_id'), args.get('search_id'), args.get('purge_type'),
                                            args.get('purge_areas'))
        status = get_status_of_operation(client, resp)
        return CommandResults(readable_output=f'eDiscovery purge status is {status}.')


    def create_ediscovery_search_command(client: MsGraphClient, args):
        resp = client.create_ediscovery_search(args.get('case_id'), args.get('display_name'), args.get('description'),
                                               args.get('query'), args.get('data_source_scopes'))

        return to_ediscovery_search_command_results(resp)


    def list_ediscovery_search_command(client: MsGraphClient, args):

        raw_res = client.list_ediscovery_search(args.get('case_id'), args.get('search_id'))
        if case_list := raw_res.get('value'):
            demisto.info(f'returned {len(case_list)} results from the api')
        else:
            case_list = [raw_res]
        if not argToBoolean(args.get('all_results', 'false')):
            case_list = case_list[:arg_to_number(args.get('limit'))]
        return to_ediscovery_search_command_results(case_list, raw_res)


    def test_auth_code_command(client: MsGraphClient, args):
        """
        Called to test authorization code flow (since integration context cant be accessed during test_module)
        Calls list cases with no arguments
        """
        permissions = args.get('permission_type', 'all')
        if permissions == 'all':
            permissions = "ediscovery, alerts, threat assessment"
        for permission in argToList(permissions):
            try:
                demisto.debug(f'checking permission {permission}')
                match permission:
                    case 'ediscovery':
                        list_ediscovery_case_command(client, {})
                    case 'alerts':
                        test_function(client, args, True)
                    case 'threat assessment':
                        list_threat_assessment_requests_command(client, {})
            except Exception as e:
                raise DemistoException(f'Authorization was not successful for permission {permission} '
                                       'Check that you have the required permissions') from e
        return CommandResults(readable_output='Authentication was successful.')


    def test_function(client: MsGraphClient, args, has_access_to_context=False):    # pragma: no cover
        """
        Args:
            has_access_to_context (bool): Whether this function is called from a command that allows this integration to access the
            context. When called from the test button on an integration, we dont have access to the integration context. Since auth
            code workflow depends on reading from and writing to the context, if we dont have access, this function cannot run
            successfully, so we will throw an exception.
           Performs basic GET request to check if the API is reachable and authentication is successful.
        Returns:
            'ok' if connection is successful.
        Raises:
            DemistoException: If using auth code flow and called from test_module
        """
        if not has_access_to_context and hasattr(client.ms_client, 'grant_type') \
                and client.ms_client.grant_type == AUTHORIZATION_CODE:
            raise DemistoException(
                "Test module is not available for the authorization code flow."
                " Use the msg-auth-test command instead.")

        response = client.ms_client.http_request(
            method='GET', url_suffix=CMD_URL, params={'$top': 1}, resp_type='response')
        try:
            data = response.json() if response.text else {}
            if not response.ok:
                return_error(f'API call to MS Graph Security failed. Please check authentication related parameters.'
                             f' [{response.status_code}] - {demisto.get(data, "error.message")}')

            params: dict = demisto.params()

            if params.get('isFetch'):
                fetch_time = params.get('fetch_time', '1 day')
                fetch_providers = params.get('fetch_providers', '')
                fetch_filter = params.get('fetch_filter', '')
                fetch_service_sources = params.get('fetch_service_sources', '')

                filter_query = create_filter_query(fetch_filter, fetch_providers, fetch_service_sources)
                timestamp_format = '%Y-%m-%dT%H:%M:%S.%fZ'
                time_from = parse_date_range(fetch_time, date_format=timestamp_format)[0]
                time_to = datetime.now().strftime(timestamp_format)
                args = {'time_to': time_to, 'time_from': time_from, 'filter': filter_query}
                params = create_search_alerts_filters(args, is_fetch=True)
                try:
                    client.search_alerts(params)['value']
                except Exception as e:
                    if 'Invalid ODATA query filter' in e.args[0]:
                        raise DemistoException("Wrong filter format, correct usage: {property} eq '{property-value}'"
                                               "\n\n" + e.args[0])
                    raise e

            return 'ok', None, None

        except TypeError as ex:
            demisto.debug(str(ex))
            return_error(f'API call to MS Graph Security failed, could not parse result. '
                         f'Please check authentication related parameters. [{response.status_code}]')


    def get_message_user(client, message_user):
        is_email = re.search(EMAIL_REGEX, message_user)
        if is_email:
            user_result = (client.get_user_id(message_user)).get('value')
            if not user_result:
                raise DemistoException(f'{message_user} is not a valid user')
            return user_result[0].get('id')
        return message_user


    def is_base_64(string: str) -> bool:    # pragma: no cover
        """
        Validate if string is base 64 encoded.
        Args:
            string (str): String to validate.

        Returns:
            bool: True if the string is base 64 encoded ,  else False.

        """
        try:
            if isinstance(string, str):
                # If there's any unicode here, an exception will be thrown and the function will return false
                string_bytes = bytes(string, 'ascii')
            elif isinstance(string, bytes):
                string_bytes = string
            else:
                raise ValueError("Argument must be string or bytes")
            return base64.b64encode(base64.b64decode(string_bytes)) == string_bytes
        except Exception:
            return False


    def get_content_data(entry_id, content_data):   # pragma: no cover

        if not (entry_id or content_data) or (entry_id and content_data):
            raise DemistoException('One of entry_id or content_data arguments has to be provided.')
        try:
            if entry_id:
                file = demisto.getFilePath(entry_id)
                file_path = file['path']
                with open(file_path, 'rb') as fp:
                    content = base64.b64encode(fp.read())
                    return str(content, encoding='utf-8')
            if content_data:
                return content_data if is_base_64(content_data) else base64.b64encode(content_data)

        except Exception as e:
            raise DemistoException(f'Failed loading content data: {e}')


    def get_result_outputs(result) -> Dict:
        output = {
            'ID': result.get('id'),
            'Created DateTime': result.get('createdDateTime'),
            'Content Type': result.get('contentType'),
            'Expected Assessment': result.get('expectedAssessment'),
            'Category': result.get('category'),
            'Status': result.get('status'),
            'Request Source': result.get('requestSource'),
            'Recipient Email': result.get('recipientEmail'),
            'Destination Routing Reason': result.get('destinationRoutingReason'),
            'URL': result.get('url'),
            'File Name': result.get('fileName'),
        }
        if created_by := result.get('createdBy'):
            output['Created User ID'] = created_by.get('user', {}).get('id')
            output['Created Username'] = created_by.get('user', {}).get('displayName')

        if results := result.get('results'):
            output['Result Type'] = results[0].get('resultType')
            output['Result message'] = results[0].get('message')
        return output


    def get_threat_assessment_request(client: MsGraphClient, request_id):
        result = client.get_threat_assessment_request(request_id)
        outputs = get_result_outputs(result)
        readable_output = tableToMarkdown('Threat assessment request:', outputs, removeNull=True)

        return [CommandResults(readable_output=readable_output,
                               raw_response=result,
                               outputs=outputs,
                               outputs_prefix='MSGraphMail.AssessmentRequest')]


    @polling_function('msg-create-mail-assessment-request',
                      timeout=arg_to_number(demisto.args().get("timeout_in_seconds", 720)),
                      requires_polling_arg=False)
    def create_mail_assessment_request_command(args, client: MsGraphClient) -> PollResult | CommandResults:

        request_id = args.get('request_id')

        if not request_id:
            message_user = get_message_user(client, args.get('message_user'))
            result = client.create_mail_assessment_request(args.get('recipient_email'),
                                                           args.get('expected_assessment'),
                                                           args.get('category'),
                                                           message_user,
                                                           args.get('message_id'))
            request_id = result.get('id')

        result = client.get_threat_assessment_request_status(request_id)
        status = result.get('status')
        demisto.debug(f"status is: {status}")
        if status == 'completed':
            result = client.get_threat_assessment_request(request_id)
            outputs = get_result_outputs(result)
            outputs['Message ID'] = args.get('message_id')
            readable_output = tableToMarkdown('Mail assessment request:', outputs, removeNull=True)

            results = CommandResults(readable_output=readable_output,
                                     raw_response=result,
                                     outputs=outputs,
                                     outputs_prefix='MSGraphMail.MailAssessment')
            return PollResult(response=results)
        else:
            return PollResult(continue_to_poll=True, args_for_next_run={"request_id": request_id, **args},
                              response=None,
                              partial_result=CommandResults(readable_output="The status is pending, still waiting to get results..."))


    @polling_function('msg-create-email-file-assessment-request',
                      timeout=arg_to_number(demisto.args().get("timeout_in_seconds", 720)),
                      requires_polling_arg=False)
    def create_email_file_request_command(args, client: MsGraphClient) -> PollResult | CommandResults:

        request_id = args.get('request_id')

        if not request_id:
            content_data = get_content_data(args.get('entry_id'), args.get('content_data'))
            result = client.create_email_file_assessment_request(args.get('recipient_email'),
                                                                 args.get('expected_assessment'),
                                                                 args.get('category'),
                                                                 content_data)
            request_id = result.get('id')
        demisto.debug(f"got request id: {request_id}")
        result = client.get_threat_assessment_request_status(request_id)
        status = result.get('status')
        demisto.debug(f"status is: {status}")
        if status == 'completed':
            result = client.get_threat_assessment_request(request_id)
            outputs = get_result_outputs(result)
            readable_output = tableToMarkdown('Email file assessment request results:', outputs, removeNull=True)

            results = CommandResults(readable_output=readable_output,
                                     raw_response=result,
                                     outputs=outputs,
                                     outputs_prefix='MSGraphMail.EmailAssessment')
            return PollResult(response=results)
        else:
            return PollResult(continue_to_poll=True, args_for_next_run={"request_id": request_id, **args},
                              response=None,
                              partial_result=CommandResults(readable_output="The status is pending, still waiting to get results..."))


    @polling_function('msg-create-file-assessment-request', requires_polling_arg=False)
    def create_file_assessment_request_command(args, client) -> PollResult | CommandResults:
        request_id = args.get('request_id')

        if not request_id:
            content_data = get_content_data(args.get('entry_id'), args.get('content_data'))
            demisto.debug(f"got content data: {content_data}")
            result = client.create_file_assessment_request(args.get('expected_assessment'),
                                                           args.get('category'),
                                                           args.get('file_name'),
                                                           content_data)
            request_id = result.get('id')

            # request_id = "33e8c68f-9a57-4332-1739-08dbd2e880ba"
        demisto.debug(f"got request id: {request_id}")
        result = client.get_threat_assessment_request_status(request_id)
        status = result.get('status')

        demisto.debug(f"status is: {status}")
        if status == 'completed':
            result = client.get_threat_assessment_request(request_id)
            outputs = get_result_outputs(result)
            readable_output = tableToMarkdown('File assessment request results:', outputs, removeNull=True)

            results = CommandResults(readable_output=readable_output,
                                     raw_response=result,
                                     outputs=outputs,
                                     outputs_prefix='MSGraphMail.FileAssessment')
            return PollResult(response=results)
        else:
            return PollResult(continue_to_poll=True, args_for_next_run={"request_id": request_id, **args},
                              response=None,
                              partial_result=CommandResults(readable_output="The status is pending, still waiting to get results..."))


    @polling_function('msg-create-url-assessment-request',
                      timeout=arg_to_number(demisto.args().get("timeout_in_seconds", 720)),
                      requires_polling_arg=False)
    def create_url_assessment_request_command(args, client: MsGraphClient) -> PollResult | CommandResults:

        request_id = args.get('request_id')

        if not request_id:
            result = client.create_url_assessment_request(args.get('expected_assessment'),
                                                          args.get('category'),
                                                          args.get('url'))
            request_id = result.get('id')
            # request_id = "9203569d-313e-420e-fb3d-08dbd25dafbe"
        result = client.get_threat_assessment_request_status(request_id)
        status = result.get('status')
        demisto.debug(f"status is : {status}")
        if status == 'completed':
            result = client.get_threat_assessment_request(request_id)
            outputs = get_result_outputs(result)
            readable_output = tableToMarkdown('URL assessment request results:', outputs, removeNull=True)

            results = CommandResults(readable_output=readable_output,
                                     raw_response=result,
                                     outputs=outputs,
                                     outputs_prefix='MSGraphMail.UrlAssessment')
            return PollResult(response=results)
        else:
            return PollResult(continue_to_poll=True, args_for_next_run={"request_id": request_id, **args},
                              response=None,
                              partial_result=CommandResults(readable_output="The status is pending, still waiting to get results..."))


    def list_threat_assessment_requests_command(client: MsGraphClient, args) -> list[CommandResults]:
        command_results = []
        limit = args.get('limit')
        request_id = args.get('request_id')
        if request_id:
            return get_threat_assessment_request(client, request_id)

        result = client.list_threat_assessment_requests(
            args.get('filter'),
            args.get('order_by'),
            args.get('sort_order'),
            args.get('next_token')
        )
        outputs = []
        requests_list = result.get('value')
        if limit:
            requests_list = requests_list[:limit]
        for req in requests_list:
            outputs.append(get_result_outputs(req))
        readable_outputs = tableToMarkdown('Threat assessment request results:', outputs, removeNull=True)
        command_results.append(CommandResults(readable_output=readable_outputs,
                                              raw_response=result,
                                              outputs=outputs,
                                              outputs_prefix='MSGraphMail.AssessmentRequest'))

        skip_token_field = result.get('@odata.nextLink')
        demisto.debug(f"skip_token_field: {skip_token_field}")
        if skip_token_field:
            next_token_value: List[str] = re.split(r'skip[t|T]oken=', skip_token_field)
            if len(next_token_value) > 1:
                next_token: str = next_token_value[1]

                command_results.append(CommandResults(readable_output=f'Next token is: {next_token}\n' if next_token else None,
                                                      outputs={"next_token": next_token},
                                                      outputs_prefix='MsGraph.AssessmentRequestNextToken'))

        return command_results


    def main():
        params: dict = demisto.params()
        args: dict = demisto.args()
        url = params.get('host', '').rstrip('/') + '/v1.0/'
        tenant = params.get('creds_tenant_id', {}).get('password') or params.get('tenant_id')
        auth_and_token_url = params.get('creds_auth_id', {}).get('password') or params.get('auth_id', '')
        enc_key = params.get('creds_enc_key', {}).get('password') or params.get('enc_key')
        use_ssl = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        certificate_thumbprint = params.get('creds_certificate', {}).get('identifier') or params.get(
            'certificate_thumbprint')
        private_key = replace_spaces_in_credential(params.get('creds_certificate', {}).get('password')) or params.get(
            'private_key')
        managed_identities_client_id = get_azure_managed_identities_client_id(params)
        self_deployed: bool = params.get('self_deployed', False) or managed_identities_client_id is not None
        api_version: str = params.get('api_version', API_V2)

        if not managed_identities_client_id:
            if not self_deployed and not enc_key:
                raise DemistoException('Key must be provided. For further information see '
                                       'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')
            elif not enc_key and not (certificate_thumbprint and private_key):
                raise DemistoException('Key or Certificate Thumbprint and Private Key must be provided.')

        commands = {
            'test-module': test_function,
            'msg-auth-test': test_auth_code_command,
            'msg-search-alerts': search_alerts_command,
            'msg-get-alert-details': get_alert_details_command,
            'msg-update-alert': update_alert_command,
            'msg-get-users': get_users_command,
            'msg-get-user': get_user_command,
            'msg-create-alert-comment': create_alert_comment_command,

            # eDiscovery commands
            'msg-create-ediscovery-case': create_ediscovery_case_command,
            'msg-list-ediscovery-cases': list_ediscovery_case_command,
            'msg-update-ediscovery-case': update_ediscovery_case_command,
            'msg-close-ediscovery-case': close_ediscovery_case_command,
            'msg-reopen-ediscovery-case': reopen_ediscovery_case_command,
            'msg-delete-ediscovery-case': delete_ediscovery_case_command,
            'msg-create-ediscovery-custodian': create_ediscovery_custodian_command,
            'msg-list-ediscovery-custodians': list_ediscovery_custodian_command,
            'msg-release-ediscovery-custodian': release_ediscovery_custodian_command,
            'msg-activate-ediscovery-custodian': activate_ediscovery_custodian_command,
            'msg-create-ediscovery-custodian-user-source': create_ediscovery_custodian_user_source_command,
            'msg-list-ediscovery-custodian-user-sources': list_ediscovery_custodian_user_sources_command,
            'msg-create-ediscovery-custodian-site-source': create_ediscovery_custodian_site_source_command,
            'msg-list-ediscovery-custodian-site-sources': list_ediscovery_custodian_site_sources_command,
            'msg-create-ediscovery-non-custodial-data-source': create_ediscovery_non_custodial_data_source_command,
            'msg-list-ediscovery-non-custodial-data-sources': list_ediscovery_non_custodial_data_source_command,
            'msg-apply-hold-ediscovery-custodian': apply_hold_ediscovery_custodian_command,
            'msg-remove-hold-ediscovery-custodian': remove_hold_ediscovery_custodian_command,
            'msg-create-ediscovery-search': create_ediscovery_search_command,
            'msg-update-ediscovery-search': update_ediscovery_search_command,
            'msg-list-ediscovery-searchs': list_ediscovery_search_command,
            'msg-delete-ediscovery-search': delete_ediscovery_search_command,
            'msg-purge-ediscovery-data': purge_ediscovery_data_command,
        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            auth_code = params.get('auth_code', {}).get('password')
            redirect_uri = params.get('redirect_uri')
            grant_type = AUTHORIZATION_CODE if auth_code and redirect_uri else CLIENT_CREDENTIALS

            client: MsGraphClient = MsGraphClient(tenant_id=tenant,
                                                  auth_code=auth_code,
                                                  auth_id=auth_and_token_url,
                                                  enc_key=enc_key,
                                                  redirect_uri=redirect_uri,
                                                  app_name=APP_NAME,
                                                  base_url=url,
                                                  verify=use_ssl,
                                                  proxy=proxy,
                                                  self_deployed=self_deployed,
                                                  certificate_thumbprint=certificate_thumbprint,
                                                  private_key=private_key,
                                                  managed_identities_client_id=managed_identities_client_id,
                                                  api_version=api_version,
                                                  grant_type=grant_type)
            if command == "fetch-incidents":
                fetch_time = params.get('fetch_time', '1 day')
                fetch_limit = params.get('fetch_limit', 10) or 10
                fetch_providers = params.get('fetch_providers', '')
                fetch_service_sources = params.get('fetch_service_sources', '')
                fetch_filter = params.get('fetch_filter', '')
                incidents = fetch_incidents(client, fetch_time=fetch_time, fetch_limit=int(fetch_limit),
                                            filter=fetch_filter, providers=fetch_providers,
                                            service_sources=fetch_service_sources)
                demisto.incidents(incidents)
            elif command == 'msg-create-mail-assessment-request':
                return_results(create_mail_assessment_request_command(args, client))
            elif command == 'msg-create-email-file-assessment-request':
                return_results(create_email_file_request_command(args, client))
            elif command == 'msg-create-file-assessment-request':
                return_results(create_file_assessment_request_command(args, client))
            elif command == 'msg-create-url-assessment-request':
                return_results(create_url_assessment_request_command(args, client))
            elif command == 'msg-list-threat-assessment-requests':
                return_results(list_threat_assessment_requests_command(client, args))
            elif command == "ms-graph-security-auth-reset":
                return_results(reset_auth())
            elif demisto.command() == 'msg-generate-login-url':
                return_results(generate_login_url(client.ms_client))
            else:
                if command not in commands:
                    raise NotImplementedError(f'The provided command {command} was not implemented.')
                command_res = commands[command](client, args)  # type: ignore
                if isinstance(command_res, CommandResults):
                    return_results(command_res)
                else:
                    human_readable, entry_context, raw_response = command_res  # pylint: disable=E0633  # type: ignore
                    return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as err:
            return_error(f'Failed to execute {command} command.\nError:\n{err}\nTraceback:{traceback.format_exc()}')


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Microsoft Graph Test', 'end', __line__())
  subtype: python3
  type: python
