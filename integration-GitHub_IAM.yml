category: Identity and Access Management
commonfields:
  id: GitHub IAM
  version: -1
configuration:
- display: GitHub URL https://<domain>.github.com/
  name: url
  required: true
  section: Connect
  type: 0
- display: ""
  displaypassword: Token
  hiddenusername: true
  name: creds_token
  required: false
  section: Connect
  type: 9
- advanced: true
  display: Token
  hidden: true
  name: token
  required: false
  section: Connect
  type: 4
- display: Organization name
  name: org
  required: true
  section: Connect
  type: 0
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "true"
  display: Allow creating users
  name: create-user-enabled
  required: false
  section: Collect
  type: 8
- advanced: true
  defaultvalue: "true"
  display: Allow updating users
  name: update-user-enabled
  required: false
  section: Collect
  type: 8
- advanced: true
  defaultvalue: "true"
  display: Allow disabling users
  name: disable-user-enabled
  required: false
  section: Collect
  type: 8
- advanced: true
  defaultvalue: "true"
  display: Automatically create user if not found in update and enable commands
  name: create-if-not-exists
  required: false
  section: Collect
  type: 8
- defaultvalue: User Profile - SCIM (Incoming)
  display: Incoming Mapper
  name: mapper_in
  required: true
  section: Connect
  type: 0
- defaultvalue: User Profile - SCIM (Outgoing)
  display: Outgoing Mapper
  name: mapper_out
  required: true
  section: Connect
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 2.1.2
    packID: GitHub
    packName: GitHub
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Integrate with GitHub services to perform Identity Lifecycle Management
  operations.
detaileddescription: "\n To access the requested repository, you need to provide \n
  the username, repository name, and API key as parameters when configuring the\n
  integration instance.\n \n To generate your personal access token, visit:\n https://github.com/settings/tokens\n
  \n \n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/git-hub-iam)"
display: GitHub IAM
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAETlJREFUeAHtm2lwVNeVgLvf61X7voCEJbEJUWY1xtjJmDgTbBKInQXsil0VklScxBN7yuMax5NZzCT5kcRMqpypmRg7rnFldUE8cWIc7AARBBuG1TJGFEIsAoHMJiS1pF5fd893HnrN60WtltCPmcq71NPdzzn3bPfcexubzUoWBywOWBywOGBxwOKAxQGLAxYHLA5YHLA4YOKA3VSeaFFhomPu3Lku8rJIJDJN07SqUCCQH43H7V6vN+Byua46HI5u2i9FOzrCJ222CGNjE0VozcudAzcjYKWurs6dn58/MxIKfTIcifx1TIvOidts1fF4XDWTYLfb43y9iqp0Kqq60+t0vsnEtiNHjgQZFzWPtcqTy4EJCbihocHjdTgW+IPBv9Ei2mostRih5kQZgrYpdntQcag78jye//CHQjvPnz8vgs4NQE5YrEEGB8YrYGXevHkVvn7f34XDoW/EYrGiXAVrIDRyu41/il1zuly/LC4p/s4HH3xwlj7Lmg0GTVI+HgEr8+bMa+kf6vtJOBz+SDw2OQaHNdtUh+N4UUH+N4+dOLGLdWmTtDYLDBxI2iuzcERpaWlZMuDr/00kFJ6fozfOAu5Gl6gJnqAiommfrqmt6bh27doJmiZHe26g+Yst5STglvktLb5r/a8RITeZOCXuVDzAeLyAabouRImkdRgI2RONRO+bMnXKe729vafMA63yxDkwpoBvv/328quXrvwaC7vVQEMkPOxyOt8hYNLYg720y1FJPnMyrDBVAWJ6kKWqPQ6ns40J+cDIl4mxeMxD0PZXTdOb3rx06VKvGdgEykLPzSjgBFD+35uSyvxUCpWGWxo2BAOBJ83BlNPlfK37/Pm1S5cuLcWl3hMMBB+LRiJLRaIIPco3zPgAVTkeeSkX8CFXu8JR6TjR88a8wsI32traPmyY1vCvoVDwnwz4jLG5XM43XR7P506ePBlKJWiMumPKlCmuqVOnlgcCgVLO4G68TsTpdPrwEDiG3lBXV5dE7OYkijCuM/mMGTPcBgBoFE+WGjfYGSP3AnpizETP/Q7g6Ebodrvj7e3tYQNmrnlWAbfMbFnaP9jXGo1GxUr1JALweLzPdJ3r+oHRtm7dOs/ed/Y+HI2GbV63+5i3qOhiMBgcVlUV8/bmDWqDFcPDw7MZX1lRUfGL/fv3J6yzcdq01YFg6PeGgAUm0bWtML/o4c7Tnb8ycIyVL168OI+LlFXI8xG+hcArZY6DXBTODy09fDurqqqe3blzZ7+g4URQifAbYd6ZPXv2XKHN8Dqjolu2bJl3YGDgSQYUyqC8vLzdBw8e/IN5wpIlS+r9fv9j4BYFl8ueTYx5zzwml/LChQs/HwqFFstYaO8H949efPFFUZackyPLSGXQP/AUmp8QrjGWm6khoyz5K6+8IlbxsrktpXyW+iFpO336dFKX4nQO2UNhG7xItEuE7g/6n0YAv+MyZDjRMUphxYoV+Zyl/43o/msCxwxLplDPk0AOBain+l1pu/POO5vwPpux9Lkw7yhCWXPgwAGdOLmVQyH1LYeLnJjZcvAC+cD5FnIrUhTFhiBle0kSMPxpQAmewTBEMIJOYopxCxgjWQuuNdAucK52d3f/BDiTI2Ci5jl9vdc+lcosoTYcDtZJPhlJC2lTMuGIadr84HDwE+B4fQw89gsXLjwtwhVGSIL5EhuEJacqjQ7K8Eg90Nra2kvZhgBWw7yFMoexixD0Ksb9mE/SV7HMBikgxE6yF6UsibpoYoA5RSP40hiOYOnS4coJQaalunBpyyWFDDjg8+NtblhBLrMZM6oFB4YDnwVoXgY4MQxs3IgywNGb3HluNRQJaXA5iRadi8HhhxiUVcBiiVeuXPnbEUaKcCMej2cLd98/RxinEWIMwcqFzK1yH06/Tjtu+RRKEaAuwtekLgQxzj5r1qwvky+SOnN3kyUELG3/n1ISUw3C16xZo+57d89KFmk06bls2KpDbZtaN3XDue5zSX0TrSxfvvzXb23duiocDK0xYxPcsWj0ox+//ePlO/bvSOzZqXiwxM8xtljaRXgI6mXof3z9+vWpVvOueW5RUdFW9mrZJ+9CiHsKCwvfFhC33XabCDxgKAxKEp49e7a+33Z0dPjNMEYrCx2Z+ri79xYXF+s+my1AMwd8EkPgkvVtgblh87ZgwGJtcv9fRi40Co4QAZxsl9ddlzHQlGcUcE9PT7UWi0tQlJwkwnW7N+7du/dacsfEaxI0YDH/Hg6FH8B8nGZI0Zitpqu3S+jYY243l7HQuwxFZNE+ApoNGYRrnqKXmSdbQzkC7MClllFvYu/1IfQFDKiUQQKXvgb21CfENbNPvyqhuA5g5A841aamJl3BjHbmJSLokTZd4KWlpQ9Sr5E2BH2abJOUEa4T4a4DR5HU8TQHybZL2UjgcXV2dj6IIi6F1mnUIyjmkUWLFv3q8OHD7YyLGmPNeUYBX758uT4Wj0oUmpwUux/CWpMbb77G0ea9ocGhC1FNazBDQ0lhq65oGQX86KOPOnft2tVkCJgFdxCtnmHxOtMQTBXMMKxCB437Du7evfsKDJ2Ni94glgpjbUNDQ6eY9xH24icQakLRmD+dMd8TmORHCgoKWhmrwxK89N+NRa030+3z+aYaNJnbwfk09TnSBq27yHQBI1AvtKxnTqXggZ4X6EsSMDRVg3ejzDVgQ89K2u9H8T5PgChCTksZBRwNhSrZZdOOUDgFX4mtRI4Tk5qWt7b6T9XVX0IFG8yAZYfggqXa3GYunzhxws0Cdfc5IoDz5Lq7IkiaefXq1c30J6aIIAcHB9toeBjmSCRkBEHi3onrNNmrRXpiSborpV1c/aDApy8toBKLp0+sPikZQjA30hYy2pmTdKalPSj0CB6En7q9CG79yRWlhUxN5SujSeVrRvB/D54v8emewowzSbuNjpiiSOifllhirDfamyb4tIHjbHj2OmEZ4QbD4UyBno4BzVdhSEJJEWBCADC+ECa0mD/apD4jE3kCB/f3CxTjH2FwlzEGmKew+m/D2G9XVla2Y50J65YxzNP4hinK/uwfKcuxcVITEXQ/9H0da11VU1PzCHSdEQQI2Ma67lm5cqWu6KlIE8wxd9hj9htqb+qI25QCFltAU5+p+aaLn3ziCReE6vtPKjDFpqRpszEGYQmdCaFiAYlFIvwgTLgoVkEqB74hmIzwsHQHe9mfGftnYoKHENR0mQiMrqNHj4rL1FNzc3M57tSoirW146J3Gw0jVjgFVy+nEKP5pnPw9L300ku/JwjU10u88Cou37gBrELxakHiS0WU0YLZrwfQzdSx2H+soL+/vzGt4yYbultbq2BMRlfs8rjSiDbQEYEHEUS/1IWZlJtWr16tW3xtbe0J4oXVBDb3Y33HjTlj5cCRhevuWcZST5RT54LPhmW9zVv248ZH9Ps4OH8gfZOc7Fu2bDGUVOjSY40RHC6EndHrZhSwJz//Q54ObqjpCBR4qHB19rFJJtzGhcYd8VisJBNcGHguU7u0SbSMhbUbzERJms6ePXsHXfbNmzcHuBIl5jq4n/5RlWQ02Lm2w+g0L4jLTAgiFzh4m5xMnaNdYhx4E7JjfXIdmyYvwZ0YZCaEy/puxa58aG7Ty0g4FtHWcoVYldY3wQYi6DzuG9bFrltOMhTOo2NZH8x5WxYoE1m0C/f5LwsWLJghRxf2zAIu6yVwGtUKkxEmagnzA7Yixxh6MvIqMWOcBeA68ECiHApn4jHpYw12jq9Cg3wOlHkabQbWYWIHvG56ykj09u3bB1RVOZxYpWleJBpt4Sc7T/FokNjvTN3jKsrBP8+d94WQpq1InSi4HarayZXpmdQ+c726uvoPWLHugmXBWM/d3A+/jmL8c1lZ2WMogNynN5jmZFqWqVs/wugXGgKPvXkmXms5F//NojR4lFEvFQwgxAZG0ch1nOyjupUJXGia2dfX99H58+fPoXw/bUlnaWOikTOmcMeOHSuFDuaIl/qMwJGEspzjzvyyXkn5k+ZejH5+K/VGJBy5H7PgbYdkt8vTHResNm8wFHiyOL9wiD1uIwzwcSMjfQl1kuHZklzms5cXepzOz/gDQxt4CE6ngz3MrirbxNVmg8Wie/Eo/0BQ81NokWBKjhAtLFo+sWr9M2DQljGApH9kmfY4SiVHqXv4OIbH64H9OnvcIMHU15m/jc9uYu6YCmPgRhGPUF7CZ4fWOiz3deDI+uSXqAn+CXyZQ1MCNopbRiD1Ks1X6M6jTw9KKUdRuq0kkUFaymjBMgo3/RYP+z0GBlVR3+GacpPqVHsQszIU8H+H3z7/TLWpDxB1NuJqK7CmjBu9wGvgl5gyprGx8Ra/z3cfnPvxoN//n9zLZ9ZcLlVwO7KgMRMvTm9whPgG1noYK7nGov0wIMwnEWeEugRjPr5L9O8TgFhEbKRN2n0wPyF4YP0X4zpoGwKGME4UUF6PHPK6JLBH5sg7c7q5In8zbEHHJ0+LPwXuWeDIsUrok5c6Wf8AtJ/h65N5wDROBkK70NZPn3ipQb4S5nmEBqEP4R6Bphdoz5jSLWdkGLc9H06rn/bzcDT6LVRLcTiUgcqamg0Ou2PrhZ7uZ7Hu5khEu1eLDt2rBtVTuNNjBcUFv7x48eImiEpoo4EV7V8Wj2jfDAeCc6Lx2Ez01YGKGt1JuSiV2+l8C8t8j/vfpL7RKhxx/puz4G6eDVdgHXfw1cMoL7RwrNcZdBQmtfILlQPHjx+3lZSUnGS//j7j0GM1jkt/34C9b9++Y/J8iKt/BG/QDAwHMK7Sf4x1yGPGc8wrpM3G1eheY56RoyBnsc7vX9ch/RnrsPQdOnRoH8ecB/EIX8AipyMkJ7j7+PYRL7zF8+XHaC8Hh66E5K+B+ySfj+3mTbzeveC9E7jlgJOryqPgegV6zxi4U3PDQFPb9TqLrLlw/sIWftC+WJyFU1GPVNZWf4VFz+q92vu9eDQqV3L6vSu/1BgoKilZCfPSFizA2Dtuudxz8d1ojDkZsV1vFILgeHdpYcGn2zs7xVVOKEGXfe3atbqH2rRpk1hrNrSj4hA4dDL9+g3ZqAPH2SFw2X4UHkbGTRvrUXOdl1XAQvPMpqbPDvsDL/CyU4nfkZ/TvDx9xoz1ly9efGjQN/xALKrVsvwY1rHvuR9t+CJMTbi61DXXT61/NRIJP8jiUrsSdX7UM5Tv9Xz3VFfXDxONVmHCHBgzPH9h48YTrX/6UzF75QJcqhvRNOLaWmtqa7cTvhxzez3/k19Y8Mei4qJtzz///PlslJSVltzF5ZNEgBkTR7OQ2+X67ZT6uvX8eiHjuS7jRKtxVA6MKWDcSHx2c/PBgD9Yh/+fTnRSEo1qtw4ODJzTgsEuzPUsAr/EHuZj/814FjOwFxeVsD9qy4y6ketu2a4EVZdje1V11VPsKZP+oGHg+kvLxxSwMISfxIRa5ra8E/IHyjUO2LzDzCS/l81jkRYKLSQw+AT/+Ww2j+/bsjGwpLjkvlQB6xscgYbD6dhG4PPU+++/35UNhtU3Pg6MGkWngpFHfm5enuk63dUdCoe+yNViYzQcuZv9Vz8AO2PxdyVwyBbMxHnfNeCObP4Rjl/dCPd3FVVVzxFlpt+eGROsfEIcyFnAAp2fm8q58IezmpoOB8PaV4mmb4vHYzWc+r3EmmPe8KAJbOHyvwu551aUy7z1tbu8np9xFfgbtgJrz52QCLNPGpeABdSIhW5DKPu5avtUOBhchcuei2m2Z0fF8ceunOHo+IGiOE+7nK4/llaU/lasNvWntGPBsfpz58CYx6SxQMnzHL+saClwOC4fam8/l238woUzKoNB5/Rqt/v4zrY2/Zkv23irz+KAxQGLAxYHLA5YHLA4YHHA4oDFAYsDFgcsDlgcsDgwHg78L308KT2dErwKAAAAAElFTkSuQmCC
name: GitHub IAM
script:
  commands:
  - arguments:
    - description: User Profile indicator details.
      name: user-profile
      required: true
    description: Creates a user.
    execution: true
    name: iam-create-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: If true, the employee's status is active, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Indicates if the API was successful or provides error information.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    description: Updates an existing user with the data passed in the user-profile
      argument.
    execution: true
    name: iam-update-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: If true, the employee's status is active, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Indicates if the API was successful or provides error information.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    description: Retrieves a single user resource.
    name: iam-get-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: If true, the employee's status is active, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Indicates if the API was successful or provides error information.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    description: Disable an active user.
    execution: true
    name: iam-disable-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: If true, the employee's status is active, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Indicates if the API was successful or provides error information.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully, otherwise false.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments: []
    description: Retrieves a User Profile schema which holds all of the user fields
      within the application. Used for outgoing-mapping through the Get Schema option.
    name: get-mapping-fields
  dockerimage: demisto/python3:3.10.13.72123
  ismappable: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('GitHub IAM', 'start', __line__())
    ### pack version: 2.1.2


    import traceback
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    DEFAULT_OUTGOING_MAPPER = "User Profile - SCIM (Outgoing)"
    DEFAULT_INCOMING_MAPPER = "User Profile - SCIM (Incoming)"

    IAM_GET_USER_ATTRIBUTES = ['id', 'userName', 'emails']


    class Client(BaseClient):

        def __init__(self, base_url, org, headers, ok_codes=None, verify=True, proxy=False):
            super().__init__(base_url, verify=verify, proxy=proxy, ok_codes=ok_codes, headers=headers)
            self.org = org

        def get_user(self, input_type, user_term):
            uri = f'scim/v2/organizations/{self.org}/Users?filter={input_type} eq \"{user_term}\"'

            return self._http_request(
                method='GET',
                url_suffix=uri,
            )

        def create_user(self, data):
            uri = f'scim/v2/organizations/{self.org}/Users'
            return self._http_request(
                method='POST',
                url_suffix=uri,
                json_data=data,
            )

        def update_user(self, user_term, data):
            uri = f'scim/v2/organizations/{self.org}/Users/{user_term}'
            return self._http_request(
                method='PUT',
                url_suffix=uri,
                json_data=data,
            )

        def disable_user(self, data):
            uri = f'scim/v2/organizations/{self.org}/Users/{data}'
            return self._http_request(
                method='DELETE',
                url_suffix=uri,
                resp_type='text'
            )


    def github_handle_error(e):
        """
        Handles an error from the Github API
        an error example: Error in API call [401] - Unauthorized
        {"message": "Bad credentials", "documentation_url": "https://docs.github.com/rest"}
        The error might contain error_code, error_reason and error_message
        The error_reason and error_message might be the same but usually, the error_reason adds more information that
        the error_message doesn't provide
        examples:
            error_code = 401
            error_message = 'Bad credentials'
            error_reason = 'Unauthorized'
        :param e: the client object
        :return: error_code and  error_message
        """
        try:
            error_code = ""
            error_message = str(e)
            if e.__class__ is DemistoException and e.res is not None:
                error_res = e.res
                if isinstance(error_res, dict):
                    error_code = str(error_res.get("status"))
                    error_message = str(error_res.get("detail"))
                else:
                    error_code = e.res.status_code
                    if not e.res.ok:
                        if e.res.json():
                            error_message = error_res.json().get("message", "")
                            if not error_message:
                                error_message = error_res.json().get("detail", "")
                            error_reason = error_res.reason
                            if error_reason and error_reason != error_message:
                                error_message += f' {error_reason}'
            return error_code, error_message

        except Exception as e:
            error_code = ""
            error_message = str(e)
            return error_code, error_message


    def test_module(client):
        """
        Trying to get a user by a fake id,
        if the command returns with no errors the connection is ok
        :param client: the client object
        :return: ok if got a valid accesses token
        """
        message: str = ''
        try:
            result = client.get_user("id", "1234")
            if result:
                message = 'ok'
        except DemistoException as e:
            # The url is for the users, it can throw not found for bad url as well, and we do want to catch it.
            if 'Not Found' in str(e) and 'list-scim-provisioned-identities' in str(e):
                message = 'ok'
            else:
                raise e
        return message


    def get_user_command(client, args, mapper_in, mapper_out):
        iam_user_profile = IAMUserProfile(user_profile=args.get("user-profile"), mapper=mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        try:
            iam_attr, iam_attr_value = iam_user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
            res = client.get_user(iam_attr, iam_attr_value)

            if res.get('totalResults', 0) == 0:
                error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                iam_user_profile.set_result(success=False,
                                            email=iam_attr_value if iam_attr == 'emails' else None,
                                            username=iam_attr_value if iam_attr == 'userName' else None,
                                            error_message=error_message,
                                            error_code=error_code,
                                            action=IAMActions.GET_USER)

            else:
                github_user = res.get('Resources')[0]
                email_result = iam_user_profile.get_attribute('emails',
                                                              user_profile_data=iam_user_profile.mapped_user_profile)
                if (emails := github_user.get('emails')) and not email_result:
                    first_email = emails[0].get('value')
                    email_result = next((email.get('value') for email in emails if email.get('primary')), first_email)
                iam_user_profile.update_with_app_data(github_user, mapper_in)
                iam_user_profile.set_result(success=True,
                                            iden=github_user.get('id', None),
                                            email=email_result,
                                            username=github_user.get('userName', None),
                                            action=IAMActions.GET_USER,
                                            details=github_user,
                                            active=github_user.get('active', None))

            return iam_user_profile

        except Exception as e:
            error_code, error_message = github_handle_error(e)
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=error_message,
                                        action=IAMActions.GET_USER
                                        )
            return iam_user_profile


    def create_user_command(client, args, mapper_out, is_create_enabled, is_update_enabled):
        try:
            iam_user_profile = IAMUserProfile(user_profile=args.get("user-profile"), mapper=mapper_out,
                                              incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)

            if not is_create_enabled:
                iam_user_profile.set_result(action=IAMActions.CREATE_USER,
                                            skip=True,
                                            skip_reason='Command is disabled.')

            else:
                iam_attr, iam_attr_value = iam_user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                get_user_response = client.get_user(iam_attr, iam_attr_value)

                if get_user_response.get('totalResults', 0) > 0:
                    # if user exists - update it
                    create_if_not_exists = False
                    iam_user_profile = update_user_command(client, args, mapper_out, is_update_enabled,
                                                           is_create_enabled, create_if_not_exists)

                else:
                    github_user = iam_user_profile.map_object(mapper_name=mapper_out,
                                                              incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
                    # make sure the email is transformer to a list
                    emails = github_user.get("emails")
                    if not isinstance(emails, list):
                        github_user["emails"] = [emails]

                    res = client.create_user(github_user)
                    user_id = res.get('id', None)
                    iam_user_profile.set_result(success=True,
                                                iden=user_id,
                                                email=res.get('email'),
                                                username=res.get('userName'),
                                                action=IAMActions.CREATE_USER,
                                                details=res,
                                                active=True)

            return iam_user_profile

        except Exception as e:
            error_code, error_message = github_handle_error(e)
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=error_message,
                                        action=IAMActions.CREATE_USER
                                        )
            return iam_user_profile


    def update_user_command(client, args, mapper_out, is_update_enabled, is_create_enabled, create_if_not_exists):
        try:
            iam_user_profile = IAMUserProfile(user_profile=args.get("user-profile"), mapper=mapper_out,
                                              incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)

            if not is_update_enabled:
                iam_user_profile.set_result(action=IAMActions.UPDATE_USER,
                                            skip=True,
                                            skip_reason='Command is disabled.')

            else:
                iam_attr, iam_attr_value = iam_user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                get_user_response = client.get_user(iam_attr, iam_attr_value)

                if get_user_response.get('totalResults', 0) == 0:
                    # user doesn't exists
                    if create_if_not_exists:
                        iam_user_profile = create_user_command(client, args, mapper_out, is_create_enabled, False)
                    else:
                        error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        iam_user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                    error_code=error_code,
                                                    skip=True,
                                                    skip_reason=error_message)
                else:
                    user_id: str = get_user_response.get('Resources')[0].get('id', '')
                    github_user = iam_user_profile.map_object(mapper_name=mapper_out,
                                                              incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
                    emails = github_user.get("emails")
                    if not isinstance(emails, list):
                        github_user["emails"] = [emails]

                    res = client.update_user(user_term=user_id, data=github_user)
                    iam_user_profile.set_result(success=True,
                                                iden=user_id,
                                                email=github_user.get('email'),
                                                username=github_user.get('userName'),
                                                action=IAMActions.UPDATE_USER,
                                                details=res,
                                                active=True)

            return iam_user_profile

        except Exception as e:
            error_code, error_message = github_handle_error(e)
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=error_message,
                                        action=IAMActions.UPDATE_USER
                                        )
            return iam_user_profile


    def disable_user_command(client, args, mapper_out, is_disable_enabled):
        try:
            iam_user_profile = IAMUserProfile(user_profile=args.get("user-profile"), mapper=mapper_out,
                                              incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)

            if not is_disable_enabled:
                iam_user_profile.set_result(action=IAMActions.DISABLE_USER,
                                            skip=True,
                                            skip_reason='Command is disabled.')

            else:
                iam_attr, iam_attr_value = iam_user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                get_user_response = client.get_user(iam_attr, iam_attr_value)

                if get_user_response.get('totalResults', 0) == 0:
                    error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    iam_user_profile.set_result(action=IAMActions.DISABLE_USER,
                                                error_code=error_code,
                                                skip=True,
                                                skip_reason=error_message)
                else:
                    user_data = get_user_response.get('Resources')[0]
                    user_id: str = user_data.get('id', '')
                    username: str = user_data.get('userName')
                    res = client.disable_user(user_id)
                    iam_user_profile.set_result(success=True,
                                                iden=user_data.get('id', ''),
                                                email=iam_attr_value if iam_attr == 'email' else None,
                                                action=IAMActions.DISABLE_USER,
                                                username=username,
                                                details=res,
                                                active=False)

            return iam_user_profile
        except Exception as e:
            error_code, error_message = github_handle_error(e)
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=error_message,
                                        action=IAMActions.DISABLE_USER
                                        )
            return iam_user_profile


    def get_mapping_fields_command():
        scheme = [
            "userName",
            "externalId",
            "title",
            "userType",
            "name",
            "emails",
            "phoneNumbers",
            "urn:scim:schemas:extension:enterprise:1.0"
        ]
        incident_type_scheme = SchemeTypeMapping(type_name=IAMUserProfile.DEFAULT_INCIDENT_TYPE)

        for field in scheme:
            incident_type_scheme.add_field(field, "Field")

        return GetMappingFieldsResponse([incident_type_scheme])


    def main():  # pragma: no cover
        params = demisto.params()
        args = demisto.args()

        base_url = params.get('url')
        # checks for '/' at the end url, if it is not available add it
        if base_url[-1] != '/':
            base_url += '/'

        token = params.get('creds_token', {}).get('password') or params.get('token')

        if token is None:
            raise ValueError('Token must be provided.')

        org = params.get('org')

        mapper_in = params.get('mapper_in', DEFAULT_INCOMING_MAPPER)
        mapper_out = params.get('mapper_out', DEFAULT_OUTGOING_MAPPER)
        is_create_enabled = params.get("create-user-enabled")
        is_disable_enabled = params.get("disable-user-enabled")
        is_update_enabled = demisto.params().get("update-user-enabled")
        create_if_not_exists = demisto.params().get("create-if-not-exists")

        verify_certificate = not demisto.params().get('insecure', False)

        headers = {
            'accept': 'application/json',
            'content-type': 'application/json',
            'Authorization': f'Bearer {token}'
        }

        proxy = demisto.params().get('proxy', False)
        command = demisto.command()

        demisto.debug(f'Command being called is {command}')

        try:
            client = Client(
                base_url=base_url,
                org=org,
                verify=verify_certificate,
                proxy=proxy,
                headers=headers,
                ok_codes=(200, 201, 204)
            )
            if command == 'test-module':
                return_results(test_module(client))

            elif command == 'iam-get-user':
                user_profile = get_user_command(client, args, mapper_in, mapper_out)
                return_results(user_profile)

            elif command == 'iam-create-user':
                user_profile = create_user_command(client, args, mapper_out, is_create_enabled, is_update_enabled)
                return_results(user_profile)

            elif command == 'iam-update-user':
                user_profile = update_user_command(client, args, mapper_out, is_update_enabled,
                                                   is_create_enabled, create_if_not_exists)
                return_results(user_profile)

            elif command == 'iam-disable-user':
                user_profile = disable_user_command(client, args, mapper_out, is_disable_enabled)
                return_results(user_profile)

            elif command == 'get-mapping-fields':
                return_results(get_mapping_fields_command())

        except Exception as e:
            # For any other integration command exception, return an error
            return_error(f'Failed to execute {command} command. Exception: {e}. Traceback: {traceback.format_exc()}')



    ### GENERATED CODE ###: from IAMApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('IAMApiModule', 'start', __line__(), wrapper=-3)





    class IAMErrors(object):
        """
        An enum class to manually handle errors in IAM integrations
        :return: None
        :rtype: ``None``
        """
        BAD_REQUEST = 400, 'Bad request - failed to perform operation'
        USER_DOES_NOT_EXIST = 404, 'User does not exist'
        USER_ALREADY_EXISTS = 409, 'User already exists'


    class IAMActions(object):
        """
        Enum: contains all the IAM actions (e.g. get, update, create, etc.)
        :return: None
        :rtype: ``None``
        """
        GET_USER = 'get'
        UPDATE_USER = 'update'
        CREATE_USER = 'create'
        DISABLE_USER = 'disable'
        ENABLE_USER = 'enable'


    class IAMVendorActionResult:
        """ This class is used in IAMUserProfile class to represent actions data.
        :return: None
        :rtype: ``None``
        """

        def __init__(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                     error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            self._brand = demisto.callingContext.get('context', {}).get('IntegrationBrand')
            self._instance_name = demisto.callingContext.get('context', {}).get('IntegrationInstance')
            self._success = success
            self._active = active
            self._iden = iden
            self._username = username
            self._email = email
            self._error_code = error_code
            self._error_message = error_message
            self._details = details
            self._skip = skip
            self._skip_reason = skip_reason
            self._action = action
            self._return_error = return_error

        def should_return_error(self):
            return self._return_error

        def create_outputs(self):
            """ Sets the outputs in `_outputs` attribute.
            """
            outputs = {
                'brand': self._brand,
                'instanceName': self._instance_name,
                'action': self._action,
                'success': self._success,
                'active': self._active,
                'id': self._iden,
                'username': self._username,
                'email': self._email,
                'errorCode': self._error_code,
                'errorMessage': self._error_message,
                'details': self._details,
                'skipped': self._skip,
                'reason': self._skip_reason
            }
            return outputs

        def create_readable_outputs(self, outputs):
            """ Sets the human readable output in `_readable_output` attribute.

            :param outputs: (dict) the command outputs.
            """
            title = self._action.title() + ' User Results ({})'.format(self._brand)

            if not self._skip:
                headers = ["brand", "instanceName", "success", "active", "id", "username",
                           "email", "errorCode", "errorMessage", "details"]
            else:
                headers = ["brand", "instanceName", "skipped", "reason"]

            readable_output = tableToMarkdown(
                name=title,
                t=outputs,
                headers=headers,
                removeNull=True
            )

            return readable_output


    class IAMUserProfile:
        """ A User Profile object class for IAM integrations.

        :type _user_profile: ``str``
        :param _user_profile: The user profile information.

        :type _user_profile_delta: ``str``
        :param _user_profile_delta: The user profile delta.

        :type _vendor_action_results: ``list``
        :param _vendor_action_results: A List of data returned from the vendor.

        :return: None
        :rtype: ``None``
        """

        DEFAULT_INCIDENT_TYPE = 'User Profile'
        CREATE_INCIDENT_TYPE = 'User Profile - Create'
        UPDATE_INCIDENT_TYPE = 'User Profile - Update'
        DISABLE_INCIDENT_TYPE = 'User Profile - Disable'
        ENABLE_INCIDENT_TYPE = 'User Profile - Enable'

        def __init__(self, user_profile, mapper: str, incident_type: str, user_profile_delta=None):
            self._user_profile = safe_load_json(user_profile)
            # Mapping is added here for GET USER commands, where we need to map Cortex XSOAR fields to the given app fields.
            self.mapped_user_profile = None
            self.mapped_user_profile = self.map_object(mapper, incident_type, map_old_data=True) if \
                mapper else self._user_profile
            self._user_profile_delta = safe_load_json(user_profile_delta) if user_profile_delta else {}
            self._vendor_action_results: List = []

        def get_attribute(self, item, use_old_user_data=False, user_profile_data: Optional[Dict] = None):
            user_profile = user_profile_data if user_profile_data else self._user_profile
            if use_old_user_data and user_profile.get('olduserdata', {}).get(item):
                return user_profile.get('olduserdata', {}).get(item)
            return user_profile.get(item)

        def to_entry(self):
            """ Generates a XSOAR IAM entry from the data in _vendor_action_results.
            Note: Currently we are using only the first element of the list, in the future we will support multiple results.

            :return: A XSOAR entry.
            :rtype: ``dict``
            """

            outputs = self._vendor_action_results[0].create_outputs()
            readable_output = self._vendor_action_results[0].create_readable_outputs(outputs)

            entry_context = {
                'IAM.UserProfile(val.email && val.email == obj.email)': self._user_profile,
                'IAM.Vendor(val.instanceName && val.instanceName == obj.instanceName && '
                'val.email && val.email == obj.email)': outputs
            }

            return_entry = {
                'ContentsFormat': EntryFormat.JSON,
                'Contents': outputs,
                'EntryContext': entry_context
            }

            if self._vendor_action_results[0].should_return_error():
                return_entry['Type'] = EntryType.ERROR
            else:
                return_entry['Type'] = EntryType.NOTE
                return_entry['HumanReadable'] = readable_output

            return return_entry

        def return_outputs(self):
            return_results(self.to_entry())

        def set_result(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                       error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            if not email:
                email = self.get_attribute('email')

            if not details:
                details = self.mapped_user_profile

            vendor_action_result = IAMVendorActionResult(
                success=success,
                active=active,
                iden=iden,
                username=username,
                email=email,
                error_code=error_code,
                error_message=error_message if error_message else '',
                details=details,
                skip=skip,
                skip_reason=skip_reason if skip_reason else '',
                action=action,
                return_error=return_error
            )

            self._vendor_action_results.append(vendor_action_result)

        def map_object(self, mapper_name, incident_type, map_old_data: bool = False):
            """ Returns the user data, in an application data format.

            :type mapper_name: ``str``
            :param mapper_name: The outgoing mapper from XSOAR to the application.

            :type incident_type: ``str``
            :param incident_type: The incident type used.

            :type map_old_data ``bool``
            :param map_old_data: Whether to map old data as well.

            :return: the user data, in the app data format.
            :rtype: ``dict``
            """
            if self.mapped_user_profile:
                if not map_old_data:
                    return {k: v for k, v in self.mapped_user_profile.items() if k != 'olduserdata'}
                return self.mapped_user_profile
            if incident_type not in [IAMUserProfile.CREATE_INCIDENT_TYPE, IAMUserProfile.UPDATE_INCIDENT_TYPE,
                                     IAMUserProfile.DISABLE_INCIDENT_TYPE,
                                     IAMUserProfile.ENABLE_INCIDENT_TYPE]:
                raise DemistoException('You must provide a valid incident type to the map_object function.')
            if not self._user_profile:
                raise DemistoException('You must provide the user profile data.')
            app_data = demisto.mapObject(self._user_profile, mapper_name, incident_type)
            if map_old_data and 'olduserdata' in self._user_profile:
                app_data['olduserdata'] = demisto.mapObject(self._user_profile.get('olduserdata', {}), mapper_name,
                                                            incident_type)
            return app_data

        def update_with_app_data(self, app_data, mapper_name, incident_type=None):
            """ updates the user_profile attribute according to the given app_data

            :type app_data: ``dict``
            :param app_data: The user data in app

            :type mapper_name: ``str``
            :param mapper_name: Incoming mapper name

            :type incident_type: ``str``
            :param incident_type: Optional - incident type
            """
            if not incident_type:
                incident_type = IAMUserProfile.DEFAULT_INCIDENT_TYPE
            if not isinstance(app_data, dict):
                app_data = safe_load_json(app_data)
            self._user_profile = demisto.mapObject(app_data, mapper_name, incident_type)

        def get_first_available_iam_user_attr(self, iam_attrs: List[str], use_old_user_data: bool = False):
            # Special treatment for ID field, because he is not included in outgoing mappers.
            for iam_attr in iam_attrs:
                # Special treatment for ID field, because he is not included in outgoing mappers.
                if iam_attr == 'id':
                    if attr_value := self.get_attribute(iam_attr, use_old_user_data):
                        return iam_attr, attr_value
                if attr_value := self.get_attribute(iam_attr, use_old_user_data, self.mapped_user_profile):
                    # Special treatment for emails, as mapper maps it to a list object.
                    if iam_attr == 'emails' and not isinstance(attr_value, str):
                        if isinstance(attr_value, dict):
                            attr_value = attr_value.get('value')
                        elif isinstance(attr_value, list):
                            if not attr_value:
                                continue
                            attr_value = next((email.get('value') for email in attr_value if email.get('primary', False)),
                                              attr_value[0].get('value', ''))
                    return iam_attr, attr_value

            raise DemistoException('Your user profile argument must contain at least one attribute that is mapped into one'
                                   f' of the following attributes in the outgoing mapper: {iam_attrs}')

        def set_user_is_already_disabled(self, details):
            self.set_result(
                action=IAMActions.DISABLE_USER,
                skip=True,
                skip_reason='User is already disabled.',
                details=details
            )

        def set_user_is_already_enabled(self, details):
            self.set_result(
                action=IAMActions.ENABLE_USER,
                skip=True,
                skip_reason='User is already enabled.',
                details=details
            )


    class IAMUserAppData:
        """ Holds user attributes retrieved from an application.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, user_id, username, is_active, app_data, email=None):
            self.id = user_id
            self.username = username
            self.is_active = is_active
            self.full_data = app_data
            self.email = email


    class IAMCommand:
        """ A class that implements the IAM CRUD commands - should be used.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, is_create_enabled=True, is_enable_enabled=True, is_disable_enabled=True, is_update_enabled=True,
                     create_if_not_exists=True, mapper_in=None, mapper_out=None, get_user_iam_attrs=None):
            """ The IAMCommand c'tor

            :param is_create_enabled: (bool) Whether or not to allow creating users in the application.
            :param is_enable_enabled: (bool) Whether or not to allow enabling users in the application.
            :param is_disable_enabled: (bool) Whether or not to allow disabling users in the application.
            :param is_update_enabled: (bool) Whether or not to allow updating users in the application.
            :param create_if_not_exists: (bool) Whether or not to create a user if does not exist in the application.
            :param mapper_in: (str) Incoming mapper from the application to Cortex XSOAR
            :param mapper_out: (str) Outgoing mapper from the Cortex XSOAR to the application
            :param get_user_iam_attrs (List[str]): List of IAM attributes supported by integration by precedence
                                                            order to get user details.
            """
            if get_user_iam_attrs is None:
                get_user_iam_attrs = ['email']
            self.is_create_enabled = is_create_enabled
            self.is_enable_enabled = is_enable_enabled
            self.is_disable_enabled = is_disable_enabled
            self.is_update_enabled = is_update_enabled
            self.create_if_not_exists = create_if_not_exists
            self.mapper_in = mapper_in
            self.mapper_out = mapper_out
            self.get_user_iam_attrs = get_user_iam_attrs

        def get_user(self, client, args):
            """ Searches a user in the application and updates the user profile object with the data.
                If not found, the error details will be resulted instead.
            :param client: (Client) The integration Client object that implements a get_user() method
            :param args: (dict) The `iam-get-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            try:
                iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(self.get_user_iam_attrs)
                user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                if not user_app_data:
                    error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    user_profile.set_result(action=IAMActions.GET_USER,
                                            success=False,
                                            error_code=error_code,
                                            error_message=error_message)
                else:
                    user_profile.update_with_app_data(user_app_data.full_data, self.mapper_in)
                    user_profile.set_result(
                        action=IAMActions.GET_USER,
                        active=user_app_data.is_active,
                        iden=user_app_data.id,
                        email=user_profile.get_attribute('email') or user_app_data.email,
                        username=user_app_data.username,
                        details=user_app_data.full_data
                    )

            except Exception as e:
                client.handle_exception(user_profile, e, IAMActions.GET_USER)

            return user_profile

        def disable_user(self, client, args):
            """ Disables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user() and disable_user() methods
            :param args: (dict) The `iam-disable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_disable_enabled:
                user_profile.set_result(action=IAMActions.DISABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.DISABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if user_app_data.is_active:
                            disabled_user = client.disable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.DISABLE_USER,
                                active=False,
                                iden=disabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=disabled_user.username,
                                details=disabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_disabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.DISABLE_USER)

            return user_profile

        def enable_user(self, client, args):
            """ Enables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user(),
                                    enable_user() and handle_exception methods
            :param args: (dict) The `iam-enable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_enable_enabled:
                user_profile.set_result(action=IAMActions.ENABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.ENABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if not user_app_data.is_active:
                            enabled_user = client.enable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.ENABLE_USER,
                                active=True,
                                iden=enabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=enabled_user.username,
                                details=enabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_enabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.ENABLE_USER)

            return user_profile

        def create_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If a user in the app already holds the email in the given user profile, updates
                its data with the given data.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-create-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
            if not self.is_create_enabled:
                user_profile.set_result(action=IAMActions.CREATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        # if user exists, update it
                        user_profile = self.update_user(client, args)

                    else:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.CREATE_INCIDENT_TYPE)
                        created_user = client.create_user(app_profile)
                        user_profile.set_result(
                            action=IAMActions.CREATE_USER,
                            active=created_user.is_active,
                            iden=created_user.id,
                            email=user_profile.get_attribute('email') or created_user.email,
                            username=created_user.username,
                            details=created_user.full_data
                        )

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.CREATE_USER)

            return user_profile

        def update_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If the user is disabled and `allow-enable` argument is `true`, also enables the user.
                If the user does not exist in the app and the `create-if-not-exist` parameter is checked, creates the user.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-update-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            allow_enable = args.get('allow-enable') == 'true' and self.is_enable_enabled
            if not self.is_update_enabled:
                user_profile.set_result(action=IAMActions.UPDATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs, use_old_user_data=True)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.UPDATE_INCIDENT_TYPE)

                        if allow_enable and not user_app_data.is_active:
                            client.enable_user(user_app_data.id)

                        updated_user = client.update_user(user_app_data.id, app_profile)

                        if updated_user.is_active is None:
                            updated_user.is_active = True if allow_enable else user_app_data.is_active

                        user_profile.set_result(
                            action=IAMActions.UPDATE_USER,
                            active=updated_user.is_active,
                            iden=updated_user.id,
                            email=user_profile.get_attribute('email') or updated_user.email or user_app_data.email,
                            username=updated_user.username,
                            details=updated_user.full_data
                        )
                    else:
                        if self.create_if_not_exists:
                            user_profile = self.create_user(client, args)
                        else:
                            _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                            user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                    skip=True,
                                                    skip_reason=error_message)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.UPDATE_USER)

            return user_profile


    def get_first_primary_email_by_scim_schema(res: Dict):
        return next((email.get('value') for email in res.get('emails', []) if email.get('primary')), None)

    register_module_line('IAMApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('GitHub IAM', 'end', __line__())
  subtype: python3
  type: python
system: true
