category: Messaging and Conferencing
commonfields:
  id: Zoom
  version: -1
configuration:
- defaultvalue: https://api.zoom.us/v2/
  display: Server URL (e.g. 'https://api.zoom.us/v2/')
  name: url
  required: true
  type: 0
- display: Account ID (OAuth)
  name: account_id
  required: true
  type: 0
- display: Client ID (OAuth)
  displaypassword: Client Secret (OAuth)
  name: credentials
  required: true
  type: 9
- additionalinfo: The BotJID in the Chat subscription section on the Features page
    of your App Dashboard.
  display: Bot JID
  hiddenpassword: true
  name: botJID
  required: false
  type: 0
- display: Bot Client ID ((Team Chat App))
  displaypassword: Bot Client Secret (Team Chat App)
  name: bot_credentials
  required: false
  type: 9
- additionalinfo: You must provide this token for mirror-investigation.
  display: ""
  displaypassword: Secret Token(Team Chat App)
  hiddenusername: true
  name: secret_token
  required: false
  type: 9
- additionalinfo: Token to verify the messages from Zoom.
  display: ""
  displaypassword: Verification Token(Team Chat App)
  hiddenusername: true
  name: verification_token
  required: false
  type: 9
- display: Long running instance
  name: longRunning
  required: false
  section: Collect
  type: 8
- additionalinfo: You most enable or run mirror-investigation.
  defaultvalue: "false"
  display: Enable Incident Mirroring
  name: mirroring
  required: false
  section: Collect
  type: 8
- additionalinfo: You must enable Long running instance to run the web server on this
    port from within Cortex XSOAR. Requires a unique port for each long-running integration
    instance. Do not use the same port for multiple instances.
  display: Listen Port
  name: longRunningPort
  required: false
  section: Collect
  type: 0
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: (For Cortex XSOAR 6.x) For use with HTTPS - the certificate that
    the service should use. (For Cortex XSOAR 8 and Cortex XSIAM) Custom certificates
    are supported only using engine.
  advanced: true
  display: Certificate (Required for HTTPS)
  name: certificate
  required: false
  section: Connect
  type: 12
- additionalinfo: (For Cortex XSOAR 6.x) For use with HTTPS - the private key that
    the service should use. (For Cortex XSOAR 8 and Cortex XSIAM) When using an engine,
    configure a private API key. Not supported on the Cortex XSOAR​​ or Cortex XSIAM
    server.
  advanced: true
  display: Private Key (Required for HTTPS)
  name: key
  required: false
  section: Connect
  type: 14
- display: Incident type
  name: incidentType
  required: false
  type: 13
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.6.10
    packID: Zoom
    packName: Zoom
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Use the Zoom integration to manage your Zoom users and meetings.
detaileddescription: "## Zoom Integration\nIn order to use this integration, you need
  to enter your Zoom credentials in the relevant integration instance parameters.\nAuthentication
  method available: **OAuth** \n\n**Note: JWT authentication method was deprecated
  by Zoom from June 2023 and not available anymore.**\n\nLog in to your Zoom admin
  user account, and follow these steps:\nClick [here](https://marketplace.zoom.us/develop/create)
  to create an app.\n### For the OAuth method:\n- Enable permissions.\n- Create an
  Server-to-Server OAuth app.\n- Add relevant scopes.\n- Use the following account
  credentials to get an access token:\n    Account ID\n    Client ID\n    Client secret\n\nFor
  more information about creating an OAuth app click [here](https://marketplace.zoom.us/docs/guides/build/server-to-server-oauth-app/).\n\n###
  For sending messages using the ChatBot app and mirroring\n\nTo enable the integration
  to communicate directly with Zoom for mirroring or to send messages by Zoom chatbot,\nyou
  must create a dedicated Zoom Team Chat app for the Cortex XSOAR integration.\nMake
  sure you have the following parameters:\n- Long running instance enabled\n- Listen
  Port\n- Bot JID\n- Bot Client ID\n- Bot Secret ID \n- Secret Token\n- Enable Incident
  Mirroring\n For instructions on how to create and configure your custom Zoom app,
  review the documentation found [here](https://xsoar.pan.dev/docs/reference/integrations/zoom).\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/zoom)"
display: Zoom
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAD2hJREFUeAHtWnl0lNUVv2+WLETZIkjRIogLttWqKAURTQJqImqpLWBFrVgVcQMUSdgkyhISitQWaaOCSD0u4FpU8JSQQSS2AipyUDkSQRRLiEACJCGzvf7uy7zhzTdLZkCsf3zvEOZb7rvL7y5v+4jsZiNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjcHwRECb7gaWymRyUZj47xusGKWlHMEhP1Z5Of9syTHgT8bukWHZOz6CLhZOGg+48IamHFOSVAdrmcFKV30cvg8NmT7E4lIhPMu8uLZbd0tpQfxL0OxGkc2B3NwpSvSTahuvVkPn6gQ706cZRwpeIX06JHO500Tzo+axsosWVU8VWTZ9XJi8MEg11EF0jBGwJkhPytgkHLQt4aalnkvhc01p/B0yUndLa0+XSQbdBvz7odwJJ2hl00EfA9B/+fbTuvdliv7Wf9d7q4F0AtysYfG8NhhEMokCAXg020B9iOadvseyelUV3Q+j1oO8JYwjGkNYjzMNPfrz6LEC0EAYuScZAqyGDZstzA04a43BQvkPQKUpGSBbL4QYMKOCnJujwIZyyYPvn9OqOxeJwy9vI/+HE37sy6HkEBAUDtBfB/ETQRx5nGo0D5SCnkzLBI8qWoKQ6yF4pmqmkYrL4RHMdVCjbyQ40CjrcjkA7k59zf25Kv5CO0k+f4fH8A9W0eOOTorGFIvr/EHnLi4Fz5BMOF90d9EcTHssTVszhJvIepiJPoSgN85JS5JXSvXhXhAztyoYApLhNO5oDAIBu9vmpcE2RWBG3g/Gi3ziZmdGFHoF9dwD09ixHA2eQhS+VLDiaAw20Hl8TPfDuw+KjMEHoQjk4nZ5HRqpA5sdwskRWC3a6DlJrPw562EwIhv2BIE2pLBQLBsySP0tz09PQsV9IrrVb+J77Mg7w1cqmOrqraqb4KvzSuADJkZZTLE91ZlEFou8sCI6r3JEeyV8pY/y0ofpTGsDZcN54mdXpZJqL56OYSyLHxpICEAhR3OAP0GRPEf0F1satO/1myFOyMqhcuGiwAj2UEbH4xnrGwQkga+DEu1BWXzdpTAebz5O9ZkfDmQHY/xQyNsfppl6MfbIN9FxtNjUcoiH/LhY7rP0iHMwvB5XICwhjCoT1hfB0pUAUlZVNyz0Aj+so5gMjapu/o55dL6LGvV/RM640utkaSDpzlFwthksonKL+DDcyDdP7fDQOleHPmtz8ReZ2zPwJ/dOVTv05y8ym+jMPBlm3kCxrwHGAItOayEcjVk8Ur2ny1hzMvHW2qT7gz7zN6qFt1jZq3vq5qZ8OULMyKCd7aVXtHhryyZ9Eg+7PvzFd1/1WmXF6L7oQAjpjrEjDQB+TzmSE8cwLokF4xmNpVFNZ4KU3KybQdXmzabIznaZbhwJWFA5vgMwq/K0Bk2/w54IeZ4H3QBh6IcASZr+Q8Y3+ZhqO7HrTFJyTI13OAlrsSKcRZlYwcFwBAj7aB6DexeRqHSysQQ1og8nSL5QsFyZeaKYj2FEovzWQf1VlkdjE7xM5mGVA7rfgzVn/IWxywt+9cT8E7zqbdjAvs4Xs4sz24PlKxMUe6PpT4FyA+QNPDiN140xupvtWF4r5EXzMm2O5vnyW7Ody0wsA7zQzupinA/NyZM+Kpga6KdNN3QF4FRRM1+Ax4GwQjHkNRs+snCg2RukCZ+Xm02CMbVMBTm84J9yUs7y09VCA+n8wSezVL3JK5Qi3m54zs5FlcZIiE55u9tLcdcasV/fj4SO7Mw2HStMQmN1MR3AQ+pqp4kB7KuAZdjwHq4zHxNLbQOPeKxY7NW/+zZsue4p0mg/e+SZvTaOwIKoNeuk+z0RaCnSgckvr3Vu62w6nkU5Bj6HKZmkMVfD56IvGJur7frHYp+lhw7E3LBXy4dzlEBLt3JbIWu7dSyNYsHDTJIyFYecq6QAdDivd/QHdENO5TOQRfmTNG42H6GpE6lsMtG4MEuYNZ5/AM89QG1Qu2yHSH9L3/KucK8gHh9+LSL8zlnOZjstc5QSxCI7MRwZ+zAGkGwcWJmm5bevoWv3M+sv0nHm8arA6l2lXTxXVzfvoRui93uTN71hHVBSv9NJoz0Txkulcfr9xo/BBtydRScaj2khFz11Q9oHrmRmZlMN0uh2zg3NnyetcLnoezs02M4UFqLHBR6869tLNvKQZUCr74PG1PFbrxgYim5YEV9CULcsSr5O5T1Wx2OOto5GoCBHAc1qijcwZK9vzBZZR+XDEL02dVGb4qIRnrEzTWnt3qvgMa9Bb4NTdoZKpukBnB+5bJoeYMZt8GHDIxIKOSmMtCTUt44HJ0VxUu7CT+B0v0VDKPQj0VzRtrN+aDbQIMjaZejEdSvgtJv0xORjOvR6ZswRKdTCBZAHKuV56qbmWbl1VKur5GZLuatCn6RLOyjF4DY00zYMMZZpk2toSUYsIngI+vogIdlJPOpnOZx4o5deYxodK2AZsXhxZpiUhbFWR2Aw5j5m8uGKgaP6KNyMcmAGbbBRdkP7rPUhqjDbfWa8R2+sl5gE8nurG9uBfhb6P98vJgMiq5IAINzzAP2W/fnbUDs4pk8Mxti6GNu1iOdfvped276Db15WJgyxs6FLphPL9tXP5mQJD0uuxpvf8PlGTK+kdlM/NJvDILBcceWnvctkGhl6kxyfFB6jh2UKMm3E3BeLJc/hRYXy0R8tiGwBsu/SOdAn6RAUmSmf9vi8oPBeIx7dpP9UCv4hZL9OC/dfx+pjPYd83ZnAovQSdatIclYPzZsmbXQ5aCIedGAEiOPNs2eelRfXbaNSWBUe2FLd+QBnQ/BSTnq9hzL9MhZK95oxH3woNuuqHB/jXo91O6oAM66RlcVbwzhRqRFWy/E26isnKEeu5CujGcgOSToczI1fVkIXWnMxwsw7LRegbrkKaN/Q+oK8T/UKUSh4LjaEl/GF52eptXqkciRlgOSInPIPTnXg8xdj49+2f0j3W7bO2LuxxOyibPaAbOwCg79D3qf46JW23WoAx6GSZgX1bQe0jqgVR00FBu1KV0UIvMCyq5U64eyiwusCESAeDAuO2YWW4S/TFMIy/Mro/9I4o+9EdW55g+doqXUoOzi2Rd8KwBYgctb+qBXOGsHMxNpXXdKcx8fZtNb39+8MhkLSDc2bLezDmzoeDM3TpYzXZuTzQI3Pn171I98U7MTrgJy9ida85ZnAWSBd1P1pzAzihscY/Uq0GOh1CDtWxbrohpTJPxBCh71P7lSgM1NXMyxAGu/HCkJIa1x+COikHY0I1Buvcx2GJO8q54IAF+WPZhTSW12jxlD67Dx3GYdk3odKmyPgaPK+I1yfRc96lQt+Bpj7MDP+21++k/Rgba7UsLtWYVWcimHhSlHIbOJM6wbkXm5NJlovNhi9RjiPGvJSZH+cOrTo4b7Ycj/XkPBjoNMFUmYvevEFRUSgeXEYi4XiwbJgIYL1bFZFVPHph246PC1O1U+TTVZjQnWvqhCHCjzX2WjX+S9qgHax4w8lw/h95hp2qrKCLboGszloW2wBb6rFZwZM2DE4/3pbQwbmz5SSRRmWYCIiICQsMZLQwM52BHaGiFMx7G6Xcq52sssBNXbLa0COckcnyUetPB80AH7fWi2e4AL3aWU8fMx9k25vaIaF7nuFf1HY/FSYrh+n4/BhyHjB58XwDFeI/aj3utE7zUuF+/GnjOJjPaeU0bFbMRAmKci6M473caasniKmpqJjdgzaCfjm21MJNbRo4kSEFNOPnQyV2rRM3/uoDXzo8gw2T87lvuCHg4IhFelPF1ZFW4iODTebShp0EJ0/MLZUxD0TCvEIXl02X52CmugQ4dDEdDLlB3JczGQCMg6GV2//nPko5zqTcMpoBo4p5UqEzhNULZV4DgBtXMUE8mqrKXKZxfluKLD5sLZ+QV9ilD72ImXrvmHxZr9ny121OoLdxEjWY94R1Cy3Pth7000L9bNUoUY8gLNP3/Mu2oBq54fT5COAn+0+XZ5vv9TUfNuSWydvc6bQSARERSNCTv06pxGHDck3/Y/41cqlFTUc+FcGISQAnwrnqLbIE0fshZo7fAuxhyRwjAlB2Rb2/jj7hkrZmoliPDJoFBz+qs4KBZ3mQ+xuIuBInNHGPCzFjF6ZzOVDApxElebx5ksT6YrdraeBqKkC234SdKNWUkzHzRZDcgb6/hazYx4XOluNCs0pwNcCwVIPAfzDht1oOTo0kWyq0SbI0yaIcjDkhf+AV7Vz0YocgWwbwH9Mk07gPQJLp2VQNMB9GWX/hpB40Cwf+Z1oP/NlxqBJZmPFegZ2yI7NrDgDwCfEKi2XnclXBgf9k61kwE/Fu16V95f1pHamHeeDPTlayHNQRJ05DwGdImGlIljlj5nfKuS0H/qNxEJBwnxl6xvx+KyzjyAWr0nTkNrUrdG62LhOtHKJKNGLvSyuRec8go8Ty4XJSf5w58IFA5p0BMBfnzpGDuVR/V0OjcRxXzk6KGCdhMWeNksFy+A88GHBGQzcuyzCuAduiYz2F9Lh+bv3lU5smLw2HHm+h3EZ8vaEDJpYskw/3Uwf9XrrR/JrDpAlftwT+rvB9wgvBO1lfH/Uojo8PUFEiTqOs4qIcjA6v4ITDy8B/X40dw06DU9KQcQ9iqeJWZ64P0WiAez/ef8tjm+noWLI5W5mGnYuSvtkXoKGeIgHnAqYE7f0pYlfDLhqKrz7mgLCOZbVmn5IFOSwPweHxNVKB9Xssq0jug0CQCJyXre/i3WM/+0Uu6Nw31Xawjtajb+SxqYVJlBvXTBJrMYmYCrrG1kCw8Gr1lrMQq+VemduxV8xNCLm6SPz10EF8L+WjOXhfzYayXNNgvlZAB8mPQNmMkjz28Hd0ebJfVLKo9+eJJpwDT8BWzGXovxCY7mKepiwlm2XBsShUTQj2KpyKjajeQgWxvqhkvroprBzkwzp8bmVP9YmOfpX4dwW9hCCfjywOpIr3RhzDwlf3A7uvWGcTMy00btzklcgrsYQvhKUXoGM71NmoYNBMkv1lBZCtB7w+OmPtJFFr7cdLIOuH70F864Uz122Qf3w+fMdJJvK/F6zrhmyoxxJwG/Rajd25Nw6eRFsSTqZAyMemLic9i+DcgKoyr7WDeqvNLfdYlpbQDcB7DHS5AFXgOny98k5s2uinWM71cGbQZOBUAJyyKx4SGdFU9hMbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBG4Hjg8D/AE/3aj3dQ3z7AAAAAElFTkSuQmCC
name: Zoom
script:
  commands:
  - arguments:
    - description: First name of the new user.
      name: first_name
      required: true
    - description: Last name of the new user.
      name: last_name
      required: true
    - description: The email of the new user.
      name: email
      required: true
    - auto: PREDEFINED
      defaultValue: Basic
      description: 'The type of the newly created user.  Note: The old type "pro"
        is now called "Licensed", and the type "Corporate" is not supprted in Zoom
        v2 and above .'
      name: user_type
      predefined:
      - Basic
      - Licensed
      - pro
      - Corporate
    description: Create a new user in zoom account.
    execution: true
    name: zoom-create-user
    outputs:
    - contextPath: Zoom.User.id
      description: The ID of the created user.
      type: string
    - contextPath: Zoom.User.first_name
      description: First name of the created user.
      type: string
    - contextPath: Zoom.User.last_name
      description: Last name for the created user.
      type: string
    - contextPath: Zoom.User.email
      description: Email of the created user.
      type: string
    - contextPath: Zoom.User.created_at
      description: Created date of the user. Note that this field does not appear
        in zoom v2 and above.
      type: date
    - contextPath: Zoom.User.type
      description: The type of the user.
      type: number
  - arguments:
    - auto: PREDEFINED
      defaultValue: Instant
      description: The type of the meeting.
      name: type
      predefined:
      - Instant
      - Scheduled
      - Recurring meeting with fixed time
      required: true
    - description: |
        For recurring meetings only. Select the final date on which the meeting will recur before it is canceled. For example: 2017-11-25T12:00:00Z.
      name: end_date_time
    - description: "For recurring meetings only.\nSelect how many times the meeting
        should recur before it is canceled. \nmax = 365. Default = 1.\n"
      name: end_times
    - description: |
        For recurring meetings with Monthly recurrence_type only.
        State the day in a month, the meeting should recur. The value range is from 1 to 31. Default = 1.
      name: monthly_day
    - description: 'For recurring meetings with Monthly recurrence_type only. State
        the week of the month when the meeting should recur. If you use this field,
        you must also use the monthly_week_day field to state the day of the week
        when the meeting should recur. Allowed: -1 (for last week of the month) ┃1┃2┃3┃4.'
      name: monthly_week
    - description: |
        For recurring meetings with Monthly recurrence_type only.
        State a specific day in a week when the monthly meeting should recur. Allowed: 1┃2┃3┃4┃5┃6┃7.
        To use this field, you must also use the monthly_week field.
      name: monthly_week_day
    - description: |
        For recurring meeting with fixed time only.
        Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as 2 and the value of the type parameter as Monthly.
        For a daily meeting, the maximum is 90 days. For a weekly meeting the maximum is of 12 weeks. For a monthly meeting, there is a maximum of 3 months.
      name: repeat_interval
    - auto: PREDEFINED
      description: |
        For recurring meetings  only.
        Set the recurrence meeting types.
      name: recurrence_type
      predefined:
      - Daily
      - Weekly
      - Monthly
    - description: |
        For recurring meetings with a Weekly recurrence_type only.
        State a specific day in a week when the weekly meeting should recur. Allowed: 1┃2┃3┃4┃5┃6┃7  Default = 1.
      name: weekly_days
    - auto: PREDEFINED
      defaultValue: none
      description: "The automatic recording settings. \nNote that the Cloud option
        is available for zoom paid customers only.\n"
      name: auto-record-meeting
      predefined:
      - local
      - cloud
      - none
    - auto: PREDEFINED
      defaultValue: enhanced_encryption
      description: The type of end-to-end (E2EE) encryption, enhanced_encryption or
        e2ee.
      name: encryption_type
      predefined:
      - enhanced_encryption
      - e2ee
    - auto: PREDEFINED
      defaultValue: "true"
      description: start meetings with the host video on.
      name: host_video
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: "If the value of the join_before_host field is true, this field
        sets the time that a participant can join before the meeting's host. \nYou
        can choose: 5 or 10 (minuts), or 0 for any time.\n"
      name: join_before_host_time
      predefined:
      - "0"
      - "5"
      - "10"
    - auto: PREDEFINED
      description: Whether participants can join the meeting before its host. For
        scheduled or recurring meetings only. The default value is False.
      name: join_before_host
      predefined:
      - "false"
      - "true"
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, only authenticated users can join the meeting.
      name: meeting_authentication
      predefined:
      - "false"
      - "true"
    - description: Email address or ID of the user for the meeting.
      name: user
      required: true
    - description: The topic of the meeting.
      name: topic
      required: true
    - auto: PREDEFINED
      description: This allows the host to control when a participant joins the meeting.
        The default is False.
      name: waiting_room
      predefined:
      - "false"
      - "true"
    - description: Meeting start time. When using a format like “yyyy-MM-ddTHH:mm:ssZ”,
        always use GMT time. When using a format like “yyyy-MM-ddTHH:mm:ss”, you should
        use local time and you will need to specify the time zone. Only used for scheduled
        meetings and recurring meetings with fixed time.
      name: start-time
    - description: 'Timezone to format start_time. For example, “America/Los_Angeles”.
        For scheduled meetings only. '
      name: timezone
    description: Create a new Zoom meeting (scheduled, instant, or recurring).
    name: zoom-create-meeting
    outputs:
    - contextPath: Zoom.Meeting.join_url
      description: Join the URL for the meeting.
      type: string
    - contextPath: Zoom.Meeting.id
      description: Meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.start_url
      description: The URL to start the meeting.
      type: string
    - contextPath: Zoom.Meeting.uuid
      description: Unique meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.status
      description: The status of the meeting.
      type: string
    - contextPath: Zoom.Meeting.start_time
      description: The time that the meeting will start at.
      type: Date
    - contextPath: Zoom.Meeting.host email
      description: The email of the host of this meeting.
      type: string
    - contextPath: Zoom.Meeting.topic
      description: The topic of the meeting.
      type: string
    - contextPath: Zoom.Meeting.duration
      description: The duratian of the meeting.
      type: number
    - contextPath: Zoom.Meeting.created_at
      description: The time that this meeting was created.
      type: Date
    - contextPath: Zoom.Meeting.type
      description: The type of the new meeting, Instant = 1, Scheduled =2,Recurring
        with fixed time = 8.
      type: number
  - arguments:
    - description: Meeting ID of the recorded meeting.
      name: meeting_id
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether to delete the recording from the cloud after downloading.
      name: delete_after
      predefined:
      - "false"
      - "true"
    description: Get the meeting record and save it as a file in the War Room.
    name: zoom-fetch-recording
    outputs:
    - contextPath: File.SHA256
      description: Attachment's SHA256.
      type: Unknown
    - contextPath: File.SHA1
      description: Attachment's SHA1.
      type: Unknown
    - contextPath: File.MD5
      description: Attachment's MD5.
      type: Unknown
    - contextPath: File.Name
      description: Attachment's name.
      type: Unknown
    - contextPath: File.Info
      description: Attachment's info.
      type: Unknown
    - contextPath: File.Size
      description: Attachment's size (in bytes).
      type: Unknown
    - contextPath: File.Extension
      description: Attachment's extension.
      type: Unknown
    - contextPath: File.Type
      description: Attachment's type.
      type: Unknown
    - contextPath: File.EntryID
      description: Attachment's entryID.
      type: Unknown
    - contextPath: File.SSDeep
      description: Attachment's SSDeep hash.
      type: Unknown
  - arguments:
    - auto: PREDEFINED
      defaultValue: active
      description: Which status of users to list.
      name: status
      predefined:
      - active
      - inactive
      - pending
    - description: Number of users to return. Max 300. The default is 30.
      name: page-size
      type: int
    - description: |
        The next page token is used to get the next page. IMPORTENT: You must pass the same page size that you pased at the first call.
      name: next_page_token
      type: string
    - description: |
        Which page of results to return. The default = 1.
        Note: This argument is in a deprecate process by the API. As an alternative use "next_page_token" or "limit".
      name: page-number
    - description: The total amunt of results to show.
      name: limit
    - description: A user ID. This is for a single user.
      name: user_id
      type: string
    - description: 'Filter the response by a specific role. For example: role_id=0
        (Owner), role_id=2 (Member).'
      name: role_id
    description: List the existing users.
    name: zoom-list-users
    outputs:
    - contextPath: Zoom.Metadata.Count
      description: Total page count available.
      type: number
    - contextPath: Zoom.Metadata.Number
      description: Current page number.
      type: number
    - contextPath: Zoom.Metadata.Size
      description: Number of results in current page.
      type: number
    - contextPath: Zoom.Metadata.Total
      description: Total number of records.
      type: number
    - contextPath: Zoom.User.id
      description: ID of the user.
      type: string
    - contextPath: Zoom.User.first_name
      description: First name of the user.
      type: string
    - contextPath: Zoom.User.last_name
      description: Last name of the user.
      type: string
    - contextPath: Zoom.User.email
      description: Email of the user.
      type: string
    - contextPath: Zoom.User.type
      description: Type of user.
      type: number
    - contextPath: Zoom.User.created_at
      description: Date when the user was created.
      type: date
    - contextPath: Zoom.User.dept
      description: Department for the user.
      type: string
    - contextPath: Zoom.User.verified
      description: Is the user verified.
      type: number
    - contextPath: Zoom.User.last_login_time
      description: Last login time of the user.
      type: date
    - contextPath: Zoom.User.timezone
      description: Default timezone for the user.
      type: string
    - contextPath: Zoom.User.pmi
      description: Personal meeting ID of the user.
      type: string
    - contextPath: Zoom.User.group_ids
      description: Groups the user belongs to.
      type: string
  - arguments:
    - default: true
      description: The user ID or email to delete.
      name: user
      required: true
    - auto: PREDEFINED
      defaultValue: disassociate
      description: The action to take.
      name: action
      predefined:
      - disassociate
      - delete
    description: Delete a user from Zoom.
    execution: true
    name: zoom-delete-user
  - arguments:
    - description: The ID of the existing meeting.
      name: meeting_id
      required: true
      type: string
    - description: Provide this field to view meeting details of a particular occurrence
        of the recurring meeting.
      name: occurrence_id
      type: string
    - auto: PREDEFINED
      defaultValue: "true"
      description: Set the value of this field to true if you would like to view meeting
        details of all previous occurrences of a recurring meeting.
      name: show_previous_occurrences
      predefined:
      - "false"
      - "true"
    description: Get the information of an existing Zoom meeting.
    name: zoom-meeting-get
    outputs:
    - contextPath: Zoom.Meeting.join_url
      description: Join URL for the meeting.
      type: string
    - contextPath: Zoom.Meeting.id
      description: Meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.start_url
      description: The URL to start the meeting.
      type: string
    - contextPath: Zoom.Meeting.uuid
      description: Unique meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.status
      description: The status of the meeting.
      type: string
    - contextPath: Zoom.Meeting.start_time
      description: The time that the meeting will start.
      type: Date
    - contextPath: Zoom.Meeting.host email
      description: The email of the host of this meeting.
      type: string
    - contextPath: Zoom.Meeting.topic
      description: The topic of the meeting.
      type: string
    - contextPath: Zoom.Meeting.duration
      description: The duratian of the meeting.
      type: number
    - contextPath: Zoom.Meeting.created_at
      description: The time that this meeting was created.
      type: Date
    - contextPath: Zoom.Meeting.type
      description: The type of the new meeting, Instant = 1, Scheduled =2,Recurring
        with fixed time = 8.
      type: number
  - arguments:
    - description: The user ID of the meetings owner.
      name: user_id
      required: true
      type: string
    - description: Number of users to return. Default = 30. Max = 300.
      name: page_size
    - description: |
        Which page of results to return. The default = 1.
        Note: This argument is in a deprecate process by the API. As an alternative use "next_page_token" or "limit".
      name: page_number
    - description: |
        The next page token is used to paginate te the next page. IMPORTENT: You must pass the same page size that you pased at the first call.
      name: next_page_token
      type: string
    - description: The total amunt of results to show.
      name: limit
      type: string
    - auto: PREDEFINED
      defaultValue: '"scheduled"'
      description: Filter the results by searching specific types.
      name: type
      predefined:
      - all
      - scheduled
      - live
      - upcoming
      - upcoming_meetings
      - previous_meetings
    description: |
      Show all the meetings of a given user. Note: only scheduled and unexpired meetings will appear.
    name: zoom-meeting-list
    outputs:
    - contextPath: Zoom.Metadata.Total
      description: Total number of records.
      type: number
    - contextPath: Zoom.Meeting.page_size
      description: The size of the page returned from the API.
      type: number
    - contextPath: Zoom.Meeting.total_records
      description: The total records in the API for this request.
      type: number
    - contextPath: Zoom.Meeting.join_url
      description: Join URL for the meeting.
      type: string
    - contextPath: Zoom.Meeting.id
      description: Meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.start_url
      description: The URL to start the meeting.
      type: string
    - contextPath: Zoom.Meeting.uuid
      description: Unique meeting ID of the new meeting that is created.
      type: string
    - contextPath: Zoom.Meeting.status
      description: The status of the meeting.
      type: string
    - contextPath: Zoom.Meeting.start_time
      description: The time that the meeting will start.
      type: Date
    - contextPath: Zoom.Meeting.host email
      description: The email of the host of this meeting.
      type: string
    - contextPath: Zoom.Meeting.topic
      description: The topic of the meeting.
      type: string
    - contextPath: Zoom.Meeting.duration
      description: The duratian of the meeting.
      type: number
    - contextPath: Zoom.Meeting.created_at
      description: The time that this meeting was created.
      type: Date
    - contextPath: Zoom.Meeting.type
      description: The type of this meeting.
  - arguments:
    - description: Number of channels to return. Max 300. The default is 50.
      name: page-size
      type: int
    - description: |
        The next page token is used to get the next page. IMPORTANT: You must pass the same page size that you passed in the first call.
      name: next_page_token
      type: string
    - description: |
        Which page of results to return. The default = 1.
        Note: This argument is in a deprecate process by the API. As an alternative use "next_page_token" or "limit".
      name: page-number
    - description: The total amunt of results to show.
      name: limit
    - description: A channel ID. This is for a single channel.
      name: channel_id
      type: string
    description: |
      List the existing channels You can only retrieve the channel information for the authorized user. In order to get a public channel by its name (for example Admins_to_delete_4)  you need to run the command zoom-list-account-public-channels without the channel_id param and find which channel_id fits the channel name.
    name: zoom-list-account-public-channels
    outputs:
    - contextPath: Zoom.Channels.properties.channel_settings.add_member_permissions
      description: |
        Who can add new channel members: - 1: All channel members can add new members. - 2: Only channel owner and administrators can add new members. Note: This setting can only be modified by the channel owner.
      type: integer
    - contextPath: Zoom.Channels.properties.channel_settings.new_members_can_see_previous_messages_files
      description: Whether new channel members can view messages and files previously
        posted in the channel.
      type: boolean
    - contextPath: Zoom.Channels.properties.channel_settings.posting_permissions
      description: |
        The channel members' posting permissions: - 1: All chat channel members can post to the channel. - 2: Only the channel owner and administrators can post to the channel. - 3: Only the channel owner, administrators, and certain members can post to the channel. Note: This setting can only be modified by the channel owner.
      type: integer
    - contextPath: Zoom.Channels.properties.channel_settings.mention_all_permissions
      description: |
        Who can use @all: - 1: Everyone can use @all. - 2: Only channel owner and administrators can use @all. - 3: Nobody can use @all. Note: This setting can only be modified by the channel owner.
      type: integer
    - contextPath: Zoom.Channels.properties.channel_settings.allow_to_add_external_users
      description: |
        Whether external users can be added to the channel: - 0: External user cannot be added to the channel. - 1: All chat channel members can add external users to the channel. - 2: Only members within your organization can add external users to the channel. - 3: Only channel owner and administrators can add external users to the channel.
      type: integer
    - contextPath: Zoom.Channels.id
      description: The channel's ID.
      type: string
    - contextPath: Zoom.Channels.jid
      description: The Jabber ID (JID) used to access the account.
      type: string
    - contextPath: Zoom.Channels.name
      description: The channel name.
      type: string
    - contextPath: Zoom.Channels.type
      description: |
        The channel's type: 0 — An unknown channel type. 1 — A private channel. Members must be invited to join this channel. 2 — A private channel with members that belong to a Zoom account. All members of this channel are from the same organization and must be invited to join. 3 — A public channel. Anyone can search for and join this channel. 4 — An instant channel. This type of channel is created by adding members to a new chat. 5 — A public channel. Anyone can join this channel and invite members from other Zoom accounts.
      type: integer
    - contextPath: Zoom.Channels.channel_url
      description: The URL of the Zoom chat channel.
      type: string
  - arguments:
    - description: Number of channels to return. Max 300. The default is 50.
      name: page-size
      type: int
    - description: |
        The next page token is used to get the next page. IMPORTANT: You must pass the same page size that you passed in the first call.
      name: next_page_token
      type: string
    - description: |
        Which page of results to return. The default = 1.
        Note: This argument is in a deprecate process by the API. As an alternative use "next_page_token" or "limit".
      name: page-number
    - description: The total amunt of results to show.
      name: limit
    - description: A channel ID. This is for a single channel.
      name: channel_id
      type: string
    - description: Email or user ID.
      name: user_id
      required: true
      type: string
    description: |
      List the existing channels. In order get the user ID by user email - use the existing command zoom-list-users.  In order to get the user channel by its name, run the command zoom-list-user-channels without the channel_id param and find which channel_id fits the channel name.
    name: zoom-list-user-channels
    outputs:
    - contextPath: Zoom.Channel.id
      description: The ID of the created channel.
      type: string
    - contextPath: Zoom.Channel.name
      description: The name of the created channel.
      type: string
    - contextPath: Zoom.Channel.type
      description: The created channel type.
      type: string
    - contextPath: Zoom.Channel.url
      description: The created channel URL.
      type: string
  - arguments:
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
    - description: The member(s) to include in the channel. A maximum of 20 members
        can be added to the channel at once with this API.
      isArray: true
      name: member_emails
      required: true
    - auto: PREDEFINED
      description: |
        Who can add new channel members: * 1 - All channel members can add new members. * 2 - Only channel owner and administrators can add new members. Note: This setting can only be modified by the channel owner. Default: 1 .
      name: add_member_permissions
      predefined:
      - All channel members can add
      - Only channel owner and admins can add
    - auto: PREDEFINED
      description: |
        The channel members' posting permissions: * 1 — All chat channel members can post to the channel. * 2 — Only the channel owner and administrators can post to the channel. * 3 — Only the channel owner, administrators and certain members can post to the channel. Default: 1 .
      name: posting_permissions
      predefined:
      - All members can post
      - Only the owner and admins can post
      - Only the owner, admins and certain members can post
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether new channel members can view messages and files previously
        posted in the channel.
      name: new_members_can_see_prev_msgs
      predefined:
      - "true"
      - "false"
    - description: The name of the channel. Maximum of 128 characters.
      name: channel_name
      required: true
    - auto: PREDEFINED
      description: |
        The type of the channel. The value can be one of the following: 1: Private channel. In this type of channel, members must be invited to join a channel. 2: Private channel with members that belong to one Zoom account. Members in this channel should be invited and the members should be from the same organization. 3: Public channel. Anyone can search for this channel and join the channel. 4: New chat. This is an instant channel which can be created by adding members to a new chat.
      name: channel_type
      predefined:
      - Private channel
      - Private channel with members that belong to one account
      - Public channel
      - New chat
      required: true
    description: |
      Creates a channel for a user. Use the existing command zoom-list-users to get the user ID by email (only if the user has an email address as part of the user parameters).
    execution: true
    name: zoom-create-channel
    outputs:
    - contextPath: Zoom.Channel.id
      description: the channel's unique identifier.
      type: string
    - contextPath: Zoom.Channel.jid
      description: The channel JID.
      type: string
    - contextPath: Zoom.Channel.name
      description: The channel name.
      type: string
    - contextPath: Zoom.Channel.type
      description: |
        The type of the channel. The value can be one of the following: 1: Private channel. In this type of channel, members must be invited to join a channel. 2: Private channel with members that belong to one Zoom account. Members in this channel should be invited and the members should be from the same organization. 3: Public channel. Anyone can search for this channel and join the channel. 4: Group chat. This is an instant channel which can be created by adding members to a new chat.
      type: string
    - contextPath: Zoom.Channel.url
      description: The URL of the Zoom chat channel.
      type: string
  - arguments:
    - description: Unique identifier of a channel.
      name: channel_id
      required: true
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
    description: |
      Deletes a specific Zoom channel. Use the command zoom-list-account-public-channels  in order to fetch the channel ID by the channel name.
    execution: true
    name: zoom-delete-channel
  - arguments:
    - description: The channel ID.
      name: channel_id
      required: true
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
    - auto: PREDEFINED
      description: |
        Who can add new channel members: * 1 - All channel members can add new members. * 2 - Only channel owner and administrators can add new members. Note: This setting can only be modified by the channel owner.
      name: add_member_permissions
      predefined:
      - All channel members can add
      - Only channel owner and admins can add
    - auto: PREDEFINED
      description: |
        The channel members' posting permissions: * 1 — All chat channel members can post to the channel. * 2 — Only the channel owner and administrators can post to the channel. * 3 — Only the channel owner, administrators and certain members can post to the channel.
      name: posting_permissions
      predefined:
      - All members can post
      - Only the owner and admins can post
      - Only the owner, admins and certain members can post
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether new channel members can view messages and files previously
        posted in the channel.
      name: new_members_can_see_prev_msgs
      predefined:
      - "true"
      - "false"
    - description: A new name for the channel.
      name: channel_name
    description: 'Update an existing channel in a Zoom account. Use the command zoom-list-account-public-channels
      in order to fetch the channel ID by the channel name. "Need to provide at least
      one of the following arguments:  posting_permissions or channnel_name.".'
    execution: true
    name: zoom-update-channel
  - arguments:
    - description: The channel's unique identifier.
      name: channel_id
      required: true
      type: string
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
    - description: The member's email address.
      isArray: true
      name: members
      required: true
      type: string
    description: |
      Invites members that are in a user's contact list to a channel. A channel can have one or more members. The maximum number of members that can be added at once with this API is 5. Use the command zoom-list-account-public-channels in order to fetch the channel ID by the channel name.
    name: zoom-invite-to-channel
    outputs:
    - contextPath: Zoom.Channel.ids
      description: |
        A comma-separated list of user IDs of the members added to the channel. The user IDs of those who are not from the same account will be omitted from the list.
      type: string
    - contextPath: Zoom.Channel.added_at
      description: The date and time when the members are added to the channel.
      type: string
    - contextPath: Zoom.Channel.member_ids
      description: A comma-separated list of member IDs of the members added to the
        channel.
      type: string
  - arguments:
    - description: The unique identifier of the channel from where to remove a member.
      name: channel_id
      required: true
      type: string
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
      type: string
    - description: |
        The email address or user ID or member ID of the member to remove from the channel.
      name: member_id
      required: true
      type: string
    description: |
      Removes a member from a chat channel. A channel can have one or more members. Use the command zoom-list-account-public-channels in order to fetch the channel ID by the channel name. In order get the user ID by the user email - use the existing command zoom-list-users.
    name: zoom-remove-from-channel
  - arguments:
    - description: The channel ID of the channel to which to send the chat file.
      name: to_channel
      type: string
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
    - description: The user ID or member ID of the contact to send the chat file.
      name: to_contact
      type: string
    - description: Cortex XSOAR internal file ID.
      name: entry_id
      required: true
      type: string
    description: |
      Sends a file on Zoom to either an individual user in your contact list or a channel of which you are a member. Use existing command zoom-list-users to get the user ID by the user email (for to_contact). Use the command zoom-list-user-channels in order to fetch the channel ID by the channel name (for to_channel).
    name: zoom-send-file
  - arguments:
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
      type: string
    - description: |
        Email address of the mention contact.
      name: at_contact
      type: string
    - auto: PREDEFINED
      defaultValue: "false"
      description: |-
        You can provide a markdown message in the message argument.
        | Element   | Markdown Syntax |
        |------------|-------------------|
        | Paragraph | # H1 , ## H2 ,### H3|
        | Addlink   | [link text](link url) url must contain http or https |
        | LeftIndent| >, >>, >>> |
        | FontColor | [#<rgb>](text)|
        | FontSize  | [s|m|l](text)|
        | BackgroundColor| [#<rgb>bg](text)|
        | Mention | @<text>  if mention is not @all please provide argument at_contact= email|.
      name: is_markdown
      predefined:
      - "true"
      - "false"
    - description: "The message to be sent. Maximum of 1024 characters.\nYou can provide
        a markdown format \n| Element   | Markdown Syntax |\n|------------|-------------------|\n|
        Paragraph | # H1 , ## H2 ,### H3|\n| Addlink   | [link text](link url) url
        must contain http or https |\n| LeftIndent| >, >>, >>> |\n| FontColor | [#<rgb>](text)|\n|
        FontSize  | [s|m|l](text)|\n| BackgroundColor| [#<rgb>bg](text)|\n| Mention
        | @<text>  if mention is not @all please provide argument at_contact= email|."
      name: message
      required: true
      type: string
    - description: A list of the file IDs to send. This field only accepts a maximum
        of six file IDs.
      isArray: true
      name: entry_ids
      type: string
    - description: The reply message's ID. This field only returns if the message
        is a reply message.
      name: reply_main_message_id
      type: string
    - description: The channel ID of the channel to send a message.
      name: to_channel
      type: string
    - description: The email address or user ID or member ID of the person to send
        a message.
      name: to_contact
      type: string
    description: |
      Sends chat messages on Zoom to either an individual user who is in your contact list or to a channel of which you are a member.  Use the command zoom-list-users to get the user id by the user email (for to_contact). Use the command zoom-list-user-channels in order to fetch the channel ID by the channel name (for to_channel). In order to send a message, you need to provide at least a message (message text) and to_contact (contact to send) or to_channel (channel to send to), but not both of them. In order to send a style message you need to provide is-markdown=true and the message can contain a markdown format. If you are using mention markdown in a message, provide the email address in the at_contact argument.
    name: zoom-send-message
    outputs:
    - contextPath: Zoom.ChatMessage.id
      description: Unique identifier of the message.
      type: number
  - arguments:
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
      type: string
    - description: Unique identifier of the message.
      name: message_id
      required: true
      type: string
    - description: |
        The channel ID where the message was sent. You must provide this parameter or the to_contact parameter.
      name: to_channel
      type: string
    - description: |
        The member ID or user ID or email address of a chat contact to whom the message was sent.  You must provide this parameter or the to_channel parameter.
      name: to_contact
      type: string
    description: |
      Deletes a chat message previously sent to a contact or a channel. Use the command zoom-list-user-channels  to get the channel ID by the channel name (for to_channel). See the existing command zoom-list-users to get the user ID by email (for to_contact). In order to update messages (or a single message using messageId), you need to provide  to_contact (contact to send) or to_channel (channel to send to), but not both of them.
    name: zoom-delete-message
  - arguments:
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
      type: string
    - description: Unique identifier of the message.
      name: message_id
      required: true
      type: string
    - description: The edited message.
      name: message
      required: true
      type: string
    - description: |
        The channel ID of the channel where you sent the message. You must provide either to_contact or to_channel parameter in the API request. Channel ID can be retrieved from List User's Channels API.
      name: to_channel
      type: string
    - description: |
        The email address or user ID or member ID of the contact to whom the message was sent.  You must provide either this parameter or the to_channel parameter in the API request.
      name: to_contact
      type: string
    - description: A list of Cortex XSOAR file entry IDs to send.
      isArray: true
      name: entry_ids
      type: string
    description: |
      Edits a chat message that you previously sent to either a contact or a channel in Zoom by providing the ID of the message as the value of the messageId parameter.  As a query parameter, you must provide either the contact's email address of the contact or the Channel ID of the channel where the message was sent. Use the command zoom-list-user-channels to get the channel ID by the channel name (for to_channel). Use the existing command zoom-list-users to get the user ID by email (for to_contact). In order to update messages (or a single message using messageId), you need to provide to_contact (contact to send) or to_channel (channel to send to), but not both of them.
    name: zoom-update-message
  - arguments:
    - description: Email or unique identifier of the user.
      name: user_id
      required: true
      type: string
    - description: |
        This field allows you to query by the email address or user ID or member ID of a chat contact with whom the user communicated. The API only returns messages sent and/or received between the user and the queried contact.
      name: to_contact
      type: string
    - description: |
        This field queries by the channel ID of a channel in which the user had chat conversations. The API only returns messages sent and/or received by the user in the queried channel.
      name: to_channel
      type: string
    - description: |
        The query date from which to retrieve the chat messages. This value defaults to the current date. Format %Y-%m-%dT%H:%M:%S.
      name: date
      type: string
    - description: Start date. Format %Y-%m-%dT%H:%M:%S.
      name: from
      type: string
    - description: End date. Format %Y-%m-%dT%H:%M:%S.
      name: to
      type: string
    - defaultValue: "false"
      description: Whether to include deleted and edited messages.
      name: include_deleted_and_edited_message
      type: boolean
    - auto: PREDEFINED
      description: |
        The type of search: message — Search messages. file — Search files.
      name: search_type
      predefined:
      - message
      - file
      type: string
    - description: Key for search in messages.
      name: search_key
      type: string
    - defaultValue: "false"
      description: |
        Default: false Whether to exclude returning all child messages in a chat, leaving only the parent messages.
      name: exclude_child_message
      type: boolean
    - description: |
        The next page token paginates through a large set of results. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
      name: next_page_token
      type: string
    - description: Number of records returned from a single API call. Default 50.
      name: page_size
      type: number
    - description: Which page of results to return. Default 1.
      name: page_number
      type: number
    - description: Total amount of results to show.
      name: limit
      type: number
    description: "Searches chat messages or shared files between a user and an individual
      contact or a chat channel. \n"
    name: zoom-list-messages
    outputs:
    - contextPath: Zoom.ChatMessageNextToken.user_id
      description: The user ID associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.to_channel
      description: The channel ID associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.include_deleted_and_edited_message
      description: Indicates whether deleted and edited messages are included in the
        next page token request.
      type: boolean
    - contextPath: Zoom.ChatMessageNextToken.search_type
      description: The search type associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.to
      description: The recipient associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.date
      description: The date associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.page_size
      description: The page size associated with the next page token.
      type: integer
    - contextPath: Zoom.ChatMessageNextToken.next_page_token
      description: The next page token for pagination.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.from
      description: The sender associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.search_key
      description: The search key associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessageNextToken.exclude_child_message
      description: Indicates whether child messages are excluded in the next page
        token request.
      type: boolean
    - contextPath: Zoom.ChatMessageNextToken.to_contact
      description: The contact ID associated with the next page token.
      type: string
    - contextPath: Zoom.ChatMessage.date
      description: The queried date value.
      type: date
    - contextPath: Zoom.ChatMessage.id
      description: the channel's unique identifier.
      type: string
    - contextPath: Zoom.Channel.jid
      description: The channel JID.
      type: string
    - contextPath: Zoom.Channel.name
      description: The channel name.
      type: string
    - contextPath: Zoom.Channel.type
      description: |
        The type of the channel. The value can be one of the following: 1: Private channel. In this type of channel, members must be invited to join a channel. 2: Private channel with members that belong to one Zoom account. Members in this channel should be invited and the members should be from the same organization. 3: Public channel. Anyone can search for this channel and join the channel. 4: Group chat. This is an instant channel which can be created by adding members to a new chat.
      type: string
    - contextPath: Zoom.ChatMessage.date
      description: The queried date value.
      type: date
    - contextPath: Zoom.ChatMessage.from
      description: The queried from value. (Returned only if the from query parameter
        is used.)
      type: date-time
    - contextPath: Zoom.ChatMessage.messages
      description: Information about received messages and files.
      type: array of object
    - contextPath: Zoom.ChatMessage.messages.bot_message
      description: The chatbot's message in JSON format.
      type: object
    - contextPath: Zoom.ChatMessage.messages.bot_message.date_time
      description: The date and time when the message was sent.
      type: date-time
    - contextPath: Zoom.ChatMessage.messages.files
      description: Information about chat files (if multiple files exist).
      type: array of object
    - contextPath: Zoom.ChatMessage.messages.files.download_url
      description: The download URL of the chat file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.files.file_id
      description: The unique ID of the chat file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.files.file_name
      description: The name and file extension of the chat file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.files.file_size
      description: The size of the chat file in bytes.
      type: integer
    - contextPath: Zoom.ChatMessage.messages.rich_text
      description: Rich text formatting information.
      type: array of object
    - contextPath: Zoom.ChatMessage.messages.rich_text.start_position
      description: The start position of the rich text in the message string.
      type: integer
    - contextPath: Zoom.ChatMessage.messages.rich_text.end_position
      description: The end position of the rich text.
      type: integer
    - contextPath: Zoom.ChatMessage.messages.rich_text.format_type
      description: The type of rich text format.
      type: enum
    - contextPath: Zoom.ChatMessage.messages.rich_text.format_attr
      description: The attribute values of a specific format_type.
      type: string
    - contextPath: Zoom.ChatMessage.messages.rich_text.download_url
      description: The download URL of the first file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.rich_text.file_id
      description: The unique ID of the first file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.rich_text.file_name
      description: The name of the first file.
      type: string
    - contextPath: Zoom.ChatMessage.messages.rich_text.file_size
      description: The size of the first file in bytes.
      type: integer
    - contextPath: Zoom.ChatMessage.messages.id
      description: Unique identifier of the message.
      type: string
    - contextPath: Zoom.ChatMessage.messages.message
      description: The message content.
      type: string
    - contextPath: Zoom.ChatMessage.messages.reply_main_message_id
      description: The unique identifier of a reply message. (Returned only for reply
        messages.)
      type: string
    - contextPath: Zoom.ChatMessage.messages.reply_main_message_timestamp
      description: The timestamp of when the reply message was sent. (Returned only
        for reply messages.)
      type: integer
    - contextPath: Zoom.ChatMessage.messages.sender
      description: The email address of the message sender. Empty if the sender does
        not belong to the same account as the current user or is not a contact.
      type: string
    - contextPath: Zoom.ChatMessage.messages.sender_member_id
      description: The member ID of the message sender.
      type: string
    - contextPath: Zoom.ChatMessage.messages.sender_display_name
      description: The display name of the message sender.
      type: string
    - contextPath: Zoom.ChatMessage.messages.status
      description: Indicates the status of the message. Allowed values Deleted, Edited,
        Normal. (Returned only when include_deleted_and_edited_message query parameter
        is set to true.)
      type: enum
    - contextPath: Zoom.ChatMessage.messages.timestamp
      description: The timestamp of the message in microseconds.
      type: integer
    - contextPath: Zoom.ChatMessage.at_items
      description: Information about mentions.
      type: array of object
    - contextPath: Zoom.ChatMessage.at_items.at_contact
      description: The user ID of the mentioned contact. Empty if the contact does
        not belong to the same account as the current user.
      type: string
    - contextPath: Zoom.ChatMessage.at_items.at_contact_member_id
      description: The member ID of the mentioned contact.
      type: string
    - contextPath: Zoom.ChatMessage.at_items.at_type
      description: The type of mention. Allowed values 1 (Contact), 2 (Channel).
      type: integer
    - contextPath: Zoom.ChatMessage.at_items.end_position
      description: The end position of the mention.
      type: integer
    - contextPath: Zoom.ChatMessage.at_items.start_position
      description: The start position of the mention.
      type: integer
  - arguments:
    - description: The name of the channel to archive. If not provided, the mirrored
        investigation channel is archived (if the channel exists).
      name: channel
    - description: The ID of the channel to archive. If not provided, the mirrored
        investigation channel is archived (if the channel exists).
      name: channel_id
    description: Delete a mirrored Zoom channel.
    name: close-channel
  - arguments:
    - description: the message.
      name: message
      required: true
      type: string
    - description: The user ID, JID or email to whom to send the message. You must
        provide this parameter or the channel_id parameter.
      name: to
      type: string
    - description: The ID or the JID of the channel to which to send the message.
        You must provide this parameter or the to parameter.
      name: channel_id
      type: string
    - description: The channel name can be provided only if the channel is part of
        a mirroring incident, instead of the channel JID  .
      name: channel
      type: string
    - description: The UserID that allows a chatbot to send a message to a group channel
        when it has only one designated person in that group channel to see the message.
      name: visible_to_user
      type: string
    - description: The message as a JSON for asking questions to the user.
      name: zoom_ask
      type: boolean
    description: Send a message using a chatbot app.
    name: send-notification
  - arguments:
    - auto: PREDEFINED
      default: true
      defaultValue: all
      description: The mirroring type. Can be "all", which mirrors everything, "chat",
        which mirrors only chats (not commands), or "none", which stops all mirroring.
      name: type
      predefined:
      - all
      - chat
      - none
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether the channel is auto-closed when an investigation is closed.
      name: autoclose
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: Both
      description: The mirroring direction.
      name: direction
      predefined:
      - Both
      - FromDemisto
      - ToDemisto
    - description: The name of the channel. The default is "incident-<incidentID>".
      name: channelName
    description: Mirrors the investigation between Zoom and the Cortex XSOAR War Room.
    name: mirror-investigation
  dockerimage: demisto/fastapi:1.0.0.83979
  longRunning: true
  longRunningPort: true
  runonce: false
  script: |
    register_module_line('Zoom', 'start', __line__())
    ### pack version: 1.6.10


    import shutil

    ### GENERATED CODE ###: from ZoomApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('ZoomApiModule', 'start', __line__(), wrapper=-3)


    from datetime import timedelta
    import dateparser

    ''' CONSTANTS '''

    OAUTH_TOKEN_GENERATOR_URL = 'https://zoom.us/oauth/token'
    # The token’s time to live is 1 hour,
    # two minutes were subtract for extra safety.
    TOKEN_LIFE_TIME = timedelta(minutes=58)
    # the lifetime for an JWT token is 90 minutes == 5400 seconds
    # 400 seconds were subtract for extra safety.
    JWT_LIFETIME = 5000
    # maximun records that the api can return in one request
    MAX_RECORDS_PER_PAGE = 300

    # ERRORS
    INVALID_CREDENTIALS = 'Invalid credentials. Please verify that your credentials are valid.'
    INVALID_API_SECRET = 'Invalid API Secret. Please verify that your API Secret is valid.'
    INVALID_ID_OR_SECRET = 'Invalid Client ID or Client Secret. Please verify that your ID and Secret is valid.'
    INVALID_TOKEN = 'Invalid Authorization token. Please verify that your Bot ID and Bot Secret is valid.'
    INVALID_BOT_ID = 'No Chatbot can be found with the given robot_jid value. Please verify that your Bot JID is correct'
    '''CLIENT CLASS'''


    class Zoom_Client(BaseClient):
        """ A client class that implements logic to authenticate with Zoom application. """

        def __init__(
            self,
            base_url: str,
            api_key: str | None = None,
            api_secret: str | None = None,
            account_id: str | None = None,
            client_id: str | None = None,
            client_secret: str | None = None,
            bot_client_id: str | None = None,
            bot_client_secret: str | None = None,
            verify=True,
            proxy=False,
            bot_jid: str | None = None,
        ):
            super().__init__(base_url, verify, proxy)
            self.api_key = api_key
            self.api_secret = api_secret
            self.account_id = account_id
            self.client_id = client_id
            self.client_secret = client_secret
            self.bot_client_id = bot_client_id
            self.bot_client_secret = bot_client_secret
            self.bot_jid = bot_jid
            try:
                self.access_token, self.bot_access_token = self.get_oauth_token()
            except Exception as e:
                demisto.info(f"Cannot get access token. Error: {e}")
                self.access_token = None
                self.bot_access_token = None

        def generate_oauth_token(self):
            """
            Generate an OAuth Access token using the app credentials (AKA: client id and client secret) and the account id

            :return: valid token
            """
            token_res = self._http_request(method="POST", full_url=OAUTH_TOKEN_GENERATOR_URL,
                                           params={"account_id": self.account_id,
                                                   "grant_type": "account_credentials"},
                                           auth=(self.client_id, self.client_secret))
            return token_res.get('access_token')

        def generate_oauth_client_token(self):
            """
            Generate an OAuth Access token using the app credentials (AKA: client id and client secret) and the account id

            :return: valid token
            """
            token_res = self._http_request(method="POST", full_url=OAUTH_TOKEN_GENERATOR_URL,
                                           params={"account_id": self.account_id,
                                                   "grant_type": "client_credentials"},
                                           auth=(self.bot_client_id, self.bot_client_secret))
            return token_res.get('access_token')

        def get_oauth_token(self, force_gen_new_token=False):
            """
                Retrieves the token from the server if it's expired and updates the global HEADERS to include it

                :param force_gen_new_token: If set to True will generate a new token regardless of time passed

                :rtype: ``str``
                :return: Token
            """
            now = datetime.now()
            ctx = get_integration_context()
            client_oauth_token = None
            oauth_token = None

            if not ctx or not ctx.get('token_info').get('generation_time', force_gen_new_token):
                # new token is needed
                if self.client_id and self.client_secret:
                    oauth_token = self.generate_oauth_token()
                if self.bot_client_id and self.bot_client_secret:
                    client_oauth_token = self.generate_oauth_client_token()
                ctx = {}
            else:
                if generation_time := dateparser.parse(
                    ctx.get('token_info').get('generation_time')
                ):
                    time_passed = now - generation_time
                else:
                    time_passed = TOKEN_LIFE_TIME
                if time_passed < TOKEN_LIFE_TIME:
                    # token hasn't expired
                    return ctx.get('token_info', {}).get('oauth_token'), ctx.get('token_info', {}).get('client_oauth_token')
                else:
                    # token expired
                    # new token is needed
                    if self.client_id and self.client_secret:
                        oauth_token = self.generate_oauth_token()
                    if self.bot_client_id and self.bot_client_secret:
                        client_oauth_token = self.generate_oauth_client_token()

            ctx.update({'token_info': {'oauth_token': oauth_token, 'client_oauth_token': client_oauth_token,
                       'generation_time': now.strftime("%Y-%m-%dT%H:%M:%S")}})
            set_integration_context(ctx)
            return oauth_token, client_oauth_token

        def error_handled_http_request(self, method, url_suffix='', full_url=None, headers=None,
                                       auth=None, json_data=None, params=None, files=None, data=None,
                                       return_empty_response: bool = False, resp_type: str = 'json', stream: bool = False, ):

            # all future functions should call this function instead of the original _http_request.
            # This is needed because the OAuth token may not behave consistently,
            # First the func will make an http request with a token,
            # and if it turns out to be invalid, the func will retry again with a new token.
            try:
                return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                             auth=auth, json_data=json_data, params=params, files=files, data=data,
                                             return_empty_response=return_empty_response, resp_type=resp_type, stream=stream)
            except DemistoException as e:
                if any(message in e.message for message in ["Invalid access token",
                                                            "Access token is expired.",
                                                            "Invalid authorization token"]):
                    if url_suffix == '/im/chat/messages':
                        demisto.debug('generate new bot client token')
                        self.bot_access_token = self.generate_oauth_client_token()
                        headers = {'authorization': f'Bearer {self.bot_access_token}'}
                    else:
                        self.access_token = self.generate_oauth_token()
                        headers = {'authorization': f'Bearer {self.access_token}'}
                    return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                                 auth=auth, json_data=json_data, params=params, files=files, data=data,
                                                 return_empty_response=return_empty_response, resp_type=resp_type, stream=stream)
                else:
                    raise DemistoException(e.message, url_suffix)


    ''' HELPER FUNCTIONS '''

    register_module_line('ZoomApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###
    from traceback import format_exc
    from datetime import datetime
    from fastapi import Depends, FastAPI, Request, Response, status
    from fastapi.responses import JSONResponse
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    from fastapi.security.api_key import APIKey, APIKeyHeader
    from secrets import compare_digest
    from fastapi_utils.tasks import repeat_every
    import uvicorn
    from uvicorn.logging import AccessFormatter
    from copy import copy
    import hashlib
    import hmac
    from tempfile import NamedTemporaryFile


    app = FastAPI()

    basic_auth = HTTPBasic(auto_error=False)
    token_auth = APIKeyHeader(auto_error=False, name='Authorization')

    SYNC_CONTEXT = True
    OBJECTS_TO_KEYS = {
        'messages': 'entitlement',
    }
    DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
    PLAYGROUND_INVESTIGATION_TYPE = 9

    # Note#1: type "Pro" is the old version, and "Licensed" is the new one, and i want to support both.
    # Note#2: type "Corporate" is officially not supported any more, but i did not remove it just in case it still works.
    USER_TYPE_MAPPING = {
        "Basic": 1,
        "Pro": 2,
        "Licensed": 2,
        "Corporate": 3
    }
    MONTHLY_RECURRING_TYPE_MAPPING = {
        "Daily": 1,
        "Weekly": 2,
        "Monthly": 3
    }
    INSTANT = "Instant"
    SCHEDULED = "Scheduled"
    RECURRING_WITH_TIME = "Recurring meeting with fixed time"

    MEETING_TYPE_NUM_MAPPING = {
        "Instant": 1,
        "Scheduled": 2,
        "Recurring meeting with fixed time": 8
    }
    FILE_TYPE_MAPPING = {
        'MP4': 'Video',
        'M4A': 'Audio'
    }
    POSTING_PERMISSIONS_MAPPING = {
        'All members can post': 1,
        'Only the owner and admins can post': 2,
        'Only the owner, admins and certain members can post': 3
    }

    MEMBER_PERMISSIONS_MAPPING = {
        'All channel members can add': 1,
        'Only channel owner and admins can add': 2
    }

    CHANNEL_TYPE_MAPPING = {
        'Private channel': 1,
        'Private channel with members that belong to one account': 2,
        'Public channel': 3,
        'New chat': 4
    }
    AT_TYPE = {
        'Mention a contact': 1,
        'Mention "all" to notify everyone in the channel.': 2

    }

    WRONG_TIME_FORMAT = "Wrong time format. Use this format: 'yyyy-MM-ddTHH:mm:ssZ' or 'yyyy-MM-ddTHH:mm:ss' "
    LIMIT_AND_EXTRA_ARGUMENTS = """Too many arguments. If you choose a limit,
                                           don't enter a user_id or page_size or next_page_token or page_number."""
    LIMIT_AND_EXTRA_ARGUMENTS_MEETING_LIST = """Too many arguments. If you choose a limit,
                                           don't enter a page_size or next_page_token or page_number."""
    INSTANT_AND_TIME = "Too many arguments.Use start_time and timezone for scheduled meetings only."
    JBH_TIME_AND_NO_JBH = """Collision arguments.
    join_before_host_time argument can be used only if join_before_host is 'True'."""
    WAITING_ROOM_AND_JBH = "Collision arguments. join_before_host argument can be used only if waiting_room is 'False'."
    END_TIMES_AND_END_DATE_TIME = "Collision arguments. Choose only one of these two arguments, end_time or end_date_time."
    NOT_RECURRING_WITH_RECURRING_ARGUMENTS = """One or more arguments that were filed
    are used for a recurring meeting with a fixed time only."""
    NOT_MONTHLY_AND_MONTHLY_ARGUMENTS = """One or more arguments that were
    filed are for a recurring meeting with a fixed time and monthly recurrence_type only."""
    MONTHLY_RECURRING_MISIING_ARGUMENTS = """Missing arguments. A recurring meeting with a fixed time and monthly recurrence_type
                must have the following arguments: monthly_week and monthly_week_day."""
    NOT_WEEKLY_WITH_WEEKLY_ARGUMENTS = "Weekly_days is for weekly recurrence_type only."
    EXTRA_PARAMS = """Too many fields were filled.
    You should fill the Account ID, Client ID, and Client Secret fields (OAuth),
    OR the API Key and API Secret fields (JWT - Deprecated)."""
    RECURRING_MISSING_ARGUMENTS = """Missing arguments. A recurring meeting with a fixed
    time is missing this argument: recurrence_type."""
    MISSING_ARGUMENT = """Missing either a contact info or a channel id"""
    USER_NOT_FOUND = """ This user email can't be found """
    MARKDOWN_AND_EXTRA_ARGUMENTS = """Too many arguments. If you choose is_markdown,
                        don't provide one of the following arguments: start_position, end_position, format_type, at_type,
                        rt_start_position, rt_end_position or format_attr"""
    MARKDOWN_EXTRA_FORMATS = """Too many style in text. you can provide only one style type"""
    MARKDOWN_EXTRA_MENTIONS = """Too many mentions in text. you can provide only one mention in each message"""
    WRONG_CHANNEL = """Couldn't find channel id base on provided channel_name. channel_name can use only for  mirrored channel.
    Otherwise, please use the channel ID instead."""
    MISSING_ARGUMENT_JID = """Missing argument: You must provide either a user ID or a channel ID.
    If you're using a mirrored channel, you have the option to specify the channel name as well."""
    TOO_MANY_JID = """Too many argument you must provide either a user JID or a channel id and not both """
    BOT_PARAM_CHECK = """If you're using the Zoom chatbot, it's essential to provide all the necessary bot parameters,
    including the botJID, bot_client_id, and bot_client_secret.
    you can find these values in the Zoom Chatbot app configuration"""
    OAUTH_PARAM_CHECK = """if you are using zoom APIs you must provide Oauth client_id and client_secret
    you can find this values in the Zoom Oauth Server-To-Server app configuration"""
    CLIENT: Zoom_Client
    SECRET_TOKEN: str
    MESSAGE_FOOTER = '\n**From Zoom**'
    MIRRORING_ENABLED: bool = False
    LONG_RUNNING: bool = False
    MIRROR_TYPE = 'mirrorEntry'
    CACHED_INTEGRATION_CONTEXT: dict
    CACHE_EXPIRY: float


    '''CLIENT CLASS'''


    class UserAgentFormatter(AccessFormatter):
        """This formatter extracts and includes the 'User-Agent' header information
        in the log messages."""

        def get_user_agent(self, scope: Dict) -> str:
            headers = scope.get('headers', [])
            user_agent_header = list(filter(lambda header: header[0].decode().lower() == 'user-agent', headers))
            user_agent = ''
            if len(user_agent_header) == 1:
                user_agent = user_agent_header[0][1].decode()
            return user_agent

        def format_message(self, record):
            """Include the 'User-Agent' header information in the log message.
            Args:
                record: The log record to be formatted.
            Returns:
                str: The formatted log message."""
            record_copy = copy(record)
            scope = record_copy.__dict__['scope']
            user_agent = self.get_user_agent(scope)
            record_copy.__dict__.update({'user_agent': user_agent})
            return super().formatMessage(record_copy)


    class Client(Zoom_Client):
        """ A client class that implements logic to authenticate with Zoom application. """

        def zoom_create_user(self, user_type_num: int, email: str, first_name: str, last_name: str):
            return self.error_handled_http_request(
                method='POST',
                url_suffix='users',
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data={
                    'action': 'create',
                    'user_info': {
                        'email': email,
                        'type': user_type_num,
                        'first_name': first_name,
                        'last_name': last_name}},
            )

        def zoom_list_users(self, page_size: int, status: str = "active",
                            next_page_token: str = None,
                            role_id: str = None, url_suffix: str = None,
                            page_number: int = None):
            return self.error_handled_http_request(
                method='GET',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    'status': status,
                    'page_size': page_size,
                    'page_number': page_number,
                    'next_page_token': next_page_token,
                    'role_id': role_id})

        def zoom_delete_user(self, user: str, action: str):
            return self.error_handled_http_request(
                method='DELETE',
                url_suffix='users/' + user,
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data={'action': action},
                resp_type='response',
                return_empty_response=True
            )

        def zoom_create_meeting(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='POST',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data=json_data)

        def zoom_meeting_get(self, meeting_id: str, occurrence_id: str | None = None,
                             show_previous_occurrences: bool | str = False):
            return self.error_handled_http_request(
                method='GET',
                url_suffix=f"/meetings/{meeting_id}",
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    "occurrence_id": occurrence_id,
                    "show_previous_occurrences": show_previous_occurrences
                })

        def zoom_meeting_list(self, user_id: str, next_page_token: str | None = None, page_size: int | str = 30,
                              type: str | int | None = None, page_number: int = None):
            return self.error_handled_http_request(
                method='GET',
                url_suffix=f"users/{user_id}/meetings",
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    'type': type,
                    'next_page_token': next_page_token,
                    'page_size': page_size,
                    'page_number': page_number
                })

        def zoom_fetch_recording(self, method: str, url_suffix: str = '', full_url: str = '',
                                 stream: bool = False, resp_type: str = 'json'):
            return self.error_handled_http_request(
                method=method,
                full_url=full_url,
                url_suffix=url_suffix,
                resp_type=resp_type,
                stream=stream,
                headers={'authorization': f'Bearer {self.access_token}'},
            )

        def zoom_list_channels(self, page_size: int, next_page_token: str = None, url_suffix: str = '',
                               page_number: int = 1):
            return self.error_handled_http_request(
                method='GET',
                url_suffix=f"chat/{url_suffix}",
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    'page_size': page_size,
                    'page_number': page_number,
                    'next_page_token': next_page_token}
            )

        def zoom_create_channel(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='POST',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data=json_data)

        def zoom_update_channel(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='PATCH',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data=json_data,
                resp_type='response',
                return_empty_response=True
            )

        def zoom_list_user_channels(self, user_id: str, page_size: int, next_page_token: str = None, url_suffix: str = '',
                                    page_number: int = None):
            return self.error_handled_http_request(
                method='GET',
                url_suffix=f"chat/{url_suffix}",
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    'user_id': user_id,
                    'page_size': page_size,
                    'page_number': page_number,
                    'next_page_token': next_page_token}
            )

        def zoom_delete_channel(self, url_suffix: str):
            return self.error_handled_http_request(
                method='DELETE',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                resp_type='response',
                return_empty_response=True
            )

        def zoom_invite_to_channel(self, members_json: str, url: str = None):
            return self.error_handled_http_request(
                method='POST',
                url_suffix=url,
                headers={'authorization': f'Bearer {self.access_token}'},
                json_data=members_json)

        def zoom_remove_from_channel(self, url_suffix: str = None):
            return self.error_handled_http_request(
                method='DELETE',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                resp_type='response',
                return_empty_response=True)

        def zoom_send_file(self, url_suffix: str, file_info: dict, json_data: dict):

            files = {'file': (file_info['name'], open(file_info['path'], 'rb'))}

            response = self.error_handled_http_request(
                method='POST',
                full_url=url_suffix,
                headers={'Authorization': f'Bearer {self.access_token}'},
                files=files,
                data=json_data
            )
            return response

        def zoom_upload_file(self, url_suffix: str, file_info: dict):
            files = {'file': (file_info['name'], open(file_info['path'], 'rb'))}
            return self._http_request('POST',
                                      headers={'Authorization': f'Bearer {self.access_token}'},
                                      files=files,
                                      full_url=url_suffix)

        def zoom_send_message(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='POST',
                url_suffix=url_suffix,
                json_data=json_data,
                headers={'authorization': f'Bearer {self.access_token}'}
            )

        def zoom_delete_message(self, url_suffix: str = None):
            return self.error_handled_http_request(
                method='DELETE',
                url_suffix=url_suffix,
                headers={'authorization': f'Bearer {self.access_token}'},
                resp_type='response',
                return_empty_response=True)

        def zoom_update_message(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='PUT',
                url_suffix=url_suffix,
                json_data=json_data,
                headers={'authorization': f'Bearer {self.access_token}'},
                return_empty_response=True
            )

        def zoom_list_user_messages(self, user_id: str, date_arg: datetime, from_arg: datetime, to_arg: datetime, page_size: int,
                                    next_page_token: str = None, url_suffix: str = None, page_number: int = None,
                                    to_contact: str = None,
                                    to_channel: str = None,
                                    include_deleted_and_edited_message: bool = False,
                                    search_type: str = None,
                                    search_key: str = None,
                                    exclude_child_message: bool = False):

            return self.error_handled_http_request(
                method='GET',
                url_suffix=f"chat/{url_suffix}",
                headers={'authorization': f'Bearer {self.access_token}'},
                params={
                    'user_id': user_id,
                    'page_size': page_size,
                    'page_number': page_number,
                    'next_page_token': next_page_token,
                    'to_contact': to_contact,
                    'to_channel': to_channel,
                    'date': date_arg,
                    'from': from_arg,
                    'to': to_arg,
                    'include_deleted_and_edited_message': include_deleted_and_edited_message,
                    'search_key': search_key,
                    'search_type': search_type,
                    'exclude_child_message': exclude_child_message}
            )

        def zoom_send_notification(self, url_suffix: str, json_data: dict):
            return self.error_handled_http_request(
                method='POST',
                url_suffix=url_suffix,
                json_data=json_data,
                headers={'authorization': f'Bearer {self.bot_access_token}'}
            )

        def zoom_get_admin_user_id_from_token(self):
            return self.error_handled_http_request(
                method='get',
                url_suffix='users/me',
                headers={'authorization': f'Bearer {self.access_token}'}
            )


    '''HELPER FUNCTIONS'''


    def next_expiry_time() -> float:
        """
        Returns:
            A float representation of a new expiry time with an offset of 5 seconds
        """
        return (datetime.now(timezone.utc) + timedelta(seconds=5)).timestamp()


    async def check_and_handle_entitlement(text: str, message_id: str, user_name: str) -> str:
        """
        Handles an entitlement message (a reply to a question)
        Args:
        Returns:
            If the message contains entitlement, return a reply.
        """
        integration_context = fetch_context(force_refresh=True)
        messages = integration_context.get('messages', [])
        reply = ''
        if not messages or not message_id:
            return reply
        messages = json.loads(messages)
        message_filter = list(filter(lambda q: q.get('message_id') == message_id, messages))
        if message_filter:
            message = message_filter[0]
            entitlement = message.get('entitlement')
            reply = message.get('reply', f'Thank you {user_name} for your response {text}.')
            guid, incident_id, task_id = extract_entitlement(entitlement)
            demisto.handleEntitlementForUser(incident_id, guid, user_name, text, task_id)
            message['remove'] = True
            set_to_integration_context_with_retries({'messages': messages}, OBJECTS_TO_KEYS, SYNC_CONTEXT)
        return reply


    def save_entitlement(entitlement, message_id, reply, expiry, default_response, to_jid):
        """
        Saves an entitlement

        Args:
            entitlement: The entitlement
            message_id: The message_id
            reply: The reply to send to the user.
            expiry: The question expiration date.
            default_response: The response to send if the question times out.
            to_jid: the user jid the message was sent to
        """
        integration_context = get_integration_context(SYNC_CONTEXT)
        messages = integration_context.get('messages', [])
        if messages:
            messages = json.loads(integration_context['messages'])
        messages.append({
            'message_id': message_id,
            'entitlement': entitlement,
            'reply': reply,
            'expiry': expiry,
            'sent': datetime.strftime(datetime.utcnow(), DATE_FORMAT),
            'default_response': default_response,
            'to_jid': to_jid
        })

        set_to_integration_context_with_retries({'messages': messages}, OBJECTS_TO_KEYS, SYNC_CONTEXT)


    def extract_entitlement(entitlement: str) -> tuple[str, str, str]:
        """
        Extracts entitlement components from an entitlement string
        Args:
            entitlement: The entitlement itself
            text: The actual reply text

        Returns:
            Entitlement components
        """
        parts = entitlement.split('@')
        if len(parts) < 2:
            raise DemistoException("Entitlement cannot be parsed")
        guid = parts[0]
        id_and_task = parts[1].split('|')
        incident_id = id_and_task[0]
        task_id = ''

        if len(id_and_task) > 1:
            task_id = id_and_task[1]

        return guid, incident_id, task_id


    @app.on_event("startup")
    @repeat_every(seconds=60, wait_first=True)
    async def check_for_unanswered_messages():
        # demisto.debug('check for unanswered messages')
        integration_context = fetch_context()
        messages = integration_context.get('messages')
        if messages:
            messages = json.loads(messages)
            now = datetime.utcnow()
            updated_messages = []

            for message in messages:
                if message.get('expiry'):
                    # Check if the question expired - if it did, answer it with the default response
                    # and remove it
                    expiry = datetime.strptime(message['expiry'], DATE_FORMAT)
                    if expiry < now:
                        demisto.debug(f"message expired: {message}")
                        _ = await answer_question(message.get('default_response'), message, email='')
                        updated_messages.append(message)
                        continue
                updated_messages.append(message)
            if updated_messages:
                set_to_integration_context_with_retries({'messages': messages}, OBJECTS_TO_KEYS, SYNC_CONTEXT)


    def run_long_running(port: int, is_test: bool = False):
        while True:
            certificate = demisto.params().get('certificate', '')
            private_key = demisto.params().get('key', '')

            certificate_path = ''
            private_key_path = ''
            try:
                ssl_args = {}

                if certificate and private_key:
                    certificate_file = NamedTemporaryFile(delete=False)
                    certificate_path = certificate_file.name
                    certificate_file.write(bytes(certificate, 'utf-8'))
                    certificate_file.close()
                    ssl_args['ssl_certfile'] = certificate_path

                    private_key_file = NamedTemporaryFile(delete=False)
                    private_key_path = private_key_file.name
                    private_key_file.write(bytes(private_key, 'utf-8'))
                    private_key_file.close()
                    ssl_args['ssl_keyfile'] = private_key_path

                    demisto.debug('Starting HTTPS Server')
                else:
                    demisto.debug('Starting HTTP Server')

                integration_logger = IntegrationLogger()
                integration_logger.buffering = False
                log_config = dict(uvicorn.config.LOGGING_CONFIG)
                log_config['handlers']['default']['stream'] = integration_logger
                log_config['handlers']['access']['stream'] = integration_logger
                log_config['formatters']['access'] = {
                    '()': UserAgentFormatter,
                    'fmt': '%(levelprefix)s %(client_addr)s - "%(request_line)s" %(status_code)s "%(user_agent)s"'
                }
                uvicorn.run(app, host='0.0.0.0', port=port, log_config=log_config, **ssl_args)
            except Exception as e:
                demisto.error(f'An error occurred in the long running loop: {str(e)} - {format_exc()}')
                demisto.updateModuleHealth(f'An error occurred: {str(e)}')
            finally:
                if certificate_path:
                    os.unlink(certificate_path)
                if private_key_path:
                    os.unlink(private_key_path)
                time.sleep(5)


    def run_log_running(port: int, is_test: bool = False):
        while True:
            try:
                demisto.debug('Starting Server')
                integration_logger = IntegrationLogger()
                integration_logger.buffering = False
                log_config = dict(uvicorn.config.LOGGING_CONFIG)
                log_config['handlers']['default']['stream'] = integration_logger
                log_config['handlers']['access']['stream'] = integration_logger
                log_config['formatters']['access'] = {
                    '()': UserAgentFormatter,
                    'fmt': '%(levelprefix)s %(client_addr)s - "%(request_line)s" %(status_code)s "%(user_agent)s"'
                }
                uvicorn.run(app, host='0.0.0.0', port=port, log_config=log_config)
                if is_test:
                    time.sleep(5)
                    return 'ok'
            except Exception as e:
                demisto.error(f'An error occurred in the long running loop: {str(e)} - {format_exc()}')
                demisto.updateModuleHealth(f'An error occurred: {str(e)}')
            finally:
                time.sleep(5)


    async def zoom_send_notification_async(client, url_suffix, json_data_all):
        client.zoom_send_notification(url_suffix, json_data_all)


    async def process_entitlement_reply(
        entitlement_reply: str,
        account_id: str,
        robot_jid: str,
        to_jid: str | None = None,
        user_name: str | None = None,
        action_text: str | None = None,
    ):
        """
        Triggered when an entitlement reply is found, this function will update the original message with the reply message.
        :param entitlement_reply: str: The text to update the asking question with.
        :param user_name: str: name of the user who answered the entitlement
        :param action_text: str: The text attached to the button, used for string replacement.
        :param toJid: str: The Jid of where the question exists.
        :param accountId: str: Zoom account ID
        :param robotJid: str: Zoom BOT JID
        :return: None
        """
        if '{user}' in entitlement_reply:
            entitlement_reply = entitlement_reply.replace('{user}', str(user_name))
        if '{response}' in entitlement_reply and action_text:
            entitlement_reply = entitlement_reply.replace('{response}', str(action_text))

        url_suffix = '/im/chat/messages'
        content_json = {
            "content": {
                "body": [
                    {
                        "type": "message",
                        "text": entitlement_reply
                    }
                ]
            },
            "to_jid": to_jid,
            "robot_jid": robot_jid,
            "account_id": account_id
        }
        await zoom_send_notification_async(CLIENT, url_suffix, content_json)


    async def answer_question(text: str, question: dict, email: str = ''):
        entitlement = question.get('entitlement', '')
        to_jid = question.get('to_jid')
        guid, incident_id, task_id = extract_entitlement(entitlement)
        try:
            demisto.handleEntitlementForUser(incident_id, guid, email, text, task_id)
            account_id = CLIENT.account_id
            bot_jid = CLIENT.bot_jid
            if account_id and bot_jid:
                _ = await process_entitlement_reply(text, account_id, bot_jid, to_jid)
        except Exception as e:
            demisto.error(f'Failed handling entitlement {entitlement}: {str(e)}')
        question['remove'] = True
        return incident_id


    async def handle_text_received_from_zoom(investigation_id: str, text: str, operator_email: str, operator_name: str):
        """
        Handles text received from Zoom

        Args:
            investigation_id: The mirrored investigation ID
            text: The received text
            operator_email: The sender email
            operator_name: The sender name
        """
        if text:
            demisto.addEntry(id=investigation_id,
                             entry=text,
                             username=operator_name,
                             email=operator_email,
                             footer=MESSAGE_FOOTER
                             )


    async def handle_listen_error(error: str):
        """
        Logs an error and updates the module health accordingly.

        Args:
            error: The error string.
        """
        demisto.error(error)
        demisto.updateModuleHealth(error)


    async def handle_mirroring(payload):
        """
        handle messages from the Zoom webhook that have been identified as possible mirrored messages
        If we find one, we will update the mirror object and send
        the message to the corresponding investigation's war room as an entry.
        :param payload: str: The request payload from zoom
        :return: None
        """
        channel_id = payload.get("object", {}).get("channel_id")
        if not channel_id:
            return
        integration_context = fetch_context()
        if not integration_context or 'mirrors' not in integration_context:
            return
        mirrors = json.loads(integration_context['mirrors'])
        mirror_filter = list(filter(lambda m: m['channel_id'] == channel_id, mirrors))
        if not mirror_filter:
            return
        for mirror in mirror_filter:
            if mirror['mirror_direction'] == 'FromDemisto' or mirror['mirror_type'] == 'none':
                return
            if not mirror['mirrored']:
                # In case the investigation is not mirrored yet
                mirror = mirrors.pop(mirrors.index(mirror))
                if mirror['mirror_direction'] and mirror['mirror_type']:
                    investigation_id = mirror['investigation_id']
                    mirror_type = mirror['mirror_type']
                    auto_close = mirror['auto_close']
                    direction = mirror['mirror_direction']
                    demisto.mirrorInvestigation(investigation_id,
                                                f'{mirror_type}:{direction}', auto_close)
                    mirror['mirrored'] = True
                    mirrors.append(mirror)
                    set_to_integration_context_with_retries({'mirrors': mirrors},
                                                            OBJECTS_TO_KEYS, SYNC_CONTEXT)
            message = payload["object"]["message"]
            demisto.info(f"payload:{payload}")
            operator_email = payload["operator"]
            operator_name = zoom_get_user_name_by_email(CLIENT, operator_email)
            investigation_id = mirror['investigation_id']
            await handle_text_received_from_zoom(investigation_id, message, operator_email, operator_name)


    async def event_url_validation(payload):
        """ Verify the authenticity of a token
        Args:
            payload : request from Zoom
        Returns:
            json_res: A dictionary containing the 'plainToken' and its corresponding 'encryptedToken' (HMAC-SHA256 signature).
        """
        plaintoken = payload.get('plainToken')
        hash_object = hmac.new(SECRET_TOKEN.encode('utf-8'), msg=plaintoken.encode('utf-8'), digestmod=hashlib.sha256)
        expected_signature = hash_object.hexdigest()
        json_res = {
            "plainToken": plaintoken,
            "encryptedToken": expected_signature
        }
        return json_res


    @app.post('/')
    async def handle_zoom_response(request: Request, credentials: HTTPBasicCredentials = Depends(basic_auth),
                                   token: APIKey = Depends(token_auth)):
        """handle any response that came from Zoom app
        Args:
            request : zoom request
        Returns:
            JSONResponse:response to zoom
        """
        request = await request.json()
        demisto.debug(request)
        credentials_param = demisto.params().get('credentials')
        auth_failed = False
        v_token = demisto.params().get('verification_token', {}).get('password')
        if not str(token).startswith('Basic') and v_token:
            if token != v_token:
                auth_failed = True

        elif credentials and credentials_param and (username := credentials_param.get('identifier')):
            password = credentials_param.get('password', '')
            if not compare_digest(credentials.username, username) or not compare_digest(credentials.password, password):
                auth_failed = True
        if auth_failed:
            demisto.debug('Authorization failed')
            return Response(status_code=status.HTTP_401_UNAUTHORIZED, content='Authorization failed.')

        event_type = request['event']
        payload = request['payload']
        try:
            if event_type == 'endpoint.url_validation' and SECRET_TOKEN:
                res = await event_url_validation(payload)
                return JSONResponse(content=res)

            elif event_type == 'interactive_message_actions':
                if 'actionItem' in payload:
                    action = payload['actionItem']['value']
                elif 'selectedItems' in payload:
                    action = payload['selectedItems'][0]['value']
                else:
                    return Response(status_code=status.HTTP_400_BAD_REQUEST)
                message_id = payload['messageId']
                account_id = payload['accountId']
                robot_jid = payload['robotJid']
                to_jid = payload['toJid']
                user_name = payload['userName']
                entitlement_reply = await check_and_handle_entitlement(action, message_id, user_name)
                if entitlement_reply:
                    await process_entitlement_reply(entitlement_reply, account_id, robot_jid, to_jid, user_name, action)
                    demisto.updateModuleHealth("")
                demisto.debug(f"Action {action} was clicked on message id {message_id}")
                return Response(status_code=status.HTTP_200_OK)
            elif event_type == "chat_message.sent" and MIRRORING_ENABLED:
                await handle_mirroring(payload)
                return Response(status_code=status.HTTP_200_OK)
            else:
                return Response(status_code=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            await handle_listen_error(f'An error occurred while handling a response from Zoom: {e}')


    def test_module(client: Client):
        """Tests connectivity with the client.
        Takes as an argument all client arguments to create a new client
        """
        try:
            if MIRRORING_ENABLED and (not LONG_RUNNING or not SECRET_TOKEN or not client.bot_client_id or not
                                      client.bot_client_secret or not client.bot_jid):
                raise DemistoException("""Mirroring is enabled, however long running is disabled
    or the necessary bot authentication parameters are missing.
    For mirrors to work correctly, long running must be enabled and you must provide all
    the zoom-bot following parameters:
    secret token,
    Bot JID,
    bot client id and secret id""")
            client.zoom_list_users(page_size=1, url_suffix="users")
            if client.bot_access_token:
                json_data = {
                    "robot_jid": client.bot_jid,
                    "to_jid": "foo@conference.xmpp.zoom.us",
                    "account_id": client.account_id,
                    "content": {
                        "head": {
                            "text": "hi"
                        }
                    }
                }
                client.zoom_send_notification(url_suffix='/im/chat/messages', json_data=json_data)
        except DemistoException as e:
            error_message = e.message
            if 'Invalid access token' in error_message:
                error_message = INVALID_CREDENTIALS
            elif "The Token's Signature resulted invalid" in error_message:
                error_message = INVALID_API_SECRET
            elif 'Invalid client_id or client_secret' in error_message:
                error_message = INVALID_ID_OR_SECRET
            elif 'No channel or user can be found with the given to_jid.' in error_message:
                return 'ok'
            elif 'Invalid authorization token.' in error_message:
                error_message = INVALID_TOKEN
            elif 'No Chatbot can be found with the given robot_jid value.' in error_message:
                error_message = INVALID_BOT_ID
            elif 'Invalid robot_jid value specified in the Request Body.' in error_message:
                error_message = INVALID_BOT_ID
            else:
                error_message = f'Problem reaching Zoom API, check your credentials. Error message: {error_message}'
            return error_message
        return 'ok'


    def remove_None_values_from_dict(dict_to_reduce: Dict[str, Any]):
        """
        Removes None values (but not False values) from a given dict and from the nested dicts in it.
        """
        reduced_dict = {}
        for key, value in dict_to_reduce.items():
            if value is not None:
                if isinstance(value, dict):
                    reduced_nested_dict = remove_None_values_from_dict(value)
                    if reduced_nested_dict:
                        reduced_dict[key] = reduced_nested_dict
                else:
                    reduced_dict[key] = value

        return reduced_dict


    def check_start_time_format(start_time):
        """checking if the time format is a full time format"""
        expected_format = "%Y-%m-%dT%H:%M:%S"
        if start_time.endswith("Z"):
            expected_format += "%z"
        try:
            datetime.strptime(start_time, expected_format)
        except ValueError as e:
            raise DemistoException(WRONG_TIME_FORMAT) from e


    def manual_list_user_pagination(client: Client, next_page_token: str | None,
                                    limit: int, status: str, role_id: str | None):
        res = []
        page_size = min(limit, MAX_RECORDS_PER_PAGE)
        while limit > 0 and next_page_token != '':
            response = client.zoom_list_users(page_size=page_size, status=status,
                                              next_page_token=next_page_token,
                                              role_id=role_id, url_suffix="users")
            next_page_token = response.get("next_page_token")

            res.append(response)
            limit -= MAX_RECORDS_PER_PAGE
        return res


    def manual_list_channel_pagination(client: Client, next_page_token: str | None,
                                       limit: int, url_suffix: str):
        res = {}
        page_size = min(limit, MAX_RECORDS_PER_PAGE)
        while limit > 0:
            response = client.zoom_list_channels(page_size=page_size,
                                                 next_page_token=next_page_token,
                                                 url_suffix=url_suffix)
            next_page_token = response.get("next_page_token")

            res.update(response)
            limit -= MAX_RECORDS_PER_PAGE
        return res


    def manual_list_user_channel_pagination(client: Client, user_id: str, next_page_token: str | None,
                                            limit: int, url_suffix: str):
        res = {}
        page_size = min(limit, MAX_RECORDS_PER_PAGE)
        while limit > 0:
            response = client.zoom_list_user_channels(user_id=user_id,
                                                      page_size=page_size,
                                                      next_page_token=next_page_token,
                                                      url_suffix=url_suffix)
            next_page_token = response.get("next_page_token")

            res.update(response)
            limit -= MAX_RECORDS_PER_PAGE
        return res


    def manual_meeting_list_pagination(client: Client, user_id: str, next_page_token: str | None,
                                       limit: int, type: str | int | None):
        res = []
        page_size = min(limit, MAX_RECORDS_PER_PAGE)
        while limit > 0 and next_page_token != '':
            response = client.zoom_meeting_list(user_id=user_id,
                                                next_page_token=next_page_token,
                                                page_size=page_size,
                                                type=type)
            next_page_token = response.get("next_page_token")
            res.append(response)
            # subtract what i already got
            limit -= MAX_RECORDS_PER_PAGE
        return res


    def remove_extra_info_list_users(limit, raw_data):
        """_summary_
        Due to the fact that page_size must be const,
        Extra information may be provided

        Args:
            limit (int): the number of records the user asked for
            raw_data (dict):the entire response from the pagination function
        """
        all_info = []
        for page in raw_data:
            users_info = page.get("users", [])
            for user in users_info:
                all_info.append(user)
                if len(all_info) >= limit:
                    return all_info
        return all_info


    def remove_extra_info_list(name, limit, raw_data):
        """_summary_
        Due to the fact that page_size must be const,
        Extra information may be provided
        Args:
            limit (int): the number of records the user asked for
            raw_data (dict):the entire response from the pagination function
        """
        all_info = []
        channel_info = raw_data.get(name, [raw_data])
        for channel in channel_info:
            all_info.append(channel)
            if len(all_info) >= limit:
                return all_info
        return all_info


    def remove_extra_info_meeting_list(limit, raw_data):
        """
        Due to the fact that page_size must be const,
        Extra information may be provided to me, such as:
        In the case of limit = 301, manual_meeting_list_pagination will return 600 meetings (MAX_RECORDS * 2),
        The last 299 must be removed.

        Args:
            limit (int): the number of records the user asked for
            raw_data (dict):the entire response from the pagination function
        """
        all_info = []
        for page in raw_data:
            meetings = page.get("meetings")
            for meeting in meetings:
                all_info.append(meeting)
                if len(all_info) >= limit:
                    return all_info
        return all_info


    '''FORMATTING FUNCTIONS'''


    def zoom_list_users_command(client, **args) -> CommandResults:

        # PREPROCESSING
        client = client
        page_size = arg_to_number(args.get('page_size', 30))
        user_id = args.get('user_id')
        status = args.get('status', "active")
        next_page_token = args.get('next_page_token')
        role_id = args.get('role_id')
        limit = arg_to_number(args.get('limit'))
        page_number = arg_to_number(args.get('page_number', 1))

        url_suffix = f'users/{user_id}' if user_id else 'users'

        if limit:
            if "page_size" in args or "page_number" in args or next_page_token or user_id:
                # arguments collision
                raise DemistoException(LIMIT_AND_EXTRA_ARGUMENTS)
            else:
                # multiple requests are needed
                raw_data = manual_list_user_pagination(client=client, next_page_token=next_page_token,
                                                       limit=limit, status=status, role_id=role_id)

                minimal_needed_info = remove_extra_info_list_users(limit, raw_data)

                md = tableToMarkdown('Users', minimal_needed_info, ['id', 'email',
                                                                    'type', 'pmi', 'verified', 'created_at', 'status', 'role_id'])
                md += '\n' + tableToMarkdown('Metadata', [raw_data][0][0], ['total_records'])
                raw_data = raw_data[0]
        else:
            # only one request is needed
            raw_data = client.zoom_list_users(page_size=page_size, status=status,                      # type: ignore[arg-type]
                                              next_page_token=next_page_token,
                                              role_id=role_id, url_suffix=url_suffix, page_number=page_number)
            # parsing the data according to the different given arguments
            if user_id:
                md = tableToMarkdown('User', [raw_data], ['id', 'email',
                                                          'type', 'pmi', 'verified', 'created_at', 'status', 'role_id'])
            else:
                md = tableToMarkdown('Users', raw_data.get("users"), ['id', 'email',
                                                                      'type', 'pmi', 'verified', 'created_at', 'status', 'role_id'])
                md += '\n' + tableToMarkdown('Metadata', [raw_data], ['page_count', 'page_number',
                                                                      'page_size', 'total_records', 'next_page_token'])
        return CommandResults(
            outputs_prefix='Zoom',
            readable_output=md,
            outputs={
                'User': raw_data.get('users'),
                'Metadata': {'Count': raw_data.get('page_count'),
                             'Number': raw_data.get('page_number'),
                             'Size': raw_data.get('page_size'),
                             'Total': raw_data.get('total_records')}
            },
            raw_response=raw_data
        )


    def zoom_create_user_command(client, **args) -> CommandResults:
        client = client
        user_type = args.get('user_type', "")
        email = args.get('email')
        first_name = args.get('first_name')
        last_name = args.get('last_name')
        user_type_num = USER_TYPE_MAPPING.get(user_type)
        raw_data = client.zoom_create_user(user_type_num, email, first_name, last_name)
        return CommandResults(
            outputs_prefix='Zoom.User',
            readable_output=f"User created successfully with ID: {raw_data.get('id')}",
            outputs=raw_data,
            raw_response=raw_data
        )


    def zoom_delete_user_command(client, **args) -> CommandResults:
        client = client
        user = args.get('user')
        action = args.get("action")
        client.zoom_delete_user(user, action)
        return CommandResults(
            readable_output=f'User {user} was deleted successfully',
        )


    def zoom_create_meeting_command(client, **args) -> CommandResults:
        client = client
        user_id = args.get('user')
        topic = args.get('topic', "")
        host_video = argToBoolean(args.get('host_video', True))
        join_before_host_time = args.get('join_before_host_time')
        start_time = args.get('start_time')
        timezone = args.get('timezone', "")
        type = args.get('type', "Instant")
        auto_record_meeting = args.get('auto_record_meeting')
        encryption_type = args.get('encryption_type')
        join_before_host = argToBoolean(args.get('join_before_host', False))
        meeting_authentication = argToBoolean(args.get('meeting_authentication', False))
        waiting_room = argToBoolean(args.get('waiting_room', False))
        end_date_time = args.get('end_date_time')
        end_times = arg_to_number(args.get('end_times', 1))
        monthly_day = arg_to_number(args.get('monthly_day', 1))
        monthly_week = arg_to_number(args.get('monthly_week'))
        monthly_week_day = arg_to_number(args.get('monthly_week_day'))
        repeat_interval = arg_to_number(args.get('repeat_interval'))
        recurrence_type = args.get('recurrence_type', "")
        weekly_days = arg_to_number(args.get('weekly_days', 1))

        num_type: int | None = MEETING_TYPE_NUM_MAPPING.get(type)

        # argument checking
        if type == INSTANT and (timezone or start_time):
            raise DemistoException(INSTANT_AND_TIME)

        if join_before_host_time and not join_before_host:
            raise DemistoException(JBH_TIME_AND_NO_JBH)

        if waiting_room and join_before_host:
            raise DemistoException(WAITING_ROOM_AND_JBH)

        if args.get("end_times") and end_date_time:
            raise DemistoException(END_TIMES_AND_END_DATE_TIME)

        if type != RECURRING_WITH_TIME and any((end_date_time, args.get("end_times"), args.get("monthly_day"),
                                                monthly_week, monthly_week_day, repeat_interval, args.get("weekly_days"))):
            raise DemistoException(NOT_RECURRING_WITH_RECURRING_ARGUMENTS)

        if type == RECURRING_WITH_TIME and recurrence_type != "Monthly" and any((args.get("monthly_day"),
                                                                                 monthly_week, monthly_week_day)):
            raise DemistoException(NOT_MONTHLY_AND_MONTHLY_ARGUMENTS)

        if (type == RECURRING_WITH_TIME and recurrence_type == "Monthly"
                and not (monthly_week and monthly_week_day) and not args.get("monthly_day")):
            raise DemistoException(MONTHLY_RECURRING_MISIING_ARGUMENTS)

        if type == RECURRING_WITH_TIME and recurrence_type != "Weekly" and args.get("weekly_days"):
            raise DemistoException(NOT_WEEKLY_WITH_WEEKLY_ARGUMENTS)

        if type == RECURRING_WITH_TIME and not recurrence_type:
            raise DemistoException(RECURRING_MISSING_ARGUMENTS)

        # converting separately after the argument checking, because 0 as an int is equaled to false
        join_before_host_time = arg_to_number(join_before_host_time)

        if start_time:
            check_start_time_format(start_time)

        json_all_data: Dict[str, Union[Any, None, int]] = {}

        # special section for recurring meeting with fixed time
        if type == RECURRING_WITH_TIME:
            recurrence_type_num = MONTHLY_RECURRING_TYPE_MAPPING.get(recurrence_type)
            json_all_data.update({"recurrence": {
                "end_date_time": end_date_time,
                "end_times": end_times,
                "monthly_day": monthly_day,
                "monthly_week": monthly_week,
                "monthly_week_day": monthly_week_day,
                "repeat_interval": repeat_interval,
                "type": recurrence_type_num,
                "weekly_days": weekly_days
            }})
        json_all_data.update({
            "settings": {
                "auto_recording": auto_record_meeting,
                "encryption_type": encryption_type,
                "host_video": host_video,
                "jbh_time": join_before_host_time,
                "join_before_host": join_before_host,
                "meeting_authentication": meeting_authentication,
                "waiting_room": waiting_room
            },
            "start_time": start_time,
            "timezone": timezone,
            "type": num_type,
            "topic": topic,
        })
        # remove all keys with val of None
        json_data = remove_None_values_from_dict(json_all_data)
        url_suffix = f"users/{user_id}/meetings"
        # call the API
        raw_data = client.zoom_create_meeting(url_suffix=url_suffix, json_data=json_data)
        # parsing the response
        if type == "Recurring meeting with fixed time":
            raw_data.update({'start_time': raw_data.get("occurrences")[0].get('start_time')})
            raw_data.update({'duration': raw_data.get("occurrences")[0].get('duration')})

        md = tableToMarkdown('Meeting details', [raw_data], ['uuid', 'id', 'host_id', 'host_email', 'topic',
                                                             'type', 'status', 'start_time', 'duration',
                                                             'timezone', 'created_at', 'start_url', 'join_url'
                                                             ])

        # removing passwords from the response#
        safe_raw_data = raw_data
        for sensitive_info in ["password", "pstn_password", "encrypted_password", "h323_password"]:
            safe_raw_data.pop(sensitive_info, None)
        return CommandResults(
            outputs_prefix='Zoom.Meeting',
            readable_output=md,
            outputs=safe_raw_data,
            raw_response=raw_data
        )


    def zoom_fetch_recording_command(client: Client, **args):
        # preprocessing
        results = []
        meeting_id = args.get('meeting_id')
        delete_after = argToBoolean(args.get('delete_after'))
        client = client

        data = client.zoom_fetch_recording(
            method='GET',
            url_suffix=f'meetings/{meeting_id}/recordings'
        )
        recording_files = data.get('recording_files')
        # Getting the audio and video files which are contained in every recording.
        for file in recording_files:
            download_url = file.get('download_url')
            try:
                # download the file
                demisto.debug(f"Trying to download the files of meeting {meeting_id}")
                record = client.zoom_fetch_recording(
                    method='GET',
                    full_url=download_url,
                    resp_type='response',
                    stream=True
                )
                file_type = file.get('file_type')
                file_type_as_literal = FILE_TYPE_MAPPING.get(file_type)
                # save the file
                filename = f'recording_{meeting_id}_{file.get("id")}.{file_type}'
                with open(filename, 'wb') as f:
                    # Saving the content of the file locally.
                    record.raw.decode_content = True
                    shutil.copyfileobj(record.raw, f)

                results.append(file_result_existing_file(filename))
                results.append(CommandResults(
                    readable_output=f"The {file_type_as_literal} file {filename} was downloaded successfully"))

                if delete_after:
                    try:
                        # delete the file from the cloud
                        demisto.debug(f"Trying to delete the file {filename}")
                        client.zoom_fetch_recording(
                            method='DELETE',
                            url_suffix=f'meetings/{meeting_id}/recordings/{file["id"]}',
                            resp_type='response'
                        )
                        results.append(CommandResults(
                            readable_output=f"The {file_type_as_literal} file {filename} was successfully removed from the cloud."))
                    except DemistoException as exp:
                        results.append(CommandResults(
                            readable_output=f"Failed to delete file {filename}. {exp}"))

            except DemistoException as exp:
                raise DemistoException(
                    f'Unable to download recording for meeting {meeting_id}: {exp}')

        return results


    def zoom_meeting_get_command(client, **args) -> CommandResults:
        client = client
        meeting_id = args.get('meeting_id')
        occurrence_id = args.get('occurrence_id')
        show_previous_occurrences = argToBoolean(args.get('show_previous_occurrences'))

        raw_data = client.zoom_meeting_get(meeting_id, occurrence_id, show_previous_occurrences)
        # parsing the response
        md = tableToMarkdown('Meeting details', raw_data, ['uuid', 'id', 'host_id', 'host_email', 'topic',
                                                           'type', 'status', 'start_time', 'duration',
                                                           'timezone', 'agenda', 'created_at', 'start_url', 'join_url',
                                                           ])
        # removing passwords from the response#
        safe_raw_data = raw_data
        for sensitive_info in ["password", "pstn_password", "encrypted_password", "h323_password"]:
            safe_raw_data.pop(sensitive_info, None)
        return CommandResults(
            outputs_prefix='Zoom.Meeting',
            readable_output=md,
            outputs_key_field="id",
            outputs=safe_raw_data,
            raw_response=raw_data
        )


    def zoom_meeting_list_command(client, **args) -> CommandResults:
        client = client
        user_id = args.get('user_id', '')
        next_page_token = args.get('next_page_token')
        page_size = arg_to_number(args.get('page_size', 30))
        limit = arg_to_number(args.get('limit'))
        type = args.get('type')
        page_number = arg_to_number(args.get('page_number', 1))

        if limit:
            if "page_size" in args or next_page_token or 'page_number' in args:
                # arguments collision
                raise DemistoException(LIMIT_AND_EXTRA_ARGUMENTS_MEETING_LIST)
            else:
                # multiple request are needed
                raw_data = manual_meeting_list_pagination(client=client, user_id=user_id, next_page_token=next_page_token,
                                                          limit=limit, type=type)

                minimal_needed_info = remove_extra_info_meeting_list(limit=limit, raw_data=raw_data)

                md = tableToMarkdown("Meeting list", minimal_needed_info, ['uuid', 'id',
                                                                           'host_id', 'topic', 'type', 'start time', 'duration',
                                                                           'timezone', 'created_at', 'join_url'
                                                                           ])
                md += "\n" + tableToMarkdown('Metadata', [raw_data][0][0], ['total_records'])
                raw_data = raw_data[0]

        else:
            # one request in needed
            raw_data = client.zoom_meeting_list(user_id=user_id, next_page_token=next_page_token,
                                                page_size=page_size, type=type, page_number=page_number)
            # parsing the data
            md = tableToMarkdown("Meeting list", raw_data.get("meetings"), ['uuid', 'id',
                                                                            'host_id', 'topic', 'type', 'start_time', 'duration',
                                                                            'timezone', 'created_at', 'join_url'
                                                                            ])
            md += "\n" + tableToMarkdown('Metadata', [raw_data], ['next_page_token', 'page_size', 'page_number', 'total_records'])

        return CommandResults(
            outputs_prefix='Zoom',
            readable_output=md,
            # keeping the syntax of the output of the previous version
            outputs={
                'Meeting': raw_data,
                'Metadata': {'Size': raw_data.get('page_size'),
                             'Total': raw_data.get('total_records')}
            },
            raw_response=raw_data
        )


    def check_authentication_type_parameters(api_key: str, api_secret: str,
                                             # checking if the user entered extra parameters
                                             # at the configuration level
                                             account_id: str, client_id: str, client_secret: str):
        if any((api_key, api_secret)) and any((account_id, client_id, client_secret)):
            raise DemistoException(EXTRA_PARAMS)


    def check_authentication_bot_parameters(bot_Jid: str, client_id: str, client_secret: str):
        """check authentication parameters that both client_id, secret_id, bot_Jid are provided or none of them"""
        if (bot_Jid and client_id and client_secret) or (not bot_Jid and not client_id and not client_secret):
            return
        else:
            raise DemistoException(BOT_PARAM_CHECK)


    def check_authentication_parameters(client_id: str, client_secret: str):
        """check authentication parameters that both client_id and secret are provided"""
        if (client_id and client_secret) or (not client_id and not client_secret):
            return
        else:
            raise DemistoException(OAUTH_PARAM_CHECK)


    def zoom_list_account_public_channels_command(client, **args) -> CommandResults:
        """
        Lists public channels associated with a Zoom account.
        """
        # PREPROCESSING
        client = client
        page_size = arg_to_number(args.get('page_size', 50))
        channel_id = args.get('channel_id')
        next_page_token = args.get('next_page_token')
        limit = arg_to_number(args.get('limit'))
        page_number = arg_to_number(args.get('page_number', 1))

        url_suffix = f'channels/{channel_id}' if channel_id else 'channels'

        if limit:
            if "page_size" in args or "page_number" in args or next_page_token or channel_id:
                # arguments collision
                raise DemistoException(LIMIT_AND_EXTRA_ARGUMENTS)
            else:
                # multiple requests are needed
                raw_data = manual_list_channel_pagination(
                    client=client, next_page_token=next_page_token, limit=limit, url_suffix=url_suffix)

                data = remove_extra_info_list('channels', limit, raw_data)
                token = raw_data.get('next_page_token', None)
        else:
            # only one request is needed
            raw_data = client.zoom_list_channels(page_size=page_size, next_page_token=next_page_token,
                                                 url_suffix=url_suffix, page_number=page_number)
            # parsing the data according to the different given arguments
            data = [raw_data] if channel_id else raw_data.get("channels")
            token = raw_data.get('next_page_token', None)
        outputs = []
        for i in data:
            outputs.append({'Channel JID': i.get('jid'),
                            'Channel ID': i.get('id'),
                            'Channel name': i.get('name'),
                            'Channel type': i.get('type'),
                            'Channel url': i.get('channel_url')})

        md = tableToMarkdown('Channels', outputs, removeNull=True)
        md += '\n' + f'Channels Next Token: {token}'

        return CommandResults(
            outputs_prefix='Zoom.Channel',
            readable_output=md,
            outputs={**raw_data,
                     'ChannelsNextToken': token},
            raw_response=raw_data
        )


    def zoom_list_user_channels_command(client, **args) -> CommandResults:
        """
        Lists channels associated with a specific Zoom user.
        """
        # PREPROCESSING
        client = client
        page_size = arg_to_number(args.get('page_size', 50))
        channel_id = args.get('channel_id')
        user_id = args.get('user_id', '')
        next_page_token = args.get('next_page_token')
        limit = arg_to_number(args.get('limit'))
        page_number = arg_to_number(args.get('page_number', 1))

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        data = []
        url_suffix = f'users/{user_id}/channels/{channel_id}' if channel_id else f'users/{user_id}/channels'
        if limit:
            if "page_size" in args or "page_number" in args or next_page_token:
                # arguments collision
                raise DemistoException(LIMIT_AND_EXTRA_ARGUMENTS)
            else:
                # multiple requests are needed
                raw_data = manual_list_user_channel_pagination(client=client, user_id=user_id,
                                                               next_page_token=next_page_token, limit=limit,
                                                               url_suffix=url_suffix)
                data = remove_extra_info_list('channels', limit, raw_data)
                token = raw_data.get('next_page_token', None)
        else:
            # only one request is needed
            raw_data = client.zoom_list_user_channels(user_id=user_id, page_size=page_size,
                                                      next_page_token=next_page_token, url_suffix=url_suffix,
                                                      page_number=page_number)
            # parsing the data according to the different given arguments
            data = [raw_data] if channel_id else raw_data.get("channels")
            token = raw_data.get('next_page_token', None)
        outputs = []
        for i in data:
            outputs.append({'User id': user_id,
                            'Channel ID': i.get('id'),
                            'channel JID': i.get('jid'),
                            'Channel name': i.get('name'),
                            'Channel type': i.get('type'),
                            'Channel url': i.get('channel_url')})
        md = tableToMarkdown('Channels', outputs)

        return CommandResults(
            outputs_prefix='Zoom.Channel',
            outputs_key_field='id',
            readable_output=md,
            outputs={**raw_data,
                     'UserChannelsNextToken': token},
            raw_response=raw_data
        )


    def zoom_create_channel_command(client, **args) -> CommandResults:
        """
            Create a new zoom channel
        """
        client = client
        user_id = args.get('user_id')
        member_emails = argToList(args.get('member_emails'))
        add_member_permissions = args.get('add_member_permissions', None)
        add_member_permissions_num = MEMBER_PERMISSIONS_MAPPING.get(add_member_permissions)
        posting_permissions = args.get('posting_permissions', None)
        posting_permissions_num = POSTING_PERMISSIONS_MAPPING.get(posting_permissions)
        new_members_can_see_prev_msgs = args.get('new_members_can_see_prev_msgs', True)
        channel_name = args.get('channel_name')
        channel_type = args.get('channel_type', None)
        channel_type_num = CHANNEL_TYPE_MAPPING.get(channel_type)
        json_all_data = {}
        email_json = [{"email": email} for email in member_emails]

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)
        # special section for recurring meeting with fixed time
        json_all_data.update({
            "channel_settings": {
                "add_member_permissions": add_member_permissions_num,
                "new_members_can_see_previous_messages_files": new_members_can_see_prev_msgs,
                "posting_permissions": posting_permissions_num,
            },
            "name": channel_name,
            "type": channel_type_num,
            "members": email_json
        })

        json_data = remove_None_values_from_dict(json_all_data)
        url_suffix = f"/chat/users/{user_id}/channels"
        raw_data = client.zoom_create_channel(url_suffix, json_data)
        # md = tableToMarkdown('Channel details', [raw_data], ['id', 'name', 'type', 'channel_url'])

        outputs = []
        outputs.append({'User id': user_id,
                        'Channel ID': raw_data.get('id'),
                        'Channel name': raw_data.get('name'),
                        'Channel type': raw_data.get('type'),
                        'Channel url': raw_data.get('channel_url')})

        human_readable = tableToMarkdown('Channel details',
                                         outputs,
                                         removeNull=True)

        return CommandResults(
            outputs_prefix='Zoom.Channel',
            outputs_key_field='id',
            readable_output=human_readable,
            outputs=raw_data,
            raw_response=raw_data
        )


    def zoom_delete_channel_command(client, **args) -> CommandResults:
        """
           Delete a Zoom channel
        """
        client = client
        channel_id = args.get('channel_id')
        user_id = args.get('user_id')
        url_suffix = f'/chat/users/{user_id}/channels/{channel_id}'

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        client.zoom_delete_channel(url_suffix)
        return CommandResults(
            readable_output=f'Channel {channel_id} was deleted successfully',
        )


    def zoom_update_channel_command(client, **args) -> CommandResults:
        """
            Update a Zoom channel
        """
        client = client
        add_member_permissions = args.get('add_member_permissions', None)
        add_member_permissions_num = MEMBER_PERMISSIONS_MAPPING.get(add_member_permissions)
        posting_permissions = args.get('posting_permissions', None)
        posting_permissions_num = POSTING_PERMISSIONS_MAPPING.get(posting_permissions)
        new_members_can_see_prev_msgs = args.get('new_members_can_see_prev_msgs', True)
        channel_name = args.get('channel_name')
        channel_id = args.get('channel_id')
        user_id = args.get('user_id')
        json_all_data = {}

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)
        # special section for recurring meeting with fixed time
        json_all_data.update({
            "name": channel_name,
            "channel_settings": {
                "add_member_permissions": add_member_permissions_num,
                "new_members_can_see_previous_messages_files": new_members_can_see_prev_msgs,
                "posting_permissions": posting_permissions_num,
            }})

        json_data = remove_None_values_from_dict(json_all_data)
        url_suffix = f"/chat/users/{user_id}/channels/{channel_id}"
        client.zoom_update_channel(url_suffix, json_data)

        return CommandResults(
            readable_output=f"Channel {channel_id} was updated successfully",
        )


    def zoom_invite_to_channel_command(client, **args) -> CommandResults:
        """
            invite users to Zoom channel
        """
        channel_id = args.get('channel_id')
        user_id = args.get('user_id')
        members = argToList(args.get('members'))
        url_suffix = f'/chat/users/{user_id}/channels/{channel_id}/members'
        json_members = [{"email": email} for email in members]

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        members_json = {'members': json_members}

        raw_data = client.zoom_invite_to_channel(members_json, url_suffix)

        outputs = [{
            'User id': raw_data.get('ids'),
            'Channel ID': channel_id,
            'Added at date and time': raw_data.get('added_at')
        }]

        human_readable = tableToMarkdown('Channel details', outputs, removeNull=True)

        return CommandResults(
            outputs_prefix='Zoom.Channel',
            outputs_key_field='id',
            readable_output=human_readable,
            outputs=raw_data,
            raw_response=raw_data
        )


    def zoom_remove_from_channel_command(client, **args) -> CommandResults:
        """
            Remove a user from Zoom channel
        """
        client = client
        channel_id = args.get('channel_id')
        member_id = args.get('member_id')
        user_id = args.get('user_id')

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        url_suffix = f'/chat/users/{user_id}/channels/{channel_id}/members/{member_id}'
        client.zoom_remove_from_channel(url_suffix)
        return CommandResults(
            readable_output=f'Member {member_id} was successfully removed from channel {channel_id}',
        )


    def zoom_send_file_command(client, **args) -> CommandResults:
        """
            Send file in Zoom
        """
        client = client
        user_id = args.get('user_id')
        to_channel = args.get('to_channel')
        to_contact = args.get('to_contact')
        entry_id = args.get('entry_id')

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        if "to_contact" not in args and "to_channel" not in args:
            raise DemistoException(MISSING_ARGUMENT)

        file_info = demisto.getFilePath(entry_id)
        upload_url = f'https://file.zoom.us/v2/chat/users/{user_id}/messages/files'
        json_data = remove_None_values_from_dict({
            'to_contact': to_contact,
            'to_channel': to_channel})
        upload_response = client.zoom_send_file(upload_url, file_info, json_data)

        message_id = upload_response.get('id')
        return CommandResults(
            readable_output=f'Message with id {message_id} was successfully sent'
        )


    def process_links(formatted_message, formats):
        """
        Processes markdown links in the formatted message.
        for example- [my link](https://****.com)
        Args:
            formatted_message (str): The formatted message to process.

        Returns:
            str: The formatted message with links processed.
        """
        add_link_regex = r'\[([^[\]]*?)\]\((http[s]?://.*?)\)'
        matches = re.findall(add_link_regex, formatted_message)

        for match in matches:
            link_text, link_url = match
            add_link_range = {
                "text": link_text,
                "format_type": "AddLink",
                "format_attr": link_url
            }
            formats.append(add_link_range)
            # Replace Markdown syntax with plain text
            formatted_message = formatted_message.replace("[" + link_text + "](" + link_url + ")", link_text)

        return formatted_message, formats


    def process_mentions(formatted_message, formats, at_contact=None):
        """
        Processes mentions in the markdown message you can provide just one mention on each message.
        for example-'@all'

        Args:
            formatted_message (str): The markdown message to process.
            at_contact (str): The contact to mention.

        Returns:
            str: The formatted message without the mention markdown.
        """
        mention_regex = r"(@\w+)"

        matches = re.findall(mention_regex, formatted_message)[:1]
        for match in matches:
            if match == '@all':
                mention_range = {
                    'text': match,
                    "at_type": 2,
                    "at_contact": at_contact,
                }
                formats.append(mention_range)
            elif at_contact:
                mention_range = {
                    'text': match,
                    "at_contact": at_contact,
                    "at_type": 1,
                }
                formats.append(mention_range)
        return formatted_message, formats


    def process_background_colors(formatted_message, formats):
        """
        Processes background colors in the markdown message.
        for example- [#<rgb>bg](message that will be with background)

        Args:
            formatted_message (str): The markdown message to process.

        Returns:
            str: The formatted message without background color markdown.
        """
        bg_color_regex = r"\[#([A-Fa-f0-9]{6})bg\]\((.*?)\)"

        matches = re.findall(bg_color_regex, formatted_message)
        for match in matches:
            bg_color, text = match
            bg_color_range = {
                "text": text,
                "format_type": "BackgroundColor",
                "format_attr": bg_color,
            }
            formats.append(bg_color_range)

            # Replace Markdown syntax with plain text
            formatted_message = formatted_message.replace("[#" + bg_color + "bg](" + text + ")", text)
        return formatted_message, formats


    def process_font_sizes(formatted_message, formats):
        """
        Processes font sizes in the markdown message.
        use s|m|l for text size
        for example- [s](message)

        Args:
            formatted_message (str): The markdown message to process.

        Returns:
            str: The formatted message without fontsize markdown.
        """
        font_size_regex = "\\[(s|m|l)\\]\\((.*?)\\)"
        matches = re.findall(font_size_regex, formatted_message)
        for match in matches:
            size, text = match
            font_size_range = {
                "text": text,
                "format_type": "FontSize",
                "format_attr": size
            }
            formats.append(font_size_range)

            # Replace Markdown syntax with plain text
            formatted_message = formatted_message.replace("[" + size + "](" + text + ")", text)
        return formatted_message, formats


    def process_font_colors(formatted_message, formats):
        """
        Processes font colors in the formatted message.

        Args:
            formatted_message (str): The formatted message to process.

        Returns:
            str: The formatted message with font colors processed.
        """
        font_color_regex = "\\[#([A-Fa-f0-9]{6})\\]\\((.*?)\\)"
        matches = re.findall(font_color_regex, formatted_message)
        for match in matches:
            color, text = match
            font_color_range = {
                "text": text,
                "format_type": "FontColor",
                "format_attr": color,
            }
            formats.append(font_color_range)

            # Replace Markdown syntax with plain text
            formatted_message = formatted_message.replace("[#" + color + "](" + text + ")", text)
        return formatted_message, formats


    def process_left_indent_and_paragraphs(formatted_message, formats):
        """
        Processes left indents and paragraphs in the markdown message.
        for left indents use >,>>,>>>
        for paragraph usr #,##,### (up to 3)
        this type of markdowns effect the whole line.

        Args:
            formatted_message (str): The formatted message to process.

        Returns:
            tuple: A tuple containing the formatted message, rich text formatting data, and @mention items.
        """

        left_indent_regex = r"(>{1,4})\s(.*?)$"
        paragraph_regex = r"(#{1,4})\s(.*?)$"
        lines = formatted_message.split("\n")
        for i, line in enumerate(lines):
            match = re.findall(left_indent_regex, line)
            for matches in match:
                indent_level, indent_text = matches
                left_indent_range = {
                    "text": indent_text,
                    "format_type": "LeftIndent",
                    "format_attr": len(indent_level) * 20,
                }
                formats.append(left_indent_range)
                # Replace Markdown syntax with plain text
                lines[i] = indent_text

            pp_matches = re.findall(paragraph_regex, line)
            for p_matches in pp_matches:
                heading_level, heading_text = p_matches
                paragraph_range = {
                    "text": heading_text,
                    "format_type": "paragraph",
                    "format_attr": f"h{len(heading_level)}",
                }
                formats.append(paragraph_range)
                lines[i] = heading_text
        formatted_message = "\n".join(lines)
        return formatted_message, formats


    def parse_markdown_message(markdown_message: str, at_contact: str = None):
        """
        Parses a Markdown message and extracts formatting information.

        Args:
            markdown_message (str): The Markdown message to parse.
            at_contact (str, optional): The contact to mention. Defaults to None.

        Returns:
            tuple: A tuple containing the formatted message, rich text formatting data, and @mention items.
        """

        formats: List[dict] = []
        at_items = []
        rich_text = []
        formatted_message, formats = process_links(markdown_message, formats)
        formatted_message, formats = process_mentions(formatted_message, formats, at_contact)
        formatted_message, formats = process_background_colors(formatted_message, formats)
        formatted_message, formats = process_font_sizes(formatted_message, formats)
        formatted_message, formats = process_font_colors(formatted_message, formats)
        formatted_message, formats = process_left_indent_and_paragraphs(formatted_message, formats)

        # extract the start,end positions
        for i in range(len(formats)):
            t = formats[i]['text']
            start_position = formatted_message.find(t)
            end_position = start_position + len(t) - 1
            formats[i]["start_position"] = start_position
            formats[i]["end_position"] = end_position
            if formats[i].get('at_type'):
                at_items.append(formats[i])
            else:
                rich_text.append(formats[i])

        return formatted_message, {
            "message": formatted_message,
            "rich_text": rich_text,
            "at_items": at_items
        }


    def zoom_send_message_command(client, **args) -> CommandResults:
        """
            Send  Zoom chat message
        """
        client = client
        at_contact = args.get('at_contact')
        user_id = args.get('user_id')
        message = args.get('message', '')
        entry_ids = argToList(args.get('entry_ids', []))
        reply_main_message_id = args.get('reply_main_message_id')
        to_channel = args.get('to_channel')
        to_contact = args.get('to_contact')
        is_markdown = args.get('is_markdown', False)

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        url_suffix = f'/chat/users/{user_id}/messages'
        upload_file_url = f'https://file.zoom.us/v2/chat/users/{user_id}/files'
        zoom_file_id: List = []
        for id in entry_ids:
            file_info = demisto.getFilePath(id)
            res = client.zoom_upload_file(upload_file_url, file_info)
            zoom_file_id.append(res.get('id'))

        # check if the text contain markdown to parse and also provide text style arguments
        if is_markdown:
            # check if text have more then 1 mention
            if message.count('@') > 1 and at_contact:
                raise DemistoException(MARKDOWN_EXTRA_MENTIONS)

            message, json_data_all = parse_markdown_message(message, at_contact)
            json_data_all.update({"file_ids": zoom_file_id, "reply_main_message_id": reply_main_message_id, "to_channel": to_channel,
                                  "to_contact": to_contact})
        else:
            json_data_all = {
                "message": message,
                "file_ids": zoom_file_id,
                "reply_main_message_id": reply_main_message_id,
                "to_channel": to_channel,
                "to_contact": to_contact
            }
        json_data = remove_None_values_from_dict(json_data_all)

        raw_data = client.zoom_send_message(url_suffix, json_data)
        data = {
            'Mentioned user': at_contact,
            'Channel ID ': to_channel,
            'Message ID': raw_data.get('id'),
            'Contact': to_contact
        }

        md = tableToMarkdown('Message', data, removeNull=True)
        return CommandResults(
            outputs_prefix='Zoom.ChatMessage',
            readable_output=md,
            outputs_key_field='id',
            outputs=raw_data,
            raw_response=raw_data
        )


    def zoom_delete_message_command(client, **args) -> CommandResults:
        """
            Delete Zoom chat message
        """
        client = client
        message_id = args.get('message_id')
        to_contact = args.get('to_contact',)
        user_id = args.get('user_id')
        to_channel = args.get('to_channel')

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        if to_channel:
            url_suffix = f'/chat/users/{user_id}/messages/{message_id}?to_channel={to_channel}'
        elif to_contact:
            url_suffix = f'/chat/users/{user_id}/messages/{message_id}?to_contact={to_contact}'
        else:
            raise DemistoException(MISSING_ARGUMENT)

        client.zoom_delete_message(url_suffix)
        return CommandResults(
            readable_output=f'Message {message_id} was deleted successfully',
        )


    def zoom_update_message_command(client, **args) -> CommandResults:
        """
            Update Zoom chat message
        """
        client = client
        message_id = args.get('message_id')
        to_contact = args.get('to_contact')
        user_id = args.get('user_id')
        to_channel = args.get('to_channel')
        message = args.get('message')
        entry_ids = argToList(args.get('entry_ids', []))

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)

        upload_file_url = f'https://file.zoom.us/v2/chat/users/{user_id}/files'
        zoom_file_id: List = []
        demisto.debug(f'file id args {entry_ids}')
        for id in entry_ids:
            file_info = demisto.getFilePath(id)
            res = client.zoom_upload_file(upload_file_url, file_info)
            zoom_file_id.append(res.get('id'))
        demisto.debug('upload the file without error')

        url_suffix = f'/chat/users/{user_id}/messages/{message_id}'
        json_data = remove_None_values_from_dict(
            {
                "message": message,
                "file_ids": zoom_file_id,
                "to_channel": to_channel,
                "to_contact": to_contact})

        client.zoom_update_message(url_suffix, json_data)
        return CommandResults(
            readable_output=f'Message {message_id} was successfully updated',
        )


    def zoom_get_user_id_by_email(client, email):
        """
        Retrieves the user ID associated with the given email address.

        :param client: The Zoom client object.,
        email: The email address of the user.

        :return: The user ID associated with the email address.
        :rtype: str
        """
        user_url_suffix = f'users/{email}'
        user_id = client.zoom_list_users(page_size=50, url_suffix=user_url_suffix).get('id')
        if not user_id:
            raise DemistoException(USER_NOT_FOUND)
        return user_id


    def zoom_get_user_name_by_email(client, user_email):
        """
        Retrieves the user name associated with the given email address.

        :param client: The Zoom client object.
        user_email: The email address of the user.

        :return: The user name associated with the email address.
        :rtype: str
        """
        user_url_suffix = f'users/{user_email}'
        user_name = client.zoom_list_users(page_size=1, url_suffix=user_url_suffix)
        demisto.info(f"user_name: {user_name}")
        if not user_name:
            raise DemistoException(USER_NOT_FOUND)
        user_name = user_name.get('display_name')
        return user_name


    def zoom_list_messages_command(client, **args) -> CommandResults:
        """
        Lists messages from Zoom chat.

        :raises DemistoException: If a required argument is missing.
        """

        client = client
        user_id = args.get('user_id')
        to_contact = args.get('to_contact')
        to_channel = args.get('to_channel')
        date_arg = arg_to_datetime(args.get('date'))
        from_arg = arg_to_datetime(args.get('from'))
        to_arg = arg_to_datetime(args.get('to'))
        date_arg = date_arg.strftime('%Y-%m-%dT%H:%M:%SZ') if date_arg else None
        from_arg = from_arg.strftime('%Y-%m-%dT%H:%M:%SZ') if from_arg else None
        to_arg = to_arg.strftime('%Y-%m-%dT%H:%M:%SZ') if to_arg else None
        include_deleted_and_edited_message = args.get('include_deleted_and_edited_message')
        search_type = args.get('search_type')
        search_key = args.get('search_key')
        exclude_child_message = args.get('exclude_child_message', False)
        limit = arg_to_number(args.get('limit', 50))
        page_size = arg_to_number(args.get('page_size'))

        if limit and page_size and limit != 50:
            raise DemistoException(LIMIT_AND_EXTRA_ARGUMENTS)
        else:
            limit = page_size if page_size else limit

        if not to_contact and not to_channel:
            raise DemistoException(MISSING_ARGUMENT)

        if user_id and re.match(emailRegex, user_id):
            user_id = zoom_get_user_id_by_email(client, user_id)
        json_data = {
            'user_id': user_id,
            'to_contact': to_contact,
            'to_channel': to_channel,
            'date': date_arg,
            'from': from_arg,
            'to': to_arg,
            'include_deleted_and_edited_message': include_deleted_and_edited_message,
            'search_type': search_type,
            'search_key': search_key,
            'exclude_child_message': exclude_child_message,
            'page_size': limit
        }
        # remove all keys with val of None
        request_data = remove_None_values_from_dict(json_data)
        url_suffix = f'users/{user_id}/messages'
        all_messages: List = []
        next_page_token = args.get('next_page_token', None)
        while True:
            try:
                raw_data = client.zoom_list_user_messages(url_suffix=url_suffix,
                                                          user_id=user_id,
                                                          to_contact=to_contact,
                                                          to_channel=to_channel,
                                                          date_arg=date_arg,
                                                          from_arg=from_arg,
                                                          to_arg=to_arg,
                                                          include_deleted_and_edited_message=include_deleted_and_edited_message,
                                                          search_type=search_type,
                                                          search_key=search_key,
                                                          exclude_child_message=exclude_child_message,
                                                          next_page_token=next_page_token,
                                                          page_size=limit)
                data = raw_data.get('messages', [])
                if limit and len(all_messages) + len(data) > limit:
                    remaining_limit = limit - len(all_messages)
                    data = data[:remaining_limit]

                all_messages.extend(data)

                if limit and len(all_messages) >= limit:
                    all_messages = all_messages[:limit]
                    break
                next_page_token = raw_data.get('next_page_token', None)
                if next_page_token and next_page_token != '':
                    next_page_token = raw_data['next_page_token']
                else:
                    break
            except DemistoException as e:
                error_message = e.message
                if 'The next page token is invalid or expired.' in error_message and next_page_token:
                    raise DemistoException(f"Please ensure that the correct argument values are used when attempting to use \
    the next_page_toke.\n Note that when using next_page_token it is mandatory to specify date time and not relative time.\n \
    To find the appropriate values, refer to the ChatMessageNextToken located in the context. \n {error_message}")

        outputs = []
        for i in all_messages:
            outputs.append({
                'User id': user_id,
                'Message Id': i.get('id'),
                'Message text': i.get('message'),
                'Message sender': i.get('sender'),
                'Sender display name': i.get('sender_display_name'),
                'Date Time': i.get('date_time'),
                'From': str(from_arg),
                'To': str(to_arg)})

        md = tableToMarkdown('Messages', outputs)
        md += '\n' + 'Messages next token:' + raw_data.get('next_page_token', '')

        if raw_data.get('next_page_token'):
            request_data.update({'next_page_token': raw_data.get('next_page_token')})
        else:
            request_data = None

        return CommandResults(
            outputs_prefix='Zoom',
            readable_output=md,
            outputs={'ChatMessage': {'messages': all_messages},
                     'ChatMessageNextToken': request_data},
            raw_response=raw_data
        )


    def get_channel_jid_from_context(channel_name: str = None, investigation_id=None):
        """
        Retrieves a Zoom channel JID based on the provided criteria.

        :param channel_name: The name of the channel to get the JID for.
        :param investigation_id: The Demisto investigation ID to search for a mirrored channel.

        :return: The requested channel JID or None if not found.
        """
        if not channel_name and not investigation_id:
            return None
        integration_context = fetch_context()
        mirrors = json.loads(integration_context.get('mirrors', '[]'))

        # Filter mirrors based on the provided criteria.
        if investigation_id:
            mirrored_channel_filter = next((m for m in mirrors if m["investigation_id"] == investigation_id), None)
        else:
            mirrored_channel_filter = next((m for m in mirrors if m["channel_name"] == channel_name), None)
        if mirrored_channel_filter:
            return mirrored_channel_filter.get('channel_jid')
        return None


    def send_notification(client, **args):

        client = client
        bot_jid = client.bot_jid
        account_id = client.account_id
        to = args.get('to')
        channel_id = args.get('channel_id')
        visible_to_user = args.get('visible_to_user')
        zoom_ask = argToBoolean(args.get('zoom_ask', False))
        entitlement = None

        message_type = args.get('messageType', '')  # From server
        original_message = args.get('originalMessage', '')  # From server
        entry_object = args.get('entryObject')  # From server
        channel = args.get('channel')  # From server
        investigation_id = None
        if entry_object:
            investigation_id = entry_object.get('investigationId')  # From server, available from demisto v6.1 and above

        if message_type and message_type != MIRROR_TYPE:
            return (f"Message type is not in permitted options. Received: {message_type}")

        if message_type == MIRROR_TYPE and original_message.find(MESSAGE_FOOTER) != -1:
            # return so there will not be a loop of messages
            return ("Message already mirrored")

        if to and '@xmpp.zoom.us' not in to:

            if re.match(emailRegex, to):
                to = zoom_get_user_id_by_email(client, to).lower() + '@xmpp.zoom.us'
            else:
                to = to.lower() + '@xmpp.zoom.us'

        if channel_id and '@conference.xmpp.zoom.us' not in channel_id:
            channel_id = channel_id.lower() + '@conference.xmpp.zoom.us'

        if zoom_ask:
            parsed_message = json.loads(args.get("message", ''))
            entitlement = parsed_message.get('entitlement')
            message = parsed_message.get('blocks')
            reply = parsed_message.get('reply')
            expiry = parsed_message.get('expiry')
            default_response = parsed_message.get('default_response')
        else:
            message = {"head": {"type": "message", "text": args.get("message", "")}}
        if channel:  # if channel name provided
            channel_id = get_channel_jid_from_context(channel, investigation_id)
            if not channel_id:
                raise DemistoException(WRONG_CHANNEL)
        if (to and channel_id):
            raise DemistoException(TOO_MANY_JID)
        if not to and not channel_id:
            raise DemistoException(MISSING_ARGUMENT_JID)

        url_suffix = '/im/chat/messages'
        json_data_all = {
            "robot_jid": bot_jid,
            "to_jid": to if to else channel_id,
            "account_id": account_id,
            "visible_to_user": visible_to_user,
            "content":
                message
        }
        json_data = remove_None_values_from_dict(json_data_all)

        raw_data = client.zoom_send_notification(url_suffix, json_data)
        if raw_data:
            message_id = raw_data.get("message_id")
            if entitlement:
                save_entitlement(entitlement, message_id, reply, expiry, default_response, to if to else channel_id)
        return CommandResults(
            readable_output=f'Message sent to Zoom successfully. Message ID is: {raw_data.get("message_id")}'
        )


    def get_admin_user_id_from_token(client):
        """ get the user admin id from the token"""
        admin_user_result = client.zoom_get_admin_user_id_from_token()
        return admin_user_result.get('id')


    def fetch_context(force_refresh: bool = False) -> dict:
        """
        Fetches the integration instance context from the server if the CACHE_EXPIRY is smaller than the current epoch time
        In the event that the cache is not expired, we return a cached copy of the context which has been stored in memory.
        We can force the retrieval of the updated context by setting the force_refresh flag to True.
        :param force_refresh: bool: Indicates if the context should be refreshed regardless of the expiry time.
        :return: dict: Either a cached copy of the integration context, or the context itself.
        """
        global CACHED_INTEGRATION_CONTEXT, CACHE_EXPIRY
        now = int(datetime.now(timezone.utc).timestamp())
        if (now >= CACHE_EXPIRY) or force_refresh:
            demisto.debug(f'Cached context has expired or forced refresh. forced refresh value is {force_refresh}. '
                          'Fetching new context')
            CACHE_EXPIRY = next_expiry_time()
            CACHED_INTEGRATION_CONTEXT = get_integration_context(SYNC_CONTEXT)

        return CACHED_INTEGRATION_CONTEXT


    def mirror_investigation(client, **args) -> CommandResults:
        if not MIRRORING_ENABLED:
            demisto.error(" couldn't mirror investigation, Mirroring is disabled")
        if MIRRORING_ENABLED and not LONG_RUNNING:
            demisto.error('Mirroring is enabled, however long running is disabled. For mirrors to work correctly,'
                          ' long running must be enabled.')
        client = client
        type = args.get('type', 'all')
        direction = args.get('direction', 'Both')
        channel_name = args.get('channelName')
        autoclose = argToBoolean(args.get('autoclose', True))
        send_first_message = False
        # kick_admin = argToBoolean(args.get('kickAdmin', False))
        # members = argToList(args.get('members'))

        investigation = demisto.investigation()
        investigation_id = str(investigation.get('id'))
        if investigation.get('type') == PLAYGROUND_INVESTIGATION_TYPE:
            return_error('Sorry, but this action cannot be performed in the playground ')

        integration_context = get_integration_context(SYNC_CONTEXT)
        if not integration_context or not integration_context.get('mirrors', []):
            mirrors: list = []
            current_mirror = []
        else:
            mirrors = json.loads(integration_context['mirrors'])
            current_mirror = list(filter(lambda m: m['investigation_id'] == investigation_id, mirrors))

        # get admin user id from token
        admin_user_id = get_admin_user_id_from_token(client)

        channel_filter: list = []
        if channel_name:
            # check if channel already exists
            channel_filter = list(filter(lambda m: m['channel_name'] == channel_name, mirrors))

        if not current_mirror:
            channel_name = channel_name or f'incident-{investigation_id}'

            if not channel_filter:
                # create new channel
                result = zoom_create_channel_command(client=client, user_id=admin_user_id, channel_type='Public channel',
                                                     channel_name=channel_name, member_emails=admin_user_id)
                if result and isinstance(result.outputs, dict) and len(result.outputs) > 0:
                    channel_jid = result.outputs.get('jid')
                    channel_id = result.outputs.get('id')
                else:
                    raise DemistoException("error in create new channel")
                send_first_message = True
            else:
                mirrored_channel = channel_filter[0]
                channel_jid = mirrored_channel['channel_jid']
                channel_id = mirrored_channel['channel_id']
                channel_name = mirrored_channel['channel_name']

            mirror = {
                'channel_jid': channel_jid,
                'channel_id': channel_id,
                'channel_name': channel_name,
                'investigation_id': investigation.get('id'),
                'mirror_type': type,
                'mirror_direction': direction,
                'auto_close': bool(autoclose),
                'mirrored': True
            }
        else:
            mirror = mirrors.pop(mirrors.index(current_mirror[0]))
            channel_jid = mirror['channel_jid']
            channel_id = mirror['channel_id']
            if type:
                mirror['mirror_type'] = type
            if autoclose:
                mirror['auto_close'] = autoclose
            if direction:
                mirror['mirror_direction'] = direction
            if channel_name and not channel_filter:
                # update channel name
                result = zoom_update_channel_command(client=client, user_id=admin_user_id,
                                                     channel_name=channel_name, channel_id=channel_id)
                mirror['channel_name'] = channel_name
            channel_name = mirror['channel_name']
            mirror['mirrored'] = True
        demisto.mirrorInvestigation(investigation_id, f'{type}:{direction}', autoclose)

        mirrors.append(mirror)
        set_to_integration_context_with_retries({'mirrors': mirrors}, OBJECTS_TO_KEYS, SYNC_CONTEXT)

        if send_first_message:
            server_links = demisto.demistoUrls()
            server_link = server_links.get('server')
            message = (f'This channel was created to mirror incident {investigation_id}.'
                       f' \n View it on: {server_link}#/WarRoom/{investigation_id}')
            url_suffix = '/im/chat/messages'
            json_data_all = {
                "content": {
                    "body": [
                        {
                            "type": "message",
                            "text": message
                        }
                    ]
                },
                "to_jid": channel_jid,
                "robot_jid": client.bot_jid,
                "account_id": client.account_id
            }
            client.zoom_send_notification(url_suffix, json_data_all)
        # if kick_admin:
        #     demisto.debug("kick-admin:")
        #     url_suffix = f'/chat/users/{admin_user_id}/channels/{channel_id}/members/{admin_user_id}'
        #     res = client.zoom_remove_from_channel(url_suffix)
        #     demisto.debug(f"res: {res}")
        return CommandResults(
            readable_output=f'Investigation mirrored successfully,\n channel name:{channel_name} \n channel JID: {channel_jid}'
        )


    def find_mirror_by_investigation() -> dict:
        """
        Finds a mirrored channel by the mirrored investigation

        Returns:
            The mirror object
        """
        mirror: dict = {}
        investigation = demisto.investigation()
        if investigation:
            integration_context = get_integration_context(SYNC_CONTEXT)
            if 'mirrors' in integration_context:
                mirrors = json.loads(integration_context['mirrors'])
                investigation_filter = list(filter(lambda m: investigation.get('id') == m['investigation_id'],
                                                   mirrors))
                if investigation_filter:
                    mirror = investigation_filter[0]

        return mirror


    def close_channel(client, **args):
        """
            if AutoClose is true in mirroring
            delete the mirrored zoom channel from zoom and from the context
        """
        client = client
        admin_user_id = get_admin_user_id_from_token(client)
        mirror = find_mirror_by_investigation()
        channel_id = None
        integration_context = get_integration_context(SYNC_CONTEXT)
        if mirror:
            mirrors = json.loads(integration_context['mirrors'])
            channel_id = mirror.get('channel_id', '')
            channel_mirrors = list(filter(lambda m: channel_id == m['channel_id'], mirrors))
            for mirror in channel_mirrors:
                mirror['remove'] = True
                demisto.mirrorInvestigation(mirror['investigation_id'], f'none:{mirror["mirror_direction"]}',
                                            bool(mirror['auto_close']))
            set_to_integration_context_with_retries({'mirrors': mirrors}, OBJECTS_TO_KEYS, SYNC_CONTEXT)
        if channel_id:
            zoom_delete_channel_command(client=client, channel_id=channel_id, user_id=admin_user_id)
            return 'Channel successfully deleted.'
        return return_error('Channel {channel_id} not found')


    def main():  # pragma: no cover
        params = demisto.params()
        args = demisto.args()
        base_url = params.get('url')
        account_id = params.get('account_id')
        client_id = params.get('credentials', {}).get('identifier')
        client_secret = params.get('credentials', {}).get('password')
        bot_client_id = params.get('bot_credentials', {}).get('identifier')
        bot_client_secret = params.get('bot_credentials', {}).get('password')
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        bot_jid = params.get('botJID', None)
        secret_token = params.get('secret_token', {}).get('password')
        global SECRET_TOKEN, LONG_RUNNING, MIRRORING_ENABLED, CACHE_EXPIRY, CACHED_INTEGRATION_CONTEXT
        SECRET_TOKEN = secret_token
        LONG_RUNNING = params.get('longRunning', False)
        MIRRORING_ENABLED = params.get('mirroring', False)

        # Pull initial Cached context and set the Expiry
        CACHE_EXPIRY = next_expiry_time()
        CACHED_INTEGRATION_CONTEXT = get_integration_context(SYNC_CONTEXT)

        if MIRRORING_ENABLED and (not LONG_RUNNING or not SECRET_TOKEN or not bot_client_id or not bot_client_secret or not bot_jid):
            raise DemistoException("""Mirroring is enabled, however long running is disabled
    or the necessary bot authentication parameters are missing.
    For mirrors to work correctly, long running must be enabled and you must provide all
    the zoom-bot following parameters:
    secret token,
    Bot JID,
    bot client id and secret id""")
        if LONG_RUNNING:
            try:
                port = int(params.get('longRunningPort'))
            except ValueError as e:
                raise ValueError(f'Invalid listen port - {e}')

        command = demisto.command()
        # this is to avoid BC. because some of the arguments given as <a-b>, i.e "user-list"
        args = {key.replace('-', '_'): val for key, val in args.items()}

        try:
            check_authentication_bot_parameters(bot_jid, bot_client_id, bot_client_secret)
            check_authentication_parameters(client_id, client_secret)
            global CLIENT
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                proxy=proxy,
                bot_jid=bot_jid,
                account_id=account_id,
                client_id=client_id,
                client_secret=client_secret,
                bot_client_id=bot_client_id,
                bot_client_secret=bot_client_secret,
            )
            CLIENT = client

            if command == 'test-module':
                return_results(test_module(client=client))

            demisto.debug(f'Command being called is {command}')

            '''CRUD commands'''
            if command == 'long-running-execution':
                run_long_running(port)
            elif command == 'mirror-investigation':
                results = mirror_investigation(client, **args)
            elif command == 'close-channel':
                results = close_channel(client, **args)
            elif command == 'zoom-create-user':
                results = zoom_create_user_command(client, **args)
            elif command == 'zoom-create-meeting':
                results = zoom_create_meeting_command(client, **args)
            elif command == 'zoom-meeting-get':
                results = zoom_meeting_get_command(client, **args)
            elif command == 'zoom-meeting-list':
                results = zoom_meeting_list_command(client, **args)
            elif command == 'zoom-delete-user':
                results = zoom_delete_user_command(client, **args)
            elif command == 'zoom-fetch-recording':
                results = zoom_fetch_recording_command(client, **args)
            elif command == 'zoom-list-users':
                results = zoom_list_users_command(client, **args)
            elif command == 'zoom-list-account-public-channels':
                results = zoom_list_account_public_channels_command(client, **args)
            elif command == 'zoom-list-user-channels':
                results = zoom_list_user_channels_command(client, **args)
            elif command == 'zoom-create-channel':
                results = zoom_create_channel_command(client, **args)
            elif command == 'zoom-delete-channel':
                results = zoom_delete_channel_command(client, **args)
            elif command == 'zoom-update-channel':
                results = zoom_update_channel_command(client, **args)
            elif command == 'zoom-invite-to-channel':
                results = zoom_invite_to_channel_command(client, **args)
            elif command == 'zoom-remove-from-channel':
                results = zoom_remove_from_channel_command(client, **args)
            elif command == 'zoom-send-file':
                results = zoom_send_file_command(client, **args)
            elif command == 'zoom-list-messages':
                results = zoom_list_messages_command(client, **args)
            elif command == 'zoom-send-message':
                results = zoom_send_message_command(client, **args)
            elif command == 'zoom-delete-message':
                results = zoom_delete_message_command(client, **args)
            elif command == 'zoom-update-message':
                results = zoom_update_message_command(client, **args)
            elif command == 'send-notification':
                results = send_notification(client, **args)

            else:
                return_error('Unrecognized command: ' + demisto.command())
            return_results(results)

        except DemistoException as e:
            # For any other integration command exception, return an error
            demisto.error(format_exc())
            return_error(f'Failed to execute {command} command. Error: {str(e)}.')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Zoom', 'end', __line__())
  subtype: python3
  type: python
system: true
