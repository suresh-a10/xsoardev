category: Analytics & SIEM
commonfields:
  id: QRadar v3
  version: -1
configuration:
- additionalinfo: (e.g., https://192.168.0.1)
  display: Server URL
  name: server
  required: true
  section: Connect
  type: 0
- display: Username
  name: credentials
  required: true
  section: Connect
  type: 9
- additionalinfo: API version of QRadar (e.g., '12.0'). Minimum API version is 10.1.
    Since QRadar API v19, The timestamp fields should be provided as milliseconds
    epoch format instead of seconds.
  defaultvalue: "17.0"
  display: QRadar API Version
  name: api_version
  required: true
  section: Connect
  type: 0
- display: Incident Type
  name: incident_type
  required: false
  section: Connect
  type: 13
- additionalinfo: if no offenses are found within the range of first fetch, will be
    set to fetch the earliest offense.
  defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  required: false
  section: Collect
  type: 0
- defaultvalue: Fetch With All Events
  display: Fetch mode
  name: fetch_mode
  options:
  - Fetch Without Events
  - Fetch With All Events
  - Fetch Correlation Events Only
  required: true
  section: Collect
  type: 15
- additionalinfo: 'Whenever enabled, the integration retries to fetch all events if
    the number of events fetched is less than `event_count`. Default number of tries
    is 3, but can be configured via the Advanced Parameter: EVENTS_SEARCH_TRIES. e.g
    EVENTS_SEARCH_TRIES=5'
  advanced: true
  defaultvalue: "true"
  display: Retry events fetch
  name: retry_events_fetch
  required: false
  section: Collect
  type: 8
- additionalinfo: The maximal amount of events to pull per incident.
  advanced: true
  defaultvalue: "20"
  display: Maximum number of events per incident.
  name: events_limit
  required: false
  section: Collect
  type: 0
- additionalinfo: In case of mirroring with events, this value will be used for mirroring
    API calls as well, and it is advised to have a small value.
  advanced: true
  defaultvalue: "10"
  display: Number of offenses to pull per API call (max 50)
  name: offenses_per_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: Define a query to determine which offenses to fetch. E.g., "severity
    >= 4 AND id > 5". filtering by status in the query may result in unexpected behavior
    when changing an incident's status.
  advanced: true
  display: Query to fetch offenses.
  name: query
  required: false
  section: Collect
  type: 0
- additionalinfo: IPs enrichment transforms IDs of the IPs of the offense to IP values.
    Asset enrichment adds correlated assets to the fetched offenses.
  advanced: true
  defaultvalue: IPs And Assets
  display: Incidents Enrichment
  name: enrichment
  options:
  - IPs
  - IPs And Assets
  - None
  required: true
  section: Collect
  type: 15
- defaultvalue: "100"
  display: Maximum number of assets to fetch
  name: limit_assets
  required: false
  section: Collect
  type: 0
- additionalinfo: 'The parameter uses the AQL SELECT syntax. For more information,
    see: https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.4/com.ibm.qradar.doc/c_aql_intro.html'
  advanced: true
  defaultvalue: QIDNAME(qid), LOGSOURCENAME(logsourceid), CATEGORYNAME(highlevelcategory),
    CATEGORYNAME(category), PROTOCOLNAME(protocolid), sourceip, sourceport, destinationip,
    destinationport, QIDDESCRIPTION(qid), username, PROTOCOLNAME(protocolid), RULENAME("creEventList"),
    sourcegeographiclocation, sourceMAC, sourcev6, destinationgeographiclocation,
    destinationv6, LOGSOURCETYPENAME(devicetype), credibility, severity, magnitude,
    eventcount, eventDirection, postNatDestinationIP, postNatDestinationPort, postNatSourceIP,
    postNatSourcePort, preNatDestinationPort, preNatSourceIP, preNatSourcePort, UTF8(payload),
    starttime, devicetime
  display: 'Event fields to return from the events query (WARNING: This parameter
    is correlated to the incoming mapper and changing the values may adversely affect
    mapping).'
  name: events_columns
  required: false
  section: Collect
  type: 12
- additionalinfo: How mirroring from QRadar to Cortex XSOAR should be done, available
    from QRadar 7.3.3 Fix Pack 3. For further explanation on how to check your QRadar
    version, see the integration documentation at https://xsoar.pan.dev.
  advanced: true
  defaultvalue: No Mirroring
  display: Mirroring Options
  name: mirror_options
  options:
  - No Mirroring
  - Mirror Offense
  - Mirror Offense and Events
  required: false
  section: Collect
  type: 15
- additionalinfo: When selected, closing the QRadar offense is mirrored in Cortex
    XSOAR.
  advanced: true
  defaultvalue: "false"
  display: Close Mirrored XSOAR Incident
  name: close_incident
  required: false
  section: Collect
  type: 8
- additionalinfo: Maximum number of incoming incidents to mirror each time.
  advanced: true
  defaultvalue: "100"
  display: The number of incoming incidents to mirror each time
  name: mirror_limit
  required: false
  section: Collect
  type: 0
- additionalinfo: Comma-separated configuration for advanced parameter values. E.g.,
    EVENTS_INTERVAL_SECS=20,FETCH_SLEEP=5
  advanced: true
  display: Advanced Parameters
  name: adv_params
  required: false
  section: Collect
  type: 12
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- additionalinfo: The timeout of the HTTP requests sent to the Qradar API (in seconds).
    If no value is provided, the timeout will be set to 60 seconds.
  advanced: true
  defaultvalue: "60"
  display: Timeout for http-requests
  name: timeout
  required: false
  section: Collect
  type: 0
- additionalinfo: The fetch interval between before each fetch-incidents execution
    (seconds).
  advanced: true
  defaultvalue: "60"
  display: Fetch Incidents Interval
  name: fetch_interval
  required: false
  section: Collect
  type: 0
- display: Long running instance
  name: longRunning
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 2.5.2
    packID: QRadar
    packName: IBM QRadar
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: QRadar
defaultmapperin: QRadar - Generic Incoming Mapper
description: IBM QRadar SIEM helps security teams accurately detect and prioritize
  threats across the enterprise, supports API versions 10.1 and above. Provides intelligent
  insights that enable teams to respond quickly to reduce the impact of incidents.
detaileddescription: "### Use API token instead of Username and Password\n- In the
  **Username / API Key** field, type **_api_token_key**.  \n- In the **Password**
  field, type your API token.\n\n## Choose your API version\n1. Visit the [QRadar
  API versions page](https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_getting_started.html)
  for a full list of available API versions according to the QRadar version.\n2. Choose
  one of the API versions listed under **Supported REST API versions** column in the
  line corresponding to your QRadar version.\n\nNote: If you're uncertain which API
  version to use, it is recommended to use the latest API version listed in the **Supported
  REST API versions** column in the line corresponding to your QRadar version.\n###
  Fetch incidents\n**The *Long Running Instance* parameter must be enabled to fetch
  incidents. Enabling this parameter will start a long-running process that will fetch
  incidents periodically.\nDepending on the system load, the initial fetch might take
  a long time.**\n\n#### Query to fetch offenses\nYou can apply additional (optional)
  filters for the fetch-incident query using the *Query to fetch offenses* integration
  parameter. For more information on how to use the filter syntax: \n- Visit [QRadar
  Filter Syntax Documentation](https://www.ibm.com/docs/en/qradar-common?topic=versions-filter-syntax)
  for explanation about filter syntax.\n- Visit [QRadar Offense Documentation](https://www.ibm.com/docs/en/qradar-common?topic=card-offenses)
  for a list of all possible fields to be used in the filter.\n\n*Note*: Since QRadar
  API v19, The timestamp fields should be provided as milliseconds epoch format instead
  of seconds.\n#### Offense Enrichment\n* Incident Enrichment (IP) - When enabled,
  fetched incidents IP values (local source addresses and local destination addresses)
  will be fetched from QRadar instead of their ID values.\n* Incident Enrichment (Asset)
  - When enabled, fetched offenses will also contain correlated assets.\n\n#### Reset
  the \"last run\" timestamp\nTo reset fetch incidents, run the ***qradar-reset-last-run***
  command - This will reset the fetch to its initial state. (Will try to fetch the
  first available offense).\n\n#### Mirroring offenses with events\nTo mirror offenses
  with events, enable the *Long running instance* parameter and set *Mirroring Options*
  to *Mirror Offense and Events*.\n- When mirroring offenses with events it is advised
  to set the *Number of offenses to pull per API call* to a small value.\n\n#### Mapping
  limitations for XSOAR users below 6.0.0\n* For XSOAR users below 6.0.0 version,
  using 'Pull from instance' option when creating a new mapper is not supported.\n####
  Required Permissions\n| Component | Permission |\n| --- | --- |\n| Assets | Vulnerability
  Management *or* Assets |\n| Domains | Admin |\n| Offenses (Manage Closing Reason)
  | Manage Offense Closing Reasons |\n| Offenses (Assign Offenses to Users) | Assign
  Offenses to Users |\n| Offenses (Read) | Offenses |\n| References (Create/Update)
  | Admin |\n| References (Read) | View Reference Data |\n\n\n---\n[View Integration
  Documentation](https://xsoar.pan.dev/docs/reference/integrations/q-radar-v3)"
display: IBM QRadar v3
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABZjSURBVHgB7VsJfFTV1b9vmz0zk8lkn2wsWVgiYBDQKqIoqIA7VvspRcS12rrUnQpotS5oKYpQWxFR0IBatIAKFVkEhUQIWSAkmSRMZiaZyWQy+5u3fudOSL4QySJS+/t9nX9+j7nvvvvOXf73nHvuuQ+E4ogjjjjiiCOOOOKII4444ugFAp0l1MlblUqPptgXbSoWJN4iEYKCRKRMknR7giKtWqGxHM1UF9sJgpBRHD8bfhLBZfZPNQpJmMhLzgdExJ0vytE0LLKvUBn+kEwKNKmsUilM79Mq86ZC48zmONn/fpwRwaVyKTW+nbzSG7Y/KciR80hEkEMVJSMJUaDVDKFbqRSTV43Kvd6J4vi34UcTXOUrNXEB75Mc33kHIgjD/z0BPZVlRBIUR5B0gCTIkCTLSiQLOkkWNDIUPlW3ZZkiFA1q2vxwzTfKLXPnzhVRHGcdP4rgCve6Ai7i3SiIkbGYLowYqYg4wdDaAxo6+UMtk7+f9WrbR44cGYVnpNW7I4FGaGxH2DaVE32zJJk7D97s0XiYFqxaYVp4TvodG0BmnOSzjCETXGXfnh0RqzeJEjcR3+N1FZyogIJKeFevL1o+TH9RvdVbrg9H6kYLsn8kRStNBBIFKOeRRHTUkHFuowKJXKez9tog57hPkqUp3ZME/uUYyvB7nyV/5TRimoDiOGsYEsGV9g1ZEaH1HUnmL8H3mFyKUJVrGeOiUem3fX4ivD3d09F8gygHbwVzXCTJogbJUkw2QYAnjRTtiCTr1IzhH2PSJi53BNx6R2flMkEM3wrPiZMy/RrG/FBxxu1vx52vs4dBCa6T65S+lm2vC1J0Pl42cR6JqOMJtHl2kWXecWvb5mJX5PgGIL+IoTU2mlDulGS6mpRlN0IiVCBbRIK4ihd8JcAaBRNjj1437BFt0vgqd8tnj3Ni8HEQqYjJJRhrsj733LzEaztRHGcF5GAFQs4DF/NieEE3uQQibYkJRdcWZt5WV2l79zpX+NheilQ4dYqca9Ms1xem08PuU2oNH+q06bUGg6VGpc54219feGFe4sRCBWVYK8rsRd5Aze6w++C54y33LFaTpqeAeAnLhvV5mC/ofAXFcdYwqAZ/b3tjPSeGbsZpcJqEBFXu5WPSb9pZ7Vh7RTDq+lChMK0xZxQ9vn9jC1cwxT+fk4L3ijI/HLQ3AXZPEhjbIE2p9tOkca0qSO8IayN3soLncYogHEZ1zi+TqGxrnf/rfVB2dKwOcLpM6lGTC1JnV6A4fjIG1GBHxzc5nBC8oesOb4EUmzC5DR1lhpDQ8bhSYXhlXMbtD5OOqHbklI61EdH7EkHQJ3SM+XkNk7ZAQ5qepCjtXk5gp0V457qgpvO1cZm3v6ShzY+JsljgZ9teYllaSNQWPoqnD64FZpwqEG18DCbTWYuy/TdjQILt/vI7wUticBqGXzBoMtfidChcMYOSFUeEjAkv1KN6yiFUvctJoeIkTf6lJdm/uUbLXbxc1uu3qOmMNeda7p1jYoonkYRyOyf6bzlke3NFceb81Qyl3cVLocvapP0LClKu2UqRyh1dtYLvLXGXWN3bR6A4fjL6JViWbWpESnO674GACh1nOoidLtC+m8Fd+kcJUcLzzu8mSShqNioLrhmZcvWh2raPz+lgtr7Jd7Ts8vLH9x5uWbVOm0m3pJPXX0+TCVuiUmBhjWP9bBWVsALIhHlD3GCHkKdWmfVmtxbLSExuDR6chOL4yaD7e9DU2ZIqSWIOTuNgBkMrP7dYpnuOtG4aFhV92VmmabE1khV8f4C19OGClFnWyrb3LvdFGv+kpBPfopWK96JC4Ioo77/baavKF+X6eQwyLkFy+ApW6HiMQJobIDZdLYOptslNpkQq7QCBKA+EMs3AMqmiDdm927NmzWKV0Bo8nxORFg0CgqYEtVLtHDt8wvGSOXPC6GfEp6Wrs5tra8dBJC82WTlWqH/wuT8fRf8h9EuwN1SeDpqkxmmIR8C4M2U4LcuhCTD+RzL1Je02m03dIr6fnSH94vuYMJGZatKMnjsiZWb9STH/OnLineqw5PqrglG/MD7jlusP2F6piYqBSSNyp/mbW7bvg6jYQhpplflJNzbuD7zURBKEORbSJMiM3u1h7b4kp6NlJUy2EVjHBwJ+CnLCdltD/eoXn1h656PPb/659tZeV9v01pbGt0iSjJkjieefhZ8l6D+Efk20IIsG8GhjE4AgFBGSpjw4zUuduQyh6JqRuvpJSlJXnpZ2TggGnopKQbYXuTEkEvmbQUs9LNc+x+u1arWUeTeuVwpJeUrS2AgRLSJBlZYOBEhKWtPc/R68k3BKexhGJmKAGAtBxC7I/sGF88muZwkcGxl/orF208rnH52Hfi5IMUeRjLUR2iOfxSPZM0G/BEui0PMMWghHfSoudiPItITkWDrMsxCxIo+fLMZAQb6vHItFHwTyeWzmBSEC6zoTickXeAUYhlhYUhblmCNHkZpAt3aCiWPQQCBIUaFU1SqVqsM9l0pVwSiUeIL1hDspkqTczhMvrH7tyXT0X4h+TTRBUiKwEEuDqVYQUlSJ0xSp6hAlIROnE+jU6jDVfHWsPEGwDa7tbX3lWL3WNCArgSQ1Vl+y0sva3MVYIsMQTl6KJuHpExL8MesgiCFj94QHzebRAFAqFMHzLp117YjRBaccN367a09Sp902tc3ZvEySJGNMliSmaRjVVZD8G/ovQ78EaxmdNxjlYZBlBgZIFeXFNJzP0PRhLuq7DKfTE8efcAT2Zi2WF5OLicUSK/qIo62lY4vS5lZ2yzHKKZ1eqrGeprXLw+3f5vIifz5FKD2ihvJJHnYC7K1ZkfR7ZbmM+a5pR3rsaBlhDab9aACA9y23Nzb7Lpv1y75hTXzf8Nqi+672etpiuwBsPdqcref0lbFvX6na0+yZVH+0+gJRiFqwS0/RtEebkNhw3kUz9oyfPLWuv/o3rVk+0mVvns1y0TSKptoLxp//xYxZNx15d8WzaDDs3r07ualm/4Vue/MkkeeMYM0FkiTcKZacyqKJo3eVlMxp7+knnMitfvnR4SRFE4IgElqtsX3eb5707Ny5k7ZW7L66s731XLBSO3+39I3tp6urX4IT9BNawu6dIQmJxpiNRoELIbuUkTRWBcVTfv/RJNBaT7Vz/abrXSPyFsOguo4lvZucnHyK2U9KmuyHRl4ASb7C9tYb4OvolIzhOa+rtlgQ+UsUtKYqWTcidLS52QxkD5egpq4vQMQ29JMgO3rfMTTFdad93veoda8fXLjjg0+e5aKsOXZSTXY1G08Gr7sN2ZuOh19ddPc7k2dc9eSUHeU+YvFitBiuIrM63eZseLmybO/1oiio8HIvyxJyO0pfOLL3y68zsoZvPW1rQO62bduUtd9uWfZV6Ru38jynB0cM9T527WhvQw3HjrS//vxDf7z1vkUrDIZE8fDhw/qm2mO7FUplGt5FavSJT3z07vLPv9n89lo2EhwL7SbAOYmCiNMS3O8anK0Z74bGW3Eae7UQWLrosO2dzPyMmztgNMoa/d+Mw40SydAWJLhus8ufaqZNmyaMGTOG6ysLOhHFTpRMiokQ8Nhv4KY/H46678ROHIGYLy36GV5ZwV8iIj7pZG+xy1SPBsHp3OLS0lJkaziKD6ksvYsmW7Jiu4DVq1ejdSvK5ruc9r8IAm8mKQo3kKcZpoVWMC0w3vxJsjVet+veXf/4aMXOIrMOZ1w2vVB9vL5ys6/D8yvouwqW9xgxJ5tCBPydl9ht1ju7SesNv7+DPPbNpy95XM57wSLq8bsURQVoRmEDq+GCIiLcY6/b7Gppfvn9lc/P72m8LPX0V6c35FSV7d/McZFiaDvR9zOKvuh/DYZOl9te/0AQoxOwCBGxY5R0+hR4tMmoyH87Itqv45Dnq+LUhW2N7Ts3eJF70HNcvWbiXWzQmizpanK4YOhXFMkclUTynWr3RjkMZ8QE6hoZkqBO5KhK9g4sTUZRiiOXPTT/lP5pNYLpk3UrbwRtuKw7j6GZamPmmC04rSI8+c42xyM4O1YXSXotw/JvsVhyD+B724nGGScajr0J/TdgoqNR9rqvdu9fBEQG//bSE3M4jj0XDyomFohxm9PSVqVb8g74PO5sp+PEwpC/85xua9Ab7/3lueneDvfdUF+svTRDV+WNHD2HMiV16lhR7XA1L7A3NyzFxOOdfDjgfxD18RlwvS5H8x3QdRrql2FS+qE8K8oyi/pBvwRjWBKvfNfq/vgPiJB02IgFePsC2MN+nJcyrbXSsY6xtm6bCsW+zjNPO4aGgOGmEh/8+MptKzeC4xWmSdOi8RbN0epW7tcS4icj1DVwDKn+HEx7y0CyeC6qb7U2fAcWUurOw2to2fZPTTzHqUE+vodBoNvzCkb//sorr4yt6b4WWzrsAtQUSZ3A94akpC0LHnz2C7xPluXFaONrSRsMpuTb/d726fg5F41o1UoVvW3bVmVLc8OjxEmrxzAKZy4QdNv9T5d119/cfGTDutde2g+ToKBve4OhABBPtVKxoAKBRhaNe/aWex5vxP3duHGj95rpc557808PL0InJx6Y8KzTdhzOYkFzPeZ0yzMll05fR9O2SCCQL6Pl609bfECCU3XD2spsq9bwou9+rMWSxM2oa/vk1za59G0LGr+qwVt/LToDJGgmLGDZo7PGZsz7yO7fYQ5GDz2DerSXDCUpi/80mAzsfETCwYzTPSNPOmoKRhHIHVn02BU33f4Fum9RLO/8OQv25eXpx3o8Xetebk4298KTv0EvP3I3UVZWoo0oj0wJ+DoLe8vDC5zfejAHYgGFotBlqGCQK0ZNmQnRvKd7yuXkFHuff+jWbSC3oK+Zvmnm/6zgMjJW43SiJCFlemr4lXorUbF/N2EkQ6bNH7x5OewcmO62D9BvMSev8J75Dy/diJ56FQ0GerACKmR6TyB8C2HaqTAJQc75AgPWqN5Xt23kyCs/QGeA/C7Ha727fY++ja39I2Tlnmw8UimMr+SmTW0cTAZ2w2iKCoI5lHtlEjwf1cWMGV5MBU7fUFv17JYP3q4D2XtxXklJCV/66qu8lK4ycu0d521ps4+iJW6YSEpp2z/clMmGg2NBUkLf+qgEw3CB59Xd5plWKBuxrB/0bdzkrw59s/13FHXq0OZMncquWPwAa8kvyG47YSthQ/5CgRLztn28JlmSxeHRcLiQJAc9nkcanf5wwZSZ/0RoKRoKBiV4tOXG8kO2lSs5OfAQtk7gvaQEIs6/qbTomr3H/n5wR4ENwRYJDRV4cL7++mvU5v4qwRE5uoxHkVt6GkMpy1WKUcuGIkelUvtS0yyz1Dplzz6YEijCG/QXeT2up0G7J2EywKHJtFmPPyYIwrdQRFjzzDMogHyXOQ4ceg7M/GgkS2psDfCaBvtmxCgYDnyAMHjImt71kYjSYk8zZmjk2Bekp/3c15KV5z4k/7DPzy1ZRJoo+r7K/XseBE2FOL+kOfksVq9SqQzjX7y0ogEAS86RlpYWDg0RgxKMv3Rsavr6KQ9VncyLwVtjx3mymBHi7Fv0hrTH50uXfvCruvPC779/ILaNGAjYww3xdiJxhCuzhXWsF2Tuwl6RvKCSSny2MPkXATQEYOdVqzY23nzvY44+jxpKS9/+rmbP58ckUTLhDI5lL1+7fEkmDF7zn5fcf3GntW2DLMlJJ/sXAM/0K6VGu0+t0jQY0zK/d1qPLwdvd/YpUkkqiLrNLo5BklQiJq6vKXY67Ka+bY1Go4SGa3+i1dv+DBRnYhaAZloTjImbKXAAEw1Jxw0pGYcrD+5qgG3bgJzIBMXfWFMz5Lj6oARj5OZezB537n44IB1ScxJ7Q1en5ORQ1PEWZ++Yq9NZ/jBjZmHVrAdKw0m+EPLkjkXnwh/4X3Alo2p3DWJ5L6EQUhKt7i/vjIreByFwmdJNLqhFp57Juqkw46btsnxbT72n224MBTfeOL99eXXZtx1u15WxDNAK8Djx+bINHLBbgfikblObZE594rdL33ij+108CUWpRtVXZntbSxNNMSxE8WDvS4ITFC3cufNfePx6dg94gld8+68LYluvXrBaK0xsJDQXkxvrF0n58kePn33z3Y/1OGh+v5v4ft+XDDrLGBLBGPnpF7mrXVvul9gGLZwAzexa5QhSkKIzOtn6S6gMiAVHDRuDCvX+FFe0LaCpC3RG0xmRajZLQngMJVMXRlD55RIvZvX+Lhpk+IyqrLlBZ+au712rezpYVGTA3vEZfUKLPeJlT93do9lgUEmdyZhUX1/PCFE2rSe4IEmdw/InbMOkglbEjnyMJGmudLvG9J1cF8wcb920qgHHBUbhe1HgJvqaakb9/cVHj4TUEZQm5KG0CeM1ez5tmA1x/FPebaipMcG+vEezBZ47dt2vf3tYvguH5Z9BK1Y8gL74YE0xWBrwC5XobGLIBGOMTrmqFUKKV1c6q2+P8O4lsL6lxgaCICCcGZ0YjLZNhFFDQa4J2SMnX4oFAvDS1eVA/EAnCYhJcq1rUFLrKdnH3dTn8HMHOkPQSlVHbxPKR1iTz+eDRQ71LAGgafq6Ywdvy8geseKTTCWf2OIwlH+39UVoVFpvWUpo9Zgxc7m1f16ytP545Xo8QXmON1ce/naLOSXlOUpUHPLTrsTGbe/dH2Ujo/u2JSfT5IfYbc+5tEKhGL3+ry/OTDYY9gQVGyAeSI2sC1a92ZtcmCRn5RTqRxGMQRAxz3H1Mcem8rDgfJCXuamSJGQQ3TEVgurzwsDywMXQijL3w0N8ikpEg2CghYgLhzp7N6G91ZFzM3i9f1ly/85IJHQNtBaPJun1uBdFwuG5JEV0iqKUEQ2HsiHuK0C7eqyJOsEQG/n8SZd/2tRw9AhEwMbh3goCZ3HYmlfhs1987Inz4ITrBBeNZhG9TMDYyXPc//z4oy9g8EZAh0lwpnTW2qrSVrWmSsJOlgBedDSSBJEsodvJYiMRJZ6gFRWH0WnGBg0Vg/vl/aAw44YyX8OYeQxlvEpFG5fQhOoriqC9cgwibvZPvU6ZGnKEhYHhZRjc2CVKoszTfL/Txx/oaAMtkGLlRUH2uBzn4wHLSxuzzmBKWQoWxYdbiomIsuHCcDAwmYtE0rR6w8dGc8pr3fXA1khOMCSlYplTpkyJ5A4vnKdL0H8GZh8fgcpgBeQuzxpOZRQq27hJ0x6GdR7F2ijieSJgKyKlpGYt02r1pdhlxj44hFVUkXCoJBIMTIR20lDvap3BuEM8WS/sAujyHRsNBgPWZrGn3zLW7KefHipNP16DewPHnuEHf7pTccy9N4GXWlJoSc6SSdIoyawGrPUZTyCCUNl7319yw52uim+23BNlWT2+pymSN+dMaO/v/bETJ22NdIavFrsO/5GSpqTy8nJm9l13hWHNfcXfdGiX094ymYMzarxm63SJPlNScg3Mm3KlIVVnMJj2YU0RRRFlDyvqiYvP+93iI599tvqXrbX2C5wt1nN4nlXBaZKQnj28KcWStX/WBTNcbpejKwAkQj8kuRahreiOR/7Y/Nlnny1oqdpV2uZoyQdnjaEoCM6npLpTM3MO3GwPV23INRclpXpWxV6FenOyMiRz7rjwiKIxCxl1QowrldGAYwTx//kRRxxxxBFHHHHEEUccccQRRxxxxBHH/zP8Lxg8Eh9Y8imKAAAAAElFTkSuQmCC
name: QRadar v3
script:
  commands:
  - arguments:
    - description: The offense ID to retrieve its details. Specify offense_id to get
        details about a specific offense.
      name: offense_id
    - auto: PREDEFINED
      defaultValue: None
      description: IPs enrichment transforms IDs of the IPs of the offense to IP values.
        Asset enrichment adds correlated assets to the fetched offenses.
      name: enrichment
      predefined:
      - IPs
      - IPs And Assets
      - None
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query to filter offenses, e.g., "severity >= 4 AND id > 5 AND
        status=OPEN". For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,severity,status". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-offenses-GET.html.'
      isArray: true
      name: fields
    description: Gets offenses from QRadar.
    name: qradar-offenses-list
    outputs:
    - contextPath: QRadar.Offense.Description
      description: Description of the offense.
      type: String
    - contextPath: QRadar.Offense.Rules.id
      description: The ID of the rule.
      type: Number
    - contextPath: QRadar.Offense.Rules.type
      description: The type of the rule.
      type: String
    - contextPath: QRadar.Offense.Rules.name
      description: The name of the rule.
      type: String
    - contextPath: QRadar.Offense.EventCount
      description: Number of events that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.FlowCount
      description: Number of flows that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.AssignedTo
      description: The user to whom the offense is assigned.
      type: String
    - contextPath: QRadar.Offense.Followup
      description: Whether the offense is marked for follow-up.
      type: Boolean
    - contextPath: QRadar.Offense.SourceAddress
      description: Source addresses (IPs if IPs enrich have been requested, else IDs
        of the IPs) that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.Protected
      description: Whether the offense is protected.
      type: Boolean
    - contextPath: QRadar.Offense.ClosingUser
      description: The user who closed the offense.
      type: String
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destination networks that are associated with the offense.
      type: String
    - contextPath: QRadar.Offense.CloseTime
      description: Time when the offense was closed.
      type: Date
    - contextPath: QRadar.Offense.RemoteDestinationCount
      description: Number of remote destinations that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.StartTime
      description: Date of the earliest item that contributed to the offense.
      type: Date
    - contextPath: QRadar.Offense.Magnitude
      description: Magnitude of the offense.
      type: Number
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: Date of the most recent item that contributed to the offense.
      type: String
    - contextPath: QRadar.Offense.Credibility
      description: Credibility of the offense.
      type: Number
    - contextPath: QRadar.Offense.ID
      description: ID of the offense.
      type: Number
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
      type: String
    - contextPath: QRadar.Offense.Severity
      description: Severity of the offense.
      type: Number
    - contextPath: QRadar.Offense.ClosingReason
      description: Reason the offense was closed.
      type: String
    - contextPath: QRadar.Offense.OffenseType
      description: Type of the offense.
      type: String
    - contextPath: QRadar.Offense.Relevance
      description: Relevance of the offense.
      type: Number
    - contextPath: QRadar.Offense.OffenseSource
      description: Source of the offense.
      type: String
    - contextPath: QRadar.Offense.DestinationAddress
      description: Destination addresses (IPs if IPs enrichment have been requested,
        else IDs of the IPs) that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.Status
      description: 'Status of the offense. Possible values: "OPEN", "HIDDEN", "CLOSED".'
      type: String
    - contextPath: QRadar.Offense.LinkToOffense
      description: Link to the URL containing information about the offense.
      type: String
    - contextPath: QRadar.Offense.Assets
      description: Assets correlated to the offense, if enrichment was requested.
      type: String
  - arguments:
    - description: The ID of the offense to update.
      name: offense_id
      required: true
    - auto: PREDEFINED
      defaultValue: None
      description: IPs enrichment transforms IDs of the IPs of the offense to IP values.
        Asset enrichment adds correlated assets to the fetched offenses.
      name: enrichment
      predefined:
      - IPs
      - IPs And Assets
      - None
    - auto: PREDEFINED
      description: Whether the offense should be protected.
      name: protected
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the offense should be marked for follow-up.
      name: follow_up
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: The new status for the offense. When the status of an offense is
        set to CLOSED, a valid closing_reason_id must be provided. To hide an offense,
        use the HIDDEN status. To show a previously hidden offense, use the OPEN status.
      name: status
      predefined:
      - OPEN
      - HIDDEN
      - CLOSED
    - description: The ID of a closing reason. You must provide a valid closing_reason_id
        when you close an offense. For a full list of closing reason IDs, use the
        'qradar-closing-reasons' command.
      name: closing_reason_id
    - description: 'The name of a closing reason. You must provide a valid closing_reason_name
        when you close an offense. The default closing_reasons are: (1) False-Positive,
        Tuned (2) Non-Issues (3) Policy Violation.'
      name: closing_reason_name
    - description: User to assign the offense to.
      name: assigned_to
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,severity,status". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-offenses-offense_id-POST.html.'
      isArray: true
      name: fields
    description: Updates an offense.
    name: qradar-offense-update
    outputs:
    - contextPath: QRadar.Offense.Description
      description: Description of the offense.
      type: String
    - contextPath: QRadar.Offense.Rules.id
      description: The ID of the rule.
      type: Number
    - contextPath: QRadar.Offense.Rules.type
      description: The type of the rule.
      type: String
    - contextPath: QRadar.Offense.Rules.name
      description: The name of the rule.
      type: String
    - contextPath: QRadar.Offense.EventCount
      description: Number of events that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.FlowCount
      description: Number of flows that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.AssignedTo
      description: The user to whom the offense is assigned.
      type: String
    - contextPath: QRadar.Offense.Followup
      description: Whether the offense is marked for follow-up.
      type: Boolean
    - contextPath: QRadar.Offense.SourceAddress
      description: Source addresses (IPs if IPs enrich have been requested, else IDs
        of the IPs) that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.Protected
      description: Whether the offense is protected.
      type: Boolean
    - contextPath: QRadar.Offense.ClosingUser
      description: The user who closed the offense.
      type: String
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destination networks that are associated with the offense.
      type: String
    - contextPath: QRadar.Offense.CloseTime
      description: Time when the offense was closed.
      type: Date
    - contextPath: QRadar.Offense.RemoteDestinationCount
      description: Number of remote destinations that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.StartTime
      description: Date of the earliest item that contributed to the offense.
      type: Date
    - contextPath: QRadar.Offense.Magnitude
      description: Magnitude of the offense.
      type: Number
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: Date of the most recent item that contributed to the offense.
      type: String
    - contextPath: QRadar.Offense.Credibility
      description: Credibility of the offense.
      type: Number
    - contextPath: QRadar.Offense.ID
      description: ID of the offense.
      type: Number
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
      type: String
    - contextPath: QRadar.Offense.Severity
      description: Severity of the offense.
      type: Number
    - contextPath: QRadar.Offense.ClosingReason
      description: Reason the offense was closed.
      type: String
    - contextPath: QRadar.Offense.OffenseType
      description: Type of the offense.
      type: String
    - contextPath: QRadar.Offense.Relevance
      description: Relevance of the offense.
      type: Number
    - contextPath: QRadar.Offense.OffenseSource
      description: Source of the offense.
      type: String
    - contextPath: QRadar.Offense.DestinationAddress
      description: Destination addresses (IPs if IPs enrichment have been requested,
        else IDs of the IPs) that are associated with the offense.
      type: Number
    - contextPath: QRadar.Offense.Status
      description: 'Status of the offense. Possible values: "OPEN", "HIDDEN", "CLOSED".'
      type: String
    - contextPath: QRadar.Offense.LinkToOffense
      description: Link to the URL containing information about the offense.
      type: String
    - contextPath: QRadar.Offense.Assets
      description: Assets correlated to the offense, if enrichment was requested.
      type: String
  - arguments:
    - description: The closing reason ID for which to retrieve its details. Specify
        closing_reason_id to get details about a specific closing reason.
      name: closing_reason_id
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, reserved closing reasons are included in the response.
      name: include_reserved
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, deleted closing reasons are included in the response.
      name: include_deleted
      predefined:
      - "true"
      - "false"
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query to filter closing reasons, e.g. "id > 5". For reference
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,text". Specify subfields
        in brackets and multiple fields in the same object separated by commas. For
        a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-offense_closing_reasons-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of offense closing reasons.
    name: qradar-closing-reasons
    outputs:
    - contextPath: QRadar.Offense.ClosingReasons.IsDeleted
      description: Whether the closing reason is deleted. Deleted closing reasons
        cannot be used to close an offense.
      type: Boolean
    - contextPath: QRadar.Offense.ClosingReasons.IsReserved
      description: Whether the closing reason is reserved. Reserved closing reasons
        cannot be used to close an offense.
      type: Boolean
    - contextPath: QRadar.Offense.ClosingReasons.Name
      description: Name of the closing reason.
      type: String
    - contextPath: QRadar.Offense.ClosingReasons.ID
      description: ID of the closing reason.
      type: Number
  - arguments:
    - description: The offense ID to retrieve the notes for.
      name: offense_id
      required: true
    - description: The note ID for which to retrieve its details. Specify note_id
        to get details about a specific note.
      name: note_id
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query to filter offense notes, e.g., "username=admin". For reference,
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "username,note_text". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-offenses-offense_id-notes-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of notes for an offense.
    name: qradar-offense-notes-list
    outputs:
    - contextPath: QRadar.Note.Text
      description: The text of the note.
      type: String
    - contextPath: QRadar.Note.CreateTime
      description: Creation date of the note.
      type: Date
    - contextPath: QRadar.Note.ID
      description: ID of the note.
      type: Number
    - contextPath: QRadar.Note.CreatedBy
      description: The user who created the note.
      type: String
  - arguments:
    - description: The offense ID to add the note to.
      name: offense_id
      required: true
    - description: The text of the note.
      name: note_text
      required: true
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "username,note_text". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-offenses-offense_id-notes-POST.html.'
      isArray: true
      name: fields
    description: Creates a note on an offense.
    name: qradar-offense-note-create
    outputs:
    - contextPath: QRadar.Note.Text
      description: The text of the note.
      type: String
    - contextPath: QRadar.Note.CreateTime
      description: Creation date of the note.
      type: Date
    - contextPath: QRadar.Note.ID
      description: ID of the note.
      type: Number
    - contextPath: QRadar.Note.CreatedBy
      description: The user who created the note.
      type: String
  - arguments:
    - description: The rule ID for which to retrieve its details. Specify rule_id
        to get details about a specific rule.
      name: rule_id
    - auto: PREDEFINED
      description: Retrieves rules corresponding to the specified rule type.
      name: rule_type
      predefined:
      - EVENT
      - FLOW
      - COMMON
      - USER
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter rules, e.g., "type=EVENT". For reference,
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "owner,identifier,origin".
        Specify subfields in brackets and multiple fields in the same object separated
        by commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--analytics-rules-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of rules.
    name: qradar-rules-list
    outputs:
    - contextPath: QRadar.Rule.Owner
      description: Owner of the rule.
      type: String
    - contextPath: QRadar.Rule.BaseHostID
      description: ID of the host from which the rule's base capacity was determined.
      type: Number
    - contextPath: QRadar.Rule.CapacityTimestamp
      description: Date when the rule's capacity values were last updated.
      type: Number
    - contextPath: QRadar.Rule.Origin
      description: 'Origin of the rule. Possible values: "SYSTEM", "OVERRIDE", "USER".'
      type: String
    - contextPath: QRadar.Rule.CreationDate
      description: Date when rule was created.
      type: Date
    - contextPath: QRadar.Rule.Type
      description: 'Type of the rule. Possible values: "EVENT", "FLOW", "COMMON",
        "USER".'
      type: String
    - contextPath: QRadar.Rule.Enabled
      description: Whether rule is enabled.
      type: Boolean
    - contextPath: QRadar.Rule.ModificationDate
      description: Date when the rule was last modified.
      type: Date
    - contextPath: QRadar.Rule.Name
      description: Name of the rule.
      type: String
    - contextPath: QRadar.Rule.AverageCapacity
      description: Moving average capacity in EPS of the rule across all hosts.
      type: Number
    - contextPath: QRadar.Rule.ID
      description: ID of the rule.
      type: Number
    - contextPath: QRadar.Rule.BaseCapacity
      description: Base capacity of the rule in events per second.
      type: Number
  - arguments:
    - description: The rule group ID for which to retrieve its details. Specify rule_group_id
        to get details about a specific rule group.
      name: rule_group_id
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter rules, e.g., "id >= 125". For reference,
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "owner,parent_id". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--analytics-rule_groups-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of the rule groups.
    name: qradar-rule-groups-list
    outputs:
    - contextPath: QRadar.RuleGroup.Owner
      description: Owner of the group.
      type: String
    - contextPath: QRadar.RuleGroup.ModifiedTime
      description: Date since the group was last modified.
      type: Date
    - contextPath: QRadar.RuleGroup.Level
      description: Depth of the group in the group hierarchy.
      type: Number
    - contextPath: QRadar.RuleGroup.Name
      description: Name of the group.
      type: String
    - contextPath: QRadar.RuleGroup.Description
      description: Description of the group.
      type: String
    - contextPath: QRadar.RuleGroup.ID
      description: ID of the group.
      type: Number
    - contextPath: QRadar.RuleGroup.ChildItems
      description: Child items of the group.
      type: String
    - contextPath: QRadar.RuleGroup.ChildGroups
      description: Child group IDs.
      type: Number
    - contextPath: QRadar.RuleGroup.Type
      description: The type of the group.
      type: String
    - contextPath: QRadar.RuleGroup.ParentID
      description: ID of the parent group.
      type: Number
  - arguments:
    - description: The asset ID for which to retrieve its details. Specify asset_id
        to get details about a specific asset.
      name: asset_id
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter assets, e.g., "domain_id=0". For reference,
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,interfaces,users,properties".
        Specify subfields in brackets and multiple fields in the same object separated
        by commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--asset_model-assets-GET.html.'
      isArray: true
      name: fields
    description: Retrieves assets list.
    name: qradar-assets-list
    outputs:
    - contextPath: Endpoint.Domain
      description: DNS name.
      type: String
    - contextPath: Endpoint.OS
      description: Asset operating system.
      type: String
    - contextPath: Endpoint.MACAddress
      description: Asset MAC address.
      type: String
    - contextPath: Endpoint.IPAddress
      description: IP addresses of the endpoint.
      type: Unknown
    - contextPath: QRadar.Asset.Interfaces.id
      description: ID of the interface.
      type: Number
    - contextPath: QRadar.Asset.Interfaces.mac_address
      description: MAC address of the interface. Null if unknown.
      type: String
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.id
      description: ID of the interface.
      type: Number
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.network_id
      description: Network ID of the network the IP belongs to.
      type: Number
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.value
      description: The IP address.
      type: String
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.type
      description: 'Type of IP address. Possible values: "IPV4", "IPV6".'
      type: String
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.created
      description: Date when the IP address was created.
      type: Date
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.first_seen_scanner
      description: Date when the IP address was first seen during a vulnerability
        scan.
      type: Date
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.first_seen_profiler
      description: Date when the IP address was first seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.last_seen_scanner
      description: Date when the IP address was most recently seen during a vulnerability
        scan.
      type: Date
    - contextPath: QRadar.Asset.Interfaces.ip_addresses.last_seen_profiler
      description: Date when the IP address was most recently seen in event or flow
        traffic.
      type: Date
    - contextPath: QRadar.Asset.Products.id
      description: The ID of this software product instance in QRadar's asset model.
      type: Number
    - contextPath: QRadar.Asset.Products.product_variant_id
      description: The ID of this software product variant in QRadar's catalog of
        products.
      type: Number
    - contextPath: QRadar.Asset.Products.first_seen_scanner
      description: Date when the product was first seen during a vulnerability scan.
      type: Date
    - contextPath: QRadar.Asset.Products.first_seen_profiler
      description: Date when the product was first seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.Products.last_seen_scanner
      description: Date when the product was most recently seen seen during a vulnerability
        scan.
      type: Date
    - contextPath: QRadar.Asset.Products.last_seen_profiler
      description: Date when the product was most recently seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.VulnerabilityCount
      description: The total number of vulnerabilities associated with this asset.
      type: Number
    - contextPath: QRadar.Asset.RiskScoreSum
      description: The sum of the CVSS scores of the vulnerabilities on this asset.
      type: Number
    - contextPath: QRadar.Asset.Hostnames.last_seen_profiler
      description: Date when the host was most recently seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.Hostnames.created
      description: Date when the host was created.
      type: Date
    - contextPath: QRadar.Asset.Hostnames.last_seen_scanner
      description: Date when the host was most recently seen during a vulnerability
        scan.
      type: Date
    - contextPath: QRadar.Asset.Hostnames.name
      description: Name of the host.
      type: String
    - contextPath: QRadar.Asset.Hostnames.first_seen_scanner
      description: Date when the host was first seen during a vulnerability scan.
      type: Date
    - contextPath: QRadar.Asset.Hostnames.id
      description: ID of the host.
      type: Number
    - contextPath: QRadar.Asset.Hostnames.type
      description: 'Type of the host. Possible values: "DNS", "NETBIOS", "NETBIOSGROUP".'
      type: String
    - contextPath: QRadar.Asset.Hostnames.first_seen_profiler
      description: Date when the host was first seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.ID
      description: ID of the asset.
      type: Number
    - contextPath: QRadar.Asset.Users.last_seen_profiler
      description: Date when the user was most recently seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.Users.last_seen_scanner
      description: Date when the user was most recently seen during a vulnerability
        scan.
      type: Date
    - contextPath: QRadar.Asset.Users.first_seen_scanner
      description: Date when the user was first seen during a vulnerability scan.
      type: Date
    - contextPath: QRadar.Asset.Users.id
      description: ID of the user.
      type: Number
    - contextPath: QRadar.Asset.Users.first_seen_profiler
      description: Date when the user was first seen in event or flow traffic.
      type: Date
    - contextPath: QRadar.Asset.Users.username
      description: Name of the user.
      type: String
    - contextPath: QRadar.Asset.DomainID
      description: ID of the domain this asset belongs to.
      type: Number
    - contextPath: QRadar.Asset.Properties.last_reported
      description: Date when the property was last updated.
      type: Date
    - contextPath: QRadar.Asset.Properties.name
      description: Name of the property.
      type: String
    - contextPath: QRadar.Asset.Properties.type_id
      description: Type ID of the property.
      type: Number
    - contextPath: QRadar.Asset.Properties.id
      description: ID of the property.
      type: Number
    - contextPath: QRadar.Asset.Properties.last_reported_by
      description: The source of the most recent update to this property.
      type: String
    - contextPath: QRadar.Asset.Properties.value
      description: Property value.
      type: String
  - arguments:
    - description: The saved search ID for which to retrieve its details. Specify
        saved_search_id to get details about a specific saved search.
      name: saved_search_id
    - defaultValue: "35"
      description: Number of seconds until timeout for the specified command.
      name: timeout
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter saved searches, e.g., "database=EVENTS
        and is_dashboard=true". For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,owner,description".
        Specify subfields in brackets and multiple fields in the same object separated
        by commas. For a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--ariel-saved_searches-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of Ariel saved searches.
    name: qradar-saved-searches-list
    outputs:
    - contextPath: QRadar.SavedSearch.Owner
      description: Owner of the saved search.
      type: String
    - contextPath: QRadar.SavedSearch.Description
      description: Description of the saved search.
      type: String
    - contextPath: QRadar.SavedSearch.CreationDate
      description: Date when saved search was created.
      type: Date
    - contextPath: QRadar.SavedSearch.UID
      description: UID of the saved search.
      type: String
    - contextPath: QRadar.SavedSearch.Database
      description: The database of the Ariel saved search, events, or flows.
      type: String
    - contextPath: QRadar.SavedSearch.QuickSearch
      description: Whether the saved search is a quick search.
      type: Boolean
    - contextPath: QRadar.SavedSearch.Name
      description: Name of the saved search.
      type: String
    - contextPath: QRadar.SavedSearch.ModifiedDate
      description: Date when the saved search was most recently modified.
      type: Date
    - contextPath: QRadar.SavedSearch.ID
      description: ID of the saved search.
      type: Number
    - contextPath: QRadar.SavedSearch.AQL
      description: The AQL query.
      type: String
    - contextPath: QRadar.SavedSearch.IsShared
      description: Whether the saved search is shared with other users.
      type: Boolean
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    description: Retrieves the list of Ariel searches IDs. Search status and results
      can be polled by sending the search ID to the 'qradar-search-status-get' and
      'qradar-search-results-get' commands.
    name: qradar-searches-list
    outputs:
    - contextPath: QRadar.SearchID.SearchID
      description: ID of the search.
      type: String
  - arguments:
    - description: The ID of the offense to retrieve. Mutually exclusive with query_expression
        and saved_search_id.
      name: offense_id
      type: Number
    - description: The number of events to return. Mutually exclusive with query_expression
        and saved_search_id.
      name: events_limit
      type: Number
    - description: Comma separated list of columns to return. Mutually exclusive with
        query_expression and saved_search_id.
      name: events_columns
      type: String
    - description: The mode to use when fetching events. Mutually exclusive with query_expression
        and saved_search_id.
      name: fetch_mode
      predefined:
      - Fetch With All Events
      - Fetch Correlation Events Only
      type: PREDEFINED
    - description: The start time of the search.
      name: start_time
      type: Date
    - description: The AQL query to execute. Mutually exclusive with all other arguments.
      name: query_expression
    - description: Saved search ID to execute. Mutually exclusive with all other arguments.
        Saved search ID is the 'id' field returned by the 'qradar-saved-searches-list'
        command.
      name: saved_search_id
    description: Creates a new asynchronous Ariel search. Returns the search ID. Search
      status and results can be polled by sending the search ID to the 'qradar-search-status-get'
      and 'qradar-search-results-get' commands. Accepts SELECT query expressions only.
    name: qradar-search-create
    outputs:
    - contextPath: QRadar.Search.Status
      description: Status of the newly created search.
      type: String
    - contextPath: QRadar.Search.ID
      description: ID of the newly created search.
      type: String
  - arguments:
    - description: The identifier for an Ariel search.
      name: search_id
      required: true
    description: Retrieves status information for a search, based on the search ID.
    name: qradar-search-status-get
    outputs:
    - contextPath: QRadar.Search.Status
      description: Status of the search.
      type: String
    - contextPath: QRadar.Search.ID
      description: ID of the search.
      type: String
  - arguments:
    - description: The identifier for an Ariel search.
      name: search_id
      required: true
    - description: Replaces the default context output path for the query result (QRadar.Search.Result).
        E.g., for output_path=QRadar.Correlations, the result will be under the 'QRadar.Correlations'
        key in the context data.
      name: output_path
    - defaultValue: 0-49
      description: 'Range of events to return. (e.g.: 0-20, 3-5, 3-3).'
      name: range
    description: Retrieves search results.
    name: qradar-search-results-get
    outputs:
    - contextPath: QRadar.Search.Result
      description: The result of the search.
      type: Unknown
  - arguments:
    - description: The identifier for an Ariel search.
      name: search_id
      required: true
    description: Deletes the search from Qradar.
    name: qradar-search-delete
  - arguments:
    - description: The identifier for an Ariel search.
      name: search_id
      required: true
    description: Cancels the search in QRadar.
    name: qradar-search-cancel
  - arguments:
    - description: The reference name of the reference set for which to retrieve its
        details. Specify ref_name to get details about a specific reference set.
      name: ref_name
    - auto: PREDEFINED
      defaultValue: "False"
      description: If set to true will try to convert the data values to ISO-8601
        string.
      name: date_value
      predefined:
      - "True"
      - "False"
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: |-
        Query by which to filter reference sets, e.g., "timeout_type=FIRST_SEEN". For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html.
        when using both ref_name and filter arguments, the filter should be from the data values of the specified reference set, e.g. "value='1.1.1.1'".
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "name,timeout_type". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--reference_data-sets-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of reference sets.
    name: qradar-reference-sets-list
    outputs:
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Timeout type of the reference set. Possible values: "UNKNOWN",
        "FIRST_SEEN", "LAST_SEEN".'
      type: String
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements in the reference set.
      type: Number
    - contextPath: QRadar.Reference.TimeToLive
      description: Time left to live for the reference.
      type: String
    - contextPath: QRadar.Reference.Data.LastSeen
      description: Date when this data was last seen.
      type: Date
    - contextPath: QRadar.Reference.Data.FirstSeen
      description: Date when this data was first seen.
      type: Date
    - contextPath: QRadar.Reference.Data.Source
      description: Source of this data.
      type: String
    - contextPath: QRadar.Reference.Data.Value
      description: Data value.
      type: String
    - contextPath: QRadar.Reference.CreationTime
      description: Date when the reference set was created.
      type: Date
    - contextPath: QRadar.Reference.Name
      description: Name of the reference set.
      type: String
    - contextPath: QRadar.Reference.ElementType
      description: Type of the elements in the reference set.
      type: String
  - arguments:
    - description: The name of the reference set to be created.
      name: ref_name
      required: true
    - auto: PREDEFINED
      description: The element type for the values allowed in the reference set.
      name: element_type
      predefined:
      - ALN
      - ALNIC
      - NUM
      - IP
      - PORT
      - DATE
      required: true
    - auto: PREDEFINED
      defaultValue: UNKNOWN
      description: Indicates if the time_to_live interval is based on when the data
        was first seen or last seen.
      name: timeout_type
      predefined:
      - FIRST_SEEN
      - LAST_SEEN
      - UNKNOWN
    - description: 'The time to live interval, time range. for example: ''1 month''
        or ''5 minutes''.'
      name: time_to_live
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "name,timeout_type". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--reference_data-sets-POST.html.'
      isArray: true
      name: fields
    description: Creates a new reference set.
    name: qradar-reference-set-create
    outputs:
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Timeout type of the reference set. Possible values: "UNKNOWN",
        "FIRST_SEEN", "LAST_SEEN".'
      type: String
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements in the reference set.
      type: Number
    - contextPath: QRadar.Reference.TimeToLive
      description: Time left to live for the reference.
      type: String
    - contextPath: QRadar.Reference.Data.LastSeen
      description: Date when this data was last seen.
      type: Date
    - contextPath: QRadar.Reference.Data.FirstSeen
      description: Date when this data was first seen.
      type: Date
    - contextPath: QRadar.Reference.Data.Source
      description: Source of this data.
      type: String
    - contextPath: QRadar.Reference.Data.Value
      description: Data value.
      type: String
    - contextPath: QRadar.Reference.CreationTime
      description: Date when the reference set was created.
      type: Date
    - contextPath: QRadar.Reference.Name
      description: Name of the reference set.
      type: String
    - contextPath: QRadar.Reference.ElementType
      description: Type of the elements in the reference set.
      type: String
  - arguments:
    - description: The name of the reference set to be deleted. Reference names can
        be found by 'Name' field in 'qradar-reference-sets-list' command.
      name: ref_name
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Indicates if the reference set should have its contents purged
        (true), keeping the reference set structure. If the value is 'false', or not
        specified the reference set is removed completely.
      name: purge_only
      predefined:
      - "true"
      - "false"
    description: Removes a reference set or purges its contents.
    name: qradar-reference-set-delete
  - arguments:
    - description: The name of the reference set to add or update an element in. Reference
        names can be found by the 'Name' field in the 'qradar-reference-sets-list'
        command.
      name: ref_name
      required: true
    - description: 'Comma-separated list of the values to add or update in the reference
        set. If the values are dates, the supported date formats are: epoch, ISO,
        and time range (<number> <time unit>'', e.g., 12 hours, 7 days.).'
      isArray: true
      name: value
      required: true
    - defaultValue: reference data api
      description: An indication of where the data originated.
      name: source
    - auto: PREDEFINED
      description: True if the specified value  type was date.
      name: date_value
      predefined:
      - "true"
      - "false"
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "name,timeout_type". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--reference_data-sets-name-POST.html.'
      isArray: true
      name: fields
    - description: The ID of the task that is created to add or update the element
        in the reference set. The task ID can be used to poll the status of the task
        by using the 'qradar-tasks-get' command.
      name: task_id
    description: Adds or updates an element in a reference set.
    name: qradar-reference-set-value-upsert
    outputs:
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Timeout type of the reference set. Possible values: "UNKNOWN",
        "FIRST_SEEN", "LAST_SEEN".'
      type: String
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements in the reference set.
      type: Number
    - contextPath: QRadar.Reference.TimeToLive
      description: Time left to live for the reference.
      type: String
    - contextPath: QRadar.Reference.Data.LastSeen
      description: Date when this data was last seen.
      type: Date
    - contextPath: QRadar.Reference.Data.FirstSeen
      description: Date when this data was first seen.
      type: Date
    - contextPath: QRadar.Reference.Data.Source
      description: Source of this data.
      type: String
    - contextPath: QRadar.Reference.Data.Value
      description: Data value.
      type: String
    - contextPath: QRadar.Reference.CreationTime
      description: Date when the reference set was created.
      type: Date
    - contextPath: QRadar.Reference.Name
      description: Name of the reference set.
      type: String
    - contextPath: QRadar.Reference.ElementType
      description: Type of the elements in the reference set.
      type: String
    polling: true
  - arguments:
    - description: The name of the reference set from which to remove a value. Reference
        names can be found by the 'Name' field in the 'qradar-reference-sets-list'
        command.
      name: ref_name
      required: true
    - description: 'The value to remove from the reference set. If the specified value
        is date, the supported date formats are: epoch, ISO, and time range (<number>
        <time unit>, e.g., 12 hours, 7 days.)'
      name: value
      required: true
    - auto: PREDEFINED
      description: True if the specified value type was date.
      name: date_value
      predefined:
      - "True"
      - "False"
    description: Removes a value from a reference set.
    name: qradar-reference-set-value-delete
  - arguments:
    - description: The domain ID from which to retrieve its details. Specify domain_id
        to get details about a specific domain.
      name: domain_id
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter domains, e.g., "id > 3". For reference,
        see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name". Specify subfields
        in brackets and multiple fields in the same object separated by commas. For
        a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--config-domain_management-domains-GET.html.'
      isArray: true
      name: fields
    description: Gets the list of domains. You must have System Administrator or Security
      Administrator permissions to call this endpoint if you are trying to retrieve
      the details of all domains. You can retrieve details of domains that are assigned
      to your Security Profile without having the System Administrator or Security
      Administrator permissions. If you do not have the System Administrator or Security
      Administrator permissions, then for each domain assigned to your security profile
      you can only view the values for the ID and name fields. All other values return
      null.
    name: qradar-domains-list
    outputs:
    - contextPath: QRadar.Domains.AssetScannerIDs
      description: Asset scanner IDs that are associated with the domain.
      type: Number
    - contextPath: QRadar.Domains.CustomProperties
      description: Custom properties of the domain.
      type: Unknown
    - contextPath: QRadar.Domains.Deleted
      description: Whether the domain has been deleted.
      type: Boolean
    - contextPath: QRadar.Domains.Description
      description: Description of the domain.
      type: String
    - contextPath: QRadar.Domains.EventCollectorIDs
      description: Event collector IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.FlowCollectorIDs
      description: Flow collector IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.FlowSourceIDs
      description: Flow source IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.ID
      description: ID of the domain.
      type: Number
    - contextPath: QRadar.Domains.LogSourceGroupIDs
      description: Log source group IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.LogSourceIDs
      description: Log source IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.Name
      description: Name of the domain.
      type: String
    - contextPath: QRadar.Domains.QVMScannerIDs
      description: QVM scanner IDs that are assigned to this domain.
      type: Number
    - contextPath: QRadar.Domains.TenantID
      description: ID of the tenant that this domain belongs to.
      type: Number
  - arguments:
    - description: The name of set to add or update data in. Reference names can be
        found by the 'Name' field in the 'qradar-reference-sets-list' command.
      name: ref_name
      required: true
    - description: The query for getting indicators from Cortex XSOAR.
      name: query
    - defaultValue: "50"
      description: The maximum number of indicators to fetch from Cortex XSOAR.
      name: limit
    - description: The page from which to get the indicators.
      name: page
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "name,timeout_type". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--reference_data-maps-bulk_load-namespace-name-domain_id-POST.html.'
      isArray: true
      name: fields
    - description: The ID of the task that is created to add or update the element
        in the reference set. The task ID can be used to poll the status of the task
        by using the 'qradar-tasks-get' command.
      name: task_id
    description: Uploads indicators to QRadar.
    name: qradar-indicators-upload
    outputs:
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Timeout type of the reference set. Possible values: "UNKNOWN",
        "FIRST_SEEN", "LAST_SEEN".'
      type: String
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements in the reference set.
      type: Number
    - contextPath: QRadar.Reference.TimeToLive
      description: Time left to live for the reference.
      type: String
    - contextPath: QRadar.Reference.Data.LastSeen
      description: Date when this data was last seen.
      type: Date
    - contextPath: QRadar.Reference.Data.FirstSeen
      description: Date when this data was first seen.
      type: Date
    - contextPath: QRadar.Reference.Data.Source
      description: Source of this data.
      type: String
    - contextPath: QRadar.Reference.Data.Value
      description: Data value.
      type: String
    - contextPath: QRadar.Reference.CreationTime
      description: Date when the reference set was created.
      type: Date
    - contextPath: QRadar.Reference.Name
      description: Name of the reference set.
      type: String
    - contextPath: QRadar.Reference.ElementType
      description: Type of the elements in the reference set.
      type: String
    polling: true
  - arguments:
    - description: Comma-separated list of IPs fro which to retrieve their geolocation.
      isArray: true
      name: ip
      required: true
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "continent,ip_address".
        Specify subfields in brackets and multiple fields in the same object separated
        by commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--services-geolocations-GET.html.'
      isArray: true
      name: fields
    description: Retrieves the MaxMind GeoIP data for the specified IP address.
    name: qradar-geolocations-for-ip
    outputs:
    - contextPath: QRadar.GeoForIP.CityName
      description: Name of the city that is associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.ContinentName
      description: Name of the continent that is associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.LocationAccuracyRadius
      description: The approximate accuracy radius in kilometers around the latitude
        and longitude for the IP address.
      type: Number
    - contextPath: QRadar.GeoForIP.LocationAverageIncome
      description: The average income associated with the IP address.
      type: Number
    - contextPath: QRadar.GeoForIP.LocationLatitude
      description: The approximate latitude of the location associated with the IP
        address.
      type: Number
    - contextPath: QRadar.GeoForIP.LocationTimezone
      description: Timezone of the location.
      type: String
    - contextPath: QRadar.GeoForIP.LocationLongitude
      description: The approximate longitude of the location associated with the IP
        address.
      type: Number
    - contextPath: QRadar.GeoForIP.LocationMetroCode
      description: The metro code associated with the IP address. These are only available
        for IP addresses in the US. Returns the same metro codes as the Google AdWords
        API.
      type: Number
    - contextPath: QRadar.GeoForIP.LocationPopulationDensity
      description: The estimated number of people per square kilometer.
      type: Number
    - contextPath: QRadar.GeoForIP.PhysicalCountryIsoCode
      description: ISO code of country where MaxMind believes the end user is located.
      type: String
    - contextPath: QRadar.GeoForIP.PhysicalCountryName
      description: Name of country where MaxMind believes the end user is located.
      type: String
    - contextPath: QRadar.GeoForIP.RegisteredCountryIsoCode
      description: ISO code of the country that the ISP has registered the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.RegisteredCountryName
      description: Name of the country that the ISP has registered the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.RepresentedCountryIsoCode
      description: ISO code of the country that is represented by users of the IP
        address.
      type: String
    - contextPath: QRadar.GeoForIP.RepresentedCountryName
      description: Name of the country that is represented by users of the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.RepresentedCountryConfidence
      description: Value between 0-100 that represents MaxMind's confidence that the
        represented country is correct.
      type: Number
    - contextPath: QRadar.GeoForIP.IPAddress
      description: IP address to look up.
      type: String
    - contextPath: QRadar.GeoForIP.Traits.autonomous_system_number
      description: The autonomous system number associated with the IP address.
      type: Number
    - contextPath: QRadar.GeoForIP.Traits.autonomous_system_organization
      description: The organization associated with the registered autonomous system
        number for the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.Traits.domain
      description: The second level domain associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.Traits.internet_service_provider
      description: The name of the internet service provider associated with the IP
        address.
      type: String
    - contextPath: QRadar.GeoForIP.Traits.organization
      description: The name of the organization associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.Traits.user_type
      description: The user type associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.Coordinates
      description: Latitude and longitude by MaxMind.
      type: Number
    - contextPath: QRadar.GeoForIP.PostalCode
      description: The postal code associated with the IP address.
      type: String
    - contextPath: QRadar.GeoForIP.PostalCodeConfidence
      description: Value between 0-100 that represents MaxMind's confidence that the
        postal code is correct.
      type: Number
  - arguments:
    - auto: PREDEFINED
      defaultValue: AES128
      description: The algorithm to use for encrypting the sensitive data of this
        endpoint.
      name: qrd_encryption_algorithm
      predefined:
      - AES128
      - AES256
      required: true
    - description: The password to use for encrypting the sensitive data of this endpoint.
        If password was not given, random password will be generated.
      name: qrd_encryption_password
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter log sources, e.g., "auto_discovered=false".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,status". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--config-event_sources-log_source_management-log_sources-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific log source.
      name: id
    description: Retrieves a list of log sources.
    name: qradar-log-sources-list
    outputs:
    - contextPath: QRadar.LogSource.SendingIP
      description: IP of the system which the log source is associated with, or fed
        by.
      type: String
    - contextPath: QRadar.LogSource.Internal
      description: Whether log source is internal.
      type: Boolean
    - contextPath: QRadar.LogSource.ProtocolParameters
      description: Protocol parameters.
      type: Unknown
    - contextPath: QRadar.LogSource.Description
      description: Description of the log source.
      type: String
    - contextPath: QRadar.LogSource.Enabled
      description: Whether log source is enabled.
      type: Boolean
    - contextPath: QRadar.LogSource.GroupIDs
      description: Log source group IDs.
      type: Number
    - contextPath: QRadar.LogSource.Credibility
      description: Credibility of the log source.
      type: Number
    - contextPath: QRadar.LogSource.ID
      description: ID of the log source.
      type: Number
    - contextPath: QRadar.LogSource.ProtocolTypeID
      description: Protocol type used by log source.
      type: Number
    - contextPath: QRadar.LogSource.CreationDate
      description: Date when log source was created.
      type: Date
    - contextPath: QRadar.LogSource.Name
      description: Name of the log source.
      type: String
    - contextPath: QRadar.LogSource.AutoDiscovered
      description: Whether log source was auto discovered.
      type: Boolean
    - contextPath: QRadar.LogSource.ModifiedDate
      description: Date when log source was last modified.
      type: Date
    - contextPath: QRadar.LogSource.TypeID
      description: The log source type.
      type: Number
    - contextPath: QRadar.LogSource.LastEventTime
      description: Date when the last event was received by the log source.
      type: Date
    - contextPath: QRadar.LogSource.Gateway
      description: Whether log source is configured as a gateway.
      type: Boolean
    - contextPath: QRadar.LogSource.Status
      description: Status of the log source.
      type: Unknown
  - arguments:
    - description: A comma-separated list of names of the exact properties to search
        for.
      name: field_name
    - defaultValue: "25"
      description: The maximum number of regex event properties to fetch.
      name: limit
    - description: A comma-separated list names of a properties to search for. Values
        are case insensitive.
      name: like_name
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter regex properties, e.g., "auto_discovered=false".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,gateway". Specify subfields
        in brackets and multiple fields in the same object separated by commas. For
        a full list of available fields, see: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--config-event_sources-custom_properties-regex_properties-GET.html.'
      isArray: true
      name: fields
    description: Retrieves a list of event regex properties.
    name: qradar-get-custom-properties
    outputs:
    - contextPath: QRadar.Properties.identifier
      description: ID of the event regex property.
      type: String
    - contextPath: QRadar.Properties.modification_date
      description: Date when the event regex property was last updated.
      type: Date
    - contextPath: QRadar.Properties.datetime_format
      description: Date/time pattern that the event regex property matches.
      type: String
    - contextPath: QRadar.Properties.property_type
      description: 'Property type. Possible values: "STRING", "NUMERIC", "IP", "PORT",
        "TIME".'
      type: String
    - contextPath: QRadar.Properties.name
      description: Name of the event regex property.
      type: String
    - contextPath: QRadar.Properties.auto_discovered
      description: Whether the event regex property was auto discovered.
      type: Boolean
    - contextPath: QRadar.Properties.description
      description: Description of the event regex property.
      type: String
    - contextPath: QRadar.Properties.id
      description: ID of the event regex property.
      type: Number
    - contextPath: QRadar.Properties.use_for_rule_engine
      description: Whether the event regex property is parsed when the event is received.
      type: Boolean
    - contextPath: QRadar.Properties.creation_date
      description: Date when the event regex property was created.
      type: Date
    - contextPath: QRadar.Properties.locale
      description: Language tag of what locale the property matches.
      type: String
    - contextPath: QRadar.Properties.username
      description: The owner of the event regex property.
      type: String
  - arguments: []
    description: Resets the fetch incidents last run value, which resets the fetch
      to its initial fetch state. (Will try to fetch the first available offense).
    name: qradar-reset-last-run
  - arguments: []
    description: Returns the list of fields for an incident type. This command should
      be used for debugging purposes.
    name: get-mapping-fields
  - arguments:
    - description: The offense ID.
      name: id
      required: true
    - description: Date string in local time representing the last time the incident
        was updated. The incident is only returned if it was modified after the last
        update time.
      name: lastUpdate
      required: true
    description: Gets remote data from a remote incident. This method does not update
      the current incident, and should be used for debugging purposes.
    name: get-remote-data
  - arguments:
    - description: Date string in local time representing the last time the incident
        was updated. The incident is only returned if it was modified after the last
        update time.
      name: lastUpdate
    description: Returns the list of incidents IDs that were modified since the last
      update time. Note that this method is for debugging purposes. The get-modified-remote-data
      command is used as part of the mirroring feature, which is available from version
      6.1.
    name: get-modified-remote-data
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter event collectors, e.g., "auto_discovered=false".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,status". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-event_collectors-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific event collector.
      name: id
    description: Retrieves a list of event collectors.
    name: qradar-event-collectors-list
    outputs:
    - contextPath: QRadar.EventCollector.Name
      description: The display name of the event collector. Not localized because
        it is derived from a process/component name and the hostname of the managed
        host it runs on, neither of which are translatable.
      type: String
    - contextPath: QRadar.EventCollector.HostID
      description: The ID of the host on which this event collector process runs.
      type: Number
    - contextPath: QRadar.EventCollector.ComponentName
      description: The name of the component backing this event collector process.
        Also contained in the "name" field.
      type: String
    - contextPath: QRadar.EventCollector.ID
      description: The unique ID of the event collector.
      type: Number
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter wincollect destinations, e.g., "internal=true".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,host". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-wincollect-wincollect_destinations-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific WinCollect destination.
      name: id
    description: "Retrieves a list of WinCollect destinations. \nIn order to get wincollect_internal_destination_ids
      - filter internal=true needs to be used\nIn order to get wincollect_external_destination_ids
      - filter internal=false needs to be used."
    name: qradar-wincollect-destinations-list
    outputs:
    - contextPath: QRadar.WinCollectDestination.ID
      description: The ID of the WinCollect destination.
      type: Number
    - contextPath: QRadar.WinCollectDestination.Name
      description: The name of the WinCollect destination.
      type: String
    - contextPath: QRadar.WinCollectDestination.Host
      description: The IP or hostname of the WinCollect destination. WinCollect agents
        that use this destination send syslog event data to this host.
      type: String
    - contextPath: QRadar.WinCollectDestination.TlsCertificate
      description: The TLS Certificate of the WinCollect destination.
      type: String
    - contextPath: QRadar.WinCollectDestination.Port
      description: The listen port of the WinCollect destination. WinCollect agents
        that use this destination send syslog event data to this port.
      type: Number
    - contextPath: QRadar.WinCollectDestination.TransportProtocol
      description: The protocol that is used to send event data to this WinCollect
        destination. Possible values are TCP or UDP.
      type: String
    - contextPath: QRadar.WinCollectDestination.IsInternal
      description: Set to "true" if the destination corresponds to a QRadar event
        collector process from this deployment; otherwise, it is set to false if it
        is any other host.
      type: Boolean
    - contextPath: QRadar.WinCollectDestination.EventRateThrottle
      description: The events-per-second rate that is used to throttle the event flow
        to this destination.
      type: Number
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-disconnected_log_collectors-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves a list of disconnected log collectors.
    name: qradar-disconnected-log-collectors-list
    outputs:
    - contextPath: QRadar.DisconnectedLogCollector.ID
      description: The ID of the disconnected log collector.
      type: Number
    - contextPath: QRadar.DisconnectedLogCollector.Name
      description: The name of the disconnected log Collector.
      type: String
    - contextPath: QRadar.DisconnectedLogCollector.Description
      description: The description of the disconnected log collector.
      type: String
    - contextPath: QRadar.DisconnectedLogCollector.Protocol
      description: The transport protocol used by the disconnected log collector to
        send events to QRadar. Possible values are TLS and UDP.
      type: String
    - contextPath: QRadar.DisconnectedLogCollector.UUID
      description: The UUID of the disconnected log collector.
      type: String
    - contextPath: QRadar.DisconnectedLogCollector.Version
      description: The version of the disconnected log collector.
      type: String
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_types-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves a list of log sources types.
    name: qradar-log-source-types-list
    outputs:
    - contextPath: QRadar.LogSourceTypesList.Custom
      description: The condition is set to true if this is a custom log source type;
        otherwise, the condition is set to false.
      type: Boolean
    - contextPath: QRadar.LogSourceTypesList.DefaultProtocolID
      description: The ID of the default protocol type for this log source type. The
        ID must correspond to an existing protocol type. See the Protocol Type API
        (/api/config/event_sources/log_source_management/protocol_types/).
      type: Number
    - contextPath: QRadar.LogSourceTypesList.ID
      description: The ID of the log source type.
      type: Number
    - contextPath: QRadar.LogSourceTypesList.Internal
      description: The condition is set to true if the log source type is an internal
        log source type (for example, System Notification, SIM Audit, Asset Profiler,
        and so on) for which log sources cannot be created, edited, or deleted. If
        this is a user configurable log source type, the condition is set to false.
      type: Boolean
    - contextPath: QRadar.LogSourceTypesList.LatestVersion
      description: The latest available version of the log source type component.
      type: String
    - contextPath: QRadar.LogSourceTypesList.LogSourceExtensionID
      description: The log source extension that is associated with the log source
        type. The ID must correspond to an existing log source extension or be set
        to null. See the Log Source Extension API (/api/config/event_sources/log_source_management/log_source_extensions/).
      type: Number
    - contextPath: QRadar.LogSourceTypesList.Name
      description: The unique name of the log source type. The name is not localized.
      type: String
    - contextPath: QRadar.LogSourceTypesList.protocol_types.documented
      description: Indicates whether the protocol is documented/fully supported for
        this log source type.
      type: Boolean
    - contextPath: QRadar.LogSourceTypesList.protocol_types.protocol_id
      description: ID of the protocol type.
      type: Number
    - contextPath: QRadar.LogSourceTypesList.supported_language_ids
      description: 'The IDs of the languages supported by this log source type. Each
        ID must correspond to an existing log source language. See the Log Source
        Language API: https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_languages-id-GET.html'
      type: List
    - contextPath: QRadar.LogSourceTypesList.uuid
      description: A UUID string of the log source type.
      type: String
    - contextPath: QRadar.LogSourceTypesList.version
      description: The log source type plugin version.
      type: String
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_extensions-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves a list of log source extensions.
    name: qradar-log-source-extensions-list
    outputs:
    - contextPath: QRadar.LogSourceExtension.Name
      description: The name of the log source extension.
      type: String
    - contextPath: QRadar.LogSourceExtension.Description
      description: The description of the log source extension.
      type: String
    - contextPath: QRadar.LogSourceExtension.ID
      description: The ID of the extension.
      type: Number
    - contextPath: QRadar.LogSourceExtension.UUID
      description: The UUID string of the log source extension.
      type: String
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_languages-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves a list of log source languages.
    name: qradar-log-source-languages-list
    outputs:
    - contextPath: QRadar.LogSourceLanguage.ID
      description: The ID of the language. This ID does not change across deployments.
      type: Number
    - contextPath: QRadar.LogSourceLanguage.Name
      description: The display name of the language.
      type: String
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol". Specify
        subfields in brackets and multiple fields in the same object separated by
        commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_groups-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves a list of log source languages.
    name: qradar-log-source-groups-list
    outputs:
    - contextPath: QRadar.LogSourceGroup.Assignable
      description: If log sources can be assigned to this group, the condition is
        set to true; otherwise, the condition is set to false. Log sources cannot
        be assigned directly to the "Other" group or to the root log source group
        node.
      type: Boolean
    - contextPath: QRadar.LogSourceGroup.ChildGroupIDs
      description: The list of IDs of any child log source groups that belong to this
        group.
      type: List
    - contextPath: QRadar.LogSourceGroup.Description
      description: The description of the group.
      type: String
    - contextPath: QRadar.LogSourceGroup.ID
      description: The ID of the group.
      type: Number
    - contextPath: QRadar.LogSourceGroup.ModificationDate
      description: The date and time (expressed as milliseconds since epoch) that
        the group was last modified.
      type: Number
    - contextPath: QRadar.LogSourceGroup.Name
      description: The name of the group.
      type: String
    - contextPath: QRadar.LogSourceGroup.Owner
      description: The name of the user who owns the group.
      type: String
    - contextPath: QRadar.LogSourceGroup.ParentID
      description: The ID of the group's parent group. The root node group has a null
        parent_ID.
      type: Number
  - arguments:
    - defaultValue: 0-49
      description: 'Range of results to return (e.g.: 0-20, 3-5, 3-3).'
      name: range
    - description: 'Query by which to filter disconnected log collectors, e.g., "protocol=udp".
        For reference, see: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'Comma-separated list of fields to retrieve in the response. Fields
        that are not explicitly named are excluded. E.g., "id,name,protocol_parameters".
        Specify subfields in brackets and multiple fields in the same object separated
        by commas. For a full list of available fields, see:  https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-protocol_types-GET.html.'
      isArray: true
      name: fields
    - description: ID of a specific disconnected log collector.
      name: id
    description: Retrieves the list of protocol types.
    name: qradar-log-source-protocol-types-list
    outputs:
    - contextPath: QRadar.LogSourceProtocolType.GatewaySupported
      description: If this protocol type can be configured for a gateway log source,
        the condition is set to 'true'; otherwise, the condition is set to 'false'.
        A gateway log source is a standalone protocol configuration. The log source
        receives no events itself, and serves as a host for a protocol configuration
        that retrieves event data to feed other log sources. It acts as a 'gateway'
        for events from multiple systems to enter the event pipeline. Not all protocol
        types can be used as a gateway if they don't support collecting event data
        from multiple sources.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.ID
      description: The ID of the protocol type.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Inbound
      description: Indicates whether this is an inbound protocol.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.LatestVersion
      description: The latest version available of the protocol type component.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Name
      description: The unique name of the protocol type.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.ParameterGroups.id
      description: The ID of the protocol parameter group.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.ParameterGroups.name
      description: The name of the protocol parameter group.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.ParameterGroups.required
      description: If at least one parameter in this group must be set, the condition
        is set to true; otherwise, the condition is set to false.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.Parameters.allowed_values.name
      description: An allowed value for the name of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.allowed_values.value
      description: An allowed value for the value of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.default_value
      description: The optional default parameter value.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.description
      description: The description of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.group_id
      description: The ID of the protocol parameter group that this parameter belongs
        to. The group_id is optional.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.id
      description: The ID of the parameter.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.label
      description: The label of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.max_length
      description: 'The maximum length of the parameter value for the following parameter
        types: STRING, TEXT, HOST, PASSWORD, REGEX. The max_length is optional.'
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.max_value
      description: 'The maximum of the parameter value for the following parameter
        types: INTEGER, REAL, DATE, TIME, DATETIME, INTERVAL. The max_value is optional.'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.min_length
      description: 'The minimum length of the parameter value for the following parameter
        types: STRING, TEXT, HOST, PASSWORD, REGEX. The max_length is optional.'
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.min_value
      description: 'The minimum of the parameter value for the following parameter
        types: INTEGER, REAL, DATE, TIME, DATETIME, INTERVAL. The max_value is optional.'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.name
      description: The name of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.pattern
      description: 'An optional Java regex pattern restriction on the parameter value
        for the following parameter types: STRING, TEXT, HOST, PASSWORD.'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.pattern_description
      description: The description of the pattern of the parameter.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.required
      description: If the parameter is mandatory, the condition is set to true; otherwise,
        the condition is set to false.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.Parameters.rules.affected_property
      description: 'The affected property. For possible values visit: https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-protocol_types-GET.html'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.rules.affected_property_value
      description: 'The value to be applied to the affected parameter when the rule
        is triggered. For further info visit: https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-protocol_types-GET.html'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.rules.parameter_id
      description: The ID of the parameter affected by the rule.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.rules.trigger_parameter_id
      description: The ID of the trigger parameter.
      type: Number
    - contextPath: QRadar.LogSourceProtocolType.Parameters.rules.trigger_pattern
      description: The pattern that triggers the rule. For example, if the value of
        trigger_parameter_id matches the regular expression of this field, the rule
        triggers.
      type: String
    - contextPath: QRadar.LogSourceProtocolType.Parameters.type
      description: 'The type of the parameter. Possible values are: STRING, TEXT,
        INTEGER, REAL, BOOLEAN, DATE, TIME, DATETIME, INTERVAL, HOST, PASSWORD, REGEX.'
      type: String
    - contextPath: QRadar.LogSourceProtocolType.TestingCapabilities.can_accept_sample_events
      description: Indicates whether the protocol type can accept sample events (only
        applicable to inbound protocol types).
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.TestingCapabilities.can_collect_events
      description: Indicates whether the protocol type can collect test events.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.TestingCapabilities.testable
      description: Indicates whether the protocol type is testable.
      type: Boolean
    - contextPath: QRadar.LogSourceProtocolType.Version
      description: The version of the protocol type component.
      type: String
  - arguments:
    - description: The ID of the log source to be deleted. If this argument is not
        provided, name must be provided.
      name: id
    - description: The unique name of the log source to be deleted. If this argument
        is not provided, the ID must be provided.
      name: name
    description: Deletes a log source by ID or name. One of the arguments must be
      provided.
    name: qradar-log-source-delete
  - arguments:
    - description: The unique name of the log source.
      name: name
      required: true
    - description: The type of protocol that is used by the log source. Must correspond
        to an existing protocol type.
      name: protocol_type_id
      required: true
    - description: The type of the log source. Must correspond to an existing log
        source type.
      name: type_id
      required: true
    - description: 'The list of protocol parameters corresponding with the selected
        protocol type ID. The syntax for this argument should follow: protocol_parameters="name_1=value_1,name_2=value_2,...,name_n=value_n"
        where each name should correspond to a name of a protocol parameter from the
        protocol type and each value should fit the type of the protocol parameter.
        The command qradar-log-source-protocol-types-list can be used to list all
        available protocol types.'
      name: protocol_parameters
      required: true
    - description: The ID of the event collector where the log source sends its data.
        The ID must correspond to an existing event collector.
      name: target_event_collector_id
      required: true
    - description: The IP of the system which the log source is associated to, or
        fed by.
      name: sending_ip
    - description: The description of the log source.
      name: description
    - description: Determines if events collected by this log source are coalesced
        based on common properties. If each individual event is stored, then the condition
        is set to false. Defaults to true.
      name: coalesce_events
    - description: Determines if the log source is enabled. Defaults to true.
      name: enabled
    - description: The order in which log sources will parse if multiples exist with
        a common identifier.
      name: parsing_order
    - description: The set of log source group IDs this log source is a member of.
        Each ID must correspond to an existing log source group. The command qradar-log-sources-groups-list
        can be used to list all available groups. See the Log Source Group API (https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_groups-id-GET.html).
      name: group_ids
    - description: On a scale of 0-10, the amount of credibility that the QRadar administrator
        places on this log source.
      name: credibility
    - description: If the payloads of events that are collected by this log source
        are stored, the condition is set to 'true'. If only the normalized event records
        are stored, then the condition is set to 'false'.
      name: store_event_payload
    - description: The ID of the disconnected log collector where this log source
        will run. The ID must correspond to an existing disconnected log collector.
      name: disconnected_log_collector_id
    - description: The language of the events that are being processed by this log
        source. Must correspond to an existing log source language.
      name: language_id
    - description: Set to 'true' if you need to deploy changes to enable the log source
        for use; otherwise, set to 'false' if the log source is already active.
      name: requires_deploy
    - description: The internal WinCollect destination for this log source, if applicable.
        Log sources without an associated WinCollect agent have a null value. Must
        correspond to an existing WinCollect destination.
      name: wincollect_internal_destination_id
    - description: The set of external WinCollect destinations for this log source,
        if applicable. Log sources without an associated WinCollect agent have a null
        value. Each ID must correspond to an existing WinCollect destination.
      name: wincollect_external_destination_ids
    - description: If the log source is configured as a gateway, the condition is
        set to 'true'; otherwise, the condition is set to 'false'. A gateway log source
        is a standalone protocol configuration. The log source receives no events
        itself, and serves as a host for a protocol configuration that retrieves event
        data to feed other log sources. It acts as a "gateway" for events from multiple
        systems to enter the event pipeline.
      name: gateway
    description: Creates a new log source.
    name: qradar-log-source-create
    outputs:
    - contextPath: QRadar.LogSource.SendingIP
      description: IP of the system which the log source is associated with, or fed
        by.
      type: String
    - contextPath: QRadar.LogSource.Internal
      description: Whether log source is internal.
      type: Boolean
    - contextPath: QRadar.LogSource.ProtocolParameters
      description: Protocol parameters.
      type: Unknown
    - contextPath: QRadar.LogSource.Description
      description: Description of the log source.
      type: String
    - contextPath: QRadar.LogSource.Enabled
      description: Whether log source is enabled.
      type: Boolean
    - contextPath: QRadar.LogSource.GroupIDs
      description: Log source group IDs.
      type: Number
    - contextPath: QRadar.LogSource.Credibility
      description: Credibility of the log source.
      type: Number
    - contextPath: QRadar.LogSource.ID
      description: ID of the log source.
      type: Number
    - contextPath: QRadar.LogSource.ProtocolTypeID
      description: Protocol type used by log source.
      type: Number
    - contextPath: QRadar.LogSource.CreationDate
      description: Date when log source was created.
      type: Date
    - contextPath: QRadar.LogSource.Name
      description: Name of the log source.
      type: String
    - contextPath: QRadar.LogSource.AutoDiscovered
      description: Whether log source was auto discovered.
      type: Boolean
    - contextPath: QRadar.LogSource.ModifiedDate
      description: Date when log source was last modified.
      type: Date
    - contextPath: QRadar.LogSource.TypeID
      description: The log source type.
      type: Number
    - contextPath: QRadar.LogSource.LastEventTime
      description: Date when the last event was received by the log source.
      type: Date
    - contextPath: QRadar.LogSource.Gateway
      description: Whether log source is configured as a gateway.
      type: Boolean
    - contextPath: QRadar.LogSource.Status
      description: Status of the log source.
    - contextPath: QRadar.LogSource.TargetEventCollectorID
      description: The ID of the event collector where the log source sends its data.
      type: Number
  - arguments:
    - description: The ID of the log source.
      name: id
      required: true
    - description: The unique name of the log source.
      name: name
    - description: The type of protocol that is used by the log source. Must correspond
        to an existing protocol type.
      name: protocol_type_id
    - description: The type of the log source. Must correspond to an existing log
        source type.
      name: type_id
    - description: 'The list of protocol parameters corresponding with the selected
        protocol type ID. The syntax for this argument should follow: protocol_parameters="name_1=value_1,name_2=value_2,...,name_n=value_n"
        where each name should correspond to a name of a protocol parameter from the
        protocol type and each value should fit the type of the protocol parameter.
        The command qradar-log-source-protocol-types-list can be used to list all
        available protocol types.'
      name: protocol_parameters
    - description: The ID of the event collector where the log source sends its data.
        The ID must correspond to an existing event collector.
      name: target_event_collector_id
    - description: The IP of the system which the log source is associated to, or
        fed by.
      name: sending_ip
    - description: The description of the log source.
      name: description
    - description: Determines if events collected by this log source are coalesced
        based on common properties. If each individual event is stored, then the condition
        is set to false. Defaults to true.
      name: coalesce_events
    - description: Determines if the log source is enabled. Defaults to true.
      name: enabled
    - description: The order in which log sources will parse if multiples exist with
        a common identifier.
      name: parsing_order
    - description: The set of log source group IDs this log source is a member of.
        Each ID must correspond to an existing log source group. The command qradar-log-sources-groups-list
        can be used to list all available groups. See the Log Source Group API (https://ibmsecuritydocs.github.io/qradar_api_20.0/20.0--config-event_sources-log_source_management-log_source_groups-id-GET.html).
      name: group_ids
    - description: On a scale of 0-10, the amount of credibility that the QRadar administrator
        places on this log source.
      name: credibility
    - description: If the payloads of events that are collected by this log source
        are stored, the condition is set to 'true'. If only the normalized event records
        are stored, then the condition is set to 'false'.
      name: store_event_payload
    - description: The ID of the disconnected log collector where this log source
        will run. The ID must correspond to an existing disconnected log collector.
      name: disconnected_log_collector_id
    - description: The language of the events that are being processed by this log
        source. Must correspond to an existing log source language.
      name: language_id
    - description: Set to 'true' if you need to deploy changes to enable the log source
        for use; otherwise, set to 'false' if the log source is already active.
      name: requires_deploy
    - description: The internal WinCollect destination for this log source, if applicable.
        Log sources without an associated WinCollect agent have a null value. Must
        correspond to an existing WinCollect destination.
      name: wincollect_internal_destination_id
    - description: The set of external WinCollect destinations for this log source,
        if applicable. Log Sources without an associated WinCollect agent have a null
        value. Each ID must correspond to an existing WinCollect destination.
      name: wincollect_external_destination_ids
    - description: If the log source is configured as a gateway, the condition is
        set to 'true'; otherwise, the condition is set to 'false'. A gateway log source
        is a standalone protocol configuration. The log source receives no events
        itself, and serves as a host for a protocol configuration that retrieves event
        data to feed other log sources. It acts as a "gateway" for events from multiple
        systems to enter the event pipeline.
      name: gateway
    description: Updates an exising log source.
    name: qradar-log-source-update
  - arguments:
    - description: 'Query by which to filter offenses. For reference, consult: https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.1/com.ibm.qradar.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named, are excluded. Specify subfields
        in brackets and multiple fields in the same object separated by commas. The
        filter uses QRadar''s field names. For reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-GET.html'
      name: fields
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: Gets offenses from QRadar. Deprecated, Use qradar-offenses-list instead.
    hidden: true
    name: qradar-offenses
    outputs:
    - contextPath: QRadar.Offense.Followup
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.Credibility
      description: The credibility of the offense.
      type: number
    - contextPath: QRadar.Offense.Relevance
      description: The relevance of the offense.
      type: number
    - contextPath: QRadar.Offense.Severity
      description: The severity of the offense.
      type: number
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.DestinationAddress
      description: The destination addresses that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.AssignedTo
      description: The user the offense is assigned to.
      type: string
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
      type: date
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
      type: int
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destintion hostname.
      type: Unknown
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
      type: string
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
      type: string
    - contextPath: QRadar.Offense.Status
      description: The status of the offense. One of "OPEN", "HIDDEN", or "CLOSED".
      type: string
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
      type: number
    - contextPath: QRadar.Offense.ClosingUser
      description: The user that closed the offense.
      type: string
    - contextPath: QRadar.Offense.ClosingReason
      description: The offense closing reason.
      type: string
    - contextPath: QRadar.Offense.CloseTime
      description: The time when the offense was closed.
      type: date
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: The time (ISO) when the offense was last updated.
      type: date
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.FollowUp
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type.
      type: string
    - contextPath: QRadar.Offense.Protected
      description: Is the offense protected.
      type: boolean
    - contextPath: QRadar.Offense.RemoteDestinationCount
      description: The remote destinations that are associated with the offesne. If
        this value is greater than 0 that means your offense has a remote destination,
        you will need to use QRadarFullSearch playbook with the following query -
        SELECT destinationip FROM events WHERE inOffense(<offenseID>) GROUP BY destinationip.
      type: Unknown
  - arguments:
    - default: true
      description: Offense ID.
      name: offense_id
      required: true
    - description: 'Query to filter offense. For reference please consult: https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.1/com.ibm.qradar.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object separated by commas. The
        filter uses QRadar''s field names, for reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-GET.html'
      name: fields
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: Gets offense with matching offense ID from qradar.Deprecated, Use
      qradar-offense-list instead.
    hidden: true
    name: qradar-offense-by-id
    outputs:
    - contextPath: QRadar.Offense.Followup
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.Credibility
      description: The credibility of the offense.
      type: number
    - contextPath: QRadar.Offense.Relevance
      description: The relevance of the offense.
      type: number
    - contextPath: QRadar.Offense.Severity
      description: The severity of the offense.
      type: number
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.DestinationAddress
      description: The local destination addresses that are associated with the offense.
        If your offense has a remote destination, you will need to use the QRadarFullSearch
        playbook with the following query - SELECT destinationip FROM events WHERE
        inOffense(<offenseID>) GROUP BY destinationip.
      type: Unknown
    - contextPath: QRadar.Offense.RemoteDestinationCount
      description: The remote destination that are associated with the offesne. If
        this value is greater than 0, it means that your offense has a remote destination,
        you will need to use the QRadarFullSearch playbook with the following query
        - SELECT destinationip FROM events WHERE inOffense(<offenseID>) GROUP BY destinationip.
      type: Unknown
    - contextPath: QRadar.Offense.AssignedTo
      description: The user the offense is assigned to.
      type: string
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
      type: date
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
      type: int
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destintion hostname.
      type: Unknown
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
      type: string
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
      type: string
    - contextPath: QRadar.Offense.Status
      description: The status of the offense. One of "OPEN", "HIDDEN", or "CLOSED".
      type: string
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
      type: number
    - contextPath: QRadar.Offense.ClosingUser
      description: The user that closed the offense.
      type: string
    - contextPath: QRadar.Offense.ClosingReason
      description: The offense closing reason.
      type: string
    - contextPath: QRadar.Offense.CloseTime
      description: The time when the offense was closed.
      type: date
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: The time (ISO) when the offense was last updated.
      type: date
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.FollowUp
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type.
      type: string
    - contextPath: QRadar.Offense.Protected
      description: Is the offense protected.
      type: boolean
  - arguments:
    - default: true
      description: The ID of the offense to update.
      name: offense_id
      required: true
    - auto: PREDEFINED
      description: Set to true to protect the offense.
      name: protected
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Set to true to set the follow up flag on the offense.
      name: follow_up
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: The new status for the offense.
      name: status
      predefined:
      - OPEN
      - HIDDEN
      - CLOSED
    - description: 'The id of a closing reason. You must provide a valid closing_reason_name
        when you close an offense. The default closing_reasons are: (1) False-Positive,
        Tuned (2) Non-Issues (3) Policy Violation.'
      name: closing_reason_id
    - description: 'The name of a closing reason. You must provide a valid closing_reason_name
        when you close an offense. The default closing_reasons are: (1) False-Positive,
        Tuned (2) Non-Issues (3) Policy Violation.'
      name: closing_reason_name
    - description: A user to assign the offense to.
      name: assigned_to
    - description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets and multiple fields in the same object  separated by commas. Please
        consult - https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-POST.html
      name: fields
    deprecated: true
    description: Update an offense. Deprecated, Use qradar-offense-update instead.
    hidden: true
    name: qradar-update-offense
    outputs:
    - contextPath: QRadar.Offense.Followup
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.Credibility
      description: The credibility of the offense.
      type: number
    - contextPath: QRadar.Offense.Relevance
      description: The relevance of the offense.
      type: number
    - contextPath: QRadar.Offense.Severity
      description: The severity of the offense.
      type: number
    - contextPath: QRadar.Offense.SourceAddress
      description: The source addresses that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.DestinationAddress
      description: The destination addresses that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.AssignedTo
      description: The user the offense is assigned to.
      type: string
    - contextPath: QRadar.Offense.StartTime
      description: The time (ISO) when the offense was started.
      type: date
    - contextPath: QRadar.Offense.ID
      description: The ID of the offense.
      type: int
    - contextPath: QRadar.Offense.DestinationHostname
      description: Destintion hostname.
      type: Unknown
    - contextPath: QRadar.Offense.Description
      description: The description of the offense.
      type: string
    - contextPath: QRadar.Offense.EventCount
      description: The number of events that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.OffenseSource
      description: The source of the offense.
      type: string
    - contextPath: QRadar.Offense.Status
      description: The status of the offense. One of "OPEN", "HIDDEN", or "CLOSED".
      type: string
    - contextPath: QRadar.Offense.Magnitude
      description: The magnitude of the offense.
      type: number
    - contextPath: QRadar.Offense.ClosingUser
      description: The user that closed the offense.
      type: string
    - contextPath: QRadar.Offense.ClosingReason
      description: The offense closing reason.
      type: string
    - contextPath: QRadar.Offense.CloseTime
      description: The time when the offense was closed.
      type: date
    - contextPath: QRadar.Offense.LastUpdatedTime
      description: The time (ISO) when the offense was last updated.
      type: date
    - contextPath: QRadar.Offense.Categories
      description: Event categories that are associated with the offense.
      type: Unknown
    - contextPath: QRadar.Offense.FlowCount
      description: The number of flows that are associated with the offense.
      type: number
    - contextPath: QRadar.Offense.FollowUp
      description: Offense followup.
      type: boolean
    - contextPath: QRadar.Offense.OffenseType
      description: A number that represents the offense type.
      type: string
    - contextPath: QRadar.Offense.Protected
      description: Is the offense protected.
      type: boolean
    - contextPath: QRadar.Offense.RemoteDestinationCount
      description: The remote destinations that are associated with the offesne. If
        this value is greater than 0 that means your offense has a remote destination,
        you will need to use QRadarFullSearch playbook with the following query -
        SELECT destinationip FROM events WHERE inOffense(<offenseID>) GROUP BY destinationip.
      type: Unknown
  - arguments:
    - default: true
      description: The query expressions in AQL (for more information about Ariel
        Query Language, review "https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.0/com.ibm.qradar.doc/c_aql_intro.html").
      name: query_expression
      required: true
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: |
      Searches in QRadar using AQL. It is highly recommended to use the playbook 'QRadarFullSearch' instead of this command - it will execute the search, and will return the result.
      Deprecated, Use qradar-search-create instead.
    hidden: true
    name: qradar-searches
    outputs:
    - contextPath: QRadar.Search.ID
      description: Search ID.
      type: number
    - contextPath: QRadar.Search.Status
      description: The status of the search.
      type: string
  - arguments:
    - default: true
      description: The search ID.
      name: search_id
      required: true
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: Gets a specific search ID and status. Deprecated, Use qradar-search-status-get
      instead.
    hidden: true
    name: qradar-get-search
    outputs:
    - contextPath: QRadar.Search.ID
      description: Search ID.
      type: number
    - contextPath: QRadar.Search.Status
      description: The status of the search.
      type: string
  - arguments:
    - default: true
      description: The search id.
      name: search_id
      required: true
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    - description: Replaces the default context output path for the query result (QRadar.Search.Result).
        e.g. for output_path=QRadar.Correlations the result will be under the key
        "QRadar.Correlations" in the context data.
      name: output_path
    deprecated: true
    description: Gets search results. Deprecated, Use qradar-search-results-get instead.
    hidden: true
    name: qradar-get-search-results
    outputs:
    - contextPath: QRadar.Search.Result
      description: The result of the search.
      type: Unknown
  - arguments:
    - description: 'Query to filter assets. For reference please consult: https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.1/com.ibm.qradar.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not named are excluded. Specify subfields in brackets
        and multiple fields in the same object separated by commas. The filter uses
        QRadar''s field names, for reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--asset_model-assets-GET.html'
      name: fields
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: List all assets found in the model. Deprecated, Use qradar-assets-list
      instead.
    hidden: true
    name: qradar-get-assets
    outputs:
    - contextPath: QRadar.Asset.ID
      description: The ID of the asset.
      type: number
    - contextPath: Endpoint.IPAddress
      description: IP address of the asset.
      type: Unknown
    - contextPath: QRadar.Asset.Name.Value
      description: Name of the asset.
      type: string
    - contextPath: Endpoint.OS
      description: Asset OS.
      type: number
    - contextPath: QRadar.Asset.AggregatedCVSSScore.Value
      description: CVSSScore.
      type: number
    - contextPath: QRadar.Asset.AggregatedCVSSScore.LastUser
      description: Last user who updated the Aggregated CVSS Score.
      type: string
    - contextPath: QRadar.Asset.Weight.Value
      description: Asset weight.
      type: number
    - contextPath: QRadar.Asset.Weight.LastUser
      description: Last user who updated the weight.
      type: string
    - contextPath: QRadar.Asset.Name.LastUser
      description: Last user who updated the name.
      type: string
  - arguments:
    - default: true
      description: The ID of the requested asset.
      name: asset_id
      required: true
    deprecated: true
    description: Retrieves the asset by id. Deprecated, Use qradar-assets-list instead.
    hidden: true
    name: qradar-get-asset-by-id
    outputs:
    - contextPath: QRadar.Asset.ID
      description: The ID of the asset.
      type: number
    - contextPath: Endpoint.MACAddress
      description: Asset MAC address.
      type: Unknown
    - contextPath: Endpoint.IPAddress
      description: IP address of the endpoint.
      type: Unknown
    - contextPath: QRadar.Asset.ComplianceNotes.Value
      description: Compliance notes.
      type: string
    - contextPath: QRadar.Asset.CompliancePlan.Value
      description: Compliance plan.
      type: string
    - contextPath: QRadar.Asset.CollateralDamagePotential.Value
      description: Collateral damage potential.
      type: Unknown
    - contextPath: QRadar.Asset.AggregatedCVSSScore.Value
      description: CVSSScore.
      type: number
    - contextPath: QRadar.Asset.Name.Value
      description: Name of the asset.
      type: string
    - contextPath: QRadar.Asset.GroupName
      description: Name of the asset's group.
      type: string
    - contextPath: Endpoint.Domain
      description: DNS name.
      type: Unknown
    - contextPath: Endpoint.OS
      description: Asset OS.
      type: Unknown
    - contextPath: QRadar.Asset.Weight.Value
      description: Asset weight.
      type: number
    - contextPath: QRadar.Asset.Vulnerabilities.Value
      description: Vulnerabilities.
      type: Unknown
    - contextPath: QRadar.Asset.Location
      description: Location.
      type: string
    - contextPath: QRadar.Asset.Description
      description: The asset description.
      type: string
    - contextPath: QRadar.Asset.SwitchID
      description: Switch ID.
      type: number
    - contextPath: QRadar.Asset.SwitchPort
      description: Switch port.
      type: number
    - contextPath: QRadar.Asset.Name.LastUser
      description: Last user who updated the name.
      type: string
    - contextPath: QRadar.Asset.AggregatedCVSSScore.LastUser
      description: Last user who updated the Aggregated CVSS Score.
      type: string
    - contextPath: QRadar.Asset.Weight.LastUser
      description: Last user who updated the weight.
      type: string
    - contextPath: QRadar.Asset.ComplianceNotes.LastUser
      description: Last user who updated the compliance notes.
      type: string
    - contextPath: QRadar.Asset.CompliancePlan.LastUser
      description: Last user who updated the compliance plan.
      type: string
    - contextPath: QRadar.Asset.CollateralDamagePotential.LastUser
      description: Last user who updated the collateral damage potential.
      type: string
    - contextPath: QRadar.Asset.Vulnerabilities.LastUser
      description: Last user who updated the vulnerabilities.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "true"
      description: If true, reserved closing reasons are included in the response.
      name: include_reserved
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: If true, deleted closing reasons are included in the response.
      name: include_deleted
      predefined:
      - "true"
      - "false"
    - description: 'Query to filter results. For reference, consult: https://www.ibm.com/support/knowledgecenter/en/SS42VS_7.3.1/com.ibm.qradar.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object separated by commas. The
        filter uses QRadar''s field names. For reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offense_closing_reasons-GET.html'
      name: fields
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    deprecated: true
    description: Get closing reasons. Deprecated, Use qradar-closing-reasons instead.
    hidden: true
    name: qradar-get-closing-reasons
    outputs:
    - contextPath: QRadar.Offense.ClosingReasons.ID
      description: Closing reason ID.
      type: number
    - contextPath: QRadar.Offense.ClosingReasons.Name
      description: Closing reason name.
      type: string
  - arguments:
    - default: true
      description: The offense ID to retrieve the note from.
      name: offense_id
      required: true
    - description: The note ID.
      name: note_id
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object separated by commas. The
        filter uses QRadar''s field names. For reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-notes-note_id-GET.html'
      name: fields
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: Retrieve a note for an offense. Deprecated, Use qradar-offense-notes-list
      instead.
    hidden: true
    name: qradar-get-note
    outputs:
    - contextPath: QRadar.Note.ID
      description: Note ID.
      type: number
    - contextPath: QRadar.Note.Text
      description: Note text.
      type: string
    - contextPath: QRadar.Note.CreateTime
      description: The creation time of the note.
      type: date
    - contextPath: QRadar.Note.CreatedBy
      description: The user who created the note.
      type: string
  - arguments:
    - default: true
      description: The offense ID to add the note to.
      name: offense_id
      required: true
    - description: The note text.
      name: note_text
      required: true
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object separated by commas. The
        filter uses QRadar''s field names. For reference, consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-notes-POST.html'
      name: fields
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    deprecated: true
    description: Create a note on an offense. Deprecated, Use qradar-offense-note-create
      instead.
    hidden: true
    name: qradar-create-note
    outputs:
    - contextPath: QRadar.Note.ID
      description: Note ID.
      type: number
    - contextPath: QRadar.Note.Text
      description: Note text.
      type: string
    - contextPath: QRadar.Note.CreateTime
      description: The creation time of the note.
      type: date
    - contextPath: QRadar.Note.CreatedBy
      description: The user who created the note.
      type: string
  - arguments:
    - default: true
      description: The name of the requestered reference.
      name: ref_name
      required: true
    - description: Table headers to use in the human readable output (if none provided,
        will show all table headers).
      name: headers
    - auto: PREDEFINED
      defaultValue: "False"
      description: If set to true will try to convert the data values to ISO-8601
        string.
      name: date_value
      predefined:
      - "True"
      - "False"
    deprecated: true
    description: |
      Information about the reference set that had data added or updated. This returns the information set, but not the contained data. This feature is supported from version 8.1 and upward.
      Deprecated, Use qradar-reference-sets-list instead.
    hidden: true
    name: qradar-get-reference-by-name
    outputs:
    - contextPath: QRadar.Reference.Name
      description: The name of the reference set.
      type: string
    - contextPath: QRadar.Reference.CreationTime
      description: The creation time (ISO) of the reference.
      type: date
    - contextPath: QRadar.Reference.ElementType
      description: Reference element type.
      type: string
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements.
      type: number
    - contextPath: QRadar.Reference.TimeToLive
      description: Reference time to live.
      type: string
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Reference timeout type. Valid values are: UNKNOWN, FIRST_SEEN,
        LAST_SEEN.'
      type: string
    - contextPath: QRadar.Reference.Data
      description: Reference set items.
      type: Unknown
  - arguments:
    - description: Reference name to be created.
      name: ref_name
      required: true
    - auto: PREDEFINED
      description: 'The element type for the values allowed in the reference set.
        The allowed values are: ALN (alphanumeric), ALNIC (alphanumeric ignore case),
        IP (IP address), NUM (numeric), PORT (port number) or DATE. Note that date
        values need to be represented in milliseconds since the Unix Epoch January
        1st 1970.'
      name: element_type
      predefined:
      - ALN
      - ALNIC
      - IP
      - NUM
      - PORT
      - DATE
      required: true
    - auto: PREDEFINED
      description: The allowed values are "FIRST_SEEN", LAST_SEEN and UNKNOWN. The
        default value is UNKNOWN.
      name: timeout_type
      predefined:
      - FIRST_SEEN
      - LAST_SEEN
      - UNKNOWN
    - description: 'The time to live interval, for example: "1 month" or "5 minutes".'
      name: time_to_live
    deprecated: true
    description: |
      Creates a new reference set. If the provided name is already in use, this command will fail.
      Deprecated, Use qradar-reference-set-create instead.
    hidden: true
    name: qradar-create-reference-set
    outputs:
    - contextPath: QRadar.Reference.CreationTime
      description: Creation time of the reference set.
      type: date
    - contextPath: QRadar.Reference.ElementType
      description: 'The element type for the values allowed in the reference set.
        The allowed values are: ALN (alphanumeric), ALNIC (alphanumeric ignore case),
        IP (IP address), NUM (numeric), PORT (port number) or DATE.'
      type: string
    - contextPath: QRadar.Reference.Name
      description: Name of the reference set.
      type: string
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements in the created reference set.
      type: number
    - contextPath: QRadar.Reference.TimeoutType
      description: Timeout type of the reference. The allowed values are FIRST_SEEN,
        LAST_SEEN and UNKNOWN.
      type: string
  - arguments:
    - default: true
      description: The name of reference set to delete.
      name: ref_name
      required: true
    deprecated: true
    description: Deletes a reference set corresponding to the name provided. Deprecated,
      Use qradar-reference-set-delete instead.
    hidden: true
    name: qradar-delete-reference-set
  - arguments:
    - description: The name of the reference set to add or update a value in.
      name: ref_name
      required: true
    - description: 'The value/s to add or update in the reference set. Note: Date
        values must be represented in epoch in reference sets (milliseconds since
        the Unix Epoch January 1st 1970). If ''date_value'' is set to ''True'', then
        the argument will be converted from date in format: ''%Y-%m-%dT%H:%M:%S.%f000Z''
        (e.g. ''2018-11-06T08:56:41.000000Z'') to epoch.'
      isArray: true
      name: value
      required: true
    - description: An indication of where the data originated. The default value is
        'reference data api'.
      name: source
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'If set to True, will convert ''value'' argument from date in format:
        ''%Y-%m-%dT%H:%M:%S.%f000Z'' (e.g. ''2018-11-06T08:56:41.000000Z'') to epoch.'
      name: date_value
      predefined:
      - "True"
      - "False"
    deprecated: true
    description: Add or update a value in a reference set. Deprecated, Use qradar-reference-set-value-upsert
      instead.
    hidden: true
    name: qradar-create-reference-set-value
    outputs:
    - contextPath: QRadar.Reference.Name
      description: The name of the reference set.
      type: string
    - contextPath: QRadar.Reference.CreationTime
      description: The creation time (ISO) of the reference.
      type: date
    - contextPath: QRadar.Reference.ElementType
      description: Reference element type.
      type: string
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements.
      type: number
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Reference timeout type. One of: UNKNOWN, FIRST_SEEN, LAST_SEEN.'
      type: string
  - arguments:
    - description: The name of the reference set to add or update a value in.
      name: ref_name
      required: true
    - description: A comma-separated list of values to add or update in the reference
        set. Date values must be represented in milliseconds since the Unix Epoch
        January 1st 1970.
      isArray: true
      name: value
      required: true
    - description: An indication of where the data originated. The default value is
        'reference data api'.
      name: source
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'If set to True, will convert ''value'' argument from date in format:
        ''%Y-%m-%dT%H:%M:%S.%f000Z'' (e.g. ''2018-11-06T08:56:41.000000Z'') to epoch.'
      name: date_value
      predefined:
      - "True"
      - "False"
    deprecated: true
    description: Adds or updates a value in a reference set. Deprecated, Use qradar-reference-set-value-upsert
      instead.
    hidden: true
    name: qradar-update-reference-set-value
    outputs:
    - contextPath: QRadar.Reference.Name
      description: The name of the reference set.
      type: string
    - contextPath: QRadar.Reference.CreationTime
      description: The creation time (ISO) of the reference.
      type: date
    - contextPath: QRadar.Reference.ElementType
      description: Reference element type.
      type: string
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements.
      type: number
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Reference timeout type. One of: UNKNOWN, FIRST_SEEN, LAST_SEEN.'
      type: string
  - arguments:
    - description: The name of the reference set to remove a value from.
      name: ref_name
      required: true
    - description: The value to remove from the reference set.
      name: value
      required: true
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'If set to True will convert ''value'' argument from date in format:
        ''%Y-%m-%dT%H:%M:%S.%f000Z'' (e.g.,  ''2018-11-06T08:56:41.000000Z'') to epoch.'
      name: date_value
      predefined:
      - "True"
      - "False"
    deprecated: true
    description: |-
      Deletes a value in a reference set.
      Deprecated, Use qradar-reference-set-value-delete instead.
    hidden: true
    name: qradar-delete-reference-set-value
    outputs:
    - contextPath: QRadar.Reference.Name
      description: The name of the reference set.
      type: string
    - contextPath: QRadar.Reference.CreationTime
      description: The creation time (ISO) of the reference.
      type: date
    - contextPath: QRadar.Reference.ElementType
      description: Reference element type.
      type: string
    - contextPath: QRadar.Reference.NumberOfElements
      description: Number of elements.
      type: number
    - contextPath: QRadar.Reference.TimeoutType
      description: 'Reference timeout type. One of: UNKNOWN, FIRST_SEEN, LAST_SEEN.'
      type: string
  - arguments:
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas.
        The filter uses QRadar''s field names, for reference please consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-notes-note_id-GET.html'
      name: fields
    - description: Number of results in return.
      name: range
    - description: Query to filter offenses.
      name: filter
    deprecated: true
    description: Retrieve all Domains. Deprecated, Use qradar-domains-list instead.
    hidden: true
    name: qradar-get-domains
    outputs:
    - contextPath: QRadar.Domains.AssetScannerIDs
      description: Array of Asset Scanner IDs.
      type: Number
    - contextPath: QRadar.Domains.CustomProperties
      description: Custom properties of the domain.
      type: String
    - contextPath: QRadar.Domains.Deleted
      description: Indicates if the domain is deleted.
      type: Boolean
    - contextPath: QRadar.Domains.Description
      description: Description of the domain.
      type: String
    - contextPath: QRadar.Domains.EventCollectorIDs
      description: Array of Event Collector IDs.
      type: Number
    - contextPath: QRadar.Domains.FlowCollectorIDs
      description: Array of Flow Collector IDs.
      type: Number
    - contextPath: QRadar.Domains.FlowSourceIDs
      description: Array of Flow Source IDs.
      type: Number
    - contextPath: QRadar.Domains.ID
      description: ID of the domain.
      type: Number
    - contextPath: QRadar.Domains.LogSourceGroupIDs
      description: Array of Log Source Group IDs.
      type: Number
    - contextPath: QRadar.Domains.LogSourceIDs
      description: Array of Log Source IDs.
      type: Number
    - contextPath: QRadar.Domains.Name
      description: Name of the Domain.
      type: String
    - contextPath: QRadar.Domains.QVMScannerIDs
      description: Array of QVM Scanner IDs.
      type: Number
    - contextPath: QRadar.Domains.TenantID
      description: ID of the Domain tenant.
      type: Number
  - arguments:
    - description: ID of the domain.
      name: id
      required: true
    - description: 'If used, will filter all fields except for the specified ones.
        Use this parameter to specify which fields you would like to get back in the
        response. Fields that are not explicitly named are excluded. Specify subfields
        in brackets and multiple fields in the same object are separated by commas.
        The filter uses QRadar''s field names, for reference please consult: https://www.ibm.com/support/knowledgecenter/SSKMKU/com.ibm.qradar.doc_cloud/9.1--siem-offenses-offense_id-notes-note_id-GET.html'
      name: fields
    deprecated: true
    description: Retrieves Domain information By ID. Deprecated, Use qradar-domains-list
      instead.
    hidden: true
    name: qradar-get-domain-by-id
    outputs:
    - contextPath: QRadar.Domains.AssetScannerIDs
      description: Array of Asset Scanner IDs.
      type: Number
    - contextPath: QRadar.Domains.CustomProperties
      description: Custom properties of the domain.
      type: String
    - contextPath: QRadar.Domains.Deleted
      description: Indicates if the domain is deleted.
      type: Boolean
    - contextPath: QRadar.Domains.Description
      description: Description of the domain.
      type: String
    - contextPath: QRadar.Domains.EventCollectorIDs
      description: Array of Event Collector IDs.
      type: Number
    - contextPath: QRadar.Domains.FlowCollectorIDs
      description: Array of Flow Collector IDs.
      type: Number
    - contextPath: QRadar.Domains.FlowSourceIDs
      description: Array of Flow Source IDs.
      type: Number
    - contextPath: QRadar.Domains.ID
      description: ID of the domain.
      type: Number
    - contextPath: QRadar.Domains.LogSourceGroupIDs
      description: Array of Log Source Group IDs.
      type: Number
    - contextPath: QRadar.Domains.LogSourceIDs
      description: Array of Log Source IDs.
      type: Number
    - contextPath: QRadar.Domains.Name
      description: Name of the Domain.
      type: String
    - contextPath: QRadar.Domains.QVMScannerIDs
      description: Array of QVM Scanner IDs.
      type: Number
    - contextPath: QRadar.Domains.TenantID
      description: ID of the Domain tenant.
      type: Number
  - arguments:
    - description: The name of the reference set to add or update a value in. To create
        a new reference set, you need to set the element type.
      name: ref_name
      required: true
    - auto: PREDEFINED
      description: 'The element type for the values permitted in the reference set.
        Only required when creating a new reference set. The valid values are: ALN
        (alphanumeric), ALNIC (alphanumeric ignore case), IP (IP address), NUM (numeric),
        PORT (port number) or DATE. Note that date values need to be represented in
        milliseconds since the Unix Epoch January 1st 1970.'
      name: element_type
      predefined:
      - ALN
      - ALNIC
      - IP
      - NUM
      - PORT
      - DATE
    - auto: PREDEFINED
      description: The timeout_type can be "FIRST_SEEN", "LAST_SEEN", or "UNKNOWN".
        The default value is UNKNOWN. Only required for creating a new reference set.
      name: timeout_type
      predefined:
      - FIRST_SEEN
      - LAST_SEEN
      - UNKNOWN
    - description: 'The time to live interval, for example: "1 month" or "5 minutes".
        Only required when creating a new reference set.'
      name: time_to_live
    - description: The query for getting indicators.
      name: query
      required: true
    - defaultValue: "1000"
      description: The maximum number of indicators to return. The default value is
        1000.
      name: limit
    - defaultValue: "0"
      description: The page from which to get the indicators.
      name: page
    - description: The ID of the task that is created to add or update the element
        in the reference set. The task ID can be used to poll the status of the task
        by using the 'qradar-tasks-get' command.
      name: task_id
    description: Uploads indicators from Demisto to QRadar.
    hidden: true
    name: qradar-upload-indicators
  - arguments:
    - description: Comma separated list. Source IPs to retrieve their data, E.g "192.168.0.1,192.160.0.2".
      isArray: true
      name: source_ip
    - description: 'Query to filter IPs. E.g, filter=`source_ip="192.168.0.1"`. For
        reference please consult: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the ones specified.
        Use this argument to specify which fields should be returned in the response.
        Fields that are not named are excluded. Specify subfields in brackets and
        multiple fields in the same object separated by commas. The filter uses QRadar''s
        field names, for reference, consult: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-source_addresses-GET.html.'
      name: fields
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    description: Get Source IPs.
    name: qradar-ips-source-get
    outputs:
    - contextPath: QRadar.SourceIP.ID
      description: The ID of the destination address.
      type: Number
    - contextPath: QRadar.SourceIP.DomainID
      description: The ID of associated domain.
      type: String
    - contextPath: QRadar.SourceIP.EventFlowCount
      description: The number of events and flows that are associated with the destination
        address.
      type: Number
    - contextPath: QRadar.SourceIP.FirstEventFlowSeen
      description: Date when the first event or flow was seen.
      type: Date
    - contextPath: QRadar.SourceIP.LastEventFlowSeen
      description: Date when the last event or flow was seen.
      type: Date
    - contextPath: QRadar.SourceIP.SourceIP
      description: The IP address.
      type: String
    - contextPath: QRadar.SourceIP.Magnitude
      description: The magnitude of the destination address.
      type: Number
    - contextPath: QRadar.SourceIP.Network
      description: The network of the destination address.
      type: String
    - contextPath: QRadar.SourceIP.OffenseIDs
      description: List of offense IDs the destination address is part of.
      type: Unknown
    - contextPath: QRadar.SourceIP.LocalDestinationAddressIDs
      description: List of local destination address IDs associated with the source
        address.
      type: Unknown
  - arguments:
    - description: Comma separated list. Local destination IPs to retrieve their data,
        E.g "192.168.0.1,192.160.0.2".
      isArray: true
      name: local_destination_ip
    - description: 'Query to filter IPs. E.g, filter=`local_destination_ip="192.168.0.1"`
        For reference please consult: https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html'
      name: filter
    - description: 'If used, will filter all fields except for the ones specified.
        Use this argument to specify which fields should be returned in the response.
        Fields that are not named are excluded. Specify subfields in brackets and
        multiple fields in the same object separated by commas. The filter uses QRadar''s
        field names, for reference, consult: https://ibmsecuritydocs.github.io/qradar_api_14.0/14.0--siem-local_destination_addresses-GET.html.'
      name: fields
    - description: 'Range of results to return. e.g.: 0-20.'
      name: range
    description: Get Source IPs.
    name: qradar-ips-local-destination-get
    outputs:
    - contextPath: QRadar.LocalDestinationIP.ID
      description: The ID of the destination address.
      type: Number
    - contextPath: QRadar.LocalDestinationIP.DomainID
      description: The ID of associated domain.
      type: String
    - contextPath: QRadar.LocalDestinationIP.EventFlowCount
      description: The number of events and flows that are associated with the destination
        address.
      type: Number
    - contextPath: QRadar.LocalDestinationIP.FirstEventFlowSeen
      description: Date when the first event or flow was seen.
      type: Date
    - contextPath: QRadar.LocalDestinationIP.LastEventFlowSeen
      description: Date when the last event or flow was seen.
      type: Date
    - contextPath: QRadar.LocalDestinationIP.LocalDestinationIP
      description: The IP address.
      type: String
    - contextPath: QRadar.LocalDestinationIP.Magnitude
      description: The magnitude of the destination address.
      type: Number
    - contextPath: QRadar.LocalDestinationIP.Network
      description: The network of the destination address.
      type: String
    - contextPath: QRadar.LocalDestinationIP.OffenseIDs
      description: List of offense IDs the destination address is part of.
      type: Unknown
    - contextPath: QRadar.LocalDestinationIP.SourceAddressIDs
      description: List of source address IDs associated with the destination address.
      type: Unknown
  - arguments:
    - description: The ID of the offense to retrieve. Mutually exclusive with query_expression.
      name: offense_id
      type: Number
    - description: The number of events to return. Mutually exclusive with query_expression.
      name: events_limit
      type: Number
    - description: Comma separated list of columns to return. Mutually exclusive with
        query_expression.
      name: events_columns
      type: String
    - description: The mode to use when fetching events. Mutually exclusive with query_expression.
      name: fetch_mode
      predefined:
      - Fetch With All Events
      - Fetch Correlation Events Only
      type: PREDEFINED
    - description: The start time of the search. Mutually exclusive with query_expression.
      name: start_time
      type: Date
    - description: The AQL query to execute. Mutually exclusive with the other arguments.
      name: query_expression
      type: String
    - description: The interval in seconds to use when polling events.
      name: interval_in_seconds
      type: Number
    - description: The search id to query the results.
      name: search_id
      type: String
    - auto: PREDEFINED
      description: Whenever set to true, the command retries to fetch all events if
        the number of events fetched is less than `event_count`.
      name: retry_if_not_all_fetched
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      default: true
      description: Wait for search results.
      name: polling
      predefined:
      - "true"
      - "false"
    - description: The timeout in seconds to use when polling events.
      name: timeout_in_seconds
      type: Number
    description: Polling command to search for events of a specific offense.
    name: qradar-search-retrieve-events
    outputs:
    - contextPath: QRadar.SearchEvents.ID
      description: The search id of the query.
      type: Unknown
    - contextPath: QRadar.SearchEvents.Events
      description: The events from QRadar search.
      type: Unknown
    - contextPath: QRadar.SearchEvents.Status
      description: The status of the search ('wait', 'partial', 'success').
      type: Unknown
    polling: true
  - arguments:
    - description: An input list of CIDRs to add to QRadar (can be obtained automatically
        from EDL integrations and playbook). Multiple values in the same object are
        separated by commas. A CIDR or query is required.
      isArray: true
      name: cidrs
    - description: The query for getting indicators from Cortex XSOAR. A CIDR or query
        is required.
      name: query
    - description: A CIDR (remote network) name that will be displayed for all uploaded
        values in QRadar.
      name: name
      required: true
    - description: Description that will be displayed and associated with all the
        newly uploaded CIDRs in QRadar.
      name: description
      required: true
    - description: The exact name of the remote network group that CIDRs should be
        associated with as it appears in QRadar. A single group can be assigned to
        each create command. A new remote network group can be created in QRadar by
        giving a new unique remote network group name (that does not already exist
        in QRadar remote networks).
      name: group
      required: true
    - description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded from the output.
        Specify subfields in brackets, and multiple fields in the same object are
        separated by commas. The possible fields are id, group, name, CIDR, and description.
      name: fields
    description: Create remote network CIDRs.
    name: qradar-remote-network-cidr-create
  - arguments:
    - description: The maximum number of results to return. The default is 50.
      name: limit
    - description: The page offset.
      name: page
    - description: Maximum number of results to retrieve in each page.
      name: page_size
    - description: The name of the remote network group that the CIDRs are associated
        with, as it appears in QRadar.
      name: group
    - description: ID of the CIDR (remote network).
      name: id
    - description: The name of the CIDRs (remote network) as it appears in QRadar.
      name: name
    - description: Additional options to filter results using a query expression.
      name: filter
    - description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. By default,
        this argument returns all fields (id, name, cidrs, group, description).
      name: fields
    description: Retrieves the list of staged remote networks.
    name: qradar-remote-network-cidr-list
    outputs:
    - contextPath: QRadar.RemoteNetworkCIDR
      description: A list of all the retrieved CIDRs.
      type: Number
    - contextPath: QRadar.RemoteNetworkCIDR.id
      description: ID of each CIDR remote network that is part of the group.
      type: Number
    - contextPath: QRadar.RemoteNetworkCIDR.name
      description: The associated CIDR name as it appears in QRadar.
      type: String
    - contextPath: QRadar.RemoteNetworkCIDR.description
      description: The associated CIDR description as it appears in QRadar.
      type: String
  - arguments:
    - description: ID that is used to locate the staged remote network that users
        want to remove from QRadar.
      isArray: true
      name: id
      required: true
      type: number
    description: Deletes an existing staged remote network.
    name: qradar-remote-network-cidr-delete
  - arguments:
    - description: The ID that is associated with the CIDR object that needs to be
        modified.
      name: id
      required: true
    - description: The CIDR name in QRadar. If the CIDR name should be changed, it
        can be inserted here.
      name: name
      required: true
    - description: An input list of CIDRs to add to QRadar (can be obtained automatically
        from EDL integrations and playbook). Multiple values in the same object are
        separated by commas. A CIDR or query is required.
      isArray: true
      name: cidrs
    - description: The query for getting indicators from Cortex XSOAR. A CIDR or query
        is required.
      name: query
    - description: CIDR associated description presented in QRadar. If the CIDR description
        should be changed, it can be inserted here.
      name: description
      required: true
    - description: The remote network group that CIDRs should belong to. If the CIDR-associated
        group should be changed, it can be inserted here.
      name: group
      required: true
    - description: Use this parameter to specify which fields you would like to get
        back in the response. Fields that are not named are excluded. Specify subfields
        in brackets, and multiple fields in the same object are separated by commas.
        The possible fields are id,group,name,cidr,description.
      name: fields
    description: Updates an existing staged remote network.
    name: qradar-remote-network-cidr-update
    outputs:
    - contextPath: QRadar.RemoteNetworkCIDR
      description: A list of all the CIDR ranges that were changed.
      type: Number
    - contextPath: QRadar.RemoteNetworkCIDR.id
      description: The associated CIDR ID.
      type: Number
    - contextPath: QRadar.RemoteNetworkCIDR.name
      description: The associated CIDR name.
      type: String
    - contextPath: QRadar.RemoteNetworkCIDR.group
      description: The group to which the remote network belongs.
      type: String
    - contextPath: QRadar.RemoteNetworkCIDR.description
      description: The description of the remote network.
      type: String
  - arguments:
    - description: The IP of QRadar console host.
      name: host_ip
      required: true
    - auto: PREDEFINED
      description: The deployment status. Must be in capital letters (INITIATING).
      name: status
      predefined:
      - INITIATING
    - auto: PREDEFINED
      description: The deployment type. Must be in capital letters (INCREMENTAL
        or FULL).
      name: deployment_type
      predefined:
      - INCREMENTAL
      - FULL
      required: true
    description: |
      Executes a deployment.
      Potentially harmful: This API command executes any waiting system deployments in QRadar within the same deployment type and hosts defined.
    name: qradar-remote-network-deploy-execution
    outputs:
    - contextPath: QRadar.deploy.status
      description: The deployment status (INITIALIZING, IN_PROGRESS, COMPLETE).
      type: String
  dockerimage: demisto/python3:3.10.14.96411
  isFetchSamples: true
  ismappable: true
  isremotesyncin: true
  longRunning: true
  runonce: false
  script: |
    register_module_line('QRadar v3', 'start', __line__())
    ### pack version: 2.5.2
    import concurrent.futures
    import secrets
    from enum import Enum
    from ipaddress import ip_address
    from urllib import parse
    import uuid

    import pytz
    import urllib3




    # Disable insecure warnings
    urllib3.disable_warnings()  # pylint: disable=no-member

    ''' ADVANCED GLOBAL PARAMETERS '''

    FAILURE_SLEEP = 20  # sleep between consecutive failures events fetch
    FETCH_SLEEP = arg_to_number(demisto.params().get("fetch_interval")) or 60  # sleep between fetches
    BATCH_SIZE = 100  # batch size used for offense ip enrichment
    OFF_ENRCH_LIMIT = BATCH_SIZE * 10  # max amount of IPs to enrich per offense
    MAX_WORKERS = 8  # max concurrent workers used for events enriching
    DOMAIN_ENRCH_FLG = 'true'  # when set to true, will try to enrich offense and assets with domain names
    RULES_ENRCH_FLG = 'true'  # when set to true, will try to enrich offense with rule names
    SLEEP_FETCH_EVENT_RETRIES = 10  # sleep between iteration to try search the events of an offense
    MAX_NUMBER_OF_OFFENSES_TO_CHECK_SEARCH = 5  # Number of offenses to check during mirroring if search was completed.
    DEFAULT_EVENTS_TIMEOUT = 30  # default timeout for the events enrichment in minutes
    PROFILING_DUMP_ROWS_LIMIT = 20
    MAX_RETRIES_CONTEXT = 5  # max number of retries to update the context
    MAX_SEARCHES_QUEUE = 10  # maximum number of concurrent searches in mirroring

    SAMPLE_SIZE = 2  # number of samples to store in integration context
    EVENTS_INTERVAL_SECS = 60  # interval between events polling
    EVENTS_MODIFIED_SECS = 5  # interval between events status polling in modified

    EVENTS_SEARCH_TRIES = 3  # number of retries for creating a new search
    EVENTS_POLLING_TRIES = 10  # number of retries for events polling
    EVENTS_SEARCH_RETRY_SECONDS = 100  # seconds between retries to create a new search
    CONNECTION_ERRORS_RETRIES = 5  # num of times to retry in case of connection-errors
    CONNECTION_ERRORS_INTERVAL = 1  # num of seconds between each time to send an http-request in case of a connection error.


    ADVANCED_PARAMETERS_STRING_NAMES = [
        'DOMAIN_ENRCH_FLG',
        'RULES_ENRCH_FLG',
    ]
    ADVANCED_PARAMETER_INT_NAMES = [
        'EVENTS_INTERVAL_SECS',
        'MAX_SEARCHES_QUEUE',
        'EVENTS_SEARCH_RETRIES',
        'EVENTS_POLLING_RETRIES',
        'EVENTS_SEARCH_RETRY_SECONDS',
        'FAILURE_SLEEP',
        'FETCH_SLEEP',
        'BATCH_SIZE',
        'OFF_ENRCH_LIMIT',
        'MAX_WORKERS',
        'SLEEP_FETCH_EVENT_RETRIES',
        'DEFAULT_EVENTS_TIMEOUT',
        'PROFILING_DUMP_ROWS_LIMIT',
    ]

    ''' CONSTANTS '''
    API_USERNAME = '_api_token_key'
    RESET_KEY = 'reset'
    LAST_FETCH_KEY = 'id'
    MINIMUM_API_VERSION = 10.1
    DEFAULT_RANGE_VALUE = '0-49'
    DEFAULT_TIMEOUT_VALUE = '35'
    DEFAULT_LIMIT_VALUE = 50
    MAXIMUM_MIRROR_LIMIT = 100
    DEFAULT_EVENTS_LIMIT = 20
    MAXIMUM_OFFENSES_PER_FETCH = 50
    DEFAULT_OFFENSES_PER_FETCH = 20
    DEFAULT_MIRRORING_DIRECTION = 'No Mirroring'
    MIRROR_OFFENSE_AND_EVENTS = 'Mirror Offense and Events'
    MIRROR_DIRECTION: dict[str, Optional[str]] = {
        'No Mirroring': None,
        'Mirror Offense': 'In',
        MIRROR_OFFENSE_AND_EVENTS: 'In'
    }
    MIRRORED_OFFENSES_QUERIED_CTX_KEY = 'mirrored_offenses_queried'
    MIRRORED_OFFENSES_FINISHED_CTX_KEY = 'mirrored_offenses_finished'
    MIRRORED_OFFENSES_FETCHED_CTX_KEY = 'mirrored_offenses_fetched'

    LAST_MIRROR_KEY = 'last_mirror_update'
    LAST_MIRROR_CLOSED_KEY = 'last_mirror_closed_update'

    UTC_TIMEZONE = pytz.timezone('utc')
    ID_QUERY_REGEX = re.compile(r'(?:\s+|^)id((\s)*)>(=?)((\s)*)((\d)+)(?:\s+|$)')
    NAME_AND_GROUP_REGEX = re.compile(r'^[\w-]+$')
    ASCENDING_ID_ORDER = '+id'
    EXECUTOR = concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS)

    DEFAULT_EVENTS_COLUMNS = """QIDNAME(qid), LOGSOURCENAME(logsourceid), CATEGORYNAME(highlevelcategory), CATEGORYNAME(category), PROTOCOLNAME(protocolid), sourceip, sourceport, destinationip, destinationport, QIDDESCRIPTION(qid), username, PROTOCOLNAME(protocolid), RULENAME("creEventList"), sourcegeographiclocation, sourceMAC, sourcev6, destinationgeographiclocation, destinationv6, LOGSOURCETYPENAME(devicetype), credibility, severity, magnitude, eventcount, eventDirection, postNatDestinationIP, postNatDestinationPort, postNatSourceIP, postNatSourcePort, preNatDestinationPort, preNatSourceIP, preNatSourcePort, UTF8(payload), starttime, devicetime"""  # noqa: E501
    DEFAULT_ASSETS_LIMIT = 100

    ''' OUTPUT FIELDS REPLACEMENT MAPS '''
    OFFENSE_OLD_NEW_NAMES_MAP = {
        'credibility': 'Credibility',
        'relevance': 'Relevance',
        'severity': 'Severity',
        'assigned_to': 'AssignedTo',
        'destination_networks': 'DestinationHostname',
        'status': 'Status',
        'closing_user': 'ClosingUser',
        'closing_reason_id': 'ClosingReason',
        'close_time': 'CloseTime',
        'categories': 'Categories',
        'follow_up': 'Followup',
        'id': 'ID',
        'description': 'Description',
        'source_address_ids': 'SourceAddress',
        'local_destination_address_ids': 'DestinationAddress',
        'remote_destination_count': 'RemoteDestinationCount',
        'start_time': 'StartTime',
        'event_count': 'EventCount',
        'flow_count': 'FlowCount',
        'offense_source': 'OffenseSource',
        'magnitude': 'Magnitude',
        'last_updated_time': 'LastUpdatedTime',
        'offense_type': 'OffenseType',
        'protected': 'Protected',
        'LinkToOffense': 'LinkToOffense',
        'rules': 'Rules',
        'domain_name': 'DomainName',
        'assets': 'Assets'
    }

    CLOSING_REASONS_RAW_FORMATTED = {
        'id': 'ID',
        'text': 'Name',
        'is_reserved': 'IsReserved',
        'is_deleted': 'IsDeleted'
    }

    NOTES_RAW_FORMATTED = {
        'id': 'ID',
        'note_text': 'Text',
        'create_time': 'CreateTime',
        'username': 'CreatedBy'
    }

    RULES_RAW_FORMATTED = {
        'owner': 'Owner',
        'base_host_id': 'BaseHostID',
        'capacity_timestamp': 'CapacityTimestamp',
        'origin': 'Origin',
        'creation_date': 'CreationDate',
        'type': 'Type',
        'enabled': 'Enabled',
        'modification_date': 'ModificationDate',
        'name': 'Name',
        'average_capacity': 'AverageCapacity',
        'id': 'ID',
        'base_capacity': 'BaseCapacity'
    }

    RULES_GROUP_RAW_FORMATTED = {
        'owner': 'Owner',
        'modified_time': 'ModifiedTime',
        'level': 'Level',
        'name': 'Name',
        'description': 'Description',
        'id': 'ID',
        'child_groups': 'ChildGroups',
        'child_items': 'ChildItems',
        'type': 'Type',
        'parent_id': 'ParentID'
    }

    ASSET_RAW_FORMATTED = {
        'vulnerability_count': 'VulnerabilityCount',
        'interfaces': 'Interfaces',
        'risk_score_sum': 'RiskScoreSum',
        'hostnames': 'Hostnames',
        'id': 'ID',
        'users': 'Users',
        'domain_id': 'DomainID',
        'properties': 'Properties',
        'products': 'Products'
    }

    SEARCH_RAW_FORMATTED = {'search_id': 'ID', 'status': 'Status'}

    REFERENCE_SETS_RAW_FORMATTED = {
        'number_of_elements': 'NumberOfElements',
        'name': 'Name',
        'creation_time': 'CreationTime',
        'element_type': 'ElementType',
        'time_to_live': 'TimeToLive',
        'timeout_type': 'TimeoutType',
        'data': 'Data',
    }
    REFERENCE_SET_DATA_RAW_FORMATTED = {
        'last_seen': 'LastSeen',
        'source': 'Source',
        'value': 'Value',
        'first_seen': 'FirstSeen'
    }

    DOMAIN_RAW_FORMATTED = {
        'asset_scanner_ids': 'AssetScannerIDs',
        'custom_properties': 'CustomProperties',
        'deleted': 'Deleted',
        'description': 'Description',
        'event_collector_ids': 'EventCollectorIDs',
        'flow_collector_ids': 'FlowCollectorIDs',
        'flow_source_ids': 'FlowSourceIDs',
        'id': 'ID',
        'log_source_ids': 'LogSourceIDs',
        'log_source_group_ids': 'LogSourceGroupIDs',
        'name': 'Name',
        'qvm_scanner_ids': 'QVMScannerIDs',
        'tenant_id': 'TenantID'
    }

    SAVED_SEARCH_RAW_FORMATTED = {
        'owner': 'Owner',
        'description': 'Description',
        'creation_date': 'CreationDate',
        'uid': 'UID',
        'database': 'Database',
        'is_quick_search': 'QuickSearch',
        'name': 'Name',
        'modified_date': 'ModifiedDate',
        'id': 'ID',
        'aql': 'AQL',
        'is_shared': 'IsShared'
    }

    IP_GEOLOCATION_RAW_FORMATTED = {
        'continent': 'Continent',
        'traits': 'Traits',
        'geo_json': 'Geolocation',
        'city': 'City',
        'ip_address': 'IPAddress',
        'represented_country': 'RepresentedCountry',
        'registered_country': 'RegisteredCountry',
        'is_local': 'IsLocalCountry',
        'location': 'Location',
        'postal': 'Postal',
        'physical_country': 'PhysicalCountry',
        'subdivisions': 'SubDivisions'
    }

    LOG_SOURCES_RAW_FORMATTED = {
        'sending_ip': 'SendingIP',
        'internal': 'Internal',
        'protocol_parameters': 'ProtocolParameters',
        'description': 'Description',
        'enabled': 'Enabled',
        'group_ids': 'GroupIDs',
        'credibility': 'Credibility',
        'id': 'ID',
        'protocol_type_id': 'ProtocolTypeID',
        'creation_date': 'CreationDate',
        'name': 'Name',
        'modified_date': 'ModifiedDate',
        'auto_discovered': 'AutoDiscovered',
        'type_id': 'TypeID',
        'last_event_time': 'LastEventTime',
        'gateway': 'Gateway',
        'status': 'Status',
        'target_event_collector_id': 'TargetEventCollectorID'
    }

    USECS_ENTRIES = {'last_persisted_time',
                     'start_time',
                     'close_time',
                     'create_time',
                     'creation_time',
                     'creation_date',
                     'last_updated_time',
                     'first_persisted_time',
                     'modification_date',
                     'last_seen',
                     'first_seen',
                     'starttime',
                     'devicetime',
                     'last_reported',
                     'created',
                     'last_seen_profiler',
                     'last_seen_scanner',
                     'first_seen_scanner',
                     'first_seen_profiler',
                     'modified_time',
                     'last_event_time',
                     'modified_date',
                     'first_event_flow_seen',
                     'last_event_flow_seen'}

    LOCAL_DESTINATION_IPS_RAW_FORMATTED = {
        'domain_id': 'DomainID',
        'event_flow_count': 'EventFlowCount',
        'first_event_flow_seen': 'FirstEventFlowSeen',
        'id': 'ID',
        'last_event_flow_seen': 'LastEventFlowSeen',
        'local_destination_ip': 'LocalDestinationIP',
        'magnitude': 'Magnitude',
        'network': 'Network',
        'offense_ids': 'OffenseIDs',
        'source_address_ids': 'SourceAddressIDs'
    }
    SOURCE_IPS_RAW_FORMATTED = {
        'domain_id': 'DomainID',
        'event_flow_count': 'EventFlowCount',
        'first_event_flow_seen': 'FirstEventFlowSeen',
        'id': 'ID',
        'last_event_flow_seen': 'LastEventFlowSeen',
        'local_destination_address_ids': 'LocalDestinationAddressIDs',
        'magnitude': 'Magnitude',
        'network': 'Network',
        'offense_ids': 'OffenseIDs',
        'source_ip': 'SourceIP'
    }

    EVENT_COLLECTOR_RAW_FORMATTED = {
        'component_name': 'ComponentName',
        'host_id': 'HostID',
        'id': 'ID',
        'name': 'Name'
    }

    WINCOLLECT_DESTINATION_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name',
        'host': 'Host',
        'tls_certificate': 'TlsCertificate',
        'port': 'Port',
        'transport_protocol': 'TransportProtocol',
        'inernal': 'IsInternal',
        'event_rate_throttle': 'EventRateThrottle'
    }

    DISCONNECTED_LOG_COLLECTOR_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name',
        'description': 'Description',
        'protocol': 'Protocol',
        'uuid': 'UUID',
        'version': 'Version'
    }

    LOG_SOURCE_TYPES_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name',
        'custom': 'Custom',
        'version': 'Version',
        'uuid': 'UUID',
        'supported_language_ids': 'SupportedLanguageIDs',
        'protocol_types': 'ProtocolTypes',
        'default_protocol_id': 'DefaultProtocolID',
        'internal': 'Internal',
        'latest_version': 'LatestVersion',
        'log_source_extension_id': 'LogSourceExtensionID',
    }

    LOG_SOURCE_PROTOCOL_TYPE_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name',
        'version': 'Version',
        'latest_version': 'LatestVersion',
        'gateway_supported': 'GatewaySupported',
        'inbound': 'Inbound',
        'parameters': 'Parameters',
        'parameter_groups': 'ParameterGroups',
        'testing_capabilities': 'TestingCapabilities'
    }

    LOG_SOURCE_EXTENSION_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name',
        'description': 'Description',
        'uuid': 'UUID',
    }

    LOG_SOURCE_LANGUAGE_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'Name'
    }

    LOG_SOURCE_GROUP_RAW_FORMATTED = {
        'id': 'ID',
        'name': 'GroupName',
        'description': 'Description',
        'parent_id': 'ParentID',
        'assignable': 'Assignable'
    }

    ''' ENRICHMENT MAPS '''

    ASSET_PROPERTIES_NAME_MAP = {
        'Unified Name': 'Name',
        'CVSS Collateral Damage Potential': 'AggregatedCVSSScore',
        'Weight': 'Weight'
    }

    FULL_ASSET_PROPERTIES_NAMES_MAP = {
        'Compliance Notes': 'ComplianceNotes',
        'Compliance Plan': 'CompliancePlan',
        'Location': 'Location',
        'Switch ID': 'SwitchID',
        'Switch Port ID': 'SwitchPort',
        'Group Name': 'GroupName',
        'Vulnerabilities': 'Vulnerabilities',
    }
    LONG_RUNNING_REQUIRED_PARAMS = {'fetch_mode': 'Fetch mode',
                                    'offenses_per_fetch': 'Number of offenses to pull per API call (max 50)',
                                    'events_limit': 'Maximum number of events per incident.'}

    ''' ENUMS '''


    class FetchMode(str, Enum):
        """
        Enums for the options of fetching the incidents.
        """
        no_events = 'Fetch Without Events'
        all_events = 'Fetch With All Events'
        correlations_events_only = 'Fetch Correlation Events Only'


    class QueryStatus(str, Enum):
        """
        Enums for the options of fetching the events.
        """
        WAIT = 'wait'
        ERROR = 'error'
        SUCCESS = 'success'
        PARTIAL = 'partial'


    FIELDS_MIRRORING = 'id,start_time,event_count,last_persisted_time,close_time'

    ''' CLIENT CLASS '''


    class Client(BaseClient):

        def __init__(
            self, server: str, verify: bool, proxy: bool, api_version: str, credentials: dict, timeout: Optional[int] = None
        ):
            username = credentials.get('identifier')
            password = credentials.get('password')
            if username == API_USERNAME:
                self.base_headers = {'Version': api_version, 'SEC': password}
                auth = None
            else:
                auth = (username, password)
                self.base_headers = {'Version': api_version}
            base_url = urljoin(server, '/api')
            super().__init__(base_url=base_url, verify=verify, proxy=proxy, auth=auth)
            self.timeout = timeout  # type: ignore[assignment]
            self.password = password
            self.server = server

        def http_request(self, method: str, url_suffix: str, params: Optional[dict] = None,
                         json_data: Optional[dict | list[dict]] = None, data: Optional[dict] = None,
                         additional_headers: Optional[dict] = None,
                         timeout: Optional[int] = None, resp_type: str = 'json') -> Any:
            headers = {**additional_headers, **self.base_headers} if additional_headers else self.base_headers
            for _time in range(1, CONNECTION_ERRORS_RETRIES + 1):
                try:
                    return self._http_request(
                        method=method,
                        url_suffix=url_suffix,
                        params=params,
                        json_data=json_data,
                        data=data,
                        headers=headers,
                        error_handler=self.qradar_error_handler,
                        timeout=timeout or self.timeout,
                        resp_type=resp_type,
                        with_metrics=True
                    )
                except (DemistoException, requests.ReadTimeout) as error:
                    demisto.error(f'Error {error} in time {_time}')
                    if (
                        isinstance(
                            error, DemistoException
                        ) and not isinstance(
                            error.exception, requests.ConnectionError) or _time == CONNECTION_ERRORS_RETRIES
                    ):
                        raise
                    else:
                        time.sleep(CONNECTION_ERRORS_INTERVAL)  # pylint: disable=sleep-exists
            return None

        @staticmethod
        def qradar_error_handler(res: requests.Response):
            """
            QRadar error handler for any error occurred during the API request.
            This function job is to translate the known exceptions returned by QRadar
            to human readable exception to help the user understand why the request have failed.
            If error returned is not in the expected error format, raises the exception as is.
            Args:
                res (Any): The error response returned by QRadar.

            Returns:
                - raises DemistoException.
            """
            err_msg = f'Error in API call [{res.status_code}] - {res.reason}'
            try:
                # Try to parse json error response
                error_entry = res.json()
                message = error_entry.get('message', '')
                if 'items=x-y' in message:
                    message = 'Failed to parse Range argument. The syntax of the Range argument must follow this pattern:' \
                        ' x-y'
                elif 'unauthorized to access' in err_msg or 'No SEC header present in request' in err_msg:
                    message = 'Authorization Error: make sure credentials are correct.'
                elif 'The specified encryption strength is not available' in err_msg:
                    err_msg = ''
                    message = 'The specified encryption is not available, try using a weaker encryption (AES128).'
                elif 'User has insufficient capabilities to access this endpoint resource' in message:
                    message = 'The given credentials do not have the needed permissions to perform the call the endpoint' \
                        f'\n{res.request.path_url}.\n' \
                        'Please supply credentials with the needed permissions as can be seen in the integration ' \
                        'description, or do not call or enrich offenses with the mentioned endpoint.'
                err_msg += f'\n{message}'
                raise DemistoException(err_msg, res=res)
            except ValueError as e:
                err_msg += f'\n{res.text}'
                raise DemistoException(err_msg, res=res) from e

        def offenses_list(self, range_: Optional[str] = None, offense_id: Optional[int] = None,
                          filter_: Optional[str] = None, fields: Optional[str] = None, sort: Optional[str] = None):
            id_suffix = f'/{offense_id}' if offense_id else ''
            params = assign_params(fields=fields) if offense_id else assign_params(filter=filter_, fields=fields, sort=sort)
            additional_headers = {'Range': range_} if not offense_id else None
            return self.http_request(
                method='GET',
                url_suffix=f'/siem/offenses{id_suffix}',
                params=params,
                additional_headers=additional_headers
            )

        def offense_update(self, offense_id: int, protected: Optional[str] = None, follow_up: Optional[str] = None,
                           status: Optional[str] = None, closing_reason_id: Optional[int] = None,
                           assigned_to: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='POST',
                url_suffix=f'/siem/offenses/{offense_id}',
                params=assign_params(
                    protected=protected,
                    follow_up=follow_up,
                    status=status,
                    closing_reason_id=closing_reason_id,
                    assigned_to=assigned_to,
                    fields=fields
                )
            )

        def closing_reasons_list(self, closing_reason_id: Optional[int] = None, include_reserved: Optional[bool] = None,
                                 include_deleted: Optional[bool] = None, range_: Optional[str] = None,
                                 filter_: Optional[str] = None, fields: Optional[str] = None):
            id_suffix = f'/{closing_reason_id}' if closing_reason_id else ''
            params = assign_params(fields=fields) if closing_reason_id else assign_params(include_reserved=include_reserved,
                                                                                          include_deleted=include_deleted,
                                                                                          filter=filter_, fields=fields)
            additional_headers = {'Range': range_} if not closing_reason_id and range_ else None
            return self.http_request(
                method='GET',
                url_suffix=f'/siem/offense_closing_reasons{id_suffix}',
                additional_headers=additional_headers,
                params=params
            )

        def offense_notes_list(self, offense_id: int, range_: str, note_id: Optional[int] = None,
                               filter_: Optional[str] = None, fields: Optional[str] = None):
            note_id_suffix = f'/{note_id}' if note_id else ''
            params = assign_params(fields=fields) if note_id else assign_params(filter=filter_, fields=fields)
            additional_headers = {'Range': range_} if not note_id else None
            return self.http_request(
                method='GET',
                url_suffix=f'/siem/offenses/{offense_id}/notes{note_id_suffix}',
                additional_headers=additional_headers,
                params=params
            )

        def offense_notes_create(self, offense_id: int, note_text: str, fields: Optional[str] = None):
            return self.http_request(
                method='POST',
                url_suffix=f'/siem/offenses/{offense_id}/notes',
                params=assign_params(note_text=note_text, fields=fields)
            )

        def rules_list(self, rule_id: Optional[str] = None, range_: Optional[str] = None, filter_: Optional[str] = None,
                       fields: Optional[str] = None):
            id_suffix = f'/{rule_id}' if rule_id else ''
            params = assign_params(fields=fields) if rule_id else assign_params(filter=filter_, fields=fields)
            additional_headers = {'Range': range_} if range_ and not rule_id else None
            return self.http_request(
                method='GET',
                url_suffix=f'/analytics/rules{id_suffix}',
                params=params,
                additional_headers=additional_headers
            )

        def rule_groups_list(self, range_: str, rule_group_id: Optional[int] = None, filter_: Optional[str] = None,
                             fields: Optional[str] = None):
            id_suffix = f'/{rule_group_id}' if rule_group_id else ''
            additional_headers = {'Range': range_} if not rule_group_id else None
            params = assign_params(fields=fields) if rule_group_id else assign_params(filter=filter_, fields=fields)
            return self.http_request(
                method='GET',
                url_suffix=f'/analytics/rule_groups{id_suffix}',
                additional_headers=additional_headers,
                params=params
            )

        def assets_list(self, range_: Optional[str] = None, filter_: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/asset_model/assets',
                additional_headers={'Range': range_},
                params=assign_params(filter=filter_, fields=fields)
            )

        def saved_searches_list(self, range_: str, timeout: Optional[int], saved_search_id: Optional[str] = None,
                                filter_: Optional[str] = None, fields: Optional[str] = None):
            id_suffix = f'/{saved_search_id}' if saved_search_id else ''
            params = assign_params(fields=fields) if saved_search_id else assign_params(filter=filter_, fields=fields)
            additional_headers = {'Range': range_} if not saved_search_id else None
            return self.http_request(
                method='GET',
                url_suffix=f'/ariel/saved_searches{id_suffix}',
                additional_headers=additional_headers,
                params=params,
                timeout=timeout
            )

        def searches_list(self, range_: str, filter_: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/ariel/searches',
                additional_headers={'Range': range_},
                params=assign_params(filter=filter_)
            )

        def search_create(self, query_expression: Optional[str] = None, saved_search_id: Optional[str] = None):
            return self.http_request(
                method='POST',
                url_suffix='/ariel/searches',
                params=assign_params(
                    query_expression=query_expression,
                    saved_search_id=saved_search_id
                )
            )

        def search_status_get(self, search_id: str):
            return self.http_request(
                method='GET',
                url_suffix=f'/ariel/searches/{search_id}',
            )

        def search_delete(self, search_id: str):
            return self.http_request(
                method='DELETE',
                url_suffix=f'/ariel/searches/{search_id}',
            )

        def search_cancel(self, search_id: str):
            return self.http_request(
                method='POST',
                url_suffix=f'/ariel/searches/{search_id}?status=CANCELED',
            )

        def search_results_get(self, search_id: str, range_: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix=f'/ariel/searches/{search_id}/results',
                additional_headers={'Range': range_} if range_ else None
            )

        def reference_sets_list(self, range_: Optional[str] = None, ref_name: Optional[str] = None,
                                filter_: Optional[str] = None, fields: Optional[str] = None):
            name_suffix = f'/{parse.quote(ref_name, safe="")}' if ref_name else ''
            params = assign_params(filter=filter_, fields=fields)
            additional_headers = {'Range': range_}
            return self.http_request(
                method='GET',
                url_suffix=f'/reference_data/sets{name_suffix}',
                params=params,
                additional_headers=additional_headers
            )

        def reference_set_create(self, ref_name: str, element_type: str, timeout_type: Optional[str] = None,
                                 time_to_live: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='POST',
                url_suffix='/reference_data/sets',
                params=assign_params(
                    name=ref_name,
                    element_type=element_type,
                    timeout_type=timeout_type,
                    time_to_live=time_to_live,
                    fields=fields
                )
            )

        def reference_set_delete(self, ref_name: str, purge_only: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='DELETE',
                url_suffix=f'/reference_data/sets/{parse.quote(parse.quote(ref_name, safe=""), safe="")}',
                params=assign_params(purge_only=purge_only, fields=fields)
            )

        def reference_set_value_upsert(self, ref_name: str, value: str, source: Optional[str] = None,
                                       fields: Optional[str] = None):
            return self.http_request(
                method='POST',
                url_suffix=f'/reference_data/sets/{parse.quote(ref_name, safe="")}',
                params=assign_params(value=value, source=source, fields=fields)
            )

        def reference_set_value_delete(self, ref_name: str, value: str):
            double_encoded_value = parse.quote(parse.quote(value, safe=""), safe="")
            double_encoded_ref_name = parse.quote(parse.quote(ref_name, safe=""), safe="")
            return self.http_request(
                method='DELETE',
                url_suffix=f'/reference_data/sets/{double_encoded_ref_name}/{double_encoded_value}'
            )

        def domains_list(self, domain_id: Optional[int] = None, range_: Optional[str] = None, filter_: Optional[str] = None,
                         fields: Optional[str] = None):
            id_suffix = f'/{domain_id}' if domain_id else ''
            params = assign_params(fields=fields) if domain_id else assign_params(filter=filter_, fields=fields)
            additional_headers = {'Range': range_} if not domain_id and range_ else None
            return self.http_request(
                method='GET',
                url_suffix=f'/config/domain_management/domains{id_suffix}',
                additional_headers=additional_headers,
                params=params
            )

        def reference_set_bulk_load(self, ref_name: str, indicators: Any, fields: Optional[str] = None):
            headers = {
                'Content-Type': 'application/json'
            }
            if fields:
                headers['fields'] = fields
            return self.http_request(
                method='POST',
                url_suffix=f'/reference_data/sets/bulk_load/{parse.quote(ref_name, safe="")}',
                json_data=indicators,
                additional_headers=headers
            )

        def reference_set_entries(
            self,
            ref_name: str,
            indicators: Any,
            fields: Optional[str] = None,
            source: Optional[str] = None,
            timeout: Optional[int] = None
        ):
            headers = {
                'Content-Type': 'application/json'
            }
            if fields:
                headers['fields'] = fields
            name = parse.quote(ref_name, safe='')
            sets = self.http_request(method='GET', url_suffix=f'/reference_data/sets/{name}')
            if not sets:
                raise DemistoException(f'Reference set {ref_name} does not exist.')
            set_id = sets.get('collection_id')
            return self.http_request(
                method='PATCH',
                url_suffix='/reference_data_collections/set_entries',
                json_data=[{"collection_id": set_id, "value": str(indicator), "source": source}
                           for indicator in indicators],  # type: ignore[arg-type]
                additional_headers=headers,
                timeout=timeout
            )

        def get_reference_data_bulk_task_status(self, task_id: int):
            return self.http_request(
                method='GET',
                url_suffix=f'/reference_data_collections/set_bulk_update_tasks/{task_id}'
            )

        def geolocations_for_ip(self, filter_: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/services/geolocations',
                params=assign_params(filter=filter_, fields=fields)
            )

        def log_sources_list(self, qrd_encryption_algorithm: str, qrd_encryption_password: str,
                             range_: str, filter_: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/config/event_sources/log_source_management/log_sources',
                params=assign_params(filter=filter_, fields=fields),
                additional_headers={
                    'x-qrd-encryption-algorithm': qrd_encryption_algorithm,
                    'x-qrd-encryption-password': qrd_encryption_password,
                    'Range': range_
                }
            )

        def get_log_source(self, qrd_encryption_algorithm: str, qrd_encryption_password: str, id: str,
                           fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix=f'/config/event_sources/log_source_management/log_sources/{id}',
                params=assign_params(fields=fields),
                additional_headers={
                    'x-qrd-encryption-algorithm': qrd_encryption_algorithm,
                    'x-qrd-encryption-password': qrd_encryption_password
                }
            )

        def custom_properties(self, range_: Optional[str] = None, filter_: Optional[str] = None,
                              fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/config/event_sources/custom_properties/regex_properties',
                params=assign_params(filter=filter_, fields=fields),
                additional_headers={'Range': range_} if range_ else None
            )

        def offense_types(self, filter_: Optional[str] = None, fields: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix='/siem/offense_types',
                params=assign_params(filter=filter_, fields=fields)
            )

        def get_addresses(self, address_suffix: str, filter_: Optional[str] = None, fields: Optional[str] = None,
                          range_: Optional[str] = None):
            return self.http_request(
                method='GET',
                url_suffix=f'/siem/{address_suffix}',
                params=assign_params(filter=filter_, fields=fields),
                additional_headers={'Range': range_} if range_ else None
            )

        def create_and_update_remote_network_cidr(self, body: dict[str, Any], fields: str, update: bool = False):
            headers = {'fields': fields}

            return self.http_request(
                method='POST',
                url_suffix='/staged_config/remote_networks' + (f'/{body.get("id")}' if update else ''),
                json_data=body,
                additional_headers=headers
            )

        def get_remote_network_cidr(self, range_: Optional[str] = None, filter_: Optional[str] = None, fields: Optional[str] = None):
            headers = {'Range': range_}
            params = assign_params(filter=filter_, fields=fields)

            return self.http_request(
                method='GET',
                url_suffix='/staged_config/remote_networks',
                params=params,
                additional_headers=headers
            )

        def delete_remote_network_cidr(self, id_):
            return self.http_request(
                method='DELETE',
                url_suffix=f'/staged_config/remote_networks/{id_}',
                resp_type='response'
            )

        def remote_network_deploy_execution(self, body):
            return self.http_request(
                method='POST',
                url_suffix='/staged_config/deploy_status',
                json_data=body
            )

        def get_resource_list(
                self,
                range_: str,
                endpoint: str,
                filter_: Optional[str] = None,
                fields: Optional[str] = None,
                additional_headers_: Optional[dict] = None):
            """
            Retrieve a list of resources from a specified endpoint.

            Args:
                range_ (str): The range of resources to retrieve. eg. items=0-49
                endpoint (str): The API endpoint to retrieve resources from.
                filter_ (Optional[str], optional): Optional filter query for the request. Defaults to None.
                fields (Optional[str], optional): The fields that the API should return. Defaults to None.
                additional_headers_ (Optional[dict], optional): Optional additional headers for the request. Defaults to None.

            Returns:
                Response: The response object from the HTTP request.
            """
            return self.http_request(
                method='GET',
                url_suffix=endpoint,
                params=assign_params(filter=filter_, fields=fields),
                additional_headers={
                    'Range': range_
                } if additional_headers_ is None
                else {
                    'Range': range_,
                    **additional_headers_
                }
            )

        def get_resource_by_id(self, id: str, endpoint: str, fields: Optional[str] = None, additional_headers: Optional[dict] = None):
            return self.http_request(
                method='GET',
                url_suffix=endpoint + f'/{id}',
                params=assign_params(fields=fields),
                additional_headers=additional_headers
            )

        def get_resource(
                self,
                id,
                range_: str,
                endpoint: str,
                filter_: Optional[str] = None,
                fields: Optional[str] = None,
                additional_headers_: Optional[dict] = None):
            return self.get_resource_list(range_, endpoint, filter_, fields, additional_headers_) if id is None \
                else [self.get_resource_by_id(id, endpoint, fields, additional_headers_)]

        def delete_log_source(self, id: str) -> requests.Response:
            return self.http_request(
                method='DELETE',
                url_suffix=f'/config/event_sources/log_source_management/log_sources/{id}',
                resp_type='response'
            )

        def create_log_source(self, log_source: dict):
            return self.http_request(
                method='POST',
                url_suffix='/config/event_sources/log_source_management/log_sources',
                json_data=log_source
            )

        def update_log_source(self, log_source: dict[str, Any]):
            return self.http_request(
                method='PATCH',
                url_suffix='/config/event_sources/log_source_management/log_sources',
                json_data=[log_source],
                resp_type='response'
            )

        def test_connection(self):
            """
            Test connection with databases (should always be up)
            """
            self.http_request(method='GET', url_suffix='/ariel/databases')
            return 'ok'


    ''' HELPER FUNCTIONS '''


    def get_major_version(version: str) -> int:
        try:
            if '.' not in version:
                return int(version)
            return int(version.split('.')[0])
        except ValueError:
            print_debug_msg(f'Could not parse version {version} to int')
            return 17


    def insert_values_to_reference_set_polling(client: Client,
                                               api_version: str,
                                               args: dict,
                                               from_indicators: bool = False,
                                               values: list[str] | None = None,
                                               ) -> PollResult:
        """This function inserts values to reference set using polling method.


        Args:
            client (Client): QRadar Client
            api_version (str): The API version of QRadar.
            args (dict): args of the command
            from_indicators (bool, optional): Whether to insert values from XSOAR indicators. Defaults to False.
            values (list[str] | None, optional): The values to insert. Defaults to None.

        Raises:
            DemistoException: If there are no values to insert

        Returns:
            PollResult: The result with the CommandResults
        """
        response = {}
        use_old_api = get_major_version(api_version) <= 15
        ref_name = args.get('ref_name', '')
        try:
            if use_old_api or 'task_id' not in args:
                if from_indicators:
                    query = args.get('query')
                    limit = arg_to_number(args.get('limit', DEFAULT_LIMIT_VALUE))
                    page = arg_to_number(args.get('page', 0))

                    # Backward compatibility for QRadar V2 command. Create reference set for given 'ref_name' if does not exist.
                    element_type = args.get('element_type', '')
                    timeout_type = args.get('timeout_type')
                    time_to_live = args.get('time_to_live')
                    try:
                        client.reference_sets_list(ref_name=ref_name)
                    except DemistoException as e:
                        # Create reference set if does not exist
                        if e.message and f'{ref_name} does not exist' in e.message:
                            # if this call fails, raise an error and stop command execution
                            client.reference_set_create(ref_name, element_type, timeout_type, time_to_live)
                        else:
                            raise e

                    search_indicators = IndicatorsSearcher(page=page)
                    indicators = search_indicators.search_indicators_by_version(query=query, size=limit).get('iocs', [])
                    indicators_data = [{'Indicator Value': indicator.get('value'), 'Indicator Type': indicator.get('indicator_type')}
                                       for indicator in indicators if 'value' in indicator and 'indicator_type' in indicator]
                    values = [indicator.get('Indicator Value', '') for indicator in indicators_data]
                    if not indicators_data:
                        return PollResult(CommandResults(
                            readable_output=f'No indicators were found for reference set {ref_name}',
                        ))

                if not values:
                    raise DemistoException('Value to insert must be given.')
                source = args.get('source')
                date_value = argToBoolean(args.get('date_value', False))
                fields = args.get('fields')

                if date_value:
                    values = [get_time_parameter(value, epoch_format=True) for value in values]
                if use_old_api:
                    response = client.reference_set_bulk_load(ref_name, values, fields)
                else:
                    response = client.reference_set_entries(ref_name, values, fields, source, timeout=300)
                    args['task_id'] = response.get('id')
            if not use_old_api:
                response = client.get_reference_data_bulk_task_status(args["task_id"])
        except (DemistoException, requests.Timeout) as e:
            if 'task_id' in args:
                print_debug_msg(
                    f"Polling task status {args['task_id']} failed due to {e}. "
                    f"Will try to poll task status again in the next interval."
                )
            else:
                print_debug_msg(
                    f"Failed inserting values to reference due to {e}, will retry in the insert in the next interval"
                )
            response = {}
        if use_old_api or response.get("status") == "COMPLETED":
            if not use_old_api:
                # get the reference set data
                response = client.reference_sets_list(ref_name=ref_name)
            outputs = sanitize_outputs(response, REFERENCE_SETS_RAW_FORMATTED)

            command_results = CommandResults(
                readable_output=tableToMarkdown('Reference Update Create', outputs, removeNull=True),
                outputs_prefix='QRadar.Reference',
                outputs_key_field='Name',
                outputs=outputs,
                raw_response=response
            )
            return PollResult(command_results, continue_to_poll=False)
        return PollResult(
            partial_result=CommandResults(
                readable_output=f'Reference set {ref_name} is still being updated in task {args["task_id"]}'),
            continue_to_poll=True,
            args_for_next_run=args,
            response=None
        )


    def get_remote_events(client: Client,
                          offense_id: str,
                          context_data: dict,
                          context_version: Any,
                          events_columns: str,
                          events_limit: int,
                          fetch_mode: str,
                          ) -> tuple[list[dict], str]:
        """
        Get the remote events of the `offense_id`
        It will update the context data as well

        Args:
            client (Client): QRadar client
            offense_id (str): Offense id to update
            context_data (dict): The current context data
            context_version (Any): The current context version
            events_columns (str): events columns of AQL
            events_limit (int): events limit of AQL
            fetch_mode (str): The fetch mode configure

        Returns:
            Tuple[list[dict], SearchQueryStatus]: List of events of the offense id, the status of the request
        """
        changed_ids_ctx = []
        offenses_queried = context_data.get(MIRRORED_OFFENSES_QUERIED_CTX_KEY, {})
        offenses_finished = context_data.get(MIRRORED_OFFENSES_FINISHED_CTX_KEY, {})
        offenses_fetched = context_data.get(MIRRORED_OFFENSES_FETCHED_CTX_KEY, {})

        events: list[dict] = []
        status = QueryStatus.ERROR.value
        if offenses_queried.get(offense_id) == QueryStatus.ERROR.value:
            return events, QueryStatus.ERROR.value
        if offense_id not in offenses_finished or \
                offenses_queried.get(offense_id, '') in {QueryStatus.WAIT.value, QueryStatus.ERROR.value}:
            # if our offense not in the finished list, we will create a new search
            # the value will be error because we don't want to wait until the search is complete
            search_id = create_events_search(client, fetch_mode, events_columns, events_limit, int(offense_id))
            offenses_queried[offense_id] = search_id
            changed_ids_ctx.append(offense_id)
        elif offense_id in offenses_finished:  # if our offense is in finished list, we will get the result
            search_id = offenses_finished[offense_id]
            try:
                search_results = client.search_results_get(search_id)
                events = search_results.get('events', [])
                del offenses_finished[offense_id]
                changed_ids_ctx.append(offense_id)
                status = QueryStatus.SUCCESS.value
            except Exception as e:
                # getting results failed, move back to queried queue to be queried again
                del offenses_finished[offense_id]
                changed_ids_ctx.append(offense_id)
                offenses_queried[offense_id] = QueryStatus.ERROR.value
                status = QueryStatus.ERROR.value
                print_debug_msg(f'No results for {offense_id}. Error: {e}. Stopping execution')
                time.sleep(FAILURE_SLEEP)
        elif offense_id in offenses_queried:  # if our offense is in the queried list, we will get the result
            search_id = offenses_queried[offense_id]
            events, status = poll_offense_events(client, search_id, should_get_events=True, offense_id=int(offense_id))
            if status == QueryStatus.SUCCESS.value:
                del offenses_queried[offense_id]
                changed_ids_ctx.append(offense_id)

        if status == QueryStatus.SUCCESS.value:
            offenses_fetched[offense_id] = get_num_events(events)
            context_data.update({MIRRORED_OFFENSES_FETCHED_CTX_KEY: offenses_fetched})

        context_data.update({MIRRORED_OFFENSES_QUERIED_CTX_KEY: offenses_queried})
        context_data.update({MIRRORED_OFFENSES_FINISHED_CTX_KEY: offenses_finished})

        safely_update_context_data(context_data, context_version, offense_ids=changed_ids_ctx)
        return events, status


    def update_user_query(user_query: str) -> str:
        return f' AND ({user_query})' if user_query else ''


    def insert_to_updated_context(context_data: dict,
                                  offense_ids: list | None = None,
                                  should_update_last_fetch: bool = False,
                                  should_update_last_mirror: bool = False,
                                  should_add_reset_key: bool = False,
                                  should_force_update: bool = False
                                  ):
        """When we have a race condition, insert the changed data from context_data to the updated context data

        Args:
            context_data (dict): Context data with relevant changes.
            updated_context_data (dict): Context data that was updated before.
            offense_ids (list, optional): Offense ids that were changed. Defaults to None.
            should_update_last_fetch (bool, optional): Should update the last_fetch. Defaults to False.
            should_update_last_mirror (bool, optional): Should update the last mirror. Defaults to False.
            should_add_reset_key (bool, optional): If we should add reset key. Defaults to False
            should_force_update (bool, optional): If we should force update the current context. Defaults to False

        """
        if offense_ids is None:
            offense_ids = []
        updated_context_data, version = get_integration_context_with_version()
        new_context_data = updated_context_data.copy()
        if should_force_update:
            return context_data, version

        if should_add_reset_key:
            new_context_data[RESET_KEY] = True
        for id_ in offense_ids:
            # Those are "trusted ids" from the changed context_data, we will keep the data (either update or delete it)
            for key in (MIRRORED_OFFENSES_QUERIED_CTX_KEY, MIRRORED_OFFENSES_FINISHED_CTX_KEY, MIRRORED_OFFENSES_FETCHED_CTX_KEY):
                if id_ in context_data[key]:
                    new_context_data[key][id_] = context_data[key][id_]
                else:
                    new_context_data[key].pop(id_, None)

        if should_update_last_fetch:
            # Last fetch is updated with the samples that were fetched
            new_context_data.update({LAST_FETCH_KEY: int(context_data.get(LAST_FETCH_KEY, 0)),
                                     'samples': context_data.get('samples', [])})

        if should_update_last_mirror:
            new_context_data.update({LAST_MIRROR_KEY: int(context_data.get(LAST_MIRROR_KEY, 0)),
                                     LAST_MIRROR_CLOSED_KEY: int(context_data.get(LAST_MIRROR_CLOSED_KEY, 0))})
        return new_context_data, version


    def safely_update_context_data(
        context_data: dict,
        version: Any,
        offense_ids: list | None = None,
        should_update_last_fetch: bool = False,
        should_update_last_mirror: bool = False,
        should_add_reset_key: bool = False,
        should_force_update: bool = False,
    ) -> None:
        """Safely updates context

        Args:
            context_data (dict): The context data to save (encoded)
            version (Any): The context current version
            offense_ids (list, optional): List of offenses ids to change. Defaults to None.
            should_update_last_fetch (bool, optional): If we should update last fetch. Defaults to False
            should_update_last_mirror (bool, optional): If we should update last mirror. Defaults to False
            should_add_reset_key (bool, optional): If we should add reset key. Defaults to False
            should_force_update (bool, optional): If we should force update the current context. Defaults to False


        Raises:
            DemistoException: if could not update the context_data in all retries

        Returns:
        """
        if not offense_ids and \
                not should_update_last_fetch and \
                not should_update_last_mirror and \
                not should_add_reset_key and \
                not should_force_update:
            print_debug_msg('No need to update context, no ids and no last fetch/mirror')
            return
        print_debug_msg(f'Attempting to update context data after version {version}')
        updated_context = context_data.copy()
        new_version = version
        print_context_data_stats(updated_context, 'Safely update context - Before Update')

        for retry in range(MAX_RETRIES_CONTEXT):
            try:
                updated_context, new_version = insert_to_updated_context(context_data,
                                                                         offense_ids,
                                                                         should_update_last_fetch,
                                                                         should_update_last_mirror,
                                                                         should_add_reset_key,
                                                                         should_force_update)
                print_debug_msg(f"{updated_context=}")

                set_integration_context(updated_context, version=new_version)
                print_debug_msg(f'Updated integration context after version {new_version}.')
                break
            except Exception as e:
                # if someone else is updating the context, we will get a conflict error
                print_debug_msg(f'Could not set integration context in retry {retry + 1}. '
                                f'Error: {e}. Trying to resolve conflicts')
        else:
            raise DemistoException(f'Could not update integration context with version {new_version}.')

        print_context_data_stats(updated_context, 'Safely update context - After Update')


    def add_iso_entries_to_dict(dicts: List[dict]) -> List[dict]:
        """
        Takes list of dicts, for each dict:
        creates a new dict, and for each field in the output that
        is contained in 'USECS_ENTRIES', maps its value to be iso format corresponding to the value of the field.
        Args:
            dicts (List[Dict]): List of the dicts to be transformed.

        Returns:
            (List[Dict]): New dicts with iso entries for the corresponding items in 'USECS_ENTRIES'
        """
        return [{k: (get_time_parameter(v, iso_format=True) if k in USECS_ENTRIES else v)
                 for k, v in dict_.items()} for dict_ in dicts]


    def sanitize_outputs(outputs: Any, key_replace_dict: Optional[dict] = None) -> List[dict]:
        """
        Gets a list of all the outputs, and sanitizes outputs.
        - Removes empty elements.
        - adds ISO entries to the outputs.
        - Outputs only keys found in 'key_replace_dict', saving their names by 'key_replace_dict values,
          if 'key_replace_dict' is not None.
        Args:
            outputs (List[Dict]): List of the outputs to be sanitized.
            key_replace_dict (Dict): Dict of the keys to transform their names.

        Returns:
            (List[Dict]): Sanitized outputs.
        """
        if not isinstance(outputs, list):
            outputs = [outputs]
        outputs = [remove_empty_elements(output) for output in outputs]
        outputs = add_iso_entries_to_dict(outputs)
        return build_final_outputs(outputs, key_replace_dict) if key_replace_dict else outputs


    def get_time_parameter(arg: Union[Optional[str], Optional[int]], iso_format: bool = False, epoch_format: bool = False):
        """
        parses arg into date time object with aware time zone if 'arg' exists.
        If no time zone is given, sets timezone to UTC.
        Returns the date time object created/ISO format/epoch format.
        Args:
            arg (str): The argument to turn into aware date time.
            iso_format (bool): Whether to return date or the parsed format of the date.
            epoch_format (bool): Whether to return date or the epoch format of the date.

        Returns:
            - (None) If 'arg' is None, returns None.
            - (datetime): If 'arg' is exists and 'iso_format' and 'epoch_format' are false, returns date time.
            - (str): If 'arg' is exists and parse_format is true, returns ISO format of the date time object.
            - (int): If 'arg' is exists and epoch_format is true, returns epoch format of the date time object.
        """
        maybe_unaware_date = arg_to_datetime(arg, is_utc=True)
        if not maybe_unaware_date:
            return None

        aware_time_date = maybe_unaware_date if maybe_unaware_date.tzinfo else UTC_TIMEZONE.localize(
            maybe_unaware_date)

        if iso_format:
            return aware_time_date.isoformat()
        if epoch_format:
            return int(aware_time_date.timestamp() * 1000)
        return aware_time_date


    def build_final_outputs(outputs: List[dict], old_new_dict: dict) -> List[dict]:
        """
        Receives outputs, or a single output, and a dict containing mapping of old key names to new key names.
        Returns a list of outputs containing the new names contained in old_new_dict.
        Args:
            outputs (Dict): Outputs to replace its keys.
            old_new_dict (Dict): Old key name mapped to new key name.

        Returns:
            (Dict): The dictionary with the transformed keys and their values.
        """
        return [{old_new_dict.get(k): v for k, v in output.items() if k in old_new_dict} for output in outputs]


    def build_headers(first_headers: List[str], all_headers: set[str]) -> List[str]:
        """
        Receives headers to be shown first in entry room, and concat all the headers after first headers.
        Args:
            first_headers (Set[str]): First headers to be shown in the entry room.
            all_headers (Set[str]): List of all of the headers.

        Returns:
            (List[str]): List of all of the headers, where first_headers are first in the list.
        """
        return first_headers + list(set.difference(all_headers, first_headers))


    def is_valid_ip(ip: str) -> bool:
        try:
            ip_address(ip)
            return True
        except ValueError:
            print_debug_msg(f'IP {ip} was found invalid.')
            return False


    def get_offense_types(client: Client, offenses: List[dict]) -> dict:
        """
        Receives list of offenses, and performs API call to QRadar service to retrieve the offense type names
        matching the offense type IDs of the offenses.
        Args:
            client (Client): Client to perform the API request to QRadar.
            offenses (List[Dict]): List of all of the offenses.

        Returns:
            (Dict): Dictionary of {offense_type_id: offense_type_name}
        """
        try:
            offense_types_ids = {offense.get('offense_type') for offense in offenses if offense.get('offense_type') is not None}
            if not offense_types_ids:
                return {}
            offense_types = client.offense_types(filter_=f'''id in ({','.join(map(str, offense_types_ids))})''',
                                                 fields='id,name')
            return {offense_type.get('id'): offense_type.get('name') for offense_type in offense_types}
        except Exception as e:
            demisto.error(f"Encountered an issue while getting offense type: {e}")
            return {}


    def get_offense_closing_reasons(client: Client, offenses: List[dict]) -> dict:
        """
        Receives list of offenses, and performs API call to QRadar service to retrieve the closing reason names
        matching the closing reason IDs of the offenses.
        Args:
            client (Client): Client to perform the API request to QRadar.
            offenses (List[Dict]): List of all of the offenses.

        Returns:
            (Dict): Dictionary of {closing_reason_id: closing_reason_name}
        """
        try:
            closing_reason_ids = {offense.get('closing_reason_id') for offense in offenses
                                  if offense.get('closing_reason_id') is not None}
            if not closing_reason_ids:
                return {}
            closing_reasons = client.closing_reasons_list(filter_=f'''id in ({','.join(map(str, closing_reason_ids))})''',
                                                          fields='id,text')
            return {closing_reason.get('id'): closing_reason.get('text') for closing_reason in closing_reasons}
        except Exception as e:
            demisto.error(f"Encountered an issue while getting offense closing reasons: {e}")
            return {}


    def get_domain_names(client: Client, outputs: List[dict]) -> dict:
        """
        Receives list of outputs, and performs API call to QRadar service to retrieve the domain names
        matching the domain IDs of the outputs.
        Args:
            client (Client): Client to perform the API request to QRadar.
            outputs (List[Dict]): List of all of the offenses.

        Returns:
            (Dict): Dictionary of {domain_id: domain_name}
        """
        try:
            domain_ids = {offense.get('domain_id') for offense in outputs if offense.get('domain_id') is not None}
            if not domain_ids:
                return {}
            domains_info = client.domains_list(filter_=f'''id in ({','.join(map(str, domain_ids))})''', fields='id,name')
            return {domain_info.get('id'): domain_info.get('name') for domain_info in domains_info}
        except Exception as e:
            demisto.error(f"Encountered an issue while getting offense domain names: {e}")
            return {}


    def get_rules_names(client: Client, offenses: List[dict]) -> dict:
        """
        Receives list of offenses, and performs API call to QRadar service to retrieve the rules names
        matching the rule IDs of the offenses.
        Args:
            client (Client): Client to perform the API request to QRadar.
            offenses (List[Dict]): List of all of the offenses.

        Returns:
            (Dict): Dictionary of {rule_id: rule_name}
        """
        try:
            rules_ids = {rule.get('id') for offense in offenses for rule in offense.get('rules', [])}
            if not rules_ids:
                return {}
            rules = client.rules_list(None, None, f'''id in ({','.join(map(str, rules_ids))})''', 'id,name')
            return {rule.get('id'): rule.get('name') for rule in rules}
        except Exception as e:
            demisto.error(f"Encountered an issue while getting offenses rules: {e}")
            return {}


    def get_offense_addresses(client: Client, offenses: List[dict], is_destination_addresses: bool) -> dict:
        """
        Receives list of offenses, and performs API call to QRadar service to retrieve the source IP values
        matching the source IPs IDs of the offenses.
        Args:
            client (Client): Client to perform the API request to QRadar.
            offenses (List[Dict]): List of all of the offenses.
            is_destination_addresses(bool): Whether addresses to enrich are destination IPs (or source).

        Returns:
            (Dict): Dictionary of {source_address_id: source_address_name}.
        """
        address_type = 'local_destination' if is_destination_addresses else 'source'
        address_field = f'{address_type}_ip'
        address_list_field = f'{address_type}_address_ids'
        url_suffix = f'{address_type}_addresses'

        def get_addresses_for_batch(b: List):
            try:
                return client.get_addresses(url_suffix, f'''id in ({','.join(map(str, b))})''', f'id,{address_field}')
            except Exception as e:
                demisto.error(f'Failed getting address barch with error: {e}')
                return []

        addresses_ids = [address_id for offense in offenses
                         for address_id in offense.get(address_list_field, [])]

        # Submit addresses in batches to avoid overloading QRadar service
        addresses_batches = [get_addresses_for_batch(b) for b
                             in batch(addresses_ids[:OFF_ENRCH_LIMIT], batch_size=int(BATCH_SIZE))]

        return {address_data.get('id'): address_data.get(address_field)
                for addresses_batch in addresses_batches
                for address_data in addresses_batch}


    def create_single_asset_for_offense_enrichment(asset: dict) -> dict:
        """
        Recieves one asset, and returns the expected asset values for enriching offense.
        Args:
            asset (Dict): Asset to enrich the offense with

        Returns:
            (Dict): The enriched asset.
        """
        interfaces = {'interfaces': [{
            'mac_address': interface.get('mac_address'),
            'id': interface.get('id'),
            'ip_addresses': [{
                'type': ip_add.get('type'),
                'value': ip_add.get('value')
            } for ip_add in interface.get('ip_addresses', [])]
        } for interface in asset.get('interfaces', [])]}
        properties = {prop.get('name'): prop.get('value') for prop in asset.get('properties', [])
                      if 'name' in prop and 'value' in prop}
        offense_without_properties = {k: v for k, v in asset.items() if k != 'properties'}
        return add_iso_entries_to_asset(dict(offense_without_properties, **properties, **interfaces))


    def enrich_offense_with_assets(client: Client, offense_ips: List[str], assets_limit: int | None = 100) -> List[dict]:
        """
        Receives list of offense's IPs, and performs API call to QRadar service to retrieve assets correlated to IPs given.
        Args:
            client (Client): Client to perform the API request to QRadar.
            offense_ips (List[str]): List of all of the offense's IPs.

        Returns:
            (List[Dict]): List of all the correlated assets.
        """

        def get_assets_for_ips_batch(b: List):
            filter_query = ' or '.join([f'interfaces contains ip_addresses contains value="{ip}"' for ip in b])
            try:
                return client.assets_list(filter_=filter_query)
            except Exception as e:
                demisto.error(f'Failed getting assets for filter_query: {filter_query}. {e}')
                return []

        offense_ips = [offense_ip for offense_ip in offense_ips if is_valid_ip(offense_ip)]
        # Submit addresses in batches to avoid overloading QRadar service
        assets: List = []
        for b in batch(offense_ips[:OFF_ENRCH_LIMIT], batch_size=int(BATCH_SIZE)):
            assets.extend(get_assets_for_ips_batch(b))
            if assets_limit and len(assets) >= assets_limit:
                assets = assets[:assets_limit]
                break

        return [create_single_asset_for_offense_enrichment(asset) for asset in assets]


    def enrich_offenses_result(client: Client, offenses: Any, enrich_ip_addresses: bool,
                               enrich_assets: bool, assets_limit: int | None = None) -> List[dict]:
        """
        Receives list of offenses, and enriches the offenses with the following:
        - Changes offense_type value from the offense type ID to the offense type name.
        - Changes closing_reason_id value from closing reason ID to the closing reason name.
        - Adds a link to the URL of each offense.
        - Adds the domain name of the domain ID for each offense.
        - Adds to each rule of the offense its name.
        - Adds enrichment to each source/destination IP ID to its address (if enrich_ip_addresses is true).
        - Adds enrichment of assets to each offense (if enrich_assets is true).
        Args:
            client (Client): Client to perform the API calls.
            offenses (Any): List of all of the offenses to enrich.
            enrich_ip_addresses (bool): Whether to enrich the offense source/destination IP addresses.
            enrich_assets (bool): Whether to enrich the offense with assets.
            assets_limit (int): The limit of assets to enrich the offense with.

        Returns:
            (List[Dict]): The enriched offenses.
        """
        if not isinstance(offenses, list):
            offenses = [offenses]

        print_debug_msg('Enriching offenses')
        offense_types_id_name_dict = get_offense_types(client, offenses)
        closing_reasons_id_name_dict = get_offense_closing_reasons(client, offenses)
        domain_id_name_dict = get_domain_names(client, offenses) if DOMAIN_ENRCH_FLG.lower() == 'true' else {}
        rules_id_name_dict = get_rules_names(client, offenses) if RULES_ENRCH_FLG.lower() == 'true' else {}
        source_addresses_id_ip_dict = get_offense_addresses(client, offenses, False) if enrich_ip_addresses else {}
        destination_addresses_id_ip_dict = get_offense_addresses(client, offenses, True) if enrich_ip_addresses else {}

        def create_enriched_offense(offense: dict) -> dict:
            link_to_offense_suffix = '/console/do/sem/offensesummary?appName=Sem&pageId=OffenseSummary&summaryId' \
                                     f'''={offense.get('id')}'''
            offense_type = offense.get('offense_type')
            closing_reason_id = offense.get('closing_reason_id')
            domain_id = offense.get('domain_id')
            basic_enriches = {
                'offense_type': offense_types_id_name_dict.get(offense_type, offense_type),
                'closing_reason_id': closing_reasons_id_name_dict.get(closing_reason_id, closing_reason_id),
                'LinkToOffense': urljoin(client.server, link_to_offense_suffix),
            }

            domain_enrich = {
                'domain_name': domain_id_name_dict.get(domain_id, domain_id)
            } if DOMAIN_ENRCH_FLG.lower() == 'true' and domain_id_name_dict.get(domain_id, domain_id) else {}

            rules_enrich = {
                'rules': [{
                    'id': rule.get('id'),
                    'type': rule.get('type'),
                    'name': rules_id_name_dict.get(rule.get('id'), rule.get('id'))
                } for rule in offense.get('rules', [])] if RULES_ENRCH_FLG.lower() == 'true' else {}
            }

            source_addresses_enrich = {
                'source_address_ids': [source_addresses_id_ip_dict.get(source_address_id) for source_address_id in
                                       offense.get('source_address_ids', [])]
            } if enrich_ip_addresses else {}

            destination_addresses_enrich = {
                'local_destination_address_ids': [destination_addresses_id_ip_dict.get(destination_address_id) for
                                                  destination_address_id in
                                                  offense.get('local_destination_address_ids', [])]
            } if enrich_ip_addresses else {}

            if enrich_assets:
                source_ips: List = source_addresses_enrich.get('source_address_ids', [])
                destination_ips: List = destination_addresses_enrich.get('local_destination_address_ids', [])
                all_ips: List = source_ips + destination_ips
                asset_enrich = {'assets': enrich_offense_with_assets(client, all_ips, assets_limit)}
            else:
                asset_enrich = {}

            return dict(offense, **basic_enriches, **domain_enrich, **rules_enrich, **source_addresses_enrich,
                        **destination_addresses_enrich, **asset_enrich)

        result = [create_enriched_offense(offense) for offense in offenses]
        print_debug_msg('Enriched offenses successfully.')
        return result


    def enrich_asset_properties(properties: List, properties_to_enrich_dict: dict) -> dict:
        """
        Receives list of properties of an asset, and properties to enrich, and returns a dict containing the enrichment
        Args:
            properties (List): List of properties of an asset.
            properties_to_enrich_dict (Dict): Properties to be enriched.

        Returns:
            (List[Dict]) List of new assets with enrichment.
        """
        return {
            properties_to_enrich_dict.get(prop.get('name')): {
                'Value': prop.get('value'),
                'LastUser': prop.get('last_reported_by')
            } for prop in properties if prop.get('name') in properties_to_enrich_dict
        }


    def add_iso_entries_to_asset(asset: dict) -> dict:
        """
        Transforms epoch entries to ISO entries in an asset.
        Requires a special treatment, because some of the usec entries are nested.
        Args:
            asset (Dict): Asset to transform its epoch entries to ISO.

        Returns:
            (Dict): Asset transformed.
        """

        def get_asset_entry(k: str, v: Any):
            if k == 'interfaces':
                return [{
                    k: (get_time_parameter(v, iso_format=True) if k in USECS_ENTRIES
                        else add_iso_entries_to_dict(v) if k == 'ip_addresses' else v)
                    for k, v in interface.items()
                } for interface in v]

            elif k == 'properties':
                return add_iso_entries_to_dict(v)

            elif k in USECS_ENTRIES:
                return get_time_parameter(v, iso_format=True)

            else:
                return v

        return {k: get_asset_entry(k, v) for k, v in asset.items()}


    def enrich_assets_results(client: Client, assets: Any, full_enrichment: bool) -> List[dict]:
        """
        Receives list of assets, and enriches each asset with 'Endpoint' entry containing the following:
        - IP addresses of all interfaces.
        - OS name.
        - MAC addresses of the interfaces, if full enrichment was requested.
        - Domain name if full enrichment was requested.
        - Properties enrichment.

        Args:
            client (Client): Client to perform API call to retrieve domain names corresponding to the domain IDs.
            assets (List[Dict]): List of assets to be enriched.
            full_enrichment (bool): Whether the asset should be full enriched.

        Returns:
            (List[Dict]) List of new assets with enrichment.
        """
        domain_id_name_dict = get_domain_names(client, assets) if full_enrichment else {}

        def enrich_single_asset(asset: dict) -> dict:
            updated_asset = add_iso_entries_to_asset(asset)
            interfaces = updated_asset.get('interfaces', [])
            properties = updated_asset.get('properties', [])
            domain_id = updated_asset.get('domain_id')
            os_name = next((prop.get('value') for prop in properties if prop.get('name') == 'Primary OS ID'), None)

            ip_enrichment = {
                'IPAddress': [ip_add.get('value') for interface in interfaces
                              for ip_add in interface.get('ip_addresses', [])
                              if ip_add.get('value')]
            }

            os_enrichment = {'OS': os_name} if os_name else {}

            mac_enrichment = {
                'MACAddress': [interface.get('mac_address') for interface in interfaces if
                               interface.get('mac_address')]
            } if full_enrichment else {}

            domains_enrichment = {'Domain': domain_id_name_dict.get(domain_id, domain_id)} \
                if full_enrichment and domain_id else {}

            basic_properties_enrichment = enrich_asset_properties(properties, ASSET_PROPERTIES_NAME_MAP)
            full_properties_enrichment = enrich_asset_properties(properties,
                                                                 FULL_ASSET_PROPERTIES_NAMES_MAP) \
                if full_enrichment else {}

            enriched_asset = dict(asset, **basic_properties_enrichment, **full_properties_enrichment)
            return {'Asset': add_iso_entries_to_asset(enriched_asset),
                    'Endpoint': dict(ip_enrichment, **os_enrichment, **mac_enrichment,
                                     **domains_enrichment)}

        return [enrich_single_asset(asset) for asset in assets]


    def get_minimum_id_to_fetch(highest_offense_id: int, user_query: Optional[str], first_fetch: str, client: Client) -> int:
        """
        Receives the highest offense ID saved from last run, and user query.
        Checks if user query has a limitation for a minimum ID.
        If such ID exists, returns the maximum between 'highest_offense_id' and the minimum ID
        limitation received by the user query.
        Args:
            highest_offense_id (int): Minimum ID to fetch offenses by from last run.
            user_query (Optional[str]): User query for QRadar service.
            first_fetch (str): First fetch timestamp.
            client (Client): Client to perform the API calls.
        Returns:
            (int): The Minimum ID to fetch offenses by.
        """
        if not highest_offense_id:
            highest_offense_id = get_min_id_from_first_fetch(first_fetch, client)
        if user_query:
            id_query = ID_QUERY_REGEX.search(user_query)
            if id_query:
                id_query_raw = id_query.group(0)
                operator = '>=' if '>=' in id_query_raw else '>'
                # safe to int parse without catch because regex checks for number
                user_offense_id = int(id_query.group(0).split(operator)[1].strip())
                user_lowest_offense_id = user_offense_id if operator == '>' else user_offense_id - 1
                print_debug_msg(f'Found ID in user query: {user_lowest_offense_id}, last highest ID: {highest_offense_id}')
                return max(highest_offense_id, user_lowest_offense_id)
        return highest_offense_id


    def get_min_id_from_first_fetch(first_fetch: str, client: Client):
        """
        Receives first_fetch integration param
        and retrieve the lowest id (earliest offense) that was created after that time.
        Args:
            first_fetch (str): First fetch timestamp.
            client (Client): Client to perform the API calls.

        Returns:
            (int): The ID of the earliest offense created after first_fetch.
        """
        filter_fetch_query = f'start_time>{str(convert_start_fetch_to_milliseconds(first_fetch))}'
        raw_offenses = client.offenses_list(filter_=filter_fetch_query, sort=ASCENDING_ID_ORDER, range_="items=0-0", fields="id")
        return int(raw_offenses[0].get('id')) - 1 if raw_offenses else 0


    def arg_to_real_number(arg, arg_name=None, required=False):
        # type: (Any, Optional[str], bool) -> Optional[int | float]
        """Converts an XSOAR argument to a Python int or float

        This function acts exactly like CommonServerPython's arg_to_number, but is able to return float
        :type arg: ``Any``
        :param arg: argument to convert

        :type arg_name: ``str``
        :param arg_name: argument name

        :type required: ``bool``
        :param required:
            throws exception if ``True`` and argument provided is None

        :return:
            returns an ``int | float`` if arg can be converted
            returns ``None`` if arg is ``None`` and required is set to ``False``
            otherwise throws an Exception
        :rtype: ``Optional[int | float]``
        """

        if arg is None or arg == '':
            if required is True:
                if arg_name:
                    raise ValueError(f'Missing "{arg_name}"')
                else:
                    raise ValueError('Missing required argument')

            return None

        arg = encode_string_results(arg)

        if isinstance(arg, str):
            if arg.isdigit():
                return int(arg)

            try:
                return float(arg)
            except Exception:
                if arg_name:
                    raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
                else:
                    raise ValueError(f'"{arg}" is not a valid number')
        if isinstance(arg, int):
            return arg

        if arg_name:
            raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
        else:
            raise ValueError(f'"{arg}" is not a valid number')


    def convert_start_fetch_to_milliseconds(fetch_start_time: str):
        """
        Convert a timestamp string to milliseconds
        Args:
            fetch_start_time (str): First fetch timestamp.

        Returns:
            (int): time since (epoch - first_fetch) in milliseconds.
        """
        date = dateparser.parse(fetch_start_time, settings={'TIMEZONE': 'UTC'})
        if date is None:
            # if date is None it means dateparser failed to parse it
            raise ValueError(f'Invalid first_fetch format: {fetch_start_time}')
        return int(date.timestamp() * 1000)


    def convert_dict_to_actual_values(input_dict: dict) -> dict[str, Any]:
        """
        Recursively converts string representations of values in a dictionary to their actual data types.

        Args:
            input_dict (dict): A dictionary with string representations of values.

        Returns:
            dict: A dictionary with actual values (numbers, booleans, etc.).
        """
        output_dict: dict[str, Any] = {}
        for key, value in input_dict.items():
            if isinstance(value, dict):
                output_dict[key] = convert_dict_to_actual_values(value)
            elif isinstance(value, list):
                output_dict[key] = convert_list_to_actual_values(value)
            elif isinstance(value, str):
                try:
                    output_dict[key] = argToBoolean(value)
                except ValueError:
                    try:
                        output_dict[key] = arg_to_real_number(value)
                    except ValueError:
                        output_dict[key] = value
            else:
                output_dict[key] = value
        return output_dict


    def convert_list_to_actual_values(input_list: list) -> list[Any]:
        """
        Recursively converts string representations of values in a list to their actual data types.

        Args:
            input_list (list): A list with string representations of values.

        Returns:
            dict: A list with actual values (numbers, booleans, etc.).
        """
        output_list: list[Any] = []
        for value in input_list:
            if isinstance(value, dict):
                output_list.append(convert_dict_to_actual_values(value))
            elif isinstance(value, list):
                output_list.append(convert_list_to_actual_values(value))
            elif isinstance(value, str):
                try:
                    output_list.append(argToBoolean(value))
                except ValueError:
                    try:
                        output_list.append(arg_to_real_number(value))
                    except ValueError:
                        output_list.append(value)
            else:
                output_list.append(value)
        return output_list


    def parse_log_source(create_args: dict[str, Any]):
        pp_pairs = create_args.get('protocol_parameters', '').split(',')
        protocol_parameters = []
        group_ids = create_args.get('group_ids', '').split(',') if create_args.get('group_ids') else []
        wincollect_external_destination_ids = (
            create_args.get('wincollect_external_destination_ids', '').split(',') if create_args.get('group_ids')
            else []
        )
        for pair in pp_pairs:
            # Split the pair into name and value using '=' as delimiter
            name, value = pair.split('=')
            # Add the pair to the dictionary
            protocol_parameters.append({'name': name.strip(), 'value': value.strip()})
        return convert_dict_to_actual_values({
            **create_args,
            'protocol_parameters': protocol_parameters,
            'group_ids': group_ids,
            'wincollect_external_destination_ids': wincollect_external_destination_ids
        })


    def parse_partial_log_source(update_args: dict[str, Any]):
        protocol_parameters = update_args.get('protocol_parameters', '').split(',') if update_args.get('protocol_parameters') else []
        group_ids = update_args.get('group_ids', '').split(',') if update_args.get('group_ids') else None
        wincollect_external_destination_ids = (
            update_args.get('wincollect_external_destination_ids', '').split(',') if update_args.get('group_ids')
            else None
        )
        if protocol_parameters:
            for pair in protocol_parameters:
                # Split the pair into name and value using '=' as delimiter
                name, value = pair.split('=')
                # Add the pair to the dictionary
                protocol_parameters.append({'name': name.strip(), 'value': value.strip()})
        log_source_str = {**update_args}
        if protocol_parameters:
            log_source_str['protocol_parameters'] = protocol_parameters
        if group_ids:
            log_source_str['group_ids'] = group_ids
        if wincollect_external_destination_ids:
            log_source_str['wincollect_external_destination_ids'] = wincollect_external_destination_ids
        return convert_dict_to_actual_values(log_source_str)


    def get_offense_enrichment(enrichment: str) -> tuple[bool, bool]:
        """
        Receives enrichment asked by the user, returns true or false values indicating which enrichment should be done.
        Args:
            enrichment (Optional[str]): Enrichment argument.

        Returns:
            (bool, bool): Tuple of (ip_enrich, asset_enrich).
        """
        if enrichment == 'IPs And Assets':
            return True, True
        if enrichment == 'IPs':
            return True, False
        return False, False


    def print_debug_msg(msg: str):
        """
        Prints a message to debug with QRadarMsg prefix.
        Args:
            msg (str): Message to be logged.

        """
        demisto.debug(f'QRadarMsg - {msg}')


    def is_reset_triggered(ctx: dict | None = None, version: Any = None):
        """
        Checks if reset of integration context have been made by the user.
        Because fetch is long running execution, user communicates with us
        by calling 'qradar-reset-last-run' command which sets reset flag in
        context.

        Args:
            ctx (dict | None): The context data to check. If it is None it will get the context from the platform.
            version: The context data version.
        Returns:
            (bool):
            - True if reset flag was set. If 'handle_reset' is true, also resets integration context.
            - False if reset flag was not found in integration context.
        """
        if not ctx or not version:
            ctx, version = get_integration_context_with_version()
        if ctx and RESET_KEY in ctx:
            # if we need to reset we have to get the version of the context
            print_debug_msg('Reset fetch-incidents.')
            demisto.setLastRun({LAST_FETCH_KEY: 0})
            context_data: dict[str, Any] = {MIRRORED_OFFENSES_QUERIED_CTX_KEY: {},
                                            MIRRORED_OFFENSES_FINISHED_CTX_KEY: {},
                                            'samples': []}
            safely_update_context_data(context_data, version=version, should_force_update=True)
            return True
        return False


    def validate_long_running_params(params: dict) -> None:
        """
        Receives params, checks whether the required parameters for long running execution is configured.
        Args:
            params (Dict): Cortex XSOAR params.

        Returns:
            (None): If all required params are set, raises DemistoException otherwise.
        """
        for param_field, param_display in LONG_RUNNING_REQUIRED_PARAMS.items():
            if param_field not in params:
                raise DemistoException(f'Parameter {param_display} is required when enabling long running execution.'
                                       ' Please set a value for it.')


    def get_cidrs_indicators(query):
        """Extracts cidrs from a query"""
        if not query:
            return []

        res = demisto.searchIndicators(query=query)

        indicators = []
        for indicator in res.get('iocs', []):
            if indicator.get('indicator_type').lower() == 'cidr':
                indicators.append(indicator.get('value'))

        return indicators


    def verify_args_for_remote_network_cidr(cidrs_list, cidrs_from_query, name, group, fields):
        # verify that only one of the arguments is given
        if cidrs_list and cidrs_from_query:
            return 'Cannot specify both cidrs and query arguments.'

        # verify that at least one of the arguments is given
        if not cidrs_list and not cidrs_from_query:
            return 'Must specify either cidrs or query arguments.'

        # verify that the given cidrs are valid
        for cidr in cidrs_list:
            if not re.match(ipv4cidrRegex, cidr) and not re.match(ipv6cidrRegex, cidr):
                return f'{cidr} is not a valid CIDR.'

        # verify that the given name and group are valid
        if not NAME_AND_GROUP_REGEX.match(name) or not NAME_AND_GROUP_REGEX.match(group):
            return 'Name and group arguments only allow letters, numbers, \'_\' and \'-\'.'

        fields_list = argToList(fields)
        if fields_list:
            possible_fields = ['id', 'name', 'group', 'cidrs', 'description']
            for field in fields_list:
                if field not in possible_fields:
                    return f'{field} is not a valid field. Possible fields are: {possible_fields}.'
            return None
        return None


    def is_positive(*values: int | None) -> bool:
        # checks if all values are positive or None but not a negative numbers
        return all(value is None or value >= 1 for value in values)


    def verify_args_for_remote_network_cidr_list(limit, page, page_size, filter_, group, id_, name):
        # verify that the given limit and page and page_size are valid
        if not is_positive(limit, page, page_size):
            return 'Limit, page and page_size arguments must be positive numbers.'

        # verify that only one of the arguments is given
        if limit and (page or page_size):
            return 'Please provide either limit argument or page and page_size arguments.'

        # verify that if page are given, page_size is also given and vice versa
        if (page and not page_size) or (page_size and not page):
            return 'Please provide both page and page_size arguments.'

        # verify that only one of the arguments is given
        if filter_ and (group or id_ or name):
            return 'You can not use filter argument with group, id or name arguments.'
        return None


    ''' COMMAND FUNCTIONS '''


    def test_module_command(client: Client, params: dict) -> str:
        """
        Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.
        Args:
            client (Client): Client to perform the API calls.
            params (Dict): Demisto params.

        Returns:
            - (str): 'ok' if test passed
            - raises DemistoException if something had failed the test.
        """
        try:
            ctx = get_integration_context()
            print_context_data_stats(ctx, "Test Module")
            is_long_running = params.get('longRunning')
            if is_long_running:
                validate_long_running_params(params)
            client.offenses_list(range_="items=0-0")
            message = 'ok'
        except DemistoException as e:
            err_msg = str(e)
            if 'unauthorized to access the requested resource' in err_msg or 'No SEC header present in request' in err_msg:
                message = 'Authorization Error: make sure credentials are correct.'
            else:
                raise e
        return message


    def fetch_incidents_command() -> List[dict]:
        """
        Fetch incidents implemented, for mapping purposes only.
        Returns list of samples saved by long running execution.

        Returns:
            (List[Dict]): List of incidents samples.
        """
        ctx = get_integration_context()
        return ctx.get('samples', [])


    def create_search_with_retry(client: Client,
                                 fetch_mode: str,
                                 offense: dict,
                                 event_columns: str,
                                 events_limit: int,
                                 max_retries: int = EVENTS_SEARCH_TRIES,
                                 ) -> str:
        """
        Creates a search to retrieve events for an offense.
        Has retry mechanism, because QRadar service tends to return random errors when
        it is loaded.
        Therefore, 'max_retries' retries will be made, to try avoid such cases as much as possible.
        Args:
            client (Client): Client to perform the API calls.
            fetch_mode (str): Which enrichment mode was requested.
                              Can be 'Fetch With All Events', 'Fetch Correlation Events Only'
            offense (Dict): Offense ID to enrich with events.
            event_columns (str): Columns of the events to be extracted from query.
            events_limit (int): Maximum number of events to enrich the offense.
            max_retries (int): Number of retries.


        Returns:
            (str): The search id or `error` from `SearchQueryStatus`
        """
        offense_id = offense['id']
        for i in range(max_retries):
            search_id = create_events_search(client, fetch_mode, event_columns, events_limit, offense_id, offense['start_time'])
            if search_id == QueryStatus.ERROR.value:
                print_debug_msg(f'Failed to create search for offense ID: {offense_id}. '
                                f'Retry number {i+1}/{max_retries}.')
                print_debug_msg(traceback.format_exc())
            else:
                return search_id
        print_debug_msg(f'Reached max retries for creating a search for offense: {offense_id}. Returning error.')
        return QueryStatus.ERROR.value


    def poll_offense_events(client: Client,
                            search_id: str,
                            should_get_events: bool,
                            offense_id: int | None,
                            ):
        try:
            print_debug_msg(f"Getting search status for {search_id}")
            search_status_response = client.search_status_get(search_id)
            print_debug_msg(f"Got search status for {search_id}")
            query_status = search_status_response.get('status')
            print_debug_msg(f'Search status for offense {offense_id} is {query_status}.')

            if query_status in {'CANCELED', 'ERROR'}:
                return [], QueryStatus.ERROR.value
            elif query_status == 'COMPLETED':
                print_debug_msg(f'Search for offense {offense_id} is completed.')
                if not should_get_events:
                    return [], QueryStatus.SUCCESS.value
                print_debug_msg(f'Getting events for offense {offense_id}')
                search_results_response = client.search_results_get(search_id)
                print_debug_msg(f'Http response: {search_results_response.get("http_response", "Not specified - ok")}')
                events = search_results_response.get('events', [])
                sanitized_events = sanitize_outputs(events)
                print_debug_msg(f'Fetched events for offense {offense_id}.')
                return sanitized_events, QueryStatus.SUCCESS.value
            else:
                # still waiting for events
                return [], QueryStatus.WAIT.value
        except Exception as e:
            print_debug_msg(
                f'Error while fetching offense {offense_id} events, search_id: {search_id}. Error details: {str(e)} \n'
                f'{traceback.format_exc()}')
            time.sleep(FAILURE_SLEEP)
            return [], QueryStatus.ERROR.value


    def poll_offense_events_with_retry(
        client: Client,
        search_id: str, offense_id: int,
        max_retries: int = EVENTS_POLLING_TRIES,
    ) -> tuple[List[dict], str]:
        """
        Polls QRadar service for search ID given until status returned is within '{'CANCELED', 'ERROR', 'COMPLETED'}'.
        Afterwards, performs a call to retrieve the events returned by the search.
        Has retry mechanism, because QRadar service tends to return random errors when
        it is loaded.
        Therefore, 'max_retries' retries will be made, to try avoid such cases as much as possible.

        Args:
            client (Client): Client to perform the API calls.
            search_id (str): ID of the search to poll for its status.
            offense_id (int): ID of the offense to enrich with events returned by search. Used for logging purposes here.
            max_retries (int): Number of retries.

        Returns:
            (List[Dict], str): List of events returned by query. Returns empty list if number of retries exceeded limit,
                               A failure message in case an error occurred.
        """
        for retry in range(max_retries):
            print_debug_msg(f'Polling for events for offense {offense_id}. Retry number {retry+1}/{max_retries}')
            events, status = poll_offense_events(client, search_id, should_get_events=True, offense_id=int(offense_id))
            if status == QueryStatus.SUCCESS.value:
                return events, ''
            elif status == QueryStatus.ERROR.value:
                return [], 'Error while getting events.'
            # dont sleep in the last iteration
            if retry < max_retries - 1:
                time.sleep(EVENTS_INTERVAL_SECS)

        print_debug_msg(f'Max retries for getting events for offense {offense_id}. Cancel query search_id: {search_id}')
        # need to cancel query
        client.search_cancel(search_id=search_id)
        return [], 'Fetching events is in progress'


    def enrich_offense_with_events(client: Client, offense: dict, fetch_mode: FetchMode, events_columns: str, events_limit: int):
        """
        Enriches offense given with events.
        Has retry mechanism for events returned by query to QRadar. This is needed because events might not be
        indexed when performing the search, and QRadar will return less events than expected.
        Retry mechanism here meant to avoid such cases as much as possible
        Args:
            client (Client): Client to perform the API calls.
            offense (Dict): Offense to enrich with events.
            fetch_mode (str): Which enrichment mode was requested.
                              Can be 'Fetch With All Events', 'Fetch Correlation Events Only'
            events_columns (str): Columns of the events to be extracted from query.
            events_limit (int): Maximum number of events to enrich the offense.

        Returns:
            (Dict): Enriched offense with events.
        """
        offense_id = str(offense['id'])
        events_count = offense.get('event_count', 0)
        events: List[dict] = []
        failure_message = ''
        is_success = True
        for retry in range(EVENTS_SEARCH_TRIES):
            start_time = time.time()
            search_id = create_search_with_retry(client, fetch_mode, offense, events_columns,
                                                 events_limit)
            if search_id == QueryStatus.ERROR.value:
                failure_message = 'Search for events was failed.'
            else:
                events, failure_message = poll_offense_events_with_retry(client, search_id, int(offense_id))
            events_fetched = get_num_events(events)
            offense['events_fetched'] = events_fetched
            offense['events'] = events
            if is_all_events_fetched(client, fetch_mode, offense_id, events_limit, events):
                break
            print_debug_msg(f'Not enough events were fetched for offense {offense_id}. Retrying in {FAILURE_SLEEP} seconds.'
                            f'Retry {retry+1}/{EVENTS_SEARCH_TRIES}')
            time_elapsed = int(time.time() - start_time)
            # wait for the rest of the time
            time.sleep(max(EVENTS_SEARCH_RETRY_SECONDS - time_elapsed, 0))
        else:
            print_debug_msg(f'Not all the events were fetched for offense {offense_id} (fetched {events_fetched}/{events_count}). '
                            f'If mirroring is enabled, it will be queried again in mirroring.')
            is_success = False
        mirroring_events_message = update_events_mirror_message(mirror_options=MIRROR_OFFENSE_AND_EVENTS,
                                                                events_limit=events_limit,
                                                                fetch_mode=fetch_mode,
                                                                events_count=events_count,
                                                                events_mirrored=events_fetched,
                                                                events_mirrored_collapsed=len(events),
                                                                failure_message=failure_message,
                                                                offense_id=int(offense_id),
                                                                )
        offense['mirroring_events_message'] = mirroring_events_message

        return offense, is_success


    def get_num_events(events: list[dict]) -> int:
        return sum(int(event.get('eventcount', 1)) for event in events)


    def get_current_concurrent_searches(context_data: dict) -> int:
        """This will return the number of concurrent searches that are currently running.

        Args:
            context_data (dict): context data

        Returns:
            int: number of concurrent searches
        """
        waiting_for_update = context_data.get(MIRRORED_OFFENSES_QUERIED_CTX_KEY, {})
        # we need offenses which we have a search_id for it in QRadar
        return len([offense_id for offense_id, status in waiting_for_update.items()
                   if status not in list(QueryStatus)])


    def delete_offense_from_context(offense_id: str, context_data: dict, context_version: Any):
        for key in (MIRRORED_OFFENSES_QUERIED_CTX_KEY, MIRRORED_OFFENSES_FINISHED_CTX_KEY):
            context_data[key].pop(offense_id, None)
        safely_update_context_data(context_data, context_version, offense_ids=[offense_id])


    def is_all_events_fetched(client: Client, fetch_mode: FetchMode, offense_id: str, events_limit: int, events: list[dict]) -> bool:
        """
        This function checks if all events were fetched for a specific offense.

        Args:
            client (Client): QRadar client
            offense_id (str): offense id of qradar
            events_limit (int): event limit parameter for the integration
            events (list[dict]): list of events fetched

        Returns:
            bool: True if all events were fetched, False otherwise
        """
        if not offense_id:
            # if we don't have offense id, we can't know if we fetched all the events
            return True
        events_count = client.offenses_list(offense_id=int(offense_id)).get('event_count', 0)
        expected_events = min(events_count, events_limit) if events_limit else events_count
        num_events = get_num_events(events)
        print_debug_msg(f'Fetched {num_events}/{expected_events} events for offense {offense_id}')
        # if we're not fetching only correlation events, we can't know if we fetched all the events
        return num_events >= expected_events if fetch_mode == FetchMode.all_events else num_events > 0


    def get_incidents_long_running_execution(client: Client, offenses_per_fetch: int, user_query: str, fetch_mode: str,
                                             events_columns: str, events_limit: int, ip_enrich: bool, asset_enrich: bool,
                                             last_highest_id: int, incident_type: Optional[str], mirror_direction: Optional[str],
                                             first_fetch: str, mirror_options: str, assets_limit: int) \
            -> tuple[Optional[List[dict]], Optional[int]]:
        """
        Gets offenses from QRadar service, and transforms them to incidents in a long running execution.
        Args:
            client (Client): Client to perform the API calls.
            offenses_per_fetch (int): Maximum number of offenses to be fetched.
            user_query (str): If given, the user filters for fetching offenses from QRadar service.
            fetch_mode (str): Fetch mode of the offenses.
                              Can be 'Fetch Without Events', 'Fetch With All Events', 'Fetch Correlation Events Only'
            events_columns (str): Events columns to extract by search query for each offense. Only used when fetch mode
                                  is not 'Fetch Without Events'.
            events_limit (int): Number of events to be fetched for each offense. Only used when fetch mode is not
                                'Fetch Without Events'.
            ip_enrich (bool): Whether to enrich offense by changing IP IDs of each offense to its IP value.
            asset_enrich (bool): Whether to enrich offense with assets
            last_highest_id (int): The highest ID of all the offenses that have been fetched from QRadar service.
            incident_type (Optional[str]): Incident type.
            mirror_direction (Optional[str]): Whether mirror in is activated or not.
            first_fetch (str): First fetch timestamp.


        Returns:
            (List[Dict], int): List of the incidents, and the new highest ID for next fetch.
            (None, None): if reset was triggered
        """
        offense_highest_id = get_minimum_id_to_fetch(last_highest_id, user_query, first_fetch, client)

        user_query = update_user_query(user_query)

        filter_fetch_query = f'id>{offense_highest_id}{user_query}'
        print_debug_msg(f'Filter query to QRadar: {filter_fetch_query}')
        range_max = offenses_per_fetch - 1 if offenses_per_fetch else MAXIMUM_OFFENSES_PER_FETCH - 1
        range_ = f'items=0-{range_max}'

        # if it fails here we can't recover, retry again later
        raw_offenses = client.offenses_list(range_, filter_=filter_fetch_query, sort=ASCENDING_ID_ORDER)
        if raw_offenses:
            raw_offenses_len = len(raw_offenses)
            print_debug_msg(f'raw_offenses size: {raw_offenses_len}')
        else:
            print_debug_msg('empty raw_offenses')

        new_highest_offense_id = raw_offenses[-1].get('id') if raw_offenses else offense_highest_id
        print_debug_msg(f'New highest ID returned from QRadar offenses: {new_highest_offense_id}')

        offenses: list[dict] = []
        if fetch_mode != FetchMode.no_events.value:
            futures = []
            for offense in raw_offenses:
                futures.append(EXECUTOR.submit(
                    enrich_offense_with_events,
                    client=client,
                    offense=offense,
                    fetch_mode=fetch_mode,  # type: ignore
                    events_columns=events_columns,
                    events_limit=events_limit,
                ))
            offenses_with_metadata = [future.result() for future in futures]
            offenses = [offense for offense, _ in offenses_with_metadata]
            if mirror_options == MIRROR_OFFENSE_AND_EVENTS:
                prepare_context_for_events(offenses_with_metadata)
        else:
            offenses = raw_offenses
        if is_reset_triggered():
            return None, None
        offenses_with_mirror = [
            dict(offense, mirror_direction=mirror_direction, mirror_instance=demisto.integrationInstance())
            for offense in offenses] if mirror_direction else offenses

        enriched_offenses = enrich_offenses_result(client, offenses_with_mirror, ip_enrich, asset_enrich, assets_limit)
        final_offenses = sanitize_outputs(enriched_offenses)
        incidents = create_incidents_from_offenses(final_offenses, incident_type)
        return incidents, new_highest_offense_id


    def prepare_context_for_events(offenses_with_metadata):
        ctx, version = get_integration_context_with_version()
        changed_offense_ids = []
        for offense, is_success in offenses_with_metadata:
            if not is_success:
                offense_id = str(offense.get('id'))
                ctx[MIRRORED_OFFENSES_QUERIED_CTX_KEY][offense_id] = QueryStatus.WAIT.value
                changed_offense_ids.append(offense_id)
        safely_update_context_data(ctx, version, offense_ids=changed_offense_ids)


    def create_incidents_from_offenses(offenses: List[dict], incident_type: Optional[str]) -> List[dict]:
        """
        Transforms list of offenses given into incidents for Demisto.
        Args:
            offenses (List[Dict]): List of the offenses to transform into incidents.
            incident_type (Optional[str]): Incident type to be used for each incident.

        Returns:
            (List[Dict]): Incidents list.
        """
        print_debug_msg(f'Creating {len(offenses)} incidents')
        return [{
            'name': f'''{offense.get('id')} {offense.get('description', '')}''',
            'rawJSON': json.dumps(offense),
            'occurred': get_time_parameter(offense.get('start_time'), iso_format=True),
            'type': incident_type
        } for offense in offenses]


    def print_context_data_stats(context_data: dict, stage: str) -> set[str]:
        """Print debug message with information about mirroring events.

        Args:
            context_data: The integration context data.
            stage: A prefix for the debug message.

        Returns: The ids of the mirrored offenses being currently processed.
        """
        if MIRRORED_OFFENSES_QUERIED_CTX_KEY not in context_data or MIRRORED_OFFENSES_FINISHED_CTX_KEY not in context_data:
            raise ValueError(f'Context data is missing keys: {MIRRORED_OFFENSES_QUERIED_CTX_KEY} or '
                             f'{MIRRORED_OFFENSES_FINISHED_CTX_KEY}')

        if not context_data:
            print_debug_msg("Not printing stats")
            return set()

        finished_queries = context_data.get(MIRRORED_OFFENSES_FINISHED_CTX_KEY, {})
        waiting_for_update = context_data.get(MIRRORED_OFFENSES_QUERIED_CTX_KEY, {})
        print_debug_msg(f'{finished_queries=}')
        print_debug_msg(f'{waiting_for_update=}')
        last_fetch_key = context_data.get(LAST_FETCH_KEY, 'Missing')
        last_mirror_update = context_data.get(LAST_MIRROR_KEY, 0)
        last_mirror_update_closed = context_data.get(LAST_MIRROR_CLOSED_KEY, 0)
        concurrent_mirroring_searches = get_current_concurrent_searches(context_data)
        samples = context_data.get('samples', [])
        sample_length = 0
        if samples:
            sample_length = len(samples[0])
        not_updated_ids = list(waiting_for_update)
        finished_queries_ids = list(finished_queries)
        print_debug_msg(f"Context Data Stats: {stage}\n Finished Offenses (id): {finished_queries_ids}"
                        f"\n Offenses ids waiting for update: {not_updated_ids}"
                        f"\n Concurrent mirroring events searches: {concurrent_mirroring_searches}"
                        f"\n Last Fetch Key {last_fetch_key}, Last mirror update {last_mirror_update}, "
                        f"Last mirror update closed: {last_mirror_update_closed}, "
                        f"sample length {sample_length}")
        return set(not_updated_ids + finished_queries_ids)


    def perform_long_running_loop(client: Client, offenses_per_fetch: int, fetch_mode: str,
                                  user_query: str, events_columns: str, events_limit: int, ip_enrich: bool,
                                  asset_enrich: bool, incident_type: Optional[str], mirror_direction: Optional[str],
                                  first_fetch: str, mirror_options: str, assets_limit: int, long_running_container_id: str):
        context_data, version = get_integration_context_with_version()

        if is_reset_triggered(context_data, version):
            last_highest_id = 0
        else:
            last_highest_id = int(context_data.get(LAST_FETCH_KEY, 0))
        print_debug_msg(f'Starting fetch loop. Fetch mode: {fetch_mode} on Container:{long_running_container_id}.')
        incidents, new_highest_id = get_incidents_long_running_execution(
            client=client,
            offenses_per_fetch=offenses_per_fetch,
            user_query=user_query,
            fetch_mode=fetch_mode,
            events_columns=events_columns,
            events_limit=events_limit,
            ip_enrich=ip_enrich,
            asset_enrich=asset_enrich,
            last_highest_id=last_highest_id,
            incident_type=incident_type,
            mirror_direction=mirror_direction,
            first_fetch=first_fetch,
            mirror_options=mirror_options,
            assets_limit=assets_limit
        )
        print_debug_msg(f'Got incidents, Creating incidents and updating context data. new highest id is {new_highest_id}')
        context_data, ctx_version = get_integration_context_with_version()
        if incidents and new_highest_id:
            incident_batch_for_sample = incidents[:SAMPLE_SIZE] if incidents else context_data.get('samples', [])
            if incident_batch_for_sample:
                print_debug_msg(f'Saving New Highest ID: {new_highest_id}')
                context_data.update({'samples': incident_batch_for_sample, LAST_FETCH_KEY: int(new_highest_id)})

            # if incident creation fails, it'll drop the data and try again in the next iteration
            demisto.createIncidents(incidents, {LAST_FETCH_KEY: str(new_highest_id)})
            safely_update_context_data(context_data=context_data,
                                       version=ctx_version,
                                       should_update_last_fetch=True)

            print_debug_msg(
                f'Successfully Created {len(incidents)} incidents. Incidents created: {[incident["name"] for incident in incidents]}')


    def recover_from_last_run(ctx: dict | None = None, version: Any = None):
        """
        This recovers the integration context from the last run, if there is inconsistency between last run and context.
        It happens when the container crashes after `demisto.createIncidents` and the integration context is not updated.
        """
        if not ctx or not version:
            ctx, version = get_integration_context_with_version()
        assert isinstance(ctx, dict)
        last_run = demisto.getLastRun() or {}
        last_highest_id_last_run = int(last_run.get(LAST_FETCH_KEY, 0))
        print_debug_msg(f'Last highest ID from last run: {last_highest_id_last_run}')
        last_highest_id_context = int(ctx.get(LAST_FETCH_KEY, 0))
        if last_highest_id_last_run != last_highest_id_context and last_highest_id_last_run > 0:
            # if there is inconsistency between last run and context, we need to update the context
            print_debug_msg(
                f'Updating context data with last highest ID from last run: {last_highest_id_last_run}.'
                f'ID from context: {last_highest_id_context}')
            safely_update_context_data(ctx | {LAST_FETCH_KEY: int(last_highest_id_last_run)},
                                       version, should_update_last_fetch=True)


    def long_running_execution_command(client: Client, params: dict):
        """
        Long running execution of fetching incidents from QRadar service.
        Will continue to fetch in an infinite loop offenses from QRadar,
        Enriching each offense with events/IPs/assets according to the
        configurations given in Demisto params.
        transforming the offenses into incidents and sending them to Demisto
        to save the incidents.
        Args:
            client (Client): Client to perform API calls.
            params (Dict): Demisto params.

        """
        global EVENTS_SEARCH_TRIES
        validate_long_running_params(params)
        fetch_mode = params.get('fetch_mode', '')
        first_fetch = params.get('first_fetch', '3 days')
        ip_enrich, asset_enrich = get_offense_enrichment(params.get('enrichment', 'IPs And Assets'))
        offenses_per_fetch = int(params.get('offenses_per_fetch'))  # type: ignore
        user_query = params.get('query', '')
        events_columns = params.get('events_columns') or DEFAULT_EVENTS_COLUMNS
        events_limit = int(params.get('events_limit') or DEFAULT_EVENTS_LIMIT)
        incident_type = params.get('incident_type')
        mirror_options = params.get('mirror_options', DEFAULT_MIRRORING_DIRECTION)
        mirror_direction = MIRROR_DIRECTION.get(mirror_options)
        mirror_options = params.get('mirror_options', '')
        assets_limit = int(params.get('assets_limit', DEFAULT_ASSETS_LIMIT))
        if not argToBoolean(params.get('retry_events_fetch', True)):
            EVENTS_SEARCH_TRIES = 1
        context_data, version = get_integration_context_with_version()
        is_reset_triggered(context_data, version)
        recover_from_last_run(context_data, version)
        long_running_container_id = str(uuid.uuid4())
        print_debug_msg(f'Starting container with UUID: {long_running_container_id}')
        while True:
            try:
                perform_long_running_loop(
                    client=client,
                    offenses_per_fetch=offenses_per_fetch,
                    fetch_mode=fetch_mode,
                    user_query=user_query,
                    events_columns=events_columns,
                    events_limit=events_limit,
                    ip_enrich=ip_enrich,
                    asset_enrich=asset_enrich,
                    incident_type=incident_type,
                    mirror_direction=mirror_direction,
                    first_fetch=first_fetch,
                    mirror_options=mirror_options,
                    assets_limit=assets_limit,
                    long_running_container_id=long_running_container_id
                )
                demisto.updateModuleHealth('')

            except Exception as e:
                msg = f'Error occurred during long running loop: {e}'
                demisto.updateModuleHealth(msg)
                demisto.error(msg)
                demisto.error(traceback.format_exc())

            finally:
                print_debug_msg('Finished fetch loop')
                time.sleep(FETCH_SLEEP)


    def qradar_offenses_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of offenses from QRadar service.
        possible arguments:
        - offense_id: Retrieves details of the specific offense that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        offense_id = args.get('offense_id')
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')
        ip_enrich, asset_enrich = get_offense_enrichment(args.get('enrichment', 'None'))

        # if this call fails, raise an error and stop command execution
        response = client.offenses_list(range_, offense_id, filter_, fields)
        enriched_outputs = enrich_offenses_result(client, response, ip_enrich, asset_enrich)
        final_outputs = sanitize_outputs(enriched_outputs, OFFENSE_OLD_NEW_NAMES_MAP)
        headers = build_headers(['ID', 'Description', 'OffenseType', 'Status', 'Severity'],
                                set(OFFENSE_OLD_NEW_NAMES_MAP.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Offenses List', final_outputs, headers=headers, removeNull=True),
            outputs_prefix='QRadar.Offense',
            outputs_key_field='ID',
            outputs=final_outputs,
            raw_response=response
        )


    def qradar_offense_update_command(client: Client, args: dict) -> CommandResults:
        """
        Updates offense that corresponds to the given offense ID.
        possible arguments:
        - offense_id (Required): Update offense that corresponds to ID given.
        - protected: Whether the offense is protected.
        - follow_up: Whether the offense should be marked for follow up.
        - status: Status of the offense. One of 'OPEN', 'HIDDEN', 'CLOSED'.
        - closing_reason_id: The ID of the reason the offense was closed. full list of closing reason IDs,
                             full list of closing reason IDs can be retrieved by 'qradar-closing-reasons' command.
        - assigned_to: The user whom to assign the offense to.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        offense_id: int = int(args['offense_id'])
        protected = args.get('protected')
        follow_up = args.get('follow_up')
        closing_reason_name = args.get('closing_reason_name')

        status = args.get('status')
        closing_reason_id = args.get('closing_reason_id')
        if status == 'CLOSED' and (not closing_reason_id and not closing_reason_name):
            raise DemistoException(
                '''Closing reason ID must be provided when closing an offense. Available closing reasons can be achieved
                 by 'qradar-closing-reasons' command.'''
            )

        if closing_reason_name:
            # if this call fails, raise an error and stop command execution
            closing_reasons_list = client.closing_reasons_list(include_deleted=True, include_reserved=True)
            for closing_reason in closing_reasons_list:
                if closing_reason.get('text') == closing_reason_name:
                    closing_reason_id = closing_reason.get('id')
            if not closing_reason_id:
                raise DemistoException(f'Could not find closing reason name {closing_reason_name}. Please provide a valid'
                                       ' closing reason name. Closing reasons can be retrieved by running the '
                                       'qradar-closing-reasons command.')

        assigned_to = args.get('assigned_to')
        fields = args.get('fields')
        ip_enrich, asset_enrich = get_offense_enrichment(args.get('enrichment', 'None'))

        # if this call fails, raise an error and stop command execution
        response = client.offense_update(offense_id, protected, follow_up, status, closing_reason_id, assigned_to,
                                         fields)

        enriched_outputs = enrich_offenses_result(client, response, ip_enrich, asset_enrich)
        final_outputs = sanitize_outputs(enriched_outputs, OFFENSE_OLD_NEW_NAMES_MAP)
        headers = build_headers(['ID', 'Description', 'OffenseType', 'Status', 'Severity'],
                                set(OFFENSE_OLD_NEW_NAMES_MAP.values()))

        return CommandResults(
            readable_output=tableToMarkdown('offense Update', final_outputs, headers, removeNull=True),
            outputs_prefix='QRadar.Offense',
            outputs_key_field='ID',
            outputs=final_outputs,
            raw_response=response
        )


    def qradar_closing_reasons_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of closing reasons from QRadar service.
        possible arguments:
        - closing_reason_id: Retrieves details of the specific closing reason that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        closing_reason_id = args.get('closing_reason_id')
        include_reserved = argToBoolean(args.get('include_reserved', False))
        include_deleted = argToBoolean(args.get('include_deleted', False))
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.closing_reasons_list(closing_reason_id, include_reserved, include_deleted, range_, filter_,
                                               fields)
        outputs = sanitize_outputs(response, CLOSING_REASONS_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name'], set(CLOSING_REASONS_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Closing Reasons', outputs, headers=headers, removeNull=True),
            outputs_prefix='QRadar.Offense.ClosingReasons',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_offense_notes_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of notes corresponding to the ID of the offense ID given from QRadar service.
        possible arguments:
        - offense_id: The offense ID to retrieve the notes for.
        - note_id: The note ID to its details.
        - range: Range of notes to return for the offense corresponding to the offense ID (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        offense_id: int = int(args['offense_id'])
        note_id = args.get('note_id')
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.offense_notes_list(offense_id, range_, note_id, filter_, fields)
        outputs = sanitize_outputs(response, NOTES_RAW_FORMATTED)
        headers = build_headers(['ID', 'Text', 'CreatedBy', 'CreateTime'], set(NOTES_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown(f'Offense Notes List For Offense ID {offense_id}', outputs, headers,
                                            removeNull=True),
            outputs_prefix='QRadar.Note',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_offense_notes_create_command(client: Client, args: dict) -> CommandResults:
        """
        Create a new note for the offense corresponding to the given offense ID with the note text given
        to QRadar service.
        possible arguments:
        - offense_id: The offense ID to add note to.
        - note_text: The note text.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        offense_id: int = int(args['offense_id'])
        note_text: str = args.get('note_text', '')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.offense_notes_create(offense_id, note_text, fields)
        outputs = sanitize_outputs(response, NOTES_RAW_FORMATTED)
        headers = build_headers(['ID', 'Text', 'CreatedBy', 'CreateTime'], set(NOTES_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Create Note', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.Note',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_rules_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of rules from QRadar service.
        possible arguments:
        - rule_id: Retrieves details of the specific rule that corresponds to the ID given.
        - rule_type: Retrieves rules corresponding to the given rule type.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        rule_id = args.get('rule_id')
        rule_type = args.get('rule_type')
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        if not filter_ and rule_type:
            filter_ = f'type={rule_type}'

        # if this call fails, raise an error and stop command execution
        response = client.rules_list(rule_id, range_, filter_, fields)
        outputs = sanitize_outputs(response, RULES_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name', 'Type'], set(RULES_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Rules List', outputs, headers=headers, removeNull=True),
            outputs_prefix='QRadar.Rule',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_rule_groups_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of rule groups from QRadar service.
        possible arguments:
        - rule_group_id: Retrieves details of the specific rule group that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        rule_group_id = arg_to_number(args.get('rule_group_id'))
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.rule_groups_list(range_, rule_group_id, filter_, fields)
        outputs = sanitize_outputs(response, RULES_GROUP_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name', 'Description', 'Owner'], set(RULES_GROUP_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Rules Group List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.RuleGroup',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_assets_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of assets from QRadar service.
        possible arguments:
        - asset_id: Retrieves details of the specific asset that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        asset_id = args.get('asset_id')
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # If asset ID was given, override filter if both filter and asset ID were given.
        if asset_id:
            filter_ = f'id={asset_id}'

        full_enrichment = bool(asset_id)

        # if this call fails, raise an error and stop command execution
        response = client.assets_list(range_, filter_, fields)
        enriched_outputs = enrich_assets_results(client, response, full_enrichment)
        assets_results = {}
        assets_hr = []
        endpoints = []
        for output in enriched_outputs:
            output['Asset']['hostnames'] = add_iso_entries_to_dict(output.get('Asset', {}).get('hostnames', []))
            output['Asset']['users'] = add_iso_entries_to_dict(output.get('Asset', {}).get('users', []))
            output['Asset']['products'] = add_iso_entries_to_dict(output.get('Asset', {}).get('products', []))
            output['Asset'] = sanitize_outputs(output.get('Asset'), ASSET_RAW_FORMATTED)[0]
            assets_hr.append(output['Asset'])
            assets_results[f'''QRadar.Asset(val.ID === "{output['Asset']['ID']}")'''] = output['Asset']
            sanitized_endpoint = remove_empty_elements(output.get('Endpoint', {}))
            if sanitized_endpoint:
                endpoints.append(sanitized_endpoint)

        asset_human_readable = tableToMarkdown('Assets List', assets_hr, removeNull=True)
        endpoints_human_readable = tableToMarkdown('Endpoints', endpoints, removeNull=True)

        if endpoints:
            assets_results['Endpoint'] = endpoints

        return CommandResults(
            readable_output=asset_human_readable + endpoints_human_readable,
            outputs=assets_results,
            raw_response=response
        )


    def qradar_saved_searches_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of saved searches from QRadar service.
        possible arguments:
        - saved_search_id: Retrieves details of the specific saved search that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        saved_search_id = args.get('saved_search_id')
        timeout: Optional[int] = arg_to_number(args.get('timeout', DEFAULT_TIMEOUT_VALUE))
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.saved_searches_list(range_, timeout, saved_search_id, filter_, fields)
        outputs = sanitize_outputs(response, SAVED_SEARCH_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name', 'Description'], set(SAVED_SEARCH_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Saved Searches List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.SavedSearch',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_searches_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of searches IDs from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')

        # if this call fails, raise an error and stop command execution
        response = client.searches_list(range_, filter_)
        outputs = [{'SearchID': search_id} for search_id in response]

        return CommandResults(
            readable_output=tableToMarkdown('Search ID List', outputs),
            outputs_prefix='QRadar.SearchID',
            outputs_key_field='SearchID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_search_create_command(client: Client, params: dict, args: dict) -> CommandResults:
        """
        Create a search in QRadar service.
        possible arguments:
        - query_expression: The AQL query to execute. Mutually exclusive with saved_search_id.
        - saved_search_id: Saved search ID to execute. Mutually exclusive with query_expression.
        Args:
            client (Client): QRadar client to perform the API call.
            params (Dict): Demisto params.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        offense_id = args.get('offense_id', '')
        events_columns = args.get('events_columns', params.get('events_columns')) or DEFAULT_EVENTS_COLUMNS
        events_limit = args.get('events_limit', params.get('events_limit'))
        fetch_mode = args.get('fetch_mode', params.get('fetch_mode'))
        start_time = args.get('start_time')
        query_expression = args.get('query_expression')
        saved_search_id = args.get('saved_search_id')

        if not query_expression and not saved_search_id and not offense_id:
            raise DemistoException('Please provide one of the following args: `query_expression`, `saved_search_id` or `offense_id`.')

        if query_expression and offense_id:
            raise DemistoException('Could not use both `query_expression` and `offense_id`.')
        # if this call fails, raise an error and stop command execution
        if query_expression or saved_search_id:
            try:
                response = client.search_create(query_expression, saved_search_id)
            except Exception as e:
                if query_expression:
                    raise DemistoException(f'Could not create search for query: {query_expression}.') from e
                if saved_search_id:
                    raise DemistoException(f'Could not create search for saved_search_id: {saved_search_id}.') from e
        else:
            response = create_events_search(client,
                                            fetch_mode,
                                            events_columns,
                                            events_limit,
                                            int(offense_id),
                                            start_time,
                                            return_raw_response=True)
            if response == QueryStatus.ERROR.value:
                raise DemistoException(f'Could not create events search for offense_id: {offense_id}.')

        outputs = sanitize_outputs(response, SEARCH_RAW_FORMATTED)
        return CommandResults(
            readable_output=tableToMarkdown('Create Search', outputs),
            outputs_prefix='QRadar.Search',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_search_status_get_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves search status from QRadar service.
        possible arguments:
        - search_id (Required): The search ID to retrieve its status.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        search_id: str = args.get('search_id', '')

        # if this call fails, raise an error and stop command execution
        response = client.search_status_get(search_id)
        outputs = sanitize_outputs(response, SEARCH_RAW_FORMATTED)

        return CommandResults(
            readable_output=tableToMarkdown(f'Search Status For Search ID {search_id}', outputs),
            outputs_prefix='QRadar.Search',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_search_delete_command(client: Client, args: dict) -> CommandResults:
        """
        Delete search from QRadar service.
        possible arguments:
        - search_id (Required): The search ID to delete.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        search_id: str = args.get('search_id', '')

        # if this call fails, raise an error and stop command execution
        response = client.search_delete(search_id)

        return CommandResults(
            readable_output=f'Search ID {search_id} was successfully deleted.',
            raw_response=response
        )


    def qradar_search_cancel_command(client: Client, args: dict) -> CommandResults:
        """
        Cancelled search from QRadar service.
        possible arguments:
        - search_id (Required): The search ID to delete.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        search_id: str = args.get('search_id', '')

        # if this call fails, raise an error and stop command execution
        response = client.search_cancel(search_id)
        if response.get('status') == 'COMPLETED':
            output = f'Search ID {search_id} is already in a completed status.'
        else:
            output = f'Search ID {search_id} was successfully cancelled.'
        return CommandResults(
            readable_output=output,
            raw_response=response
        )


    def qradar_search_results_get_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves search results from QRadar service.
        possible arguments:
        - search_id: Search ID to retrieve its results.
        - output_path: If specified, will be context output path prefix.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        search_id: str = args.get('search_id', '')
        output_path = args.get('output_path')
        # Using or instead of default value for QRadarFullSearch backward compatibility
        range_ = f'''items={args.get('range') or DEFAULT_RANGE_VALUE}'''

        # if this call fails, raise an error and stop command execution
        response = client.search_results_get(search_id, range_)
        if not response:
            raise DemistoException('Unexpected response from QRadar service.')
        result_key = list(response.keys())[0]
        outputs = sanitize_outputs(response.get(result_key))

        outputs_prefix = output_path if output_path else f'QRadar.Search(val.ID === "{search_id}").Result.{result_key}'

        return CommandResults(
            readable_output=tableToMarkdown(f'Search Results For Search ID {search_id}', outputs),
            outputs_prefix=outputs_prefix,
            outputs=outputs,
            raw_response=response
        )


    def qradar_reference_sets_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of reference sets from QRadar service.
        possible arguments:
        - ref_name: Retrieves details of the specific reference that corresponds to the reference name given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        ref_name = args.get('ref_name')
        convert_date_value = argToBoolean(args.get('date_value', False))
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.reference_sets_list(range_, ref_name, filter_, fields)
        if ref_name:
            outputs = dict(response)
            if convert_date_value and outputs.get('element_type') == 'DATE':
                for data_entry in outputs.get('data', []):
                    data_entry['value'] = get_time_parameter(data_entry.get('value'), iso_format=True)
            outputs['data'] = sanitize_outputs(outputs.get('data', []), REFERENCE_SET_DATA_RAW_FORMATTED)
        else:
            outputs = response

        final_outputs = sanitize_outputs(outputs, REFERENCE_SETS_RAW_FORMATTED)
        headers = build_headers(['Name', 'ElementType', 'Data', 'TimeToLive', 'TimeoutType'],
                                set(REFERENCE_SETS_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Reference Sets List', final_outputs, headers, removeNull=True),
            outputs_prefix='QRadar.Reference',
            outputs_key_field='Name',
            outputs=final_outputs,
            raw_response=response
        )


    def qradar_reference_set_create_command(client: Client, args: dict) -> CommandResults:
        """
        Create a new reference set.
        possible arguments:
        - ref_name (Required): The name of the new reference set.
        - element_type (Required): The type of the new reference set. Can be ALN (alphanumeric),
                                   ALNIC (alphanumeric ignore case), IP (IP address), NUM (numeric),
                                   PORT (port number) or DATE.
        - timeout_type: Indicates if the time_to_live interval is based on when the data was first seen or last seen.
                        The allowed values are 'FIRST_SEEN', 'LAST_SEEN' and 'UNKNOWN'. The default value is 'UNKNOWN'.
        - time_to_live: The time to live interval, for example: '1 month' or '5 minutes'.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        ref_name: str = args.get('ref_name', '')
        element_type: str = args.get('element_type', '')
        timeout_type = args.get('timeout_type')
        time_to_live = args.get('time_to_live')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.reference_set_create(ref_name, element_type, timeout_type, time_to_live, fields)
        outputs = sanitize_outputs(response, REFERENCE_SETS_RAW_FORMATTED)
        headers = build_headers(['Name', 'ElementType', 'Data', 'TimeToLive', 'TimeoutType'],
                                set(REFERENCE_SETS_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Reference Set Create', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.Reference',
            outputs_key_field='Name',
            outputs=outputs,
            raw_response=response
        )


    def qradar_reference_set_delete_command(client: Client, args: dict) -> CommandResults:
        """
        Removes a reference set or purges its contents.
        possible arguments:
        - ref_name (Required): The name of the new reference set.
        - purge_only: Indicates if the reference set should have its contents purged (true),
                      keeping the reference set structure. If the value is 'false',
                      or not specified the reference set is removed completely.
                      Default is 'false'.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        ref_name: str = args.get('ref_name', '')
        purge_only = args.get('purge_only')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.reference_set_delete(ref_name, purge_only, fields)
        return CommandResults(
            raw_response=response,
            readable_output=f'Request to delete reference {ref_name} was submitted.'
                            f''' Current deletion status: {response.get('status', 'Unknown')}''')


    @polling_function(name='qradar-reference-set-value-upsert', requires_polling_arg=False)
    def qradar_reference_set_value_upsert_command(args: dict, client: Client, params: dict) -> PollResult:
        """
        Update or insert new value to a reference set from QRadar service.
        possible arguments:
        - ref_name (Required): The reference name to insert/update a value for.
        - values (Required): Comma separated list. All the values to be inserted/updated.
        - source: An indication of where the data originated. Default is reference data api.
        - date_value: Boolean, specifies if values given are dates or not.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            PollResult.
        """
        return insert_values_to_reference_set_polling(client,
                                                      params.get('api_version', ''),
                                                      args,
                                                      values=argToList(args.get('value', '')))


    def qradar_reference_set_value_delete_command(client: Client, args: dict) -> CommandResults:
        """
        Delete a value in reference set from QRadar service.
        possible arguments:
        - ref_name (Required): The reference name to insert/update a value for.
        - value (Required): Value to be deleted.
        - date_value: Boolean, specifies if values given are dates or not.

        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        ref_name: str = args.get('ref_name', '')
        value: str = args.get('value', '')
        date_value = argToBoolean(args.get('date_value', False))
        original_value = value

        if date_value:
            value = str(get_time_parameter(original_value, epoch_format=True))
        # if this call fails, raise an error and stop command execution
        try:
            response = client.reference_set_value_delete(ref_name, value)
        except DemistoException as e:
            response = str(e)
            if f"Set {ref_name} does not contain value {value}" not in response:
                raise e
        human_readable = f'### value: {original_value} of reference: {ref_name} was deleted successfully'

        return CommandResults(
            readable_output=human_readable,
            raw_response=response
        )


    def qradar_domains_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves list of domains sets from QRadar service.
        If you do not have the System Administrator or Security Administrator permissions,
        then for each domain assigned to your security profile you can only view the values
        for the id and name fields. All other values return null.
        possible arguments:
        - domain_id: Retrieves details of the specific domain that corresponds to the ID given.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        # backward compatibility for domain_id argument named is 'id' in QRadar v2.
        domain_id = args.get('domain_id') or args.get('id')
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.domains_list(domain_id, range_, filter_, fields)
        outputs = sanitize_outputs(response, DOMAIN_RAW_FORMATTED)

        return CommandResults(
            readable_output=tableToMarkdown('Domains List', outputs, removeNull=True),
            outputs_prefix='QRadar.Domains',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    @polling_function(name='qradar-indicators-upload', requires_polling_arg=False)
    def qradar_indicators_upload_command(args: dict, client: Client, params: dict) -> PollResult:
        """
        Uploads list of indicators from Demisto to a reference set in QRadar service.
        possible arguments:
        - ref_name (Required): Name of the reference set to upload indicators to.
        - query: The query for getting indicators from Demisto.
        - limit: Maximum number of indicators to fetch from Demisto.
        - page: The page from which to get the indicators.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            PollResult.
        """
        return insert_values_to_reference_set_polling(client, params.get('api_version', ''), args, from_indicators=True)


    def flatten_nested_geolocation_values(geolocation_dict: dict, dict_key: str, nested_value_keys: List[str]) -> dict:
        """
        Receives output from geolocation IPs command, and does:
        1) flattens output, takes nested keys values.
        2) Converts keys to prefix of 'dict_key' and suffix of nested key as camel case.
        Args:
            geolocation_dict (Dict): The dict to flatten.
            dict_key (Dict): The key of the inner dict to use his values.
            nested_value_keys (Dict): The keys inside inner dict to take.

        Returns:
            (Dict): dict of ({dict_key_name}{camel case nested key}: {nested key value}
        """
        return {f'{camelize_string(dict_key)}{camelize_string(k)}': geolocation_dict.get(dict_key, {}).get(k) for k in
                nested_value_keys}


    def qradar_geolocations_for_ip_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves the MaxMind geoip data for the given IP addresses.
        possible arguments:
        - ip (Required): Comma separated list. the IPs to retrieve data for.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        ips = argToList(args.get('ip'))
        filter_ = f'''ip_address IN ({','.join((f'"{str(ip)}"' for ip in ips))})'''  # noqa: UP034
        fields = args.get('fields')

        # if this call fails, raise an error and stop command execution
        response = client.geolocations_for_ip(filter_, fields)
        outputs = []
        for output in response:
            city_values = flatten_nested_geolocation_values(output, 'city', ['name'])
            continent_values = flatten_nested_geolocation_values(output, 'continent', ['name'])
            location_values = flatten_nested_geolocation_values(output, 'location',
                                                                ['accuracy_radius', 'average_income', 'latitude',
                                                                 'longitude', 'metro_code', 'population_density',
                                                                 'timezone'])
            physical_country_values = flatten_nested_geolocation_values(output, 'physical_country', ['iso_code', 'name'])
            registered_country_values = flatten_nested_geolocation_values(output, 'registered_country',
                                                                          ['iso_code', 'name'])
            represented_country_values = flatten_nested_geolocation_values(output, 'represented_country',
                                                                           ['iso_code', 'name', 'confidence'])
            subdivision_values = flatten_nested_geolocation_values(output, 'subdivision',
                                                                   ['name', 'iso_code', 'confidence'])
            non_nested_values = {
                'IPAddress': output.get('ip_address'),
                'Traits': output.get('traits'),
                'Coordinates': output.get('geo_json', {}).get('coordinates'),
                'PostalCode': output.get('postal', {}).get('postal_code'),
                'PostalCodeConfidence': output.get('postal', {}).get('confidence')
            }
            final_output = dict(city_values, **continent_values, **location_values, **physical_country_values,
                                **registered_country_values, **represented_country_values, **subdivision_values,
                                **non_nested_values)
            outputs.append(final_output)

        final_outputs = sanitize_outputs(outputs)

        return CommandResults(
            readable_output=tableToMarkdown('Geolocation For IP', final_outputs),
            outputs_prefix='QRadar.GeoForIP',
            outputs_key_field='IPAddress',
            outputs=final_outputs,
            raw_response=response
        )


    def qradar_log_sources_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log sources from QRadar service.
        possible arguments:
        - qrd_encryption_algorithm: The algorithm to use for encrypting the sensitive data of this
            endpoint. Using AES 128
        - qrd_encryption_password: The password to use for encrypting the sensitive data of this endpoint.
            If argument was not given, will be randomly generated.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        qrd_encryption_algorithm: str = args.get('qrd_encryption_algorithm', 'AES128')
        qrd_encryption_password: str = args.get('qrd_encryption_password', secrets.token_urlsafe(20))
        endpoint = '/config/event_sources/log_source_management/log_sources'
        range_ = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_ = args.get('filter')
        fields = args.get('fields')
        additional_headers = {
            'x-qrd-encryption-algorithm': qrd_encryption_algorithm,
            'x-qrd-encryption-password': qrd_encryption_password
        }
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields, additional_headers)
        outputs = sanitize_outputs(response, LOG_SOURCES_RAW_FORMATTED)
        readable_outputs = [{k: v for k, v in output.items() if k != 'ProtocolParameters'} for output in outputs]
        headers = build_headers(['ID', 'Name', 'Description'], set(LOG_SOURCES_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Log Sources List', readable_outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSource',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_get_custom_properties_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of event regex properties from QRadar service.
        possible arguments:
        - field_names: A comma-separated list of names of an exact properties to search for.
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: If used, will filter all fields except for the specified ones.
                  Use this parameter to specify which fields you would like to get back in the
                  response. Fields that are not explicitly named are excluded.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        limit = arg_to_number(args.get('limit', DEFAULT_LIMIT_VALUE))
        range_ = f'items=0-{limit - 1}' if limit else f'items={args.get("range", DEFAULT_RANGE_VALUE)}'

        like_names = argToList(args.get('like_name'))
        field_names = argToList(args.get('field_name'))
        filter_ = args.get('filter', '')
        fields = args.get('fields')
        if not filter_:
            if field_names:
                filter_ += f'''name IN ({','.join(f'"{str(name)}"' for name in field_names)})'''
            if like_names:
                filter_ += ' or '.join(f' name ILIKE "%{like}%"' for like in like_names)

        # if this call fails, raise an error and stop command execution
        response = client.custom_properties(range_, filter_, fields)
        outputs = sanitize_outputs(response)

        return CommandResults(
            readable_output=tableToMarkdown('Custom Properties', outputs, removeNull=True),
            outputs_prefix='QRadar.Properties',
            outputs_key_field='identifier',
            outputs=outputs,
            raw_response=response
        )


    def perform_ips_command_request(client: Client, args: dict[str, Any], is_destination_addresses: bool):
        """
        Performs request to QRadar IPs endpoint.
        Args:
            client (Client): Client to perform the request to QRadar service.
            args (Dict[str, Any]): XSOAR arguments.
            is_destination_addresses (bool): Whether request is for destination addresses or source addresses.

        Returns:
            - Request response.
        """
        range_: str = f'''items={args.get('range', DEFAULT_RANGE_VALUE)}'''
        filter_: Optional[str] = args.get('filter')
        fields: Optional[str] = args.get('fields')

        address_type = 'local_destination' if is_destination_addresses else 'source'
        ips_arg_name: str = f'{address_type}_ip'
        ips: List[str] = argToList(args.get(ips_arg_name, []))

        if ips and filter_:
            raise DemistoException(f'Both filter and {ips_arg_name} have been supplied. Please supply only one.')

        if ips:
            filter_ = ' OR '.join([f'{ips_arg_name}="{ip_}"' for ip_ in ips])
        url_suffix = f'{address_type}_addresses'

        # if this call fails, raise an error and stop command execution
        response = client.get_addresses(url_suffix, filter_, fields, range_)

        return response


    def qradar_ips_source_get_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Get source IPS from QRadar service.
        Args:
            client (Client): Client to perform API calls to QRadar service.
            args (Dict[str, Any): XSOAR arguments.

        Returns:
            (CommandResults).
        """
        response = perform_ips_command_request(client, args, is_destination_addresses=False)
        outputs = sanitize_outputs(response, SOURCE_IPS_RAW_FORMATTED)

        return CommandResults(
            readable_output=tableToMarkdown('Source IPs', outputs),
            outputs_prefix='QRadar.SourceIP',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_ips_local_destination_get_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Get local destination IPS from QRadar service.
        Args:
            client (Client): Client to perform API calls to QRadar service.
            args (Dict[str, Any): XSOAR arguments.

        Returns:
            (CommandResults).
        """
        response = perform_ips_command_request(client, args, is_destination_addresses=True)
        outputs = sanitize_outputs(response, LOCAL_DESTINATION_IPS_RAW_FORMATTED)

        return CommandResults(
            readable_output=tableToMarkdown('Local Destination IPs', outputs),
            outputs_prefix='QRadar.LocalDestinationIP',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_reset_last_run_command() -> str:
        """
        Puts the reset flag inside integration context.
        Returns:
            (str): 'fetch-incidents was reset successfully'.
        """
        ctx, version = get_integration_context_with_version()
        safely_update_context_data(ctx, version, should_add_reset_key=True)
        return 'fetch-incidents was reset successfully.'


    def qradar_get_mapping_fields_command(client: Client) -> dict:
        """
        Returns Dict object containing the list of fields for an incident type.
        This command should be used for debugging purposes.
        Args:
            client (Client): Client to perform API calls.

        Returns:
            (Dict): Contains all the mapping.
        """
        offense = {
            'username_count': 'int',
            'description': 'str',
            'rules': {
                'id': 'int',
                'type': 'str',
                'name': 'str'
            },
            'event_count': 'int',
            'flow_count': 'int',
            'assigned_to': 'NoneType',
            'security_category_count': 'int',
            'follow_up': 'bool',
            'source_address_ids': 'str',
            'source_count': 'int',
            'inactive': 'bool',
            'protected': 'bool',
            'closing_user': 'str',
            'destination_networks': 'str',
            'source_network': 'str',
            'category_count': 'int',
            'close_time': 'str',
            'remote_destination_count': 'int',
            'start_time': 'str',
            'magnitude': 'int',
            'last_updated_time': 'str',
            'credibility': 'int',
            'id': 'int',
            'categories': 'str',
            'severity': 'int',
            'policy_category_count': 'int',
            'closing_reason_id': 'str',
            'device_count': 'int',
            'offense_type': 'str',
            'relevance': 'int',
            'domain_id': 'int',
            'offense_source': 'str',
            'local_destination_address_ids': 'int',
            'local_destination_count': 'int',
            'status': 'str',
            'domain_name': 'str'
        }
        events = {
            'events': {
                'qidname_qid': 'str',
                'logsourcename_logsourceid': 'str',
                'categoryname_highlevelcategory': 'str',
                'categoryname_category': 'str',
                'protocolname_protocolid': 'str',
                'sourceip': 'str',
                'sourceport': 'int',
                'destinationip': 'str',
                'destinationport': 'int',
                'qiddescription_qid': 'str',
                'username': 'NoneType',
                'rulename_creeventlist': 'str',
                'sourcegeographiclocation': 'str',
                'sourceMAC': 'str',
                'sourcev6': 'str',
                'destinationgeographiclocation': 'str',
                'destinationv6': 'str',
                'logsourcetypename_devicetype': 'str',
                'credibility': 'int',
                'severity': 'int',
                'magnitude': 'int',
                'eventcount': 'int',
                'eventDirection': 'str',
                'postNatDestinationIP': 'str',
                'postNatDestinationPort': 'int',
                'postNatSourceIP': 'str',
                'postNatSourcePort': 'int',
                'preNatDestinationPort': 'int',
                'preNatSourceIP': 'str',
                'preNatSourcePort': 'int',
                'utf8_payload': 'str',
                'starttime': 'str',
                'devicetime': 'int'
            }
        }
        assets = {
            'assets': {
                'interfaces': {
                    'mac_address': 'str',
                    'ip_addresses': {
                        'type': 'str',
                        'value': 'str'
                    },
                    'id': 'int',
                    'Unified Name': 'str',
                    'Technical User': 'str',
                    'Switch ID': 'str',
                    'Business Contact': 'str',
                    'CVSS Availability Requirement': 'str',
                    'Compliance Notes': 'str',
                    'Primary OS ID': 'str',
                    'Compliance Plan': 'str',
                    'Switch Port ID': 'str',
                    'Weight': 'str',
                    'Location': 'str',
                    'CVSS Confidentiality Requirement': 'str',
                    'Technical Contact': 'str',
                    'Technical Owner': 'str',
                    'CVSS Collateral Damage Potential': 'str',
                    'Description': 'str',
                    'Business Owner': 'str',
                    'CVSS Integrity Requirement': 'str'
                },
                'id': 'int',
                'domain_id': 'int',
                'domain_name': 'str'
            }
        }
        # if this call fails, raise an error and stop command execution
        custom_fields = {
            'events': {field.get('name'): field.get('property_type')
                       for field in client.custom_properties()
                       if 'name' in field and 'property_type' in field}
        }
        fields = {
            'Offense': offense,
            'Events: Builtin Fields': events,
            'Events: Custom Fields': custom_fields,
            'Assets': assets,
        }
        return fields


    def update_events_mirror_message(mirror_options: Optional[Any],
                                     events_limit: int,
                                     events_count: int,
                                     events_mirrored: int,
                                     events_mirrored_collapsed: int,
                                     fetch_mode: str,
                                     offense_id: int,
                                     failure_message: Optional[str] = None,
                                     ) -> str:
        """Return the offense's events' mirror error message.

        Args:
            mirror_options (str): The mirror options for the instance.
            events_limit (int): The events limit for the mirroring.
            failure_message (str): A failure message if there was a failure during fetching of events.
            events_count (int): The number of events in the offense.
            events_mirrored (int): The number of events mirrored in the offense

        Returns: (str) An updated offense events mirror message.
        """
        mirroring_events_message = 'Unknown'
        print_debug_msg(f"Events status for Offense {offense_id}:\n"
                        f"mirror_options {mirror_options}\n events_limit {events_limit} \n"
                        f"failure_message {failure_message}\n events_count {events_count}\n "
                        f"events_mirrored {events_mirrored}")

        if mirror_options != MIRROR_OFFENSE_AND_EVENTS:
            mirroring_events_message = ''
        elif failure_message:
            mirroring_events_message = failure_message
        elif fetch_mode == FetchMode.all_events.value and events_mirrored < min(events_count, events_limit):
            mirroring_events_message = 'Fetching events did not get all events of the offense'
        elif events_mirrored == events_count:
            mirroring_events_message = 'All available events in the offense were fetched.'
        elif events_mirrored_collapsed == events_limit:
            mirroring_events_message = 'Fetching events has reached events limit in this incident.'

        return mirroring_events_message


    def get_remote_data_command(client: Client, params: dict[str, Any], args: dict) -> GetRemoteDataResponse:
        """
        get-remote-data command: Returns an updated incident and entries
        If offense's events were updated in the long running container, update the demisto incident.

        Args:
            client (Client): QRadar client to perform the API calls.
            params (Dict): Demisto params.
            args (Dict):
                id: Offense id to retrieve.
                lastUpdate: When was the last time we data was retrieved in Epoch.

        Returns:
            GetRemoteDataResponse.
        """
        remote_args = GetRemoteDataArgs(args)
        ip_enrich, asset_enrich = get_offense_enrichment(params.get('enrichment', 'IPs And Assets'))
        offense_id = str(remote_args.remote_incident_id)
        print_debug_msg(f'Starting get-remote-data for offense {offense_id}')
        # if this call fails, raise an error and stop command execution
        offense = client.offenses_list(offense_id=int(offense_id))
        offense_last_update = get_time_parameter(offense.get('last_persisted_time'))
        mirror_options = params.get('mirror_options')
        context_data, context_version = get_integration_context_with_version()
        events_columns = params.get('events_columns') or DEFAULT_EVENTS_COLUMNS
        events_limit = int(params.get('events_limit') or DEFAULT_EVENTS_LIMIT)
        fetch_mode = params.get('fetch_mode', '')
        print_context_data_stats(context_data, f"Starting Get Remote Data For "
                                               f"Offense {str(offense.get('id'))}")

        demisto.debug(f'Updating offense. Offense last update was {offense_last_update}')
        entries = []
        if offense.get('status') == 'CLOSED' and argToBoolean(params.get('close_incident', False)):
            demisto.debug(f'Offense is closed: {offense}')
            try:
                if closing_reason := offense.get('closing_reason_id', ''):
                    closing_reason = client.closing_reasons_list(closing_reason).get('text')
                offense_close_time = offense.get('close_time', '')
                closed_offense_notes = client.offense_notes_list(int(offense_id), f'items={DEFAULT_RANGE_VALUE}',
                                                                 filter_=f'create_time >= {offense_close_time}')
                # In QRadar UI, when you close a reason, a note is added with the reason and more details. Try to get note
                # if exists, else fallback to closing reason only, as closing QRadar through an API call does not create a note.
                closenotes = next((note.get('note_text') for note in closed_offense_notes if
                                   note.get('note_text').startswith('This offense was closed with reason:')),
                                  closing_reason)
                if not closing_reason:
                    print_debug_msg(f'Could not find closing reason or closing note for offense with offense id {offense_id}')
                    closing_reason = 'Unknown closing reason from QRadar'
                    closenotes = 'Unknown closing note from QRadar'

            except Exception as e:
                demisto.error(f'Failed to get closing reason with error: {e}')
                closing_reason = 'Unknown closing reason from QRadar'
                closenotes = 'Unknown closing note from QRadar'
                time.sleep(FAILURE_SLEEP)
            entries.append({
                'Type': EntryType.NOTE,
                'Contents': {
                    'dbotIncidentClose': True,
                    'closeReason': closing_reason,
                    'closeNotes': f'From QRadar: {closenotes}'
                },
                'ContentsFormat': EntryFormat.JSON
            })
        already_mirrored = False
        if mirror_options == MIRROR_OFFENSE_AND_EVENTS:
            if (num_events := context_data.get(MIRRORED_OFFENSES_FETCHED_CTX_KEY, {}).get(offense_id)) and \
                    int(num_events) >= (events_limit := int(params.get('events_limit', DEFAULT_EVENTS_LIMIT))):
                print_debug_msg(f'Events were already fetched {num_events} for offense {offense_id}, '
                                f'and are more than the events limit, {events_limit}. '
                                f'Not fetching events again.')
                # delete the offense from the queue
                delete_offense_from_context(offense_id, context_data, context_version)
                already_mirrored = True
            else:
                events, status = get_remote_events(client,
                                                   offense_id,
                                                   context_data,
                                                   context_version,
                                                   events_columns,
                                                   events_limit,
                                                   fetch_mode,
                                                   )
                print_context_data_stats(context_data, f"Get Remote Data events End for id {offense_id}")
                if status != QueryStatus.SUCCESS.value:
                    # we raise an exception because we don't want to change the offense until all events are fetched.
                    print_debug_msg(f'Events not mirrored yet for offense {offense_id}. Status: {status}')
                    raise DemistoException(f'Events not mirrored yet for offense {offense_id}')
                offense['events'] = events

        enriched_offense = enrich_offenses_result(client, offense, ip_enrich, asset_enrich)

        final_offense_data = sanitize_outputs(enriched_offense)[0]
        if not already_mirrored:
            events_mirrored = get_num_events(final_offense_data.get('events', []))
            print_debug_msg(f'Offense {offense_id} mirrored events: {events_mirrored}')
            events_message = update_events_mirror_message(
                mirror_options=mirror_options,
                events_limit=events_limit,
                events_count=int(final_offense_data.get('event_count', 0)),
                events_mirrored=events_mirrored,
                events_mirrored_collapsed=len(final_offense_data.get('events', [])),
                fetch_mode=fetch_mode,
                offense_id=int(offense_id),
            )
            print_debug_msg(f'offense {offense_id} events_message: {events_message}')
            final_offense_data['last_mirror_in_time'] = datetime.now().isoformat()
            final_offense_data['mirroring_events_message'] = events_message
            final_offense_data['events_fetched'] = events_mirrored
        return GetRemoteDataResponse(final_offense_data, entries)


    def add_modified_remote_offenses(client: Client,
                                     context_data: dict,
                                     version: str,
                                     mirror_options: str,
                                     new_modified_records_ids: set[str],
                                     new_last_update_modified: int,
                                     new_last_update_closed: int,
                                     events_columns: str,
                                     events_limit: int,
                                     fetch_mode: str
                                     ) -> set:
        """Add modified remote offenses to context_data and handle exhausted offenses.

        Args:
            client: Qradar client
            context_data: The context data to update.
            version: The version of the context data to update.
            mirror_options: The mirror options for the integration.
            new_modified_records_ids: The new modified offenses ids.
            new_last_update_modified: The current last mirror update modified.
            new_last_update_closed: The current last mirror update.
            events_columns: The events_columns param.
            events_limit: The events_limit param.

        Returns: The new modified records ids
        """
        new_context_data = context_data.copy()
        changed_ids_ctx = []
        if mirror_options == MIRROR_OFFENSE_AND_EVENTS:
            # We query the search queue, to see if some searches were finished.
            # If so - move it to finished queue and add to modified ids.
            print_context_data_stats(new_context_data, "Get Modified Remote Data - Before update")
            mirrored_offenses_queries = context_data.get(MIRRORED_OFFENSES_QUERIED_CTX_KEY, {})
            finished_offenses_queue = context_data.get(MIRRORED_OFFENSES_FINISHED_CTX_KEY, {})
            current_concurrent_searches = get_current_concurrent_searches(context_data)
            offense_ids_to_search = []

            for offense_id, search_id in mirrored_offenses_queries.copy().items():
                if search_id in {QueryStatus.WAIT.value, QueryStatus.ERROR.value}:
                    # if search_id is waiting or error, we will try to search again
                    offense_ids_to_search.append(offense_id)
                    continue
                # If the search finished, move it to finished queue
                _, status = poll_offense_events(client, search_id, should_get_events=False, offense_id=int(offense_id))
                if status == QueryStatus.ERROR.value:
                    time.sleep(FAILURE_SLEEP)
                    print_debug_msg(f'offense {offense_id}, search query {search_id}, status is {status}')
                    mirrored_offenses_queries[offense_id] = QueryStatus.ERROR.value
                    current_concurrent_searches -= 1

                elif status == QueryStatus.SUCCESS.value:
                    del mirrored_offenses_queries[offense_id]
                    finished_offenses_queue[offense_id] = search_id
                    # add the offense id to modified in order to run get_remote_data
                    new_modified_records_ids.add(offense_id)
                    changed_ids_ctx.append(offense_id)
                    current_concurrent_searches -= 1
                else:
                    print_debug_msg(f'offense {offense_id}, search query {search_id}, status is {status}')

            for offense_id in offense_ids_to_search:
                if current_concurrent_searches >= MAX_SEARCHES_QUEUE:
                    print_debug_msg(f'Reached maximum concurrent searches ({MAX_SEARCHES_QUEUE}), will try again later.')
                    break
                current_concurrent_searches += 1
                search_id = create_events_search(client, fetch_mode, events_columns, events_limit, int(offense_id))
                mirrored_offenses_queries[offense_id] = search_id
                changed_ids_ctx.append(offense_id)

            new_context_data.update({MIRRORED_OFFENSES_QUERIED_CTX_KEY: mirrored_offenses_queries})
            new_context_data.update({MIRRORED_OFFENSES_FINISHED_CTX_KEY: finished_offenses_queue})

        new_context_data.update({LAST_MIRROR_KEY: new_last_update_modified, LAST_MIRROR_CLOSED_KEY: new_last_update_closed})
        print_context_data_stats(new_context_data, "Get Modified Remote Data - After update")
        safely_update_context_data(
            new_context_data, version, offense_ids=changed_ids_ctx, should_update_last_mirror=True
        )
        return new_modified_records_ids


    def create_events_search(client: Client,
                             fetch_mode: str,
                             events_columns: str,
                             events_limit: int,
                             offense_id: int,
                             offense_start_time: str | None = None,
                             return_raw_response: bool = False,
                             ) -> str:
        additional_where = ''
        if fetch_mode == FetchMode.correlations_events_only.value:
            additional_where = ''' AND LOGSOURCETYPENAME(devicetype) = 'Custom Rule Engine' '''
        try:
            # Get all the events starting from one hour after epoch
            if not offense_start_time:
                offense = client.offenses_list(offense_id=offense_id)
                offense_start_time = offense['start_time']
            query_expression = (
                f'SELECT {events_columns} FROM events WHERE INOFFENSE({offense_id}) {additional_where} limit {events_limit} '  # noqa: S608, E501
                f'START {offense_start_time}'
            )
            print_debug_msg(f'Creating search for offense ID: {offense_id}, '
                            f'query_expression: {query_expression}')
            search_response = client.search_create(query_expression)
            print_debug_msg(f'Created search for offense ID: {offense_id}, '
                            f'Start Time: {offense_start_time}, '
                            f'events_limit: {events_limit}, '
                            f'ret_value: {search_response}.')
            if return_raw_response:
                return search_response
            return search_response['search_id'] if search_response['search_id'] else QueryStatus.ERROR.value
        except Exception as e:
            print_debug_msg(f'Search for {offense_id} failed. Error: {e}')
            time.sleep(FAILURE_SLEEP)
            return QueryStatus.ERROR.value


    def get_modified_remote_data_command(client: Client, params: dict[str, str],
                                         args: dict[str, str]) -> GetModifiedRemoteDataResponse:
        """
        Performs API calls to QRadar service, querying for offenses that were updated in QRadar later than
        the last update time given in the argument 'lastUpdate'.
        Args:
            client (Client): QRadar client to perform the API calls.
            params (Dict): Demisto params.
            args (Dict): Demisto arguments.

        Returns:
            (GetModifiedRemoteDataResponse): IDs of the offenses that have been modified in QRadar.
        """
        ctx, ctx_version = get_integration_context_with_version()
        remote_args = GetModifiedRemoteDataArgs(args)

        highest_fetched_id = ctx.get(LAST_FETCH_KEY, 0)
        limit: int = int(params.get('mirror_limit', MAXIMUM_MIRROR_LIMIT))
        fetch_mode = params.get('fetch_mode', '')
        range_ = f'items=0-{limit - 1}'
        last_update_modified = ctx.get(LAST_MIRROR_KEY, 0)
        if not last_update_modified:
            # This is the first mirror. We get the last update of the latest incident with a window of 5 minutes
            last_update = dateparser.parse(remote_args.last_update)
            if not last_update:
                last_update = datetime.now()
            last_update -= timedelta(minutes=5)
            last_update_modified = int(last_update.timestamp() * 1000)
        last_update_closed = ctx.get(LAST_MIRROR_CLOSED_KEY, last_update_modified)
        assert isinstance(last_update_modified, int)
        assert isinstance(last_update_closed, int)
        filter_modified = f'id <= {highest_fetched_id} AND status!=closed AND last_persisted_time > {last_update_modified}'
        filter_closed = f'id <= {highest_fetched_id} AND status=closed AND close_time > {last_update_closed}'
        print_debug_msg(f'Filter to get modified offenses is: {filter_modified}')
        print_debug_msg(f'Filter to get closed offenses is: {filter_closed}')
        # if this call fails, raise an error and stop command execution
        offenses_modified = client.offenses_list(range_=range_,
                                                 filter_=filter_modified,
                                                 sort='+last_persisted_time',
                                                 fields=FIELDS_MIRRORING)
        offenses_closed = client.offenses_list(range_=range_,
                                               filter_=filter_closed,
                                               sort='+close_time',
                                               fields=FIELDS_MIRRORING)
        if offenses_modified:
            last_update_modified = int(offenses_modified[-1].get('last_persisted_time'))
        if offenses_closed:
            last_update_closed = int(offenses_closed[-1].get('close_time'))
        new_modified_records_ids = {str(offense.get('id')) for offense in offenses_modified + offenses_closed if 'id' in offense}
        print_debug_msg(f'Last update modified: {last_update_modified}, Last update closed: {last_update_closed}')
        events_columns = params.get('events_columns') or DEFAULT_EVENTS_COLUMNS
        events_limit = int(params.get('events_limit') or DEFAULT_EVENTS_LIMIT)

        new_modified_records_ids = add_modified_remote_offenses(client=client, context_data=ctx, version=ctx_version,
                                                                mirror_options=params.get('mirror_options', ''),
                                                                new_modified_records_ids=new_modified_records_ids,
                                                                new_last_update_modified=last_update_modified,
                                                                new_last_update_closed=last_update_closed,
                                                                events_columns=events_columns,
                                                                events_limit=events_limit,
                                                                fetch_mode=fetch_mode,
                                                                )

        return GetModifiedRemoteDataResponse(list(new_modified_records_ids))


    def qradar_search_retrieve_events_command(
        client: Client,
        params,
        args,
    ) -> CommandResults:  # pragma: no cover (tested in test-playbook)
        """A polling command to get events from QRadar offense

        Args:
            client (Client): The QRadar client to use.
            params (dict): Parameters passed to the command.
            args (dict): Demisto arguments.

        Raises:
            DemistoException: If the search failed.

        Returns:
            CommandResults: The results of the command.
        """
        interval_in_secs = int(args.get('interval_in_seconds', 30))
        search_id = args.get('search_id')
        is_polling = argToBoolean(args.get('polling', True))
        timeout_in_secs = int(args.get('timeout_in_seconds', 600))
        search_command_results = None
        if not search_id:
            search_command_results = qradar_search_create_command(client, params, args)
            search_id = search_command_results.outputs[0].get('ID')  # type: ignore
        calling_context = demisto.callingContext.get('context', {})
        sm = get_schedule_metadata(context=calling_context)
        end_date: datetime | None = dateparser.parse(sm.get('end_date'))
        if not end_date or end_date.year == 1:
            end_date = None
        # determine if this is the last run of the polling command
        is_last_run = (datetime.now() + timedelta(seconds=interval_in_secs)).timestamp() >= end_date.timestamp() \
            if end_date else False
        try:
            events, status = poll_offense_events(client, search_id, should_get_events=True, offense_id=args.get('offense_id'))
        except (DemistoException, requests.Timeout) as e:
            if is_last_run:
                raise e
            print_debug_msg(f"Polling event failed due to {e}. Will try to poll again in the next interval.")
            events = []
            status = QueryStatus.WAIT.value
        if is_last_run and status == QueryStatus.WAIT.value:
            print_debug_msg("Its the last run of the polling, will cancel the query request. ")
            client.search_cancel(search_id=search_id)
            return CommandResults(
                readable_output='Got polling timeout. Quary got cancelled.',
            )
        if is_last_run and args.get('success') and not events:
            # if last run, we want to get the events that were fetched in the previous calls
            return CommandResults(
                readable_output='Not all events were fetched. partial data is available.',
            )

        if status == QueryStatus.ERROR.value:
            raise DemistoException('Polling for events failed')
        if status == QueryStatus.SUCCESS.value:
            # return the result only if the all events were retrieved, unless for the last call for this function
            offense_id = args.get('offense_id', '')
            events_limit = int(args.get('events_limit', params.get('events_limit')))
            fetch_mode: FetchMode = args.get('fetch_mode', params.get('fetch_mode'))
            if argToBoolean(args.get('retry_if_not_all_fetched', False)) and  \
                not is_last_run and not \
                    is_all_events_fetched(client, fetch_mode, offense_id, events_limit, events):
                # return scheduled command result without search id to search again
                polling_args = {
                    'interval_in_seconds': interval_in_secs,
                    'timeout_in_seconds': timeout_in_secs,
                    'success': True,
                    **args
                }
                scheduled_command = ScheduledCommand(
                    command='qradar-search-retrieve-events',
                    next_run_in_seconds=interval_in_secs,
                    args=polling_args,
                    timeout_in_seconds=timeout_in_secs
                )
                return CommandResults(scheduled_command=scheduled_command if is_polling else None,
                                      readable_output='Not all events were fetched. Searching again.',
                                      outputs_prefix='QRadar.SearchEvents',
                                      outputs_key_field='ID',
                                      outputs={'Events': events, 'ID': search_id, 'Status': QueryStatus.PARTIAL},
                                      )

            return CommandResults(
                outputs_prefix='QRadar.SearchEvents',
                outputs_key_field='ID',
                outputs={'Events': events, 'ID': search_id, 'Status': QueryStatus.SUCCESS},
                readable_output=tableToMarkdown(f'{get_num_events(events)} Events returned from search_id {search_id}',
                                                events,
                                                ),
            )

        print_debug_msg(f'Still polling for search results for search ID: {search_id}.')
        polling_args = {
            'search_id': search_id,
            'interval_in_seconds': interval_in_secs,
            'timeout_in_seconds': timeout_in_secs,
            **args
        }
        scheduled_command = ScheduledCommand(
            command='qradar-search-retrieve-events',
            next_run_in_seconds=interval_in_secs,
            timeout_in_seconds=timeout_in_secs,
            args=polling_args,
        )
        outputs = {'ID': search_id, 'Status': QueryStatus.WAIT}
        return CommandResults(scheduled_command=scheduled_command if is_polling else None,
                              readable_output=f'Search ID: {search_id}',
                              outputs_prefix='QRadar.SearchEvents',
                              outputs_key_field='ID',
                              outputs=outputs,
                              )


    def qradar_remote_network_cidr_create_command(client: Client, args) -> CommandResults:
        """Create remote network cidrs
        Args:
            client (Client): The QRadar client to use.
            args (dict): Demisto arguments.

        Raises:
            DemistoException: If the args are not valid.

        Returns:
            CommandResults.
        """
        cidrs_list = argToList(args.get('cidrs'))
        cidrs_from_query = get_cidrs_indicators(args.get('query'))
        name = args.get('name')
        description = args.get('description')
        group = args.get('group')
        fields = args.get('fields')

        error_message = verify_args_for_remote_network_cidr(cidrs_list, cidrs_from_query, name, group, fields)
        if error_message:
            raise DemistoException(error_message)

        body = {
            "name": name,
            "description": description,
            "cidrs": cidrs_list or cidrs_from_query,
            "group": group
        }

        response = client.create_and_update_remote_network_cidr(body, fields)
        success_message = 'The new staged remote network was successfully created.'

        return CommandResults(
            raw_response=response,
            readable_output=tableToMarkdown(success_message, response)
        )


    def qradar_remote_network_cidr_list_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Args:
        client (Client): The QRadar client to use.
        args (dict): Demisto arguments.

        Raises:
            DemistoException: If given both filter and group, id or name arguments.

        Returns:
            CommandResults.

        """
        limit = arg_to_number(args.get('limit'))
        page = arg_to_number(args.get('page'))
        page_size = arg_to_number(args.get('page_size'))
        group = args.get('group')
        id_ = args.get('id')
        name = args.get('name')
        filter_ = args.get('filter', '')
        fields = args.get('fields')

        error_message = verify_args_for_remote_network_cidr_list(limit, page, page_size, filter_, group, id_, name)
        if error_message:
            raise DemistoException(error_message)

        if page and page_size:
            first_item = (int(page) - 1) * int(page_size)
            last_item = int(page) * int(page_size) - 1
            range_ = f'items={first_item}-{last_item}'
        else:
            range_ = f'items=0-{str(limit - 1) if limit else str(DEFAULT_LIMIT_VALUE - 1)}'

        if not filter_:
            if group:
                filter_ += f'group="{group}"'
            if id_:
                filter_ += f' AND id={id_}' if group else f'id={id_}'
            if name:
                filter_ += f' AND name="{name}"' if (group or id_) else f'name="{name}"'

        response = client.get_remote_network_cidr(range_, filter_, fields)
        outputs = [{'id': res.get('id'),
                    'name': res.get('name'),
                    'description': res.get('description')}
                   for res in response]
        headers = ['id', 'name', 'group', 'cidrs', 'description']
        success_message = 'List of the staged remote networks'
        if response:
            readable_output = tableToMarkdown(success_message, response, headers=headers)
            readable_output += f"Above results are with page number: {page} and with size: {page_size}." if page and page_size \
                else f"Above results are with limit: {limit if limit else DEFAULT_LIMIT_VALUE}."
        else:
            readable_output = 'No results found.'

        return CommandResults(
            outputs_prefix='QRadar.RemoteNetworkCIDR',
            outputs_key_field='id',
            outputs=outputs,
            raw_response=response,
            readable_output=readable_output
        )


    def qradar_remote_network_cidr_delete_command(client: Client, args) -> CommandResults:
        """
        Args:
        client (Client): The QRadar client to use.
        args (dict): Demisto arguments.

        Returns:
        Two CommandResults objects, one for the success and one for the failure.
        """
        ids = argToList(args.get('id'))
        success_delete_ids = []
        unsuccessful_delete_ids = []

        for id_ in ids:
            try:
                client.delete_remote_network_cidr(id_)
                success_delete_ids.append(id_)
            except DemistoException as e:
                unsuccessful_delete_ids.append(assign_params(ID=id_, Error=e.message))

        success_human_readable = tableToMarkdown('Successfully deleted the following remote network(s)',
                                                 success_delete_ids, headers=['ID'])
        unsuccessful_human_readable = tableToMarkdown('Failed to delete the following remote network(s)',
                                                      unsuccessful_delete_ids, headers=['ID', 'Error'])

        return CommandResults(
            readable_output=((success_human_readable if success_delete_ids else '')
                             + (unsuccessful_human_readable if unsuccessful_delete_ids else ''))
        )


    def qradar_remote_network_cidr_update_command(client: Client, args):
        """
        Args:
        client (Client): The QRadar client to use.
        args (dict): Demisto arguments.

        Raises:
            DemistoException: If the args are not valid.

        Returns:
        CommandResults.
        """
        id_ = arg_to_number(args.get('id'))
        name = args.get('name')
        cidrs_list = argToList(args.get('cidrs'))
        cidrs_from_query = get_cidrs_indicators(args.get('query'))
        description = args.get('description')
        group = args.get('group')
        fields = args.get('fields')

        error_message = verify_args_for_remote_network_cidr(cidrs_list, cidrs_from_query, name, group, fields)
        if error_message:
            raise DemistoException(error_message)

        body = {
            "name": name,
            "description": description,
            "cidrs": cidrs_list or cidrs_from_query,
            "id": id_,
            "group": group
        }

        response = client.create_and_update_remote_network_cidr(body, fields, update=True)
        success_message = 'The staged remote network was successfully updated'
        outputs = {'id': response.get('id'),
                   'name': response.get('name'),
                   'group': response.get('group'),
                   'description': response.get('description')}

        return CommandResults(
            outputs_prefix='QRadar.RemoteNetworkCIDR',
            outputs_key_field='id',
            outputs=outputs,
            readable_output=tableToMarkdown(success_message, response),
            raw_response=response
        )


    def qradar_remote_network_deploy_execution_command(client: Client, args):
        """
        Args:
        client (Client): The QRadar client to use.
        args (dict): Demisto arguments.

        Returns:
        CommandResults.
        """
        host_ip = args.get('host_ip')
        status = args.get('status', 'INITIATING')
        deployment_type = args.get('deployment_type')

        if not re.match(ipv4Regex, host_ip) and not re.match(ipv6Regex, host_ip):
            raise DemistoException('The host_ip argument is not a valid ip address.')
        if not status == 'INITIATING':
            raise DemistoException('The status argument must be INITIATING.')
        if deployment_type not in ['INCREMENTAL', 'FULL']:
            raise DemistoException('The deployment_type argument must be INCREMENTAL or FULL.')

        body = {"hosts": [{"ip": host_ip, "status": status}], "type": deployment_type}

        response = client.remote_network_deploy_execution(body)
        success_message = 'The remote network deploy execution was successfully created.'

        return CommandResults(
            outputs_prefix='QRadar.deploy',
            outputs={'status': response['status']},
            readable_output=success_message,
            raw_response=response
        )


    def qradar_event_collectors_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of event collectors from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, '/config/event_sources/event_collectors', filter_, fields)
        outputs = sanitize_outputs(response, EVENT_COLLECTOR_RAW_FORMATTED)
        headers = build_headers(['ID'], set(EVENT_COLLECTOR_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Event Collectors List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.EventCollector',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_wincollect_destinations_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of WinCollect destinations from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/wincollect/wincollect_destinations'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, WINCOLLECT_DESTINATION_RAW_FORMATTED)
        headers = build_headers(['ID'], set(WINCOLLECT_DESTINATION_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('WinCollect Destinations List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.WinCollectDestination',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_disconnected_log_collectors_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of disconnected log collectors from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/disconnected_log_collectors'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, DISCONNECTED_LOG_COLLECTOR_RAW_FORMATTED)
        headers = build_headers(['ID'], set(DISCONNECTED_LOG_COLLECTOR_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Disconnected Log Collectors List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.DisconnectedLogCollector',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_types_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log source types from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/log_source_management/log_source_types'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, LOG_SOURCE_TYPES_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name', 'Custom', 'Version', 'UUID', 'SupportedLanguageIDs'], set())

        return CommandResults(
            readable_output=tableToMarkdown('Log Source Types List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSourceTypesList',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_protocol_types_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log source types from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/log_source_management/protocol_types'
        id = args.get('id')
        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, LOG_SOURCE_PROTOCOL_TYPE_RAW_FORMATTED)
        headers = ['ID', 'Name', 'CanCollectEvents', 'Testable', 'CanAcceptSampleEvents']
        readable_outputs = ([{
            **protocol_type,
            'CanCollectEvents': protocol_type['TestingCapabilities']['can_collect_events'],
            'Testable': protocol_type['TestingCapabilities']['testable'],
            'CanAcceptSampleEvents': protocol_type['TestingCapabilities']['can_accept_sample_events'],
        } for protocol_type in outputs])

        return CommandResults(
            readable_output=tableToMarkdown('Log Source Protocol Types', readable_outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSourceProtocolType',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_extensions_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log source types from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/log_source_management/log_source_extensions'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, LOG_SOURCE_EXTENSION_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name', 'Description', 'UUID'], set())

        return CommandResults(
            readable_output=tableToMarkdown('Log Source Extensions List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSourceExtension',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_languages_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log source types from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/log_source_management/log_source_languages'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, LOG_SOURCE_LANGUAGE_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name'], set())

        return CommandResults(
            readable_output=tableToMarkdown('Log Source Languages List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSourceLanguage',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_groups_list_command(client: Client, args: dict) -> CommandResults:
        """
        Retrieves a list of log source types from QRadar service.
        possible arguments:
        - range: Range of offenses to return (e.g.: 0-20, 3-5, 3-3).
        - filter: Query filter to filter results returned by QRadar service. see
                  https://www.ibm.com/support/knowledgecenter/SS42VS_SHR/com.ibm.qradarapi.doc/c_rest_api_filtering.html
                  for more details.
        - fields: Use this parameter to specify which fields you would like to get back in the response.
                  Fields that are not named are excluded.
                  Specify subfields in brackets and multiple fields in the same object are separated by commas.
        - id: If used, will fetch only the specified log source.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.

        Returns:
            CommandResults.
        """
        range_ = f"items={args.get('range', DEFAULT_RANGE_VALUE)}"
        filter_ = args.get('filter')
        fields = args.get('fields')
        endpoint = '/config/event_sources/log_source_management/log_source_groups'
        id = args.get('id')

        # if this call fails, raise an error and stop command execution
        response = client.get_resource(id, range_, endpoint, filter_, fields)
        outputs = sanitize_outputs(response, LOG_SOURCE_GROUP_RAW_FORMATTED)
        headers = build_headers(['ID', 'Name'], set(LOG_SOURCE_GROUP_RAW_FORMATTED.values()))

        return CommandResults(
            readable_output=tableToMarkdown('Log Source Groups List', outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSourceGroup',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_delete_command(client: Client, args: dict) -> CommandResults:
        """
        Deletes a log source by id or by name.
        Possible arguments:
        - name: The unique name of the log source to be deleted. If you don't provide this argument, id is required.
        - id: The ID of the log source to be deleted. If you don't provide this argument, name is required.
        Args:
            client (Client): QRadar client to perform the API call.
            args (Dict): Demisto args.
        Returns:
            CommandResults.
        """
        name = args.get('name')
        id = args.get('id')

        if id is not None:
            try:
                client.delete_log_source(id)
                return CommandResults(
                    readable_output=f'Log source {id} was deleted successfully'
                )
            except DemistoException as e:
                if e.res.status_code == 404:
                    return CommandResults(
                        readable_output=f'Log source with id {id} does not exist'
                    )
        if name is not None:
            log_source_list = client.get_resource_list(
                'items=0-0',
                'config/event_sources/log_source_management/log_sources',
                f'name="{name}"'
            )
            if not log_source_list:
                return CommandResults(
                    readable_output=f'Log source with name {name} does not exist'
                )
            relevant_log_source = log_source_list[0]
            client.delete_log_source(relevant_log_source.get('id'))
            return CommandResults(
                readable_output=f'Log source {name} was deleted successfully'
            )
        raise Exception('At least one of the arguments: name, id must be provided.')


    def qradar_log_source_create_command(client: Client, args: dict) -> CommandResults:
        """
        Creates a log source.
        Possible arguments:
        - name: Required. The unique name of the log source.
        - sending_ip: The ip of the system which the log source is associated to, or fed by.
        - protocol_type_id: Required. The type of protocol that is used by the log source.
        - type_id: Required. The type of the log source. Must correspond to an existing log source type.
          Must correspond to an existing protocol type.
        - protocol_parameters: Required. The list of protocol parameters corresponding with the selected protocol type id. The syntax
          for this argument should follow: protocol_parameters="name_1=value_1,name_2=value_2,...,name_n=value_n" where each name
          should correspond to a name of a protocol parameter from the protocol type and each value should fit the type of the
          protocol parameter.
        - descrption: The description of the log source
        - coalesce_events: Determines if events collected by this log source are coalesced based on common properties.
          If each individual event is stored, then the condition is set to false. Defaults to true.
        - enabled: Determines if the log source is enabled. Defaults to true.
        - parsing_order: The order in which log sources will parse if multiple exists with a common identifier.
        - group_ids: Required. The set of log source group IDs this log source is a member of.
          Each ID must correspond to an existing log source group.
        - credibility: On a scale of 0-10, the amount of credibility that the QRadar administrator places on this log source
        - store_event_payload: If the payloads of events that are collected by this log source are stored, the condition is set to
          'true'. If only the normalized event records are stored, then the condition is set to 'false'.
        - target_event_collector_id:  Required. The ID of the event collector where the log source sends its data.
          The ID must correspond to an existing event collector.
        - disconnected_log_collector_id:  The ID of the disconnected log collector where this log source will run.
          The ID must correspond to an existing disconnected log collector.
        - language_id: The language of the events that are being processed by this log source.
          Must correspond to an existing log source language.
        - requires_deploy: Set to 'true' if you need to deploy changes to enable the log source for use;
          otherwise, set to 'false' if the log source is already active.
        - wincollect_internal_destination_id : The internal WinCollect destination for this log source, if applicable.
          Log sources without an associated WinCollect agent have a null value. Must correspond to an existing WinCollect destination.
        - wincollect_external_destination_ids: The set of external WinCollect destinations for this log source, if applicable.
          Log Sources without an associated WinCollect agent have a null value.
          Each ID must correspond to an existing WinCollect destination.
        - gateway: If the log source is configured as a gateway, the condition is set to 'true';
          otherwise, the condition is set to 'false'. A gateway log source is a stand-alone protocol configuration.
          The log source receives no events itself, and serves as a host for a protocol configuration that retrieves event data to
          feed other log sources. It acts as a "gateway" for events from multiple systems to enter the event pipeline.
        """
        log_source = parse_log_source(args)
        response = client.create_log_source(log_source)
        outputs = sanitize_outputs(response, LOG_SOURCES_RAW_FORMATTED)[0]
        headers = build_headers(['ID', 'Name', 'Description'], set(LOG_SOURCES_RAW_FORMATTED.values()))
        readable_outputs = {
            'ID': outputs['ID'],
            'Name': outputs['Name'],
            'CreationDate': outputs['CreationDate'],
            'Description': outputs['Description'],
            'Enabled': outputs['Enabled'],
            'Status': outputs['Status']['status'],
            'StatusLastUpdated': outputs['Status'].get('last_updated', ''),
            'StatusMessages': outputs['Status'].get('messages', ''),
        }
        return CommandResults(
            readable_output=tableToMarkdown('Log Source Created', readable_outputs, headers, removeNull=True),
            outputs_prefix='QRadar.LogSource',
            outputs_key_field='ID',
            outputs=outputs,
            raw_response=response
        )


    def qradar_log_source_update_command(client: Client, args: dict) -> CommandResults:
        """
        Creates a log source.
        Possible arguments:
        - id: Required. The id of the log source.
        - name: The unique name of the log source.
        - sending_ip: The ip of the system which the log source is associated to, or fed by.
        - protocol_type_id: The type of protocol that is used by the log source.
        - type_id: The type of the log source. Must correspond to an existing log source type.
          Must correspond to an existing protocol type.
        - protocol_parameters: The list of protocol parameters corresponding with the selected protocol type id. The syntax
          for this argument should follow: protocol_parameters="name_1=value_1,name_2=value_2,...,name_n=value_n" where each name
          should correspond to a name of a protocol parameter from the protocol type and each value should fit the type of the
          protocol parameter.
        - descrption: The description of the log source
        - coalesce_events: Determines if events collected by this log source are coalesced based on common properties.
          If each individual event is stored, then the condition is set to false. Defaults to true.
        - enabled: Determines if the log source is enabled. Defaults to true.
        - parsing_order: The order in which log sources will parse if multiple exists with a common identifier.
        - group_ids: The set of log source group IDs this log source is a member of.
          Each ID must correspond to an existing log source group.
        - credibility: On a scale of 0-10, the amount of credibility that the QRadar administrator places on this log source
        - store_event_payload: If the payloads of events that are collected by this log source are stored, the condition is set to
          'true'. If only the normalized event records are stored, then the condition is set to 'false'.
        - target_event_collector_id:  The ID of the event collector where the log source sends its data.
          The ID must correspond to an existing event collector.
        - disconnected_log_collector_id:  The ID of the disconnected log collector where this log source will run.
          The ID must correspond to an existing disconnected log collector.
        - language_id: The language of the events that are being processed by this log source.
          Must correspond to an existing log source language.
        - requires_deploy: Set to 'true' if you need to deploy changes to enable the log source for use;
          otherwise, set to 'false' if the log source is already active.
        - wincollect_internal_destination_id : The internal WinCollect destination for this log source, if applicable.
          Log sources without an associated WinCollect agent have a null value. Must correspond to an existing WinCollect destination.
        - wincollect_external_destination_ids: The set of external WinCollect destinations for this log source, if applicable.
          Log Sources without an associated WinCollect agent have a null value.
          Each ID must correspond to an existing WinCollect destination.
        - gateway: If the log source is configured as a gateway, the condition is set to 'true';
          otherwise, the condition is set to 'false'. A gateway log source is a stand-alone protocol configuration.
          The log source receives no events itself, and serves as a host for a protocol configuration that retrieves event data to
          feed other log sources. It acts as a "gateway" for events from multiple systems to enter the event pipeline.
        """
        id = args.get('id')
        log_source = parse_partial_log_source(args)
        client.update_log_source(log_source)
        return CommandResults(readable_output=f'Log source {id} was updated successfully')


    def migrate_integration_ctx(ctx: dict) -> dict:
        """Migrates the old context to the current context

        Args:
            ctx: The context_data to simplify

        Returns: The cleared context_data
        """
        fetch_id_ctx: str = ctx.get(LAST_FETCH_KEY, '0')
        try:
            fetch_id = int(fetch_id_ctx)
        except ValueError:
            try:
                fetch_id = int(json.loads(fetch_id_ctx))
            except ValueError:
                print_debug_msg(f"Could not retrieve LAST_FETCH_KEY from {fetch_id_ctx} Setting to 0")
                fetch_id = 0

        last_update_ctx: str = ctx.get(LAST_MIRROR_KEY, '0')
        try:
            last_update = int(last_update_ctx)
        except ValueError:
            try:
                last_update = int(json.loads(last_update_ctx))
            except ValueError:
                print_debug_msg(f"Could not retrieve last_mirror_update from {last_update_ctx} Setting to 0")
                last_update = 0

        mirrored_offenses: dict[str, str] = {}
        try:
            for key in ('mirrored_offenses', 'updated_mirrored_offenses', 'resubmitted_mirrored_offenses'):
                mirrored_offenses |= {json.loads(offense).get(
                    'id'): QueryStatus.WAIT.value for offense in json.loads(ctx.get(key, '[]'))}
        except Exception as e:
            print_debug_msg(f'Could not load mirrored_offenses from context_data. Error: {e}')

        return {LAST_FETCH_KEY: fetch_id,
                LAST_MIRROR_KEY: last_update,
                MIRRORED_OFFENSES_QUERIED_CTX_KEY: mirrored_offenses,
                MIRRORED_OFFENSES_FINISHED_CTX_KEY: {},
                MIRRORED_OFFENSES_FETCHED_CTX_KEY: {},
                'samples': []}


    def validate_integration_context() -> None:
        """
        The new context structure consists two dictionaries of queried offenses and finished offenses.
        The structure consists the actual objects and JSON of them.

        Because some customers already have instances with the old context, we will try to convert the old context to the new one.
        to make them be compatible with new changes.
        Returns:
            (None): Modifies context to be compatible.
        """
        context_data, context_version = get_integration_context_with_version()
        new_ctx = context_data.copy()
        try:
            print_context_data_stats(context_data, "Checking ctx")
            print_debug_msg("Context is with the new mirroring standard")
            extract_works = True
        except Exception as e:
            print_debug_msg(f"Checking {context_data} failed, trying to make it retry compatible. Error was: {str(e)}")
            extract_works = False

        if not extract_works:
            cleared_ctx = migrate_integration_ctx(new_ctx)
            print_debug_msg(f"Change ctx context data was cleared and changing to {cleared_ctx}")
            safely_update_context_data(cleared_ctx, context_version, should_force_update=True)
            print_debug_msg(f"Change ctx context data was cleared and changed to {cleared_ctx}")
        elif MIRRORED_OFFENSES_FETCHED_CTX_KEY not in context_data:
            print_debug_msg(f"Adding {MIRRORED_OFFENSES_FETCHED_CTX_KEY} to context")
            new_ctx[MIRRORED_OFFENSES_FETCHED_CTX_KEY] = {}
            safely_update_context_data(new_ctx, context_version, should_force_update=True)


    ''' MAIN FUNCTION '''


    def main() -> None:  # pragma: no cover
        params = demisto.params()
        command = demisto.command()
        args = demisto.args()

        # handle allowed advanced parameters
        adv_params = params.get('adv_params')
        if adv_params:
            try:
                globals_ = globals()
                for adv_p in adv_params.split(','):
                    adv_p_kv = [item.strip() for item in adv_p.split('=')]
                    if len(adv_p_kv) != 2:
                        raise DemistoException(
                            f'Failed to parse advanced parameter: {adv_p} - please make sure you entered it correctly.')
                    adv_param_name = adv_p_kv[0]
                    if adv_param_name in ADVANCED_PARAMETERS_STRING_NAMES:
                        globals_[adv_p_kv[0]] = adv_p_kv[1]
                    elif adv_param_name in ADVANCED_PARAMETER_INT_NAMES:
                        globals_[adv_p_kv[0]] = int(adv_p_kv[1])
                    else:
                        raise DemistoException(
                            f'The parameter: {adv_p_kv[0]} is not a valid advanced parameter. Please remove it')
            except DemistoException as e:
                raise DemistoException(
                    f'Failed to parse advanced params. Error: {e.message}'
                ) from e
            except Exception as e:
                raise DemistoException(f'Failed to parse advanced params. Error: {e}') from e

        server = params.get('server')
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        api_version = params.get('api_version')
        if api_version and float(api_version) < MINIMUM_API_VERSION:
            raise DemistoException(f'API version cannot be lower than {MINIMUM_API_VERSION}')
        credentials = params.get('credentials')
        timeout = arg_to_number(params.get("timeout"))

        try:

            client = Client(
                server=server,
                verify=verify_certificate,
                proxy=proxy,
                api_version=api_version,
                credentials=credentials,
                timeout=timeout
            )
            # All command names with or are for supporting QRadar v2 command names for backward compatibility
            if command == 'test-module':
                validate_integration_context()
                return_results(test_module_command(client, params))

            elif command == 'fetch-incidents':
                demisto.incidents(fetch_incidents_command())

            elif command == 'long-running-execution':
                validate_integration_context()
                support_multithreading()
                long_running_execution_command(client, params)

            elif command in [
                'qradar-offenses-list',
                'qradar-offenses',
                'qradar-offense-by-id',
            ]:
                return_results(qradar_offenses_list_command(client, args))

            elif command in ['qradar-offense-update', 'qradar-update-offense']:
                return_results(qradar_offense_update_command(client, args))

            elif command in ['qradar-closing-reasons', 'qradar-get-closing-reasons']:
                return_results(qradar_closing_reasons_list_command(client, args))

            elif command in ['qradar-offense-notes-list', 'qradar-get-note']:
                return_results(qradar_offense_notes_list_command(client, args))

            elif command in ['qradar-offense-note-create', 'qradar-create-note']:
                return_results(qradar_offense_notes_create_command(client, args))

            elif command == 'qradar-rules-list':
                return_results(qradar_rules_list_command(client, args))

            elif command == 'qradar-rule-groups-list':
                return_results(qradar_rule_groups_list_command(client, args))

            elif command in [
                'qradar-assets-list',
                'qradar-get-assets',
                'qradar-get-asset-by-id',
            ]:
                return_results(qradar_assets_list_command(client, args))

            elif command == 'qradar-saved-searches-list':
                return_results(qradar_saved_searches_list_command(client, args))

            elif command == 'qradar-searches-list':
                return_results(qradar_searches_list_command(client, args))

            elif command in ['qradar-search-create', 'qradar-searches']:
                return_results(qradar_search_create_command(client, params, args))

            elif command in ['qradar-search-status-get', 'qradar-get-search']:
                return_results(qradar_search_status_get_command(client, args))

            elif command in [
                'qradar-search-results-get',
                'qradar-get-search-results',
            ]:
                return_results(qradar_search_results_get_command(client, args))

            elif command == 'qradar-search-cancel':
                return_results(qradar_search_cancel_command(client, args))

            elif command == 'qradar-search-delete':
                return_results(qradar_search_delete_command(client, args))

            elif command in [
                'qradar-reference-sets-list',
                'qradar-get-reference-by-name',
            ]:
                return_results(qradar_reference_sets_list_command(client, args))

            elif command in [
                'qradar-reference-set-create',
                'qradar-create-reference-set',
            ]:
                return_results(qradar_reference_set_create_command(client, args))

            elif command in [
                'qradar-reference-set-delete',
                'qradar-delete-reference-set',
            ]:
                return_results(qradar_reference_set_delete_command(client, args))

            elif command in [
                'qradar-reference-set-value-upsert',
                'qradar-create-reference-set-value',
                'qradar-update-reference-set-value',
            ]:
                return_results(qradar_reference_set_value_upsert_command(args, client, params))

            elif command in [
                'qradar-reference-set-value-delete',
                'qradar-delete-reference-set-value',
            ]:
                return_results(qradar_reference_set_value_delete_command(client, args))

            elif command in [
                'qradar-domains-list',
                'qradar-get-domains',
                'qradar-get-domain-by-id',
            ]:
                return_results(qradar_domains_list_command(client, args))

            elif command in ['qradar-indicators-upload', 'qradar-upload-indicators']:
                return_results(qradar_indicators_upload_command(args, client, params))

            elif command == 'qradar-geolocations-for-ip':
                return_results(qradar_geolocations_for_ip_command(client, args))

            elif command == 'qradar-log-sources-list':
                return_results(qradar_log_sources_list_command(client, args))

            elif command == 'qradar-get-custom-properties':
                return_results(qradar_get_custom_properties_command(client, args))

            elif command == 'qradar-ips-source-get':
                return_results(qradar_ips_source_get_command(client, args))

            elif command == 'qradar-ips-local-destination-get':
                return_results(qradar_ips_local_destination_get_command(client, args))

            elif command == 'qradar-reset-last-run':
                return_results(qradar_reset_last_run_command())

            elif command == 'get-mapping-fields':
                return_results(qradar_get_mapping_fields_command(client))

            elif command == 'get-remote-data':
                validate_integration_context()
                return_results(get_remote_data_command(client, params, args))

            elif command == 'get-modified-remote-data':
                validate_integration_context()
                return_results(get_modified_remote_data_command(client, params, args))

            elif command == 'qradar-search-retrieve-events':
                return_results(qradar_search_retrieve_events_command(client, params, args))

            elif command == 'qradar-remote-network-cidr-create':
                return_results(qradar_remote_network_cidr_create_command(client, args))

            elif command == 'qradar-remote-network-cidr-list':
                return_results(qradar_remote_network_cidr_list_command(client, args))

            elif command == 'qradar-remote-network-cidr-delete':
                return_results(qradar_remote_network_cidr_delete_command(client, args))

            elif command == 'qradar-remote-network-cidr-update':
                return_results(qradar_remote_network_cidr_update_command(client, args))

            elif command == 'qradar-remote-network-deploy-execution':
                return_results(qradar_remote_network_deploy_execution_command(client, args))

            elif command == 'qradar-event-collectors-list':
                return_results(qradar_event_collectors_list_command(client, args))

            elif command == 'qradar-wincollect-destinations-list':
                return_results(qradar_wincollect_destinations_list_command(client, args))

            elif command == 'qradar-disconnected-log-collectors-list':
                return_results(qradar_disconnected_log_collectors_list_command(client, args))

            elif command == 'qradar-log-source-types-list':
                return_results(qradar_log_source_types_list_command(client, args))

            elif command == 'qradar-log-source-protocol-types-list':
                return_results(qradar_log_source_protocol_types_list_command(client, args))

            elif command == 'qradar-log-source-extensions-list':
                return_results(qradar_log_source_extensions_list_command(client, args))

            elif command == 'qradar-log-source-languages-list':
                return_results(qradar_log_source_languages_list_command(client, args))

            elif command == 'qradar-log-source-groups-list':
                return_results(qradar_log_source_groups_list_command(client, args))

            elif command == 'qradar-log-source-delete':
                return_results(qradar_log_source_delete_command(client, args))

            elif command == 'qradar-log-source-create':
                return_results(qradar_log_source_create_command(client, args))

            elif command == 'qradar-log-source-update':
                return_results(qradar_log_source_update_command(client, args))

            else:
                raise NotImplementedError(f'''Command '{command}' is not implemented.''')

        except Exception as e:
            print_debug_msg(f"The integration context_data is {get_integration_context()}")
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{traceback.format_exc()}\nException is: {str(e)}')
        finally:
            #  CIAC-10628
            if command not in ("test-module", "fetch-incidents", "long-running-execution"):
                client._return_execution_metrics_results()
                client.execution_metrics.metrics = None


    ''' ENTRY POINT '''
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        register_signal_handler_profiling_dump(profiling_dump_rows_limit=PROFILING_DUMP_ROWS_LIMIT)
        main()

    register_module_line('QRadar v3', 'end', __line__())
  subtype: python3
  type: python
system: true
