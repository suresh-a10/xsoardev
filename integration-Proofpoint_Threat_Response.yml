beta: true
category: Network Security
commonfields:
  id: Proofpoint Threat Response
  version: -1
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: url
  required: true
  section: Connect
  type: 0
- display: ""
  displaypassword: API Key
  hiddenusername: true
  name: credentials
  required: false
  section: Connect
  type: 9
- display: API Key
  hidden: true
  name: apikey
  required: false
  section: Connect
  type: 4
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: The time range for the initial data fetch. If timeout errors occur,
    consider changing this value.
  defaultvalue: 12 hours
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  required: false
  section: Collect
  type: 0
- defaultvalue: "50"
  display: Fetch limit - maximum number of incidents per fetch
  name: fetch_limit
  required: false
  section: Collect
  type: 0
- additionalinfo: The time range between create_after and created_before that is sent
    to the API when fetching older incidents. If timeout errors occur, consider changing
    this value.
  defaultvalue: 6 hours
  display: Fetch delta - The delta time in each batch. e.g. 1 hour, 3 minutes.
  name: fetch_delta
  required: false
  section: Collect
  type: 0
- additionalinfo: |
    When fetch is enable you must provide this argument. Possible values are: new, open, assigned, closed or ignored.
  display: Fetch incident with specific states.
  name: states
  options:
  - new
  - open
  - assigned
  - closed
  - ignored
  required: false
  section: Collect
  type: 16
- advanced: true
  display: Fetch incidents with specific event sources. Can be a list of comma separated
    values.
  name: event_sources
  required: false
  section: Collect
  type: 0
- advanced: true
  display: Fetch incidents with specific 'Abuse Disposition' values. Can be a list
    of comma separated values.
  name: abuse_disposition
  required: false
  section: Collect
  type: 0
- additionalinfo: You can find this value by navigating to Sources -> JSON event source
    -> POST URL.
  advanced: true
  display: POST URL of the JSON alert source.
  name: post_url_id
  required: false
  section: Collect
  type: 0
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.0.16
    packID: ProofpointThreatResponse
    packName: Proofpoint Threat Response
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Use the Proofpoint Threat Response integration to orchestrate and automate
  incident response.
detaileddescription: "In order to create the API Key go to:\n\n  Settings -> API Key
  -> Add api key\n  \n  Note: This is a beta Integration, which lets you implement
  and test pre-release software. Since the integration is beta, it might contain bugs.
  Updates to the integration during the beta phase might include non-backward compatible
  features. We appreciate your feedback on the quality and usability of the integration
  to help us identify issues, fix them, and continually improve.\n  \n- The ***proofpoint-tr-ingest-alert***
  command requires some JSON format arguments. Please make sure the inputed JSONs
  have uniqe characters (such as `\"`) escaped before entering them (e.g. `\\\"`).\n-
  For more information regarding the JSON objects, please see Proofpoint TRAP documentation
  under \"JSON Alert Source 2.0\".\n- If the **fetch-incidents** result in timeout,
  please consider changing **fetch-delta** and **fetch-limit** parameters \nwhich
  will limit the api calls and the result.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/proofpoint-threat-response)"
display: Proofpoint Threat Response (Beta)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAACHtJREFUeAHtmHls1UUQxx8KyI1AiiCHpoIkRA0QowSiIRKJyB+igChqMJEoGiNi8IBIsEgUEoxBSRS8SBQFBbWGwwO8QhBNOAppidJCoVQoFChHC6XS+vludx/Lj0d9fbYEyk74vpmdmZ3Znd3f7pZYLFCoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQEOsQKOGOKnInJrSHn5ZLNYf3qIyFlsPfy/iUx/N0eTsrcDkXAzLqY8kl3rMRhR57uWxWJUDO/qn81EU8ix3Ock3OsWc9zL+hQL9h6cSo3EqnS6iPh0Z6xiNtyoWOwl+Az+ej/GzwCXkKrW5TqSYsx9xzPjpnwu+rm2culhgNmqsGxAvBMlMphN+xyxghprx2xk0B0fB3+AUOBddgeFqIH/Fkv8/wCfZ5KcF3goGSa6BumOTv2K5xUnkrmNfuVtYP/lXgDhxLE+g8ZJVFMcNZwutULUGynckYi732r7sqetW7MKOWgFWE3YGGIC8hiPkKCgFW9A97qXshH2Z9Z+GvhfySvwOII+1fm3hr6DLBopTDkrw+wP9eBDdhCrIy/hs8fwP46+79Rmg4osy0K3FpwJUAsXUuDNAS+Qltj2Xdl/k7/E5DDSPv9C9AKK5taAv4puFzxGgsSr3RvTPAW1SR1PRfyegGGiV82mvBpm0+9L3bbAdHAD54H30aaA58mL88uAaeyVyrvpiuxHUG11PslO6W+CFoNjdMz4nu9u56ficlI3BrUfe7PzwGQfaoP/V6RJx+nyEXxMgaov/qkR+Tof/Z/g1xs/cgbRNgZwd/UrFQV8iHbwYFDq7z9G/qaSWWtN3hW+PytiX4qtTI4b8jbPTHGl1OdIRV2NKmBP75/hqfIc830ov1iDFqi/qSeIylwx5D4kmgYeQPwVmIHAdmT1AV+SjbqCWFzD5LGxDsc30YhWg0xc4DH2G6yc7usdADN3rnr+OxYlgGJiKzSyY9X8K3Q3gEfTHpSNnHu0h4CbQAf0+L1YJuqlgDPp5oEI2uI589/VN8/z3oX8eKPdk/A46G23VQwu8xNPdZ3WbnI4+Oo6nA+VcAPza9UQ/UHrP/0N0g8GVoN4ovsAk151zl5+JSWW6AaFXATriZxZYeuTZ6NoDmsZWZPW6X+4APk10sYi7BkN7+u+y/sqt4vo03vPXkSnqQp9j0hNjU7XK/KahNwsM57qMXxfGiG6+i4U8B2VTeJ7NfYr2CON4+udRxbH2bNQ6Qb5wMWiftcDodP04akb/7V78m61hihfDnYquT1KcuClTPj1/9nvzqel4MUTgPgiMr5qwFVPJmbQOAhWpB0XQK1efqO68XyR79BV6nQT6GtJh/UEntaEdYJWRTv9k4n9ITevfGdG/Q1Gf0ZarSO+BFUayP4xzkWsTszfydaCr1RXAv7WyY8sQim3jWrjeHppjQiKmbGs94wl0rr/UGqvIH78vV1uT+E15gRmQCnMikqPItbG3Rvbj60g67uxw/6jR5KIFkb9ZYLhetlows2GIrU2ir94n+aqPqBloBXD9TzqMR2nEq5iObjwtsbUH5h1gc/vzUFf1VxyRxqq515RbNreIiEb229LVCfkLUKuAjKYtHdzjx/Sl+u1cEOz6U0fHnyNNwJ+E7I7ULzoWFVYQnQS690w8gmhzNAU+taChwoq0+GXAzyd9ItJG0IbwSXNz49Hi6WTQfayAyh3118PK5dZYtdmSyY1b/ZKbRCpZ0unkHiCmP9syfjexElko3VeQKP42/A/IQCV6wW6JOA1Fb4qG305s64AWWaTcA4x0+mcI/vrSRPlAp4n54uE1ka6JO30HijKCWPwzP1theWCP2lA3cLuR7A9JBiMqjqgA7GXMyeQ2HZL8MRssSd+4W8oLzOz18FhApCfA3cjvwEcBnU06wjJB9CuT2dFehC/VIJYeGQsQHwS3gqdpvwY3RLxPEPaDJVLg3wT7B4gPA/mPpz0bbojN9TGCCmIWqVqb+BcH89+ZWJ8FetnPgj8pb/JWEWspok6ERdLh3xifdxHHAuUeh98cxUHWEbMQpkcgbv+b4h8Iu6Uf0W4DbWzULvAOVq4z5r+iDzID8zcuyeP/1ysZ/XSbUX8Hn7C6AnQ6Dn3qTFU2RPv7bewqsDsS02iv8+1RGfty/N3R3oP85fJBn4PePVT8V7T+w6I0Gkdt9PPoQ1dD7RBq/Jsd+w94mlMH2f+LYqQioMt2eWj2kc5SI2wbPZs7zUY6neP46+RKB6+CSUDXyTmJOaRG7NpsdusD8BxwClSB3Wy5yegzbNRydBtoZ8E3o0M8g/agHwreAgXAHENw9fuTWFPg+krdY24/7WHgDbAT6EvRl6b/Z96G/zT4/ah0b4ri+ZGzAeazqJBBjQLrMVYAzaMIzEQ3wetzCN09YBbYAfzcebRnAF1R5m3BguXSP0tApztcn7RqJt0GmmXSOcI/x9o2oXPjX0HMuUDxdezvxqbTEdFwppxwTqiribi1In3BWXRqzmB+J0t/eutr6QmagO3gAPCJzRcnDehcpIdWd6AHyxGQD84oAm2ftHOvAXpcqaj5wBUGMU6J8usLzmYeacwhj7n0wlt+4sq/ExSBc5GOSeXW3PWgkr9ZWLgjfTykMEQKsxD+WJzOupgjPervbJqjTjHVT/nErwK6OkpAnVH8iGYk6+os6vkP5B/RuaRXARskaZfVltwuc7y2/S8Ufzd+xy+UcdXpONyjI9mgnGixMn7E3b2YbN8Lyc/NQ/eZ0GCptrtX92w3oC9fC6xL/2Ik3YW678X1WNoFtOiBQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgUuoQr8C4/kmRLXPZUVAAAAAElFTkSuQmCC
name: Proofpoint Threat Response
script:
  commands:
  - arguments:
    - description: The ID of the list.
      name: list-id
      required: true
    description: Gets items for the specified list.
    name: proofpoint-tr-get-list
  - arguments:
    - description: The list to add a member to.
      name: list-id
      required: true
    - description: 'A comma-separated list of indicator values. Can be IP addresses,
        URLs, domains, or file hashes. For example: "192.168.1.1,192.168.1.2".'
      isArray: true
      name: indicator
      required: true
    - description: A comment about the member.
      name: comment
    - description: The member expiration.
      name: expiration
    description: Adds a member to the specified list.
    execution: true
    name: proofpoint-tr-add-to-list
  - arguments:
    - description: A comma-separated list of IP addresses to add to block list.
      isArray: true
      name: ip
      required: true
    - description: 'The date and time the supplied IP addresses should be removed
        from the block list, in the format YYYY-MM-DDTHH:MM:SSZ. For example: 2020-02-02T19:00:00Z.'
      name: expiration
    - description: The ID of the IP block list.
      name: blacklist_ip
      required: true
    description: Adds the supplied IP addresses to the specified IP block list.
    execution: true
    name: proofpoint-tr-block-ip
  - arguments:
    - description: A comma-separated list of domains to add to the block list.
      isArray: true
      name: domain
      required: true
    - description: 'The date and time the supplied IP addresses should be removed
        from the block list, in the format YYYY-MM-DDTHH:MM:SSZ. For example: 2020-02-02T19:00:00Z.'
      name: expiration
    - description: The ID of the domain block list.
      name: blacklist_domain
      required: true
    description: Adds the supplied domains to the specified block list.
    name: proofpoint-tr-block-domain
  - arguments:
    - description: The ID of the list in which to search.
      name: list-id
      required: true
    - description: The filter for the indicator search. For example, "1.1" will return
        [1.1.1.1, 22.22.1.1, 1.1.22.22].
      name: filter
      required: true
    description: Returns indicators from the specified list, according to the defined
      filter.
    name: proofpoint-tr-search-indicator
  - arguments:
    - description: The ID of the list from which to delete indicators.
      name: list-id
      required: true
    - description: 'The indicator value to delete from the list. Can be an IP address,
        URL, domain, or file hash. For example: "demisto.com".'
      name: indicator
      required: true
    description: Deletes an indicator from the specified list.
    name: proofpoint-tr-delete-indicator
  - arguments:
    - description: A comma-separated list of URLs to add to the URL block list.
      isArray: true
      name: url
      required: true
    - description: 'The date and time the supplied URLs should be removed from the
        block list, in the format YYYY-MM-DDTHH:MM:SSZ. For example: 2020-02-02T19:00:00Z.'
      name: expiration
    - description: The ID of the URL block list.
      name: blacklist_url
      required: true
    description: Adds the supplied URLs to the specified URL block list.
    name: proofpoint-tr-block-url
  - arguments:
    - description: A comma-separated list of file hashes to add to the file hash block
        list.
      isArray: true
      name: hash
      required: true
    - description: 'The date and time the supplied file hashes should be removed from
        the block list, in the format YYYY-MM-DDTHH:MM:SSZ. For example: 2020-02-02T19:00:00Z.'
      name: expiration
    - description: The ID of the hash block list.
      name: blacklist_hash
      required: true
    description: Adds the supplied file hashes to the specified file hash block list.
    name: proofpoint-tr-block-hash
  - arguments:
    - auto: PREDEFINED
      description: The state of the incidents to retrieve.
      name: state
      predefined:
      - new
      - open
      - assigned
      - closed
      - ignored
    - description: 'Retrieve incidents that were created after this date, in ISO 8601
        format (UTC). Example: 2020-02-22 or 2020-02-22T00:00:00Z.'
      name: created_after
      predefined:
      - ""
    - description: 'Retrieve incidents that were created before this date, in ISO
        8601 format (UTC). Example: 2020-02-22 or 2020-02-22T00:00:00Z.'
      name: created_before
    - description: 'Retrieve incidents that were closed after this date, in ISO 8601
        format (UTC). Example: 2020-02-22 or 2020-02-22T00:00:00Z.'
      name: closed_after
    - description: 'Retrieve incidents that were closed before this date, in ISO 8601
        format (UTC). Example: 2020-02-22 or 2020-02-22T00:00:00Z.'
      name: closed_before
    - auto: PREDEFINED
      description: If false, will return an array of event IDs instead of full event
        objects. This will significantly speed up the response time of the API for
        incidents with large numbers of alerts.
      name: expand_events
      predefined:
      - "true"
      - "false"
    - defaultValue: "50"
      description: The maximum number of incidents to return.
      name: limit
      required: true
    description: Retrieves all incident metadata from Threat Response by specifying
      filter criteria such as the state of the incident or time of closure.
    name: proofpoint-tr-list-incidents
    outputs:
    - contextPath: ProofPointTRAP.Incident.id
      description: The incident ID.
      type: Number
    - contextPath: ProofPointTRAP.Incident.summary
      description: The summary of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.score
      description: The score of the incident from Proofpoint.
      type: Number
    - contextPath: ProofPointTRAP.Incident.state
      description: The state of the incident. Can be - Open, Closed, New, Assigned,
        Ignored.
      type: String
    - contextPath: ProofPointTRAP.Incident.created_at
      description: The date the incident was created.
      type: Date
    - contextPath: ProofPointTRAP.Incident.updated_at
      description: The date the incident was last updated.
      type: Date
    - contextPath: ProofPointTRAP.Incident.event_count
      description: The number of events attached to the incident.
      type: Number
    - contextPath: ProofPointTRAP.Incident.false_positive_count
      description: The number of false positive events in the incident.
      type: Number
    - contextPath: ProofPointTRAP.Incident.event_sources
      description: The sources of the events.
      type: String
    - contextPath: ProofPointTRAP.Incident.assignee
      description: The user assigned to the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.team
      description: The team assigned to the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.hosts.attacker
      description: The host attacker.
      type: String
    - contextPath: ProofPointTRAP.Incident.hosts.forensics
      description: The host forensics.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Severity
      description: The severity of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Abuse_disposition
      description: The abuse disposition of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Attack_vector
      description: The attack vector of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Classification
      description: The classification of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.id
      description: The event ID.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.category
      description: The event category.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.alertType
      description: The alert type of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.severity
      description: The severity of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.source
      description: The source of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.state
      description: The state of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.attackDirection
      description: The attack direction of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.received
      description: The time the incident was received.
      type: Date
    - contextPath: ProofPointTRAP.Incident.events.emails.sender
      description: The sender of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.recipient
      description: The recipient of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.message_Id
      description: The message ID of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.message_delivery_time
      description: The delivery time of the message.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.attackers.location
      description: The location of the attacker.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.falsePositive
      description: Whether this incident is a false positive.
      type: Boolean
    - contextPath: ProofPointTRAP.Incident.events.threatname
      description: The threat name.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.description
      description: The description of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.malwareName
      description: The malware name.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.alertSource
      description: The alert source.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.startTime
      description: The start time of the result.
      type: Date
    - contextPath: ProofPointTRAP.Incident.quarantine_results.endTime
      description: The end time of the result.
      type: Date
    - contextPath: ProofPointTRAP.Incident.quarantine_results.status
      description: The status of the result.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.recipientType
      description: The recipient type.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.recipient
      description: The recipient email address.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.messageId
      description: The message ID.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.isRead
      description: Whether the message has been read.
      type: Boolean
    - contextPath: ProofPointTRAP.Incident.quarantine_results.wasUndone
      description: Whether the message was undone.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.details
      description: The details about the result.
      type: String
    - contextPath: ProofPointTRAP.Incident.successful_quarantines
      description: The number of successful quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.failed_quarantines
      description: The number of failed quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.pending_quarantines
      description: The number of pending quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.emails.body
      description: The body of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.body_type
      description: The format of the body.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.headers
      description: The email headers.
      type: Unknown
    - contextPath: ProofPointTRAP.Incident.events.emails.urls
      description: The list of URLs from the email.
      type: Unknown
    - contextPath: ProofPoint.Incident.event_ids
      description: The list of IDs attached to the incident.
      type: Unknown
  - arguments:
    - default: true
      description: The ID value of the incident to retrieve (e.g. for incident INC-4000,
        the input for this argument should be 4000).
      name: incident_id
      required: true
    - auto: PREDEFINED
      description: If false, will return an array of event IDs instead of full event
        objects. This will significantly speed up the response time of the API for
        incidents with large numbers of alerts.
      name: expand_events
      predefined:
      - "true"
      - "false"
    description: Retrieves incident metadata from Threat Response.
    name: proofpoint-tr-get-incident
    outputs:
    - contextPath: ProofPointTRAP.Incident.id
      description: The incident ID.
      type: Number
    - contextPath: ProofPointTRAP.Incident.summary
      description: The summary of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.score
      description: The score of the incident from Proofpoint.
      type: Number
    - contextPath: ProofPointTRAP.Incident.state
      description: The state of the incident. Can be - Open, Closed, New, Assigned,
        Ignored.
      type: String
    - contextPath: ProofPointTRAP.Incident.created_at
      description: The date the incident was created.
      type: Date
    - contextPath: ProofPointTRAP.Incident.updated_at
      description: The date the incident was last updated.
      type: Date
    - contextPath: ProofPointTRAP.Incident.event_count
      description: The number of events attached to the incident.
      type: Number
    - contextPath: ProofPointTRAP.Incident.false_positive_count
      description: The number of false positive events in the incident.
      type: Number
    - contextPath: ProofPointTRAP.Incident.event_sources
      description: The sources of the events.
      type: String
    - contextPath: ProofPointTRAP.Incident.assignee
      description: The user assigned to the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.team
      description: The team assigned to the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.hosts.attacker
      description: The host attacker.
      type: String
    - contextPath: ProofPointTRAP.Incident.hosts.forensics
      description: The host forensics.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Severity
      description: The severity of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Abuse_disposition
      description: The abuse disposition of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Attack_vector
      description: The attack vector of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.incident_field_values.Classification
      description: The classification of the incident.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.id
      description: The event ID.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.category
      description: The event category.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.alertType
      description: The alert type of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.severity
      description: The severity of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.source
      description: The source of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.state
      description: The state of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.attackDirection
      description: The attack direction of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.received
      description: The date the incident was received.
      type: Date
    - contextPath: ProofPointTRAP.Incident.events.emails.sender
      description: The sender of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.recipient
      description: The recipient of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.message_Id
      description: The message ID of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.message_delivery_time
      description: The time the message was delivered.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.attackers.location
      description: The location of the attacker.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.falsePositive
      description: Whether this incident is a false positive.
      type: Boolean
    - contextPath: ProofPointTRAP.Incident.events.threatname
      description: The threat name.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.description
      description: The description of the event.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.malwareName
      description: The malware name.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.alertSource
      description: The alert source.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.startTime
      description: The start time of the result.
      type: Date
    - contextPath: ProofPointTRAP.Incident.quarantine_results.endTime
      description: The end time of the result.
      type: Date
    - contextPath: ProofPointTRAP.Incident.quarantine_results.status
      description: The status of the result.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.recipientType
      description: The recipient type.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.recipient
      description: The recipient email address.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.messageId
      description: The message ID.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.isRead
      description: Whether the message has been read.
      type: Boolean
    - contextPath: ProofPointTRAP.Incident.quarantine_results.wasUndone
      description: Whether the message was undone.
      type: String
    - contextPath: ProofPointTRAP.Incident.quarantine_results.details
      description: The details about the result.
      type: String
    - contextPath: ProofPointTRAP.Incident.successful_quarantines
      description: The number of successful quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.failed_quarantines
      description: The number of failed quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.pending_quarantines
      description: The number of pending quarantines.
      type: Number
    - contextPath: ProofPointTRAP.Incident.events.emails.body
      description: The body of the email.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.body_type
      description: The format of the body.
      type: String
    - contextPath: ProofPointTRAP.Incident.events.emails.headers
      description: The email headers.
      type: Unknown
    - contextPath: ProofPointTRAP.Incident.events.emails.urls
      description: The list of URLs from the email.
      type: Unknown
    - contextPath: ProofPoint.Incident.event_ids
      description: The list of IDs attached to the incident.
      type: Unknown
  - arguments:
    - description: The ID value of the incident to add the comment to (e.g. for incident
        INC-4000, the input for this argument should be 4000).
      name: incident_id
      required: true
    - description: 'The details of the comments. '
      name: details
      required: true
    - description: The summary of the comments.
      name: comments
      required: true
    description: Adds comments to an existing Threat Response incident, by incident
      ID.
    name: proofpoint-tr-update-incident-comment
    outputs:
    - contextPath: ProofPointTRAP.IncidentComment.id
      description: The ID of the comment.
      type: Number
    - contextPath: ProofPointTRAP.IncidentComment.incident_id
      description: The ID of the incident.
      type: Number
    - contextPath: ProofPointTRAP.IncidentComment.response_id
      description: The ID of the response.
      type: Number
    - contextPath: ProofPointTRAP.IncidentComment.user_id
      description: The ID of the user.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.history_type
      description: The history type.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.state_from
      description: The state from of the incident.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.state_to
      description: The state to of the incident.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.summary
      description: The summary of the comments.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.detail
      description: The details of the comment.
      type: String
    - contextPath: ProofPointTRAP.IncidentComment.created_at
      description: The date the incident was created.
      type: Date
    - contextPath: ProofPointTRAP.IncidentComment.updated_at
      description: The date the incident was last updated.
      type: Date
  - arguments:
    - description: The ID value of the incident to add the user to (e.g. for incident
        INC-4000, the input for this argument should be 4000).
      name: incident_id
      required: true
    - description: The list of targets to add to the incident.
      isArray: true
      name: targets
      required: true
    - description: The list of attackers to add to the incident.
      isArray: true
      name: attackers
      required: true
    description: Assigns a user to an incident as a target or attacker.
    name: proofpoint-tr-add-user-to-incident
  - arguments:
    - description: The incident ID to close.
      name: incident_id
    - description: The incident closure details.
      name: details
    - description: The incident closure summary.
      name: summary
    description: Close a specified incident.
    name: proofpoint-tr-close-incident
  - arguments:
    - description: POST URL of the JSON alert source. You can find it by navigating
        to Sources -> JSON event source -> POST URL.
      name: post_url_id
    - auto: PREDEFINED
      defaultValue: "2.0"
      description: The Threat Response JSON version.
      name: json_version
      predefined:
      - "2.0"
      - "1.0"
      required: true
    - description: 'An attacker object in JSON format : "{"attacker" : {...}}". The
        attacker object must contain one of ["ip_address", mac_address", "host_name",
        "url", "user"] keys. You can also add the "port" key to the object. For more
        information, see Proofpoint TRAP documentation under "JSON Alert Source 2.0".'
      name: attacker
    - auto: PREDEFINED
      description: The alert classification shown as "Alert Type" in the TRAP UI.
      name: classification
      predefined:
      - malware
      - policy-violation
      - vulnerability
      - network
      - spam
      - phish
      - command-and-control
      - data-match
      - authentication
      - system-behavior
      - impostor
      - reported-abuse
      - unknown
    - description: 'The Command and Control host information in JSON format : "{"cnc_hosts":
        [{"host" : "-", "port": "-"}, ...]}". Note: Every item of the "cnc_hosts"
        list is in JSON format. For more information, see Proofpoint TRAP documentation
        under "JSON Alert Source 2.0".'
      name: cnc_hosts
    - description: 'The threat detection tool such as Firewall and IPS/IDS systems
        (in the format: "{"detector" : {...}}"), which generated the original alert.
        To see all relevant JSON fields and for more information, see Proofpoint TRAP
        documentation under "JSON Alert Source 2.0".'
      name: detector
    - description: 'The email metadata related to the alert, in JSON format: "{"email":
        {...}}". To see all relevant JSON fields and for more information, see Proofpoint
        TRAP documentation under "JSON Alert Source 2.0".'
      name: email
    - description: 'The forensics host information in JSON format : "{"forensics_hosts":
        [{"host" : "-", "port": "-"}...]}". Note: Every item of the "forensics_hosts"
        list is in JSON format. For more information, see Proofpoint TRAP documentation
        under "JSON Alert Source 2.0".'
      name: forensics_hosts
    - auto: PREDEFINED
      description: The attribute to link alerts to.
      name: link_attribute
      predefined:
      - target_ip_address
      - target_hostname
      - target_machine_name
      - target_user
      - target_mac_address
      - attacker_ip_address
      - attacker_hostname
      - attacker_machine_name
      - attacker_user
      - attacker_mac_address
      - email_recipient
      - email_sender
      - email_subject
      - message_id
      - threat_filename
      - threat_filehash
    - auto: PREDEFINED
      description: The severity of the alert.
      name: severity
      predefined:
      - info
      - minor
      - moderate
      - major
      - critical
      - Informational
      - Low
      - Medium
      - High
      - Critical
    - description: The alert summary. This argument will populate the Alert Details
        field.
      name: summary
    - description: 'The target host information in JSON format : "{"target": {...}}".
        To see all relevant JSON fields and for more information, see Proofpoint TRAP
        documentation under "JSON Alert Source 2.0".'
      name: target
    - description: 'The threat information in JSON format: "{"threat_info": {...}}".
        To see all relevant JSON fields and for more information, see Proofpoint TRAP
        documentation under "JSON Alert Source 2.0".'
      name: threat_info
    - description: 'A JSON object for collecting custom name-value pairs as part of
        the JSON alert sent to Threat Response, in the format: "{"custom_fields":
        {..}}". Although there is no limit to the number of custom fields, Proofpoint
        recommends keeping it to 10 or fewer fields. To see all relevant JSON fields
        and for more information, see Proofpoint TRAP documentation under "JSON Alert
        Source 2.0".'
      name: custom_fields
    description: Ingest an alert into Threat Response.
    name: proofpoint-tr-ingest-alert
  - arguments:
    - description: The message ID of the email.
      name: message_id
      required: true
    - description: The recipient of the email.
      name: recipient
      required: true
    - description: 'The reception time of the email in the format YYYY-MM-DDTHH:MM:SSZ.
        For example: 2020-02-02T19:00:00Z.'
      name: time
      required: true
    description: Verify if an email has been quarantined.
    name: proofpoint-tr-verify-quarantine
    outputs:
    - contextPath: ProofPointTRAP.Quarantine
      description: Results of the email quarantine operation.
      type: String
  dockerimage: demisto/python3:3.10.13.80014
  isfetch: true
  runonce: false
  script: |
    register_module_line('Proofpoint Threat Response', 'start', __line__())
    ### pack version: 2.0.16


    import json
    import requests
    from datetime import date, timedelta

    import dateparser

    import urllib3

    urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    TIME_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    BASE_URL = demisto.params().get('url')
    if BASE_URL and BASE_URL[-1] != '/':
        BASE_URL += '/'
    API_KEY = demisto.params().get('credentials', {}).get('password') or demisto.params().get('apikey')
    VERIFY_CERTIFICATE = not demisto.params().get('insecure')
    # How many time before the first fetch to retrieve incidents
    FIRST_FETCH, _ = parse_date_range(demisto.params().get('first_fetch', '12 hours') or '12 hours',
                                      date_format=TIME_FORMAT)

    ''' COMMAND FUNCTIONS '''


    def get_list(list_id):
        fullurl = BASE_URL + f'api/lists/{list_id}/members.json'
        res = requests.get(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            verify=VERIFY_CERTIFICATE
        )

        if res.status_code < 200 or res.status_code >= 300:
            return_error(f'Get list failed. URL: {fullurl}, StatusCode: {res.status_code}')

        return res.json()


    def get_list_command():
        ''' Retrieves all indicators of a the given list ID in Threat Response '''
        list_id = demisto.args().get('list-id')
        list_items = get_list(list_id)

        demisto.results({'list': list_items})


    def add_to_list(list_id, indicator, comment, expiration):
        fullurl = BASE_URL + f'api/lists/{list_id}/members.json'

        indicator = {
            'member': indicator
        }
        if comment:
            indicator['description'] = comment

        if expiration:
            indicator['expiration'] = expiration

        res = requests.post(
            fullurl,
            headers={
                'Authorization': API_KEY
            },
            verify=VERIFY_CERTIFICATE,
            json=indicator
        )

        if res.status_code < 200 or res.status_code >= 300:
            return_error(f'Add to list failed. URL: {fullurl}, Request Body: {json.dumps(indicator)}')

        return res.json()


    def add_to_list_command():
        ''' Adds given indicators to the given list ID in Threat Response '''
        list_id = demisto.args().get('list-id')
        indicators = argToList(demisto.args().get('indicator'))
        comment = demisto.args().get('comment')
        expiration = demisto.args().get('expiration')

        message = ''
        for indicator in indicators:
            add_to_list(list_id, indicator, comment, expiration)
            message += f'{indicator} added successfully to {list_id}\n'

        demisto.results(message)


    def block_ip_command():
        ''' Adds given IPs to the relevant blacklist in Threat Response '''
        list_id = demisto.params().get('blacklist_ip', demisto.args().get('blacklist_ip'))
        ips = argToList(demisto.args().get('ip'))
        expiration = demisto.args().get('expiration')

        message = ''
        for ip in ips:
            add_to_list(list_id, ip, None, expiration)
            message += f'{ip} added successfully to block_ip list\n'

        demisto.results(message)


    def block_domain_command():
        ''' Adds given domains to the relevant blacklist in Threat Response '''
        list_id = demisto.params().get('blacklist_domain', demisto.args().get('blacklist_domain'))
        domains = argToList(demisto.args().get('domain'))
        expiration = demisto.args().get('expiration')

        message = ''
        for domain in domains:
            add_to_list(list_id, domain, None, expiration)
            message += f'{domain} added successfully to block_domain list\n'

        demisto.results(message)


    def block_url_command():
        ''' Adds given URLs to the relevant blacklist in Threat Response '''
        list_id = demisto.params().get('blacklist_url', demisto.args().get('blacklist_url'))
        urls = argToList(demisto.args().get('url'))
        expiration = demisto.args().get('expiration')

        message = ''
        for url in urls:
            add_to_list(list_id, url, None, expiration)
            message += f'{url} added successfully to block_url list\n'

        demisto.results(message)


    def block_hash_command():
        ''' Adds given hashes to the relevant blacklist in Threat Response '''
        list_id = demisto.params().get('blacklist_hash', demisto.args().get('blacklist_hash'))
        hashes = argToList(demisto.args().get('hash'))
        expiration = demisto.args().get('expiration')

        message = ''
        for h in hashes:
            add_to_list(list_id, h, None, expiration)
            message += f'{h} added successfully to block_hash list\n'

        demisto.results(message)


    def search_indicators(list_id, indicator_filter):
        list_indicators = get_list(list_id)
        found_items = []
        for item in list_indicators:
            item_indicator = demisto.get(item, 'host.host')
            if item_indicator and indicator_filter in item_indicator:
                found_items.append(item)

        return found_items


    def search_indicator_command():
        ''' Retrieves indicators of a list, using a filter '''
        list_id = demisto.args().get('list-id')
        indicator_filter = demisto.args().get('filter')
        found = search_indicators(list_id, indicator_filter)

        demisto.results({'indicators': found})


    def delete_indicator(list_id, indicator_filter):
        indicator = search_indicators(list_id, indicator_filter)
        if len(indicator) == 0:
            return_error(f'{indicator_filter} not exists in {list_id}')

        indicator_id = indicator.get('id')  # pylint: disable=E1101
        fullurl = BASE_URL + f'api/lists/{list_id}/members/{indicator_id}.json'
        res = requests.delete(
            fullurl,
            headers={
                'Authorization': API_KEY
            },
            verify=VERIFY_CERTIFICATE
        )
        if res.status_code < 200 or res.status_code >= 300:
            return_error(f'Delete indicator failed. URL: {fullurl}, StatusCode: {res.status_code}')


    def delete_indicator_command():
        ''' Deletes an indicator from a list '''
        list_id = demisto.args().get('list-id')
        indicator = demisto.args().get('indicator')
        delete_indicator(list_id, indicator)

        demisto.results(f'{list_id} deleted successfully from list {indicator}')


    def test():
        """Perform API call to check that the API is accessible.

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        integration_params = demisto.params()
        if integration_params.get('isFetch') and not integration_params.get('states'):
            raise DemistoException("Missing argument - You must provide at least one incident state.")
        get_incidents_request(
            {
                'created_after': date.today(),
                'state': 'open'
            }
        )
        demisto.results('ok')


    # TRAP API
    def create_incident_field_context(incident):
        """Parses the 'incident_fields' entry of the incident and returns it

        Args:
            incident (dict): The incident to parse

        Returns:
            list. The parsed incident fields list
        """
        incident_field_values = {}
        for incident_field in incident.get('incident_field_values', []):
            incident_field_values[incident_field['name'].replace(" ", "_")] = incident_field['value']

        return incident_field_values


    def get_emails_context(event):
        """Returns the context of the emails in the event

        Args:
            event (dict): The event to parse the emails from

        Returns:
            list. The parsed emails list from the event
        """
        emails_context = []
        for email in event.get('emails', []):
            email_obj = {
                'sender': email.get('sender', {}).get('email'),
                'recipient': email.get('recipient', {}).get('email'),
                'subject': email.get('subject'),
                'message_id': email.get('messageId'),
                'body': email.get('body'),
                'body_type': email.get('bodyType'),
                'headers': email.get('headers'),
                'urls': email.get('urls'),
                'sender_vap': email.get('sender', {}).get('vap'),
                'recipient_vap': email.get('recipient', {}).get('vap'),
                'attachments': email.get('attachments'),
            }
            message_delivery_time = email.get('messageDeliveryTime', {})
            if message_delivery_time and isinstance(message_delivery_time, dict):
                email_obj['message_delivery_time'] = message_delivery_time.get('millis')
            elif message_delivery_time and isinstance(message_delivery_time, str):
                email_obj['message_delivery_time'] = message_delivery_time
            emails_context.append(
                assign_params(**email_obj)
            )

        return emails_context


    def create_incidents_context(incidents_list):
        """Parses the incidents list and returns the incidents context

        Args:
            incidents_list (list): The incidents list to parse

        Returns:
            list. The context created from the incidents list
        """
        context = list(incidents_list)
        for incident in context:
            incident['incident_field_values'] = create_incident_field_context(incident)

            if incident.get('events'):
                for event in incident['events']:
                    event['emails'] = get_emails_context(event)

        return context


    def create_incidents_human_readable(human_readable_message, incidents_list):
        """Creates the human readable entry for incidents

        Args:
            human_readable_message (str): The title of the human readable table
            incidents_list (list): The incidents list to insert to the table

        Returns:
            str. The incidents human readable in markdown format
        """
        human_readable = []
        human_readable_headers = ['ID', 'Created At', 'Type', 'Summary', 'Score', 'Event Count', 'Assignee',
                                  'Successful Quarantines', 'Failed Quarantines', 'Pending Quarantines']
        for incident in incidents_list:
            human_readable.append({
                'Created At': incident.get('created_at'),
                'ID': incident.get('id'),
                'Type': incident.get('type'),
                'Summary': incident.get('summary'),
                'Score': incident.get('score'),
                'Event Count': incident.get('event_count'),
                'Assignee': incident.get('assignee'),
                'Successful Quarantines': incident.get('successful_quarantine'),
                'Failed Quarantines': incident.get('failed_quarantines'),
                'Pending Quarantines': incident.get('pending_quarantines')
            })

        return tableToMarkdown(human_readable_message, human_readable, human_readable_headers, removeNull=True)


    def list_incidents_command():
        """ Retrieves incidents from ProofPoint API """
        args = demisto.args()
        limit = int(args.pop('limit'))

        incidents_list = get_incidents_request(args)

        incidents_list = incidents_list[:limit]
        human_readable = create_incidents_human_readable('List Incidents Results:', incidents_list)
        context = create_incidents_context(incidents_list)

        return_outputs(human_readable, {'ProofPointTRAP.Incident(val.id === obj.id)': context}, incidents_list)


    def get_incident_command():
        """
            Retrieves a single incident from ProofPoint API
        """
        args = demisto.args()
        incident_id = args.pop('incident_id')
        expand_events = args.get('expand_events')
        fullurl = BASE_URL + f'api/incidents/{incident_id}.json'
        incident_data = requests.get(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            params={
                'expand_events': expand_events,
            },
            verify=VERIFY_CERTIFICATE,
        )

        if incident_data.status_code < 200 or incident_data.status_code >= 300:
            return_error(f'Get incident failed. URL: {fullurl}, StatusCode: {incident_data.status_code}')

        incident_data = incident_data.json()
        human_readable = create_incidents_human_readable('Incident Results:', [incident_data])
        context = create_incidents_context([incident_data])

        return_outputs(human_readable, {'ProofPointTRAP.Incident(val.id === obj.id)': context}, incident_data)


    def pass_sources_list_filter(incident, sources_list):
        """Checks whether the event sources of the incident contains at least one of the sources in the sources list.

        Args:
            incident (dict): The incident to check
            sources_list (list): The list of sources from the customer

        Returns:
            bool. Whether the incident has passed the filter or not
        """
        if len(sources_list) == 0:
            return True

        return any(source in incident.get('event_sources') for source in sources_list)


    def pass_abuse_disposition_filter(incident, abuse_disposition_values):
        """Checks whether the incident's 'Abuse Disposition' value is in the abuse_disposition_values list.

        Args:
            incident (dict): The incident to check
            abuse_disposition_values (list): The list of relevant values from the customer

        Returns:
            bool. Whether the incident has passed the filter or not
        """
        if len(abuse_disposition_values) == 0:
            return True

        for incident_field in incident.get('incident_field_values', []):
            if incident_field['name'] == 'Abuse Disposition' and incident_field['value'] in abuse_disposition_values:
                return True

        return False


    def filter_incidents(incidents_list):
        """Filters the incidents list by 'abuse disposition' and 'source list' values

        Args:
            incidents_list (list): The incidents list to filter

        Returns:
            list. The filtered incidents list
        """
        filtered_incidents_list = []
        params = demisto.params()
        sources_list = argToList(params.get('event_sources'))
        abuse_disposition_values = argToList(params.get('abuse_disposition'))

        if not sources_list and not abuse_disposition_values:
            return incidents_list

        for incident in incidents_list:
            if pass_sources_list_filter(incident, sources_list) and pass_abuse_disposition_filter(incident,
                                                                                                  abuse_disposition_values):
                filtered_incidents_list.append(incident)

        return filtered_incidents_list


    def get_incidents_request(params):
        """Perform an API request to get incidents from ProofPoint.

        Args:
            params(dict): The params of the request

        Returns:
            list. The incidents returned from the API call
        """
        fullurl = BASE_URL + 'api/incidents'
        incidents_list = requests.get(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            params=params,
            verify=VERIFY_CERTIFICATE
        )
        if incidents_list.status_code < 200 or incidents_list.status_code >= 300:
            if incidents_list.status_code == 502 or incidents_list.status_code == 504:
                return_error('The operation failed. There is a possibility you are trying to get too many incidents.\n'
                             'You may consider adding a filter argument to the command.\n'
                             'URL: {}, StatusCode: {}'.format(fullurl, incidents_list.status_code))
            else:
                return_error(f'The operation failed. URL: {fullurl}, StatusCode: {incidents_list.status_code}')

        return incidents_list.json()


    def get_time_delta(fetch_delta):
        """Gets the time delta from a string that is combined with a number and a string of (minute/hour)
        Args:
            fetch_delta(str): The fetch delta param.
        Returns:
            The time delta.
        """
        fetch_delta_split = fetch_delta.strip().split(' ')
        if len(fetch_delta_split) != 2:
            raise Exception(
                'The fetch_delta is invalid. Please make sure to insert both the number and the unit of the fetch delta.')

        unit = fetch_delta_split[1].lower()
        number = int(fetch_delta_split[0])

        if unit not in ['minute', 'minutes',
                        'hour', 'hours',
                        ]:
            raise Exception('The unit of fetch_delta is invalid. Possible values are "minutes" or "hours".')

        if 'hour' in unit:
            time_delta = timedelta(hours=number)  # batch by hours
        else:
            time_delta = timedelta(minutes=number)  # batch by minutes
        return time_delta


    def get_new_incidents(request_params, last_fetched_id):
        """Perform an API request to get incidents from ProofPoint , filters then according to params, order them and
        return only the new incidnts.

        As the api does not return the results in an specific order, we query the api on specific time frames using
        created_before and created_after using the fetch delta parameter.
        Args:
            request_params(dict): The params of the request
            last_fetched_id(int): The ID of the last incident that was fetched in the previous fetch.
        Returns:
            list. The incidents returned from after the necessary actions.
        """
        incidents = get_incidents_request(request_params)
        filtered_incidents_list = filter_incidents(incidents)
        ordered_incidents = sorted(filtered_incidents_list, key=lambda k: (k['created_at'], k['id']))
        return list(filter(lambda incident: int(incident.get('id')) > last_fetched_id, ordered_incidents))


    def get_incidents_batch_by_time_request(params):
        """Perform an API request to get incidents from ProofPoint in batches to prevent a timeout.

        As the api does not return the results in an specific order, we query the api on specific time frames using
        created_before and created_after using the fetch delta parameter.
        Args:
            params(dict): The params of the request

        Returns:
            list. The incidents returned from the API call
        """
        incidents_list = []  # type:list

        fetch_delta = params.get('fetch_delta', '6 hours')
        fetch_limit = int(params.get('fetch_limit', '50'))
        last_fetched_id = int(params.get('last_fetched_id', '0'))

        current_time = datetime.now()

        time_delta = get_time_delta(fetch_delta)

        created_after = datetime.strptime(params.get('created_after'), TIME_FORMAT)
        created_before = created_after + time_delta

        request_params = {
            'state': params.get('state'),
            'created_after': created_after.isoformat().split('.')[0] + 'Z',
            'created_before': created_before.isoformat().split('.')[0] + 'Z'
        }

        # while loop relevant for fetching old incidents
        while created_before < current_time and len(incidents_list) < fetch_limit:
            demisto.debug(
                "Entered the batch loop , with fetch_limit {} and incidents list {} and incident length {} "
                "with created_after {} and created_before {}.".format(
                    str(fetch_limit), str([incident.get('id') for incident in incidents_list]), str(len(incidents_list)),
                    str(request_params['created_after']), str(request_params['created_before'])))

            new_incidents = get_new_incidents(request_params, last_fetched_id)
            incidents_list.extend(new_incidents)

            # advancing fetch time by given fetch delta time
            created_after = created_before
            created_before = created_before + time_delta

            # updating params according to the new times
            request_params['created_after'] = created_after.isoformat().split('.')[0] + 'Z'
            request_params['created_before'] = created_before.isoformat().split('.')[0] + 'Z'
            demisto.debug(f"End of the current batch loop with {str(len(incidents_list))} incidents")

        # fetching the last batch when created_before is bigger then current time = fetching new incidents
        if len(incidents_list) < fetch_limit:
            # fetching the last batch
            request_params['created_before'] = current_time.isoformat().split('.')[0] + 'Z'
            new_incidents = get_new_incidents(request_params, last_fetched_id)
            incidents_list.extend(new_incidents)

            demisto.debug(
                "Finished the last batch, with fetch_limit {} and incidents list {} and incident length {}".format(
                    str(fetch_limit), str([incident.get('id') for incident in incidents_list]), str(len(incidents_list))))

        incidents_list_limit = incidents_list[:fetch_limit]
        return incidents_list_limit


    def fetch_incidents_command():
        """
            Fetches incidents from the ProofPoint API.
        """
        integration_params = demisto.params()
        last_fetch = demisto.getLastRun().get('last_fetch', {})
        last_fetched_id = demisto.getLastRun().get('last_fetched_incident_id', {})

        fetch_delta = integration_params.get('fetch_delta', '6 hours')
        fetch_limit = integration_params.get('fetch_limit', '50')

        incidents_states = integration_params.get('states')
        for state in incidents_states:
            if not last_fetch.get(state):
                last_fetch[state] = FIRST_FETCH

        for state in incidents_states:
            if not last_fetched_id.get(state):
                last_fetched_id[state] = '0'

        incidents = []
        for state in incidents_states:
            request_params = {
                'created_after': last_fetch[state],
                'last_fetched_id': last_fetched_id[state],
                'fetch_delta': fetch_delta,
                'state': state,
                'fetch_limit': fetch_limit
            }
            id = last_fetched_id[state]
            incidents_list = get_incidents_batch_by_time_request(request_params)
            for incident in incidents_list:
                id = incident.get('id')
                inc = {
                    'name': f'ProofPoint_TRAP - ID {id}',
                    'rawJSON': json.dumps(incident),
                    'occurred': incident['created_at']
                }
                incidents.append(inc)

            if incidents:
                last_fetch_time = incidents[-1]['occurred']
                last_fetch[state] = \
                    (datetime.strptime(last_fetch_time, TIME_FORMAT) - timedelta(minutes=1)).isoformat().split('.')[0] + 'Z'
                last_fetched_id[state] = id

        demisto.debug("End of current fetch function with last_fetch {} and last_fetched_id {}".format(str(last_fetch), str(
            last_fetched_id)))

        demisto.setLastRun({'last_fetch': last_fetch})
        demisto.setLastRun({'last_fetched_incident_id': last_fetched_id})

        demisto.info(f'extracted {len(incidents)} incidents')

        demisto.incidents(incidents)


    def create_add_comment_human_readable(incident):
        """Creates the human readable entry for the 'add_comment_to_incident' command

        Args:
            incident (dict): The incident to parse

        Returns:
            str. The command human readable in markdown format
        """
        human_readable = []
        human_readable_headers = ['Incident ID', 'Created At', 'Details', 'Comments Summary', 'Action ID']
        incident_id = incident.get('incident_id')
        human_readable.append({
            'Created At': incident.get('created_at'),
            'Incident ID': incident_id,
            'Details': incident.get('detail'),
            'Comments Summary': incident.get('summary'),
            'Action ID': incident.get('id')
        })

        return tableToMarkdown(f'Comments added successfully to incident:{incident_id}', human_readable,
                               human_readable_headers, removeNull=True)


    def add_comment_to_incident_command():
        """
            Adds comments to an incident by incident ID
        """
        args = demisto.args()
        incident_id = args.get('incident_id')
        comments_to_add = args.get('comments')
        details = args.get('details')
        request_body = {
            "summary": comments_to_add,
            "detail": details
        }

        fullurl = BASE_URL + f'api/incidents/{incident_id}/comments.json'
        incident_data = requests.post(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            json=request_body,
            verify=VERIFY_CERTIFICATE
        )

        if incident_data.status_code < 200 or incident_data.status_code >= 300:
            return_error('Add comment to incident command failed. URL: {}, '
                         'StatusCode: {}'.format(fullurl, incident_data.status_code))

        incident_data = incident_data.json()
        human_readable = create_add_comment_human_readable(incident_data)

        return_outputs(human_readable,
                       {'ProofPointTRAP.IncidentComment(val.incident_id === obj.incident_id)': incident_data},
                       incident_data)


    def add_user_to_incident_command():
        """
            Adds user to an incident by incident ID
        """
        args = demisto.args()
        incident_id = args.get('incident_id')
        attackers = argToList(args.get('attackers'))
        targets = argToList(args.get('targets'))
        request_body = {
            "targets": targets,
            "attackers": attackers
        }

        fullurl = BASE_URL + 'api/incidents/{incident_id}/users.json'
        incident_data = requests.post(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            json=request_body,
            verify=VERIFY_CERTIFICATE
        )

        if incident_data.status_code < 200 or incident_data.status_code >= 300:
            return_error('Add comment to incident command failed. URL: {}, '
                         'StatusCode: {}'.format(fullurl, incident_data.status_code))

        return_outputs(f'The user was added successfully to incident {incident_id}', {}, {})


    def parse_json_argument(argument_string_value, argument_name):
        parsed_arg = {}
        try:
            parsed_arg = json.loads(argument_string_value)
        except ValueError as error:
            return_error(f"The '{argument_name}' argument is not a valid json. Error: {error}")
        if not parsed_arg.get(argument_name):
            return_error(f"The '{argument_name}' json argument should start with a key named '{argument_name}'")

        return parsed_arg


    def prepare_ingest_alert_request_body(args):
        json_arguments = ['attacker', 'cnc_host', 'detector', 'email', 'forensics_hosts', 'target', 'threat_info',
                          'custom_fields']
        request_body = {}  # type: dict
        for argument_name, argument_value in args.items():
            if argument_name in json_arguments:
                parsed_argument = parse_json_argument(argument_value, argument_name)
                request_body.update(parsed_argument)

            else:
                request_body[argument_name] = argument_value
        return request_body


    def ingest_alert_command():
        """
            Ingest an alert into Threat Response.
        """
        args = demisto.args()
        json_source_id = args.pop('post_url_id', demisto.params().get('post_url_id'))

        if not json_source_id:
            return_error("To ingest alert into TRAP, you mast specify a post_url_id,"
                         "either as an argument or as an integration parameter.")

        request_body = prepare_ingest_alert_request_body(assign_params(**args))
        fullurl = BASE_URL + f'threat/json_event/events/{json_source_id}'
        alert_data = requests.post(
            fullurl,
            headers={
                'Content-Type': 'application/json'
            },
            json=request_body,
            verify=VERIFY_CERTIFICATE
        )

        if alert_data.status_code < 200 or alert_data.status_code >= 300:
            return_error('Failed to ingest the alert into TRAP. URL: {}, '
                         'StatusCode: {}'.format(fullurl, alert_data.status_code))

        return_outputs('The alert was successfully ingested to TRAP', {}, {})


    def close_incident_command():
        args = demisto.args()
        incident_id = args.get('incident_id')
        details = args.get('details')
        summary = args.get('summary')
        request_body = {
            "summary": summary,
            "detail": details
        }

        fullurl = BASE_URL + f'api/incidents/{incident_id}/close.json'
        incident_data = requests.post(
            fullurl,
            headers={
                'Content-Type': 'application/json',
                'Authorization': API_KEY
            },
            json=request_body,
            verify=VERIFY_CERTIFICATE
        )

        if incident_data.status_code < 200 or incident_data.status_code >= 300:
            return_error('Incident closure failed. URL: {}, '
                         'StatusCode: {}'.format(fullurl, incident_data.status_code))

        return_outputs(f'The incident {incident_id} was successfully closed', {}, {})


    def search_quarantine():
        arg_time = dateparser.parse(demisto.args().get('time'))
        if isinstance(arg_time, datetime):
            emailTAPtime = int(arg_time.timestamp())
        else:
            return_error("Timestamp was bad")

        lstAlert = []
        mid = demisto.args().get('message_id')
        recipient = demisto.args().get('recipient')

        request_params = {
            'created_after': datetime.strftime(arg_time - get_time_delta('1 hour'), TIME_FORMAT),  # for safety
            'fetch_delta': '6 hours',
            'fetch_limit': '50'
        }

        incidents_list = get_incidents_batch_by_time_request(request_params)

        found = {'email': False, 'mid': False, 'quarantine': False}
        resQ = []

        # Collecting emails inside alert to find those with same recipient and messageId
        for incident in incidents_list:
            for alert in incident.get('events'):
                for email in alert.get('emails'):
                    if email.get('messageId') == mid and email.get('recipient').get('email') == recipient and email.get(
                            'messageDeliveryTime', {}).get('millis'):
                        found['mid'] = True
                        emailTRAPtimestamp = int(email.get('messageDeliveryTime', {}).get('millis') / 1000)
                        if emailTAPtime == emailTRAPtimestamp:
                            found['email'] = True
                            lstAlert.append({
                                'incidentid': incident.get('id'),
                                'alertid': alert.get('id'),
                                'alerttime': alert.get('received'),
                                'incidenttime': incident.get('created_at'),
                                'messageId': mid,
                                'quarantine_results': incident.get('quarantine_results')
                            })

        quarantineFoundcpt = 0

        # Go though the alert list, and check the quarantine results:
        for alert in lstAlert:
            for quarantine in alert.get('quarantine_results'):
                if quarantine.get('messageId') == mid and quarantine.get('recipient') == recipient:
                    found['quarantine'] = True
                    tsquarantine = dateparser.parse(quarantine.get("startTime"))
                    tsalert = dateparser.parse(alert.get("alerttime"))
                    if isinstance(tsquarantine, datetime) and isinstance(tsalert, datetime):
                        diff = (tsquarantine - tsalert).total_seconds()
                        # we want to make sure quarantine starts 2 minuts after creating the alert.
                        if 0 < diff < 120:
                            resQ.append({
                                'quarantine': quarantine,
                                'alert': {
                                    'id': alert.get('alertid'),
                                    'time': alert.get('alerttime')
                                },
                                'incident': {
                                    'id': alert.get('incidentid'),
                                    'time': alert.get('incidenttime')
                                }
                            })
                        else:
                            quarantineFoundcpt += 1
                    else:
                        demisto.debug(f"Failed to parse timestamp of incident: {alert=} {quarantine=}.")

        if quarantineFoundcpt > 0:
            return CommandResults(
                readable_output=f"{mid} Message ID matches to {quarantineFoundcpt} emails quarantined but time alert does not match")
        if not found['mid']:
            return CommandResults(readable_output=f"Message ID {mid} not found in TRAP incidents")

        midtxt = f'{mid} Message ID found in TRAP alerts,'
        if not found['email']:
            return CommandResults(
                readable_output=f"{midtxt} but timestamp between email delivery time and time given as argument doesn't match")
        elif not found['quarantine']:
            demisto.debug("\n".join([json.dumps(alt, indent=4) for alt in lstAlert]))
            return CommandResults(f"{midtxt} but not in the quarantine list meaning that email has not be quarantined.")

        return CommandResults(
            outputs_prefix='ProofPointTRAP.Quarantine',
            outputs=resQ,
            readable_output=tableToMarkdown("Quarantine Result", resQ),
            raw_response=resQ
        )


    ''' EXECUTION CODE '''


    def main():
        handle_proxy(demisto.params().get('proxy'))
        command = demisto.command()
        demisto.info(f'Command being called is {command}')

        if command == 'test-module':
            test()

        elif command == 'fetch-incidents':
            fetch_incidents_command()

        elif command == 'proofpoint-tr-get-list':
            get_list_command()

        elif command == 'proofpoint-tr-add-to-list':
            add_to_list_command()

        elif command == 'proofpoint-tr-block-ip':
            block_ip_command()

        elif command == 'proofpoint-tr-block-domain':
            block_domain_command()

        elif command == 'proofpoint-tr-block-url':
            block_url_command()

        elif command == 'proofpoint-tr-block-hash':
            block_hash_command()

        elif command == 'proofpoint-tr-delete-indicator':
            delete_indicator_command()

        elif command == 'proofpoint-tr-search-indicator':
            search_indicator_command()

        elif command == 'proofpoint-tr-list-incidents':
            list_incidents_command()

        elif command == 'proofpoint-tr-get-incident':
            get_incident_command()

        elif command == 'proofpoint-tr-update-incident-comment':
            add_comment_to_incident_command()

        elif command == 'proofpoint-tr-add-user-to-incident':
            add_user_to_incident_command()

        elif command == 'proofpoint-tr-ingest-alert':
            ingest_alert_command()

        elif command == 'proofpoint-tr-close-incident':
            close_incident_command()

        elif command == 'proofpoint-tr-verify-quarantine':
            return_results(search_quarantine())


    if __name__ == '__builtin__' or __name__ == 'builtins':
        main()

    register_module_line('Proofpoint Threat Response', 'end', __line__())
  subtype: python3
  type: python
system: true
