args:
- description: A comma-separated list of values to map from.
  isArray: true
  name: map_from
  required: true
- description: A comma-separated list of values to map to.
  isArray: true
  name: map_to
  required: true
- default: true
  defaultValue: '-'
  description: The separator between the start and end of range values.
  name: sep
- description: the input value to map.
  isArray: true
  name: value
  required: true
comment: "This script converts an input value into another value using two lists.
  The input value or range is searched in the first list (map_from). \nIf it exists,
  the value at the same index from the second list (map_to) is returned. If there
  is no match, the original value is returned.\nThis script supports mapping from
  either ranges of float numbers or text strings.\n\nExample 1:\n\nmap_from = \"1,2,3,4\"\nmap_to
  = \"4,3,2,1\"\nvalue = 3\n\nOutput is \"2\"\n\nExample 2:\n\nmap_from = \"1-3,4\"\nmap_to
  = \"5,1\"\nvalue = 3\n\nOutput is \"5\"."
commonfields:
  id: MapRangeValues
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.1.0
    itemVersion: 1.2.77
    packID: FiltersAndTransformers
    packName: Filters And Transformers
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
dockerimage: demisto/python3:3.10.14.92207
enabled: true
engineinfo: {}
mainengineinfo: {}
name: MapRangeValues
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('MapRangeValues', 'start', __line__())
  demisto.debug('pack name = Filters And Transformers, pack version = 1.2.77')


  from typing import Union


  VALUE_TYPE = Union[str, float]


  class Replace:

      def __init__(self, value: str, replacement: str):
          self._value = self.get_typed_value(value)
          self.replacement = self.get_typed_value(replacement)

      def should_replace(self, value: VALUE_TYPE) -> bool:
          return self._value == value

      @staticmethod
      def get_typed_value(value: str) -> VALUE_TYPE:
          try:
              demisto.debug(f'MapRangeValues, get_typed_value, the initial {value=}')
              f_value = float(value)
              if f_value % 1 == 0:
                  demisto.debug(f'MapRangeValues, get_typed_value, casting {f_value=} to int')
                  return int(f_value)
              demisto.debug(f'MapRangeValues, get_typed_value, return float {f_value=}')
              return f_value
          except ValueError:
              demisto.debug(f'MapRangeValues, get_typed_value, in ValueError {value=}')
              return str(value)


  class RangeReplace(Replace):
      def __init__(self, start_value: str, end_value: str, replacement: str):
          self._start_value = self.get_typed_value(start_value)
          self._end_value = self.get_typed_value(end_value)
          self.replacement = self.get_typed_value(replacement)

      def should_replace(self, value) -> bool:    # pylint: disable=W9014
          demisto.debug(f'MapRangeValues, RangeReplace class, should_replace {self._start_value=} {value=} {self._end_value=}')
          try:
              return self._start_value <= value <= self._end_value
          except TypeError:
              return False


  def get_replace_list(map_from: list[str], map_to: list[str], sep: str = '-') -> list[Replace]:
      replace_list: list[Replace] = []
      for _from, _to in zip(map_from, map_to):
          try:
              start, end = _from.split(sep)
              replace_list.append(RangeReplace(start, end, _to))
          except ValueError:
              replace_list.append(Replace(_from, _to))

      return replace_list


  def replace_values(values: list[str], replace_list: list[Replace]) -> list[VALUE_TYPE]:
      replaced_list = []
      for value in map(Replace.get_typed_value, values):
          for replace_obj in replace_list:
              if replace_obj.should_replace(value):
                  value = replace_obj.replacement
                  break
          replaced_list.append(value)
      return replaced_list


  def main():  # pragma: no cover
      try:
          args = demisto.args()
          map_from = argToList(args['map_from'])
          map_to = argToList(args['map_to'])
          assert len(map_from) == \
              len(map_to), "the length of 'map_from' list does not match the length of 'map_to' list."
          replace_list = get_replace_list(map_from, map_to, args.get('sep', '-'))
          return_results(replace_values(argToList(args['value']), replace_list))
      except Exception as error:
          return_error(str(error), error)


  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

  register_module_line('MapRangeValues', 'end', __line__())
scripttarget: 0
subtype: python3
system: true
tags:
- transformer
type: python
