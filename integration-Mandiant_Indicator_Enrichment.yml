category: Data Enrichment & Threat Intelligence
commonfields:
  id: Mandiant Indicator Enrichment
  version: -1
configuration:
- defaultvalue: https://api.intelligence.fireeye.com/
  display: Mandiant Advantage API URL
  name: url
  required: true
  type: 0
- additionalinfo: The API Key to use for connection
  display: API Key Id
  displaypassword: API Key Secret
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Get visibility into the latest threats directly from the frontlines through
  indicator enrichment from Mandiant.
detaileddescription: "### Partner Contributed Integration\n\n#### Integration Author:
  Mandiant\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email:** [customersupport@mandiant.com](mailto:customersupport@mandiant.com)\n-
  **URL:** [https://www.mandiant.com/support](https://www.mandiant.com/support)\n\n##
  Getting Started\n\nTo use the integration you will require a valid set of API keys.
  To get API keys associated with a user, \n\n1. Log in to [Mandiant Advantage](https://advantage.mandiant.com)\n2.
  Open the Settings menu\n3. Click the Get Key ID and Secret button\n\nTo request
  keys associated to your organization (recommended for production) please contact
  Customer Support.\n\n## Configuration\n\nRequired fields to complete\n\n| Parameter
  | Description |\n| --------- | ----------- |\n| URL | The base url for the Mandiant
  Threat Intelligence API (https://api.intelligence.mandiant.com) |\n| Credentials
  | The Mandiant API Public and Secret Key values |\n\n## Commands\n\n`!mandiant-enrich-indicator`
  - Enrich an indicator using Mandiant Intelligence\n\nCopyright 2022 Mandiant, Inc"
display: Mandiant Indicator Enrichment
image: data:image/png;base64,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
name: Mandiant Indicator Enrichment
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: The indicator type to be enriched. Use either ipv4, fqdn, md5,
        url
      name: type
      predefined:
      - ipv4
      - fqdn
      - md5
      - url
      required: true
    - description: The value of the indicator to enrich
      name: indicator
      required: true
    - description: Maximum number of reports returned, if any exist
      name: numReports
    description: Enriches a potential Indicator of Compromise with intelligence from
      Mandiant
    name: mandiant-enrich-indicator
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The calculated XSOAR score based on the Mandiant Indicator Confidence
        Score (mscore).
      type: number
    - contextPath: Mandiant.Indicator.first_seen
      description: The date time the indicator was first observed
      type: Date
    - contextPath: Mandiant.Indicator.last_seen
      description: The date time the indicator was most recently observed
      type: Date
    - contextPath: Mandiant.Indicator.sources.first_seen
      description: The date time the indicator was first observed by the specified
        source
      type: Date
    - contextPath: Mandiant.Indicator.sources.last_seen
      description: The date time the indicator was most recently observed by the specified
        source
      type: Date
    - contextPath: Mandiant.Indicator.sources.osint
      description: If true the indicator source is Open Source intelligence, if false
        the indicator source is Mandiant expertise
      type: Boolean
    - contextPath: Mandiant.Indicator.sources.source_name
      description: The name of the source that discovered the indicator
      type: String
    - contextPath: Mandiant.Indicator.associated_hashes.id
      description: The ID of a file hash indicator
      type: String
    - contextPath: Mandiant.Indicator.associated_hashes.type
      description: The type of a file hash represented in the value field
      type: String
    - contextPath: Mandiant.Indicator.associated_hashes.value
      description: The file hash indicator value
      type: String
    - contextPath: Mandiant.Indicator.mscore
      description: The Mandiant Indicator Confidence Score (0 - 100)
      type: Number
    - contextPath: Mandiant.Indicator.attributed_associations.id
      description: The ID of an entity associated with the indicator
      type: String
    - contextPath: Mandiant.Indicator.attributed_associations.name
      description: The name of an entity associated with the indicator
      type: String
    - contextPath: Mandiant.Indicator.attributed_associations.type
      description: The type of an entity associated with the indicator
      type: String
    - contextPath: Mandiant.Indicator.id
      description: The Mandiant ID of the indicator
      type: String
    - contextPath: Mandiant.Indicator.type
      description: The type of the indictator
      type: String
    - contextPath: Mandiant.Indicator.value
      description: The indicator's value
      type: String
    - contextPath: Mandiant.Indicator.last_updated
      description: The date time that the indicator was last updated in the Mandiant
        intel database
      type: Date
    - contextPath: Mandiant.Indicator.reports.report_id
      description: The ID of an associated report
      type: String
    - contextPath: Mandiant.Indicator.reports.report_link
      description: The link to the report in Mandiant Advantage
      type: String
    - contextPath: Mandiant.Indicator.reports.title
      description: The report title
      type: String
    - contextPath: Mandiant.Indicator.reports.published_date
      description: The date time that the report was published
      type: Date
  dockerimage: demisto/python3:3.9.8.24399
  runonce: false
  script: |
    register_module_line('Mandiant', 'start', __line__())
    """Mandiant Indicator Enrichment Integration for Cortex XSOAR (aka Demisto)"""

    import requests
    from typing import Dict, Any

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()  # pylint: disable=no-member


    ''' CONSTANTS '''

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'  # ISO8601 format with UTC, default in XSOAR

    ''' CLIENT CLASS '''


    class MandiantClient(BaseClient):
        """Client class to interact with the Mandiant Threat Intel API v4"""

        def __init__(self, base_url: str, verify: bool, headers: Dict, proxy: bool, keyId: str, keySecret: str):
            super().__init__(base_url=base_url, verify=verify, headers=headers, proxy=proxy)

            # get bearer token from client and secret key
            accessToken = self.mandiant_authenticate(keyId, keySecret)
            headers['Authorization'] = f'Bearer {accessToken}'

        def baseintegration_mandiant_url(self, url: str) -> Dict[str, str]:
            return {"url": url}

        def mandiant_authenticate(self, keyId: str, keySecret: str) -> str:
            body = {
                'grant_type': 'client_credentials'
            }
            response = self._http_request(method='POST', auth=(keyId, keySecret), url_suffix='token', resp_type='json', data=body)

            return response.get('access_token')

        # call: https://api.intelligence.fireeye.com/v4/{type}/indicator
        def mandiant_enrich_indicator(self, type: str, indicator: str, numReports: int) -> CommandResults:
            requestUrl = urljoin("v4/indicator", type)
            requestUrl = urljoin(requestUrl, indicator)

            try:
                # Check Entitlement
                entitlements = self._http_request(method="GET", url_suffix="v4/entitlements", timeout=10).get("entitlements", [])
                if "INTEL_RBI_FUS" not in entitlements or "INTEL_RBI_OPS" not in entitlements:
                    demisto.debug(f'Fusion or SecOps entitlement not found for keys. Entitlements discovered: {str(entitlements)}')
                    return [CommandResults(
                        readable_output=f'Specified keys not entitled to use integration'
                    )]
                else:
                    result = self._http_request(method="GET", url_suffix=requestUrl, timeout=10)
            except DemistoException as e:
                demisto.debug(f'Exception {str(e)} when querying {requestUrl}')
                if "404" in e.message:
                    return [CommandResults(
                        readable_output=f'Specified indicator {indicator} of type {type} not found in Mandiant Intelligence'
                    )]
                else:
                    raise e
            if 'misp' in result:
                del result['misp']
            if 'is_publishable' in result:
                del result['is_publishable']

            indicator = self.generate_dbot(result)

            if numReports < 1:
                markdown = self.generate_markdown(result)
                command_results = CommandResults(
                    readable_output=markdown,
                    outputs_prefix='Mandiant.Indicator',
                    outputs_key_field='id',
                    outputs=result,
                    indicator=indicator
                )
                return command_results
            else:
                if len(result.get("attributed_associations", [])) < 1:
                    # demisto.error("xMandiant no associations returning")
                    # no associations, so there can't be any reports
                    markdown = self.generate_markdown(result)
                    command_results = CommandResults(
                        readable_output=markdown,
                        outputs_prefix='Mandiant.Indicator',
                        outputs_key_field='id',
                        outputs=result,
                        indicator=indicator,
                    )

                    return command_results
                else:
                    # Get reports, first go through all the attributed_associations, then for each malware/actor
                    # call the reports endpoint and aggregate the response... need to sort by date and truncate to the
                    # requested number of reports. types possible are threat-actor and malware
                    associations = result.get('attributed_associations')
                    aggregateReports: list = []
                    for association in associations:
                        if association.get("type") == 'threat-actor':
                            # demisto.error("xMandiant found threat-actor")
                            aggregateReports = aggregateReports + report_processing(self, association, "v4/actor")
                        elif association.get("type") == 'malware':
                            # demisto.error("xMandiant found malware")
                            aggregateReports = aggregateReports + report_processing(self, association, "v4/malware")
                        else:
                            demisto.error(f'xMandiant found unknown association type: {association.get("type")}')
                    # demisto.error(f'xMandiant aggregated reports count: {len(aggregateReports)}')
                    # demisto.error(f'xMandiant unsorted {aggregateReports}')
                    sortedReports = sorted(aggregateReports, key=key_func, reverse=True)
                    # demisto.error(f'xMandiant sorted {sortedReports}')
                    truncatedReports = sortedReports[:numReports]

                    # merge the truncated reports into the result
                    # markdown = '### This is the Header\n'
                    result["reports"] = truncatedReports
                    markdown = self.generate_markdown(result)
                    command_results = CommandResults(
                        readable_output=markdown,
                        outputs_prefix='Mandiant.Indicator',
                        outputs_key_field='id',
                        outputs=result,
                        indicator=indicator,
                    )

                    return command_results

        def generate_dbot(self, response_json: dict) -> Common.Indicator:
            mscore = int(response_json.get('mscore', '-1'))

            if mscore <= 20:
                score = Common.DBotScore.NONE
            elif 21 <= mscore <= 40:
                score = Common.DBotScore.GOOD
            elif 41 <= mscore <= 80:
                score = Common.DBotScore.SUSPICIOUS
            else:
                score = Common.DBotScore.BAD

            DBotScore = Common.DBotScore(
                integration_name="Mandiant",
                indicator=response_json['value'],
                indicator_type=DBotScoreType.CUSTOM,
                score=score
            )

            if response_json['type'] == 'ipv4':
                DBotScore.indicator_type = DBotScoreType.IP
                return Common.IP(
                    ip=response_json['value'],
                    dbot_score=DBotScore,
                )
            elif response_json['type'] == 'fqdn':
                DBotScore.indicator_type = DBotScoreType.DOMAIN
                return Common.Domain(
                    domain=response_json['value'],
                    dbot_score=DBotScore
                )
            elif response_json['type'] == 'md5':
                DBotScore.indicator_type = DBotScoreType.FILE
                return Common.File(
                    md5=response_json['value'],
                    dbot_score=DBotScore,
                )
            elif response_json['type'] == 'url':
                DBotScore.indicator_type = DBotScoreType.URL
                return Common.URL(
                    url=response_json['value'],
                    dbot_score=DBotScore,
                )
            else:
                raise Exception("Could not map to indicator")

        def generate_markdown(self, response_json: dict) -> str:

            markdown = ""

            # Title
            markdown += f"# Mandiant Indicator Enrichment for: {response_json.get('value')}\n"

            # Indicator Details
            markdown += "## Indicator Details\n"
            markdown += f"**Type:** {response_json.get('type')}\n"
            markdown += f"**Value:** {response_json.get('value')}\n"
            markdown += f"**First Seen:** {response_json.get('first_seen')}\n"
            markdown += f"**Last Seen:** {response_json.get('last_seen')}\n"
            markdown += f"**Last Updated:** {response_json.get('last_updated')}\n"
            markdown += f"**Indicator Confidence Score:** {response_json.get('mscore')}\n"

            # Associated Hashes
            if "associated_hashes" in response_json:
                markdown += "## Associated Hashes\n"
                for hash in response_json.get("associated_hashes", []):
                    markdown += f"**{hash.get('type')}:** {hash.get('value')}\n"

            # Attributed Associations
            markdown += "## Attributed Associations\n"
            if len(response_json.get("attributed_associations", [])) == 0:
                markdown += "No associated attributions found\n"
            else:
                markdown += "| Type | Name | More information |\n"
                markdown += "| ---- | ---- | ---------------- |\n"
                for association in response_json.get("attributed_associations", []):
                    if association.get("type") == "malware":
                        markdown += f"| {association.get('type')} | {association.get('name')}" \
                            f" | https://advantage.mandiant.com/malware/{association.get('id')} |\n"
                    elif association.get("type") == "threat-actor":
                        markdown += f"| {association.get('type')} | {association.get('name')}" \
                            f" | https://advantage.mandiant.com/actors/{association.get('id')} |\n"

            # Reports
            markdown += "## Associated Reports\n"
            if len(response_json.get("reports", [])) == 0:
                markdown += "No associated reports found\n"
            else:
                markdown += "| Title | Date Published | Link |\n"
                markdown += "| ---- | ---- | ---------------- |\n"
                for report in response_json.get("reports", []):
                    markdown += f"| {report.get('title')} | {report.get('published_date')} | {report.get('report_link')} |\n"
            return markdown


    ''' HELPER FUNCTIONS '''

    report_vals_to_keep = ["report_id", "title", "published_date"]


    def report_processing(client: MandiantClient, association: dict, endpoint: str) -> list:
        requestUrl = urljoin(endpoint, association.get("id"))
        requestUrl = urljoin(requestUrl, "reports")
        reportResult = client._http_request(method='GET', url_suffix=requestUrl, timeout=10)
        # Using a value whitelist so new values don't sneak in over time.
        for report in reportResult.get("reports", []):
            for key in list(report.keys()):
                if key not in report_vals_to_keep:
                    del report[key]
            report['report_link'] = f'https://advantage.mandiant.com/reports/{report["report_id"]}'
        return reportResult.get("reports", [])


    def key_func(report):
        timeString = report.get("published_date")
        # example ret "March 14, 2018 03:17:00 PM"
        return datetime.strptime(timeString, '%B %d, %Y %I:%M:%S %p')


    valid_entitlements = ["INTEL_RBI_FUS", "INTEL_RBI_OPS"]


    def validate_entitlements(customer_entitlements: list) -> bool:
        for valid_entitlement in valid_entitlements:
            if valid_entitlement in customer_entitlements:
                return True
        return False


    ''' COMMAND FUNCTIONS '''


    def test_module(client: MandiantClient) -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type client: ``Client``
        :param Client: client to use

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """

        message: str = ''
        try:

            requestUrl = "v4/entitlements"
            # demisto.error("xMandiant request entitlements")

            response = client._http_request(method="GET", url_suffix=requestUrl, timeout=10)
            # Check that the keys are licensed to use the integration
            entitlements = response.get("entitlements", [])
            if(validate_entitlements(entitlements)):
                message = 'ok'
            else:
                message = "Connection successful but the API keys defined are not licensed for this integration." \
                    " A Mandiant Fusion or SecOps license is required. Please contact Mandiant Customer Support for assistance."
        except DemistoException as e:
            if 'Forbidden' in str(e) or 'Authorization' in str(e):
                message = 'Authorization Error: make sure API Key is correctly set'
            elif 'Unauthorized' in str(e):
                message = 'Unauthorized: check Key Id and Key Secret'
            else:
                raise e
        return message


    def mandiant_enrich_indicator(client: MandiantClient, args: Dict[str, Any]) -> CommandResults:
        type = args.get('type', None)
        indicator = args.get('indicator', None)

        try:
            numReports = int(args.get('numReports', 5))
        except ValueError:
            raise ValueError('numReports must be a positive integer value specifying the number of reports to return.')

        # cannot find a way to get to these cases through the warroom cli
        if not type:
            raise ValueError('type not specified')
        if not indicator:
            raise ValueError('indicator not specified')

        # Call the Client function and get the raw response
        result = client.mandiant_enrich_indicator(type, indicator, numReports)

        # get reports, check for actors and malwares and run report queries for them
        return result


    ''' MAIN FUNCTION '''


    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """

        auth = demisto.params().get('credentials', {})
        keyId = auth.get('identifier', None)
        keySecret = auth.get('password', None)

        # get the service API url
        base_url = demisto.params()['url']

        verify_certificate = not demisto.params().get('insecure', False)

        proxy = demisto.params().get('proxy', False)

        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            headers: Dict = {}
            headers['X-App-Name'] = "xsoar.integration.1.0"
            headers['Accept'] = "application/json"

            client = MandiantClient(
                base_url=base_url,
                verify=verify_certificate,
                headers=headers,
                proxy=proxy,
                keyId=keyId,
                keySecret=keySecret)

            if demisto.command() == 'test-module':
                result = test_module(client)
                return_results(result)
            elif demisto.command() == 'mandiant-enrich-indicator':
                demisto.debug(f'mandiant-enrich-indicator called with {demisto.args()}')
                return_results(mandiant_enrich_indicator(client, demisto.args()))

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Mandiant', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Mandiant
