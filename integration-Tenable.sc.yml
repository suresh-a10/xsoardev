category: Vulnerability Management
commonfields:
  id: Tenable.sc
  version: -1
configuration:
- additionalinfo: The server URL.
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  section: Connect
  type: 0
- additionalinfo: See the help for instructions to generate the access key.
  display: Access key
  displaypassword: Secret key
  name: creds_keys
  required: false
  section: Connect
  type: 9
- additionalinfo: The Username is either admin or secman (depend on the role you want
    to log into) and your password to the tenable server.
  display: Username
  hiddenpassword: true
  hiddenusername: true
  name: credentials
  required: false
  section: Connect
  type: 9
- advanced: true
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: The timestamp to start the fetch from.
  defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  section: Collect
  type: 0
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.0.12
    packID: Tenable_sc
    packName: Tenable.sc
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: With Tenable.sc (formerly SecurityCenter) you get a real-time, continuous
  assessment of your security posture so you can find and fix vulnerabilities faster.
detaileddescription: "Use the Tenable.sc integration to get a real-time, continuous
  assessment of your security posture so you can find and fix vulnerabilities faster.\nAll
  data in Tenable.sc is managed using group level permissions. If you have several
  groups, data (scans, scan results, assets, etc.) can be viewable but not manageable.
  Users with Security Manager roleÂ  can manage everything. These permissions come
  into play when multiple groups are in use.\nIt is important to know what data is
  manageable for the user in order to work with the integration.\n\n## Use cases:\n\n
  \   * Create and run scans.\n    * Launch and manage scan results and the found
  vulnerabilities.\n    * Create and view assets.\n    * View policies, repositories,
  credentials, users and more system information.\n    * View alerts received in real-time.\n\n**Added
  support for secret & access keys authentication method.** \n\n- Added support for
  secret & access keys authentication method (API Key Authentication) which can be
  generated from the Tenable SC UI while logged into the desired account.\n- Secret
  & access keys needs to be generated twice, once for secman and once for admin.\n-
  First, you need to enable API Key Authentication:\n\n## [Steps to follow:](https://docs.tenable.com/security-center/Content/EnableAPIKeys.htm)\n\n
  \     1. Log in to Tenable Security Center via the user interface.\n      2. Go
  to **System** > **Configuration**.\n      3. Click the **Security** tile.\n      4.
  In the Authentication Settings section, click **Allow API Keys** to enable the toggle.\n
  \     5. Click **Submit**.\n\n- Second, you need to generate the API Key: \n\n##
  [Steps to follow:](https://docs.tenable.com/security-center/Content/GenerateAPIKey.htm)\n\n
  \     1. Log in to Tenable Security Center via the user interface.\n      2. Go
  to **Users** > **Users**.\n      3. Right-click the row for the user for which you
  want to generate an API key.\n        -or-\n        Select the checkbox for the
  user for which you want to generate an API key.\n      4. Click **API Keys** > **Generate
  API Key**.\n      5. Click **Generate**.\n      6. The API Key window appears, displaying
  the access key and secret key for the user. Save the API keys in a safe location.\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/tenablesc)"
display: Tenable.sc
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAABBVBMVEUAAABFVWVIV2ZEVWZIV2hJW2lFVWVFVWVKXGpOXnMAqLYAp7ZEVGQAp7UAqLYAqLZsdIAAp7ZEVWUAp7UAp7UAqLUAp7VFVWUAp7UAqLUAqLZEVGQAqLZFVWUAqLYAqLdEVGUAp7UAp7UAp7VEVWQAp7YAussAp7UAp7UAp7UAqLZFVmZHV2YAr7xQZHNEVWRFVWRFVWVFV2YAqbYAt8FEVGVEVWVFVWZGVmUAqrhIWGlMWmxFVGVEVWVFVWVFVWRGVWYAqLZHV2YAqrYArbtFVGUAqbVFWGlHV2lFVWREVWUAp7QAp7VGV2ZEVWVGVmVFVmYArLdEVWREVmUAq7dEVWVEVGQidPTWAAAAVnRSTlMAjCF7JhjRmRUMdmD0h2pSBIv8k4+voZ+Yb0/qZGRKRLy1qZyWgwXFgH5ZRjMQCPm1h008CfB1XEIoHxDj24+CbkE5LhewNyob5sK8pC+rVFEgpqEz5PhyY/gAAAQ1SURBVFjD7ZTZctowFEAva8DGNsZL7GDM4pp9h7AECBAC2ZukTfX/n1ItcQwkM51Op+lDOQ/oXkvWsdCV4MCBAwcO/D4be9yHf4BQbUiKXukV4XMRpJ7r3JXypVJBHMPnIQj31lJdFkWh52qybpzAH/AFIRTz0yBOA/Axap6/dK2GxHFiybpU+L5ZBcZjIBCI/zWxWlqZjpzXtILCibrSs8pFAxhHZJK/JZbvqiVBtmyxAStx495XZc7S/0B89EvxpHZFvIWCmS1nTVZTtsVrDa4krD6apNnccyST4NPcEzffi5Ns20adIfZWS32zzGXhlSKv3vdPShydoj3Fb+Xa30hydXyDUPpbncSZdrsdiQVmqVZ0QN1nnWgLJWbnZ564vk6gxNfwtvj6fIZQYl3D0WMNXIlTQTGK4HOpCS/3GolmiJHGcSiFGHOcBHCbOWX5Gi+k43Wmukw8YA8SQ188TCDGd/qpOiiVfn73+HC8IZaKu+I5eiNDxT4juPCTRJiIfeqeeMg+DJGMihvlii3vinmzXL1b4mAxj+Jx5/MB1HE7fZrER/hBesLEt4vRgKw6BNBGucxDcDgjo5k4t6iFSOftqziC13uaiTXrOYRaZAfKWb4i23tiUZUc4e1oRHC7xsOvABNLI9Sh4nO62Tg4xvufAcIVMVLxnKRhLEMXTNzBv11aX/jTv+K2J9sVY/NerOjb4iae4jZOOUYoSsVBOjcTw+RxMHxIQpp0HtF3MNQ2YGKsu4lTBng/kriINUmoZPfEriipcsMX0/l9Wr44wsQDWjg3j1MiZu8QuuSPYeIU2oYUf0EsjK09cWEjqXZvS/yAdojviTNe4aR2VkyL7oiKm2gHciZN3TjhdsViYVWV+9aW+Bo3s9AbzT1xGv8u4qRwtsWskjtsxaS2/Amucef4riyVK9ve4j23cu2s5InJqCnemIk/ZFd8hki9EG488RlNyYcMqZiGV7BDXgNJE5/BI1t2N6t8VgFP3H01teO0nBYfir8D4YcnjgbJtULq4ZqJM+RhhL4SAoaR54q8Y/N9mo3NpWg+awrzQohcH19z+BSR4HzRyaXQaF+cTGPBE0DsGHlilIq2bxBVUjE9RShxtJivWygDlGrVkE9454XHG90Qs5J1knfzCjBGiBKBi1PkEQX4qLhO01vFNUWMH5NXMQTZIzoyzq5mYWlmVZOzTNWVhYLrOOO8AR7fEWL/djiHKKl18J0Y5i16XWamnvjhFhHaMf+ujn1LIcrtBTB0WAp9scCPObnS2yi9Z80Bn/CoO2KlEruodWsPExqGw+EkvYdwEKF9T916E4Lh8BlEaGew9lQLe0NiQJjU8QT1mF9NellSpYahNPDq+UbFMeCzeLac/J3BFRzdFCoS2V+bW8En8cJpmmpfwtKgFcfZ8Hn0s4Kuq0Vacb0iHDhw4MCB/5yfYHowcdS9KS4AAAAASUVORK5CYII=
name: Tenable.sc
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable scans. Returns both usable and
        manageable scans by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Get a list of Tenable.sc existing
      scans.
    name: tenable-sc-list-scans
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name.
      type: string
    - contextPath: TenableSC.Scan.ID
      description: Scan ID.
      type: number
    - contextPath: TenableSC.Scan.Description
      description: Scan description.
      type: string
    - contextPath: TenableSC.Scan.Policy
      description: Scan policy name.
      type: string
    - contextPath: TenableSC.Scan.Group
      description: Scan policy owner group name.
      type: string
    - contextPath: TenableSC.Scan.Owner
      description: Scan policy owner user name.
      type: string
  - arguments:
    - description: Scan ID, can be retrieved from list-scans command.
      name: scan_id
      required: true
    - description: Valid IP/Hostname of a specific target to scan. Must be provided
        with diagnosticPassword.
      name: diagnostic_target
    - description: Non empty string password.
      name: diagnostic_password
    - defaultValue: "10800"
      description: Relevant only when polling is true. Default is 3 hours. The timeout
        in seconds until polling ends.
      name: timeout_in_seconds
    - auto: PREDEFINED
      defaultValue: "false"
      description: Default is false. When set to true, will keep polling results until
        scan is done and return the formatted scan results.
      name: polling
      predefined:
      - "true"
      - "false"
    - deprecated: true
      description: Deprecated. Scan results ID.
      name: scan_results_id
    description: Requires security manager role. Launch an existing scan from Tenable.sc.
      Set polling to true to follow the scan and receive results when scan is over.
    name: tenable-sc-launch-scan
    outputs:
    - contextPath: TenableSC.ScanResults.Name
      description: Scan name.
      type: string
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status.
      type: string
    - contextPath: TenableSC.ScanResults.ID
      description: Scan Results ID.
      type: string
    - contextPath: TenableSC.ScanResults.OwnerID
      description: Relevant only when polling is false. Scan owner ID.
      type: string
    - contextPath: TenableSC.ScanResults.JobID
      description: Relevant only when polling is false. Job ID.
      type: string
    - contextPath: TenableSC.ScanResults.ScannedIPs
      description: Relevant only when polling is true. Scan number of scanned IPs.
      type: number
    - contextPath: TenableSC.ScanResults.StartTime
      description: Relevant only when polling is true. Scan start time.
      type: date
    - contextPath: TenableSC.ScanResults.EndTime
      description: Relevant only when polling is true. Scan end time.
      type: date
    - contextPath: TenableSC.ScanResults.Checks
      description: Relevant only when polling is true. Scan completed checks.
      type: number
    - contextPath: TenableSC.ScanResults.RepositoryName
      description: Relevant only when polling is true. Scan repository name.
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Relevant only when polling is true. Scan description.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.ID
      description: Relevant only when polling is true. Scan vulnerability ID.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Name
      description: Relevant only when polling is true. Scan vulnerability Name.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Family
      description: Relevant only when polling is true. Scan vulnerability family.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Severity
      description: Relevant only when polling is true. Scan vulnerability severity.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Total
      description: Relevant only when polling is true. Scan vulnerability total hosts.
      type: number
    - contextPath: TenableSC.ScanResults.Policy
      description: Relevant only when polling is true. Scan policy.
      type: string
    - contextPath: TenableSC.ScanResults.Group
      description: Relevant only when polling is true. Scan owner group name.
      type: string
    - contextPath: TenableSC.ScanResults.Owner
      description: Relevant only when polling is true. Scan owner user name.
      type: string
    - contextPath: TenableSC.ScanResults.Duration
      description: Relevant only when polling is true. Scan duration in minutes.
      type: number
    - contextPath: TenableSC.ScanResults.ImportTime
      description: Relevant only when polling is true. Scan import time.
      type: date
    polling: true
  - arguments:
    - description: Vulnerability ID from the scan-report command.
      name: vulnerability_id
      required: true
    - description: Scan results ID from the scan-report command.
      name: scan_results_id
    - description: Can be created via the Tenable.sc UI > Analysis > queries. Can
        be retrieved from the tenable-sc-list-query command.
      name: query_id
    - auto: PREDEFINED
      defaultValue: ASC
      description: The direction in which the results should be sorted. Requires companion
        parameter, sort_field.
      name: sort_direction
      predefined:
      - ASC
      - DESC
    - defaultValue: severity
      description: Which field to sort by, For vulnerabilities data, Tenable recommends
        you sort by severity.
      name: sort_field
    - auto: PREDEFINED
      defaultValue: individual
      description: When the source_type is "individual", a scan_results_id must be
        provided, otherwise "query_id" must be provided. cumulative â Analyzes cumulative
        vulnerabilities. patched â Analyzes mitigated vulnerabilities.
      name: source_type
      predefined:
      - individual
      - cumulative
      - patched
    - defaultValue: "50"
      description: The number of objects to return in one response (maximum limit
        is 200).
      name: limit
    - defaultValue: "0"
      description: The page to return, starting from 0.
      name: page
    description: Requires security manager role. Get details about a given vulnerability
      from a given Tenable.sc scan.
    name: tenable-sc-get-vulnerability
    outputs:
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.ID
      description: Vulnerability plugin ID.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Name
      description: Vulnerability name.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Description
      description: Vulnerability description.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Type
      description: Vulnerability type.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Severity
      description: Vulnerability Severity.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Synopsis
      description: Vulnerability Synopsis.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Solution
      description: Vulnerability Solution.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Published
      description: Vulnerability publish date.
      type: date
    - contextPath: TenableSC.ScanResults.Vulnerability.CPE
      description: Vulnerability CPE.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.CVE
      description: Vulnerability CVE.
      type: Unknown
    - contextPath: TenableSC.ScanResults.Vulnerability.ExploitAvailable
      description: Vulnerability exploit available.
      type: boolean
    - contextPath: TenableSC.ScanResults.Vulnerability.ExploitEase
      description: Vulnerability exploit ease.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.RiskFactor
      description: Vulnerability risk factor.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSBaseScore
      description: Vulnerability CVSS base score.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSTemporalScore
      description: Vulnerability CVSS temporal score.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.CVSSVector
      description: Vulnerability CVSS vector.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.PluginDetails
      description: Vulnerability plugin details.
      type: Unknown
    - contextPath: CVE.ID
      description: CVE ID.
      type: Unknown
    - contextPath: TenableSC.ScanResults.Vulnerability.Host.IP
      description: Vulnerability Host IP.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Host.MAC
      description: Vulnerability Host MAC.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Host.Port
      description: Vulnerability Host Port.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Host.Protocol
      description: Vulnerability Host Protocol.
      type: string
  - arguments:
    - description: Scan results ID from the launch-scan command.
      isArray: true
      name: scan_results_id
      required: true
    description: Requires security manager role. Get the status of a specific scan
      in Tenable.sc.
    name: tenable-sc-get-scan-status
    outputs:
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status.
      type: string
    - contextPath: TenableSC.ScanResults.Name
      description: Scan Name.
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Scan description.
      type: string
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID.
      type: string
    - contextPath: TenableSC.ScanResults.Error
      description: Will appear only in case of error in the scan, include the cause
        for the failure.
      type: string
  - arguments:
    - description: Scan results ID.
      name: scan_results_id
      required: true
    - defaultValue: Critical,High,Medium,Low,Info
      description: Comma-separated list of severity values of vulnerabilities to retrieve.
      isArray: true
      name: vulnerability_severity
    description: Requires security manager role. Get a single report with Tenable.sc
      scan results. In case of `Importstatus = Error` (The results import wasn't finished),
      the vulnerabilities section will not be added to the results.
    name: tenable-sc-get-scan-report
    outputs:
    - contextPath: TenableSC.ScanResults.ID
      description: Scan results ID.
      type: number
    - contextPath: TenableSC.ScanResults.Name
      description: Scan name.
      type: string
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status.
      type: string
    - contextPath: TenableSC.ScanResults.ScannedIPs
      description: Scan number of scanned IPs.
      type: number
    - contextPath: TenableSC.ScanResults.StartTime
      description: Scan start time.
      type: date
    - contextPath: TenableSC.ScanResults.EndTime
      description: Scan end time.
      type: date
    - contextPath: TenableSC.ScanResults.Checks
      description: Scan completed checks.
      type: number
    - contextPath: TenableSC.ScanResults.RepositoryName
      description: Scan repository name.
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Scan description.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.ID
      description: Scan vulnerability ID.
      type: number
    - contextPath: TenableSC.ScanResults.Vulnerability.Name
      description: Scan vulnerability Name.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Family
      description: Scan vulnerability family.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Severity
      description: Scan vulnerability severity.
      type: string
    - contextPath: TenableSC.ScanResults.Vulnerability.Total
      description: Scan vulnerability total hosts.
      type: number
    - contextPath: TenableSC.ScanResults.Policy
      description: Scan policy.
      type: string
    - contextPath: TenableSC.ScanResults.Group
      description: Scan owner group name.
      type: string
    - contextPath: TenableSC.ScanResults.Owner
      description: Scan owner user name.
      type: string
    - contextPath: TenableSC.ScanResults.Duration
      description: Scan duration in minutes.
      type: number
    - contextPath: TenableSC.ScanResults.ImportTime
      description: Scan import time.
      type: date
    - contextPath: TenableSC.ScanResults.IsScanRunning
      description: Whether the scan is still running.
      type: boolean
    - contextPath: TenableSC.ScanResults.ImportStatus
      description: Scan import status.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable scan credentials. Returns both
        usable and manageable by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Get a list of Tenable.sc credentials.
    name: tenable-sc-list-credentials
    outputs:
    - contextPath: TenableSC.Credential.Name
      description: Credential name.
      type: string
    - contextPath: TenableSC.Credential.ID
      description: Credential ID.
      type: number
    - contextPath: TenableSC.Credential.Description
      description: Credential description.
      type: string
    - contextPath: TenableSC.Credential.Type
      description: Credential type.
      type: string
    - contextPath: TenableSC.Credential.Tag
      description: Credential tag.
      type: string
    - contextPath: TenableSC.Credential.Group
      description: Credential owner group name.
      type: string
    - contextPath: TenableSC.Credential.Owner
      description: Credential owner user name.
      type: string
    - contextPath: TenableSC.Credential.LastModified
      description: Credential last modified time.
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable scan policies. Returns both usable
        and manageable by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Get a list of Tenable.sc scan policies.
    name: tenable-sc-list-policies
    outputs:
    - contextPath: TenableSC.ScanPolicy.Name
      description: Scan policy name.
      type: string
    - contextPath: TenableSC.ScanPolicy.ID
      description: Scan policy ID.
      type: number
    - contextPath: TenableSC.ScanPolicy.Description
      description: Scan policy description.
      type: string
    - contextPath: TenableSC.ScanPolicy.Tag
      description: Scan policy tag.
      type: string
    - contextPath: TenableSC.ScanPolicy.Group
      description: Scan policy owner group name.
      type: string
    - contextPath: TenableSC.ScanPolicy.Owner
      description: Scan policy owner user name.
      type: string
    - contextPath: TenableSC.ScanPolicy.LastModified
      description: Scan policy last modified time.
      type: date
    - contextPath: TenableSC.ScanPolicy.Type
      description: Scan policy type.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable reports. Returns both usable
        and manageable by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Get a list of Tenable.sc report definitions.
    name: tenable-sc-list-report-definitions
    outputs:
    - contextPath: TenableSC.ReportDefinition.Name
      description: Report definition name.
      type: string
    - contextPath: TenableSC.ReportDefinition.ID
      description: Report definition ID.
      type: number
    - contextPath: TenableSC.ReportDefinition.Description
      description: Report definition description.
      type: string
    - contextPath: TenableSC.ReportDefinition.Type
      description: Report definition type.
      type: string
    - contextPath: TenableSC.ReportDefinition.Group
      description: Report definition owner group name.
      type: string
    - contextPath: TenableSC.ReportDefinition.Owner
      description: Report definition owner user name.
      type: string
  - arguments: []
    description: Requires security manager role. Get a list of Tenable.sc scan repositories.
    name: tenable-sc-list-repositories
    outputs:
    - contextPath: TenableSC.ScanRepository.Name
      description: Scan Repository name.
      type: string
    - contextPath: TenableSC.ScanRepository.ID
      description: Scan Repository ID.
      type: number
    - contextPath: TenableSC.ScanRepository.Description
      description: Scan Repository.
      type: string
  - arguments: []
    description: Requires admin role. Get a list of Tenable.sc scan zones.
    name: tenable-sc-list-zones
    outputs:
    - contextPath: TenableSC.ScanZone.Name
      description: Scan Zone name.
      type: string
    - contextPath: TenableSC.ScanZone.ID
      description: Scan Zone ID.
      type: number
    - contextPath: TenableSC.ScanZone.Description
      description: Scan Zone description.
      type: string
    - contextPath: TenableSC.ScanZone.IPList
      description: Scan Zone IP list.
      type: unknown
    - contextPath: TenableSC.ScanZone.ActiveScanners
      description: Scan Zone active scanners.
      type: number
    - contextPath: TenableSC.ScanZone.Scanner.Name
      description: Scanner name.
      type: string
    - contextPath: TenableSC.ScanZone.Scanner.ID
      description: Scanner ID.
      type: number
    - contextPath: TenableSC.ScanZone.Scanner.Description
      description: Scanner description.
      type: string
    - contextPath: TenableSC.ScanZone.Scanner.Status
      description: Scanner status.
      type: number
  - arguments:
    - description: Scan name.
      name: name
      required: true
    - description: Policy ID, can be retrieved from the list-policies command.
      name: policy_id
      required: true
    - description: Plugin ID.
      name: plugin_id
    - description: Scan description.
      name: description
    - description: Scan Repository ID. Can be retrieved from the list-repositories
        command.
      name: repository_id
      required: true
    - description: Scan zone ID (default is all zones). Can be retrieved from the
        list-zones command.
      name: zone_id
    - auto: PREDEFINED
      description: Schedule for the scan.
      name: schedule
      predefined:
      - dependent
      - ical
      - never
      - rollover
      - now
    - auto: PREDEFINED
      description: Either all assets or comma-separated asset IDs to scan. Can be
        retrieved from the list-assets command.
      isArray: true
      name: asset_ids
      predefined:
      - All
      - AllManageable
    - auto: PREDEFINED
      description: Whether to include virtual hosts. Default is false.
      name: scan_virtual_hosts
      predefined:
      - "true"
      - "false"
    - description: Comma-separated IPs to scan, e.g., 10.0.0.1,10.0.0.2 .
      name: ip_list
    - description: Comma- separated list of report definition IDs to create post-scan.
        Can be retrieved from the list-report-definitions command.
      isArray: true
      name: report_ids
    - description: Comma-separated credentials IDs to use. Can be retrieved from the
        list-credentials command.
      isArray: true
      name: credentials
    - auto: PREDEFINED
      description: Scan timeout action. Default is import.
      name: timeout_action
      predefined:
      - discard
      - import
      - rollover
    - description: Maximum scan run time in hours, Default is 1.
      name: max_scan_time
    - auto: PREDEFINED
      description: Track hosts which have been issued new IP address, (e.g., DHCP).
      name: dhcp_tracking
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Scan rollover type.
      name: rollover_type
      predefined:
      - nextDay
    - description: Dependent scan ID in case of a dependent schedule. Can be retrieved
        from the list-scans command.
      name: dependent_id
    - description: 'The timezone for the given start_time, Possible values can be
        found here: https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html.'
      name: time_zone
    - description: The scan start time in the format of YYYY-MM-DD:HH:MM:SS or relative
        timestamp (i.e., now, 3 days).
      name: start_time
    - auto: PREDEFINED
      description: Specifies repeating events based on an interval of a repeat_rule_freq
        or more.
      name: repeat_rule_freq
      predefined:
      - HOURLY
      - DAILY
      - WEEKLY
      - MONTHLY
      - YEARLY
    - description: 'The number of repeat_rule_freq between each interval (for example:
        If repeat_rule_freq=DAILY and repeat_rule_interval=8 it means every eight
        days.)'
      name: repeat_rule_interval
    - description: 'A comma-separated list of days of the week to run the schedule.
        Possible values are: SU,MO,TU,WE,TH,FR,SA.'
      isArray: true
      name: repeat_rule_by_day
    - auto: PREDEFINED
      defaultValue: "true"
      description: The "enabled" field can only be set to "false" for schedules of
        type "ical". For all other schedules types, "enabled" is set to "true".
      name: enabled
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Create a scan on Tenable.sc
    name: tenable-sc-create-scan
    outputs:
    - contextPath: TenableSC.Scan.ID
      description: Scan ID.
      type: string
    - contextPath: TenableSC.Scan.CreatorID
      description: Scan's creator ID.
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name.
      type: string
    - contextPath: TenableSC.Scan.Type
      description: Scan type.
      type: string
    - contextPath: TenableSC.Scan.CreatedTime
      description: Scan creation time.
      type: date
    - contextPath: TenableSC.Scan.OwnerName
      description: Scan owner Username.
      type: string
    - contextPath: TenableSC.Scan.Reports
      description: Scan report definition IDs.
      type: unknown
  - arguments:
    - description: Scan ID. Can be retrieved from the the list-scans command.
      name: scan_id
      required: true
    description: Requires security manager role. Delete a scan in Tenable.sc.
    name: tenable-sc-delete-scan
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable assets. Returns both usable and
        manageable by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. Get a list of Tenable.sc assets.
    name: tenable-sc-list-assets
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID.
      type: string
    - contextPath: TenableSC.Asset.Name
      description: Asset name.
      type: string
    - contextPath: TenableSC.Asset.HostCount
      description: Asset host IPs count.
      type: number
    - contextPath: TenableSC.Asset.Type
      description: Asset type.
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset tag.
      type: string
    - contextPath: TenableSC.Asset.Owner
      description: Asset owner username.
      type: string
    - contextPath: TenableSC.Asset.Group
      description: Asset group.
      type: string
    - contextPath: TenableSC.Asset.LastModified
      description: Asset last modified time.
      type: date
  - arguments:
    - description: Asset name.
      name: name
      required: true
    - description: Asset description.
      name: description
    - description: Asset owner ID. Default is the Session User ID. Can be retrieved
        from the list-users command.
      name: owner_id
    - description: Asset tag.
      isArray: true
      name: tag
    - description: Comma-separated list of IPs to include in the asset, e.g., 10.0.0.2,10.0.0.4.
      name: ip_list
      required: true
    description: Requires security manager role. Create an asset in Tenable.sc with
      provided IP addresses.
    name: tenable-sc-create-asset
    outputs:
    - contextPath: TenableSC.Asset.Name
      description: Asset name.
      type: string
    - contextPath: TenableSC.Asset.ID
      description: Asset ID.
      type: string
    - contextPath: TenableSC.Asset.OwnerName
      description: Asset owner name.
      type: string
    - contextPath: TenableSC.Asset.Tags
      description: Asset tags.
      type: string
  - arguments:
    - description: Asset ID that can be retrieved from the list-assets command.
      name: asset_id
      required: true
    description: Requires security manager role. Get details for a given asset in
      Tenable.sc.
    name: tenable-sc-get-asset
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID.
      type: number
    - contextPath: TenableSC.Asset.Name
      description: Asset name.
      type: string
    - contextPath: TenableSC.Asset.Description
      description: Asset description.
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset tag.
      type: string
    - contextPath: TenableSC.Asset.Modified
      description: Asset last modified time.
      type: date
    - contextPath: TenableSC.Asset.Owner
      description: Asset owner user name.
      type: string
    - contextPath: TenableSC.Asset.Group
      description: Asset owner group.
      type: string
    - contextPath: TenableSC.Asset.IPs
      description: Asset viewable IPs.
      type: unknown
  - arguments:
    - description: Asset ID.
      name: asset_id
      required: true
    description: Requires security manager role. Delete the asset with the given ID
      from Tenable.sc.
    execution: true
    name: tenable-sc-delete-asset
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return only manageable alerts. Returns both usable and
        manageable by default.
      name: manageable
      predefined:
      - "true"
      - "false"
    description: Requires security manager role. List alerts from Tenable.sc.
    name: tenable-sc-list-alerts
    outputs:
    - contextPath: TenableSC.Alert.ID
      description: Alert ID.
      type: string
    - contextPath: TenableSC.Alert.Name
      description: Alert name.
      type: string
    - contextPath: TenableSC.Alert.Description
      description: Alert description.
      type: string
    - contextPath: TenableSC.Alert.State
      description: Alert state.
      type: string
    - contextPath: TenableSC.Alert.Actions
      description: Alert actions.
      type: string
    - contextPath: TenableSC.Alert.LastTriggered
      description: Alert last triggered time.
      type: date
    - contextPath: TenableSC.Alert.LastEvaluated
      description: Alert last evaluated time.
      type: date
    - contextPath: TenableSC.Alert.Group
      description: Alert owner group name.
      type: string
    - contextPath: TenableSC.Alert.Owner
      description: Alert owner user name.
      type: string
  - arguments:
    - description: Alert ID. Can be retrieved from the list-alerts command.
      name: alert_id
      required: true
    description: Requires security manager role. Get information about a given alert
      in Tenable.sc.
    name: tenable-sc-get-alert
    outputs:
    - contextPath: TenableSC.Alert.ID
      description: Alert ID.
      type: string
    - contextPath: TenableSC.Alert.Name
      description: Alert name.
      type: string
    - contextPath: TenableSC.Alert.Description
      description: Alert description.
      type: string
    - contextPath: TenableSC.Alert.State
      description: Alert state.
      type: string
    - contextPath: TenableSC.Alert.Condition.Trigger
      description: Alert trigger.
      type: string
    - contextPath: TenableSC.Alert.LastTriggered
      description: Alert last triggered time.
      type: date
    - contextPath: TenableSC.Alert.Condition.Query
      description: Alert query name.
      type: string
    - contextPath: TenableSC.Alert.Condition.Filter.Name
      description: Alert query filter name.
      type: string
    - contextPath: TenableSC.Alert.Condition.Filter.Values
      description: Alert query filter values.
      type: Unknown
    - contextPath: TenableSC.Alert.Action.Type
      description: Alert action type.
      type: string
    - contextPath: TenableSC.Alert.Action.Values
      description: Alert action values.
      type: Unknown
  - arguments:
    - description: A valid IP address of a device.
      name: ip
    - description: DNS name of a device.
      name: dns_name
    - description: Repository ID to get the device from. Can be retrieved from the
        list-repositories command.
      name: repository_id
    description: Requires security manager role. Gets the specified device information.
    name: tenable-sc-get-device
    outputs:
    - contextPath: TenableSC.Device.IP
      description: Device IP address.
      type: string
    - contextPath: TenableSC.Device.UUID
      description: Device UUID.
      type: string
    - contextPath: TenableSC.Device.RepositoryID
      description: Device repository ID.
      type: string
    - contextPath: TenableSC.Device.MacAddress
      description: Device Mac address.
      type: string
    - contextPath: TenableSC.Device.NetbiosName
      description: Device Netbios name.
      type: string
    - contextPath: TenableSC.Device.DNSName
      description: Device DNS name.
      type: string
    - contextPath: TenableSC.Device.OS
      description: Device operating system.
      type: string
    - contextPath: TenableSC.Device.OsCPE
      description: Device Common Platform Enumeration.
      type: string
    - contextPath: TenableSC.Device.LastScan
      description: Device's last scan time.
      type: date
    - contextPath: TenableSC.Device.RepositoryName
      description: Device repository name.
      type: string
    - contextPath: TenableSC.Device.TotalScore
      description: Device total threat score.
      type: number
    - contextPath: TenableSC.Device.LowSeverity
      description: Device total threat scores with low severity.
      type: number
    - contextPath: TenableSC.Device.MediumSeverity
      description: Device total threat scores with medium severity.
      type: number
    - contextPath: TenableSC.Device.HighSeverity
      description: Device total threat scores with high severity.
      type: number
    - contextPath: TenableSC.Device.CriticalSeverity
      description: Device total threat scores with critical severity.
      type: number
    - contextPath: Endpoint.IPAddress
      description: Endpoint IP address.
      type: string
    - contextPath: Endpoint.Hostname
      description: Endpoint DNS name.
      type: string
    - contextPath: Endpoint.MACAddress
      description: Endpoint MAC address.
      type: string
    - contextPath: Endpoint.OS
      description: Endpoint OS.
      type: string
  - arguments:
    - description: Filter by user ID.
      name: id
    - description: Filter by user username.
      name: username
    - description: Filter by user email address.
      name: email
    description: List users in Tenable.sc. Results may vary based on the role type
      (admin or security manager).
    name: tenable-sc-list-users
    outputs:
    - contextPath: TenableSC.User.ID
      description: User ID.
      type: string
    - contextPath: TenableSC.User.Username
      description: Username.
      type: string
    - contextPath: TenableSC.User.FirstName
      description: User first name.
      type: string
    - contextPath: TenableSC.User.LastName
      description: User last name.
      type: string
    - contextPath: TenableSC.User.Title
      description: User title.
      type: string
    - contextPath: TenableSC.User.Email
      description: User email address.
      type: string
    - contextPath: TenableSC.User.Created
      description: The creation time of the user.
      type: date
    - contextPath: TenableSC.User.Modified
      description: Last modification time of the user.
      type: date
    - contextPath: TenableSC.User.Login
      description: User last login.
      type: date
    - contextPath: TenableSC.User.Role
      description: User role name.
      type: string
  - arguments: []
    description: Retrieve licensing information from Tenable.sc. Requires admin role.
    name: tenable-sc-get-system-licensing
    outputs:
    - contextPath: TenableSC.Status.ActiveIPS
      description: Number of active IP addresses.
      type: number
    - contextPath: TenableSC.Status.LicensedIPS
      description: Number of licensed IP addresses.
      type: Unknown
    - contextPath: TenableSC.Status.License
      description: License status.
      type: Unknown
  - arguments: []
    description: Get the system information and diagnostics from Tenable.sc. Requires
      admin role.
    name: tenable-sc-get-system-information
    outputs:
    - contextPath: TenableSC.System.Version
      description: System version.
      type: string
    - contextPath: TenableSC.System.BuildID
      description: System build ID.
      type: string
    - contextPath: TenableSC.System.ReleaseID
      description: System release ID.
      type: string
    - contextPath: TenableSC.System.License
      description: System license status.
      type: string
    - contextPath: TenableSC.System.JavaStatus
      description: Server Java status.
      type: boolean
    - contextPath: TenableSC.System.RPMStatus
      description: Server RPM status.
      type: boolean
    - contextPath: TenableSC.System.DiskStatus
      description: Server disk status.
      type: boolean
    - contextPath: TenableSC.System.DiskThreshold
      description: Disk threshold.
      type: number
    - contextPath: TenableSC.System.LastCheck
      description: System last check time.
      type: date
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Filter only manageable alerts. By default, returns both usable
        and manageable alerts.
      name: manageable
      predefined:
      - "true"
      - "false"
    - defaultValue: "0"
      description: The page to return, starting from 0.
      name: page
    - defaultValue: "50"
      description: The number of objects to return in one response (maximum limit
        is 200).
      name: limit
    description: Returns all scan results in Tenable.sc. Requires security manager
      role.
    name: tenable-sc-get-all-scan-results
    outputs:
    - contextPath: TenableSC.ScanResults.ID
      description: Scan ID.
      type: Number
    - contextPath: TenableSC.ScanResults.Name
      description: Scan name.
      type: string
    - contextPath: TenableSC.ScanResults.Status
      description: Scan status.
      type: string
    - contextPath: TenableSC.ScanResults.Description
      description: Scan description.
      type: string
    - contextPath: TenableSC.ScanResults.Policy
      description: Scan policy.
      type: string
    - contextPath: TenableSC.ScanResults.Group
      description: Scan group name.
      type: string
    - contextPath: TenableSC.ScanResults.Checks
      description: Scan completed number of checks.
      type: number
    - contextPath: TenableSC.ScanResults.StartTime
      description: Scan results start time.
      type: date
    - contextPath: TenableSC.ScanResults.EndTime
      description: Scan results end time.
      type: date
    - contextPath: TenableSC.ScanResults.Duration
      description: Scan duration in minutes.
      type: number
    - contextPath: TenableSC.ScanResults.ImportTime
      description: Scan import time.
      type: date
    - contextPath: TenableSC.ScanResults.ScannedIPs
      description: Number of scanned IPs.
      type: number
    - contextPath: TenableSC.ScanResults.Owner
      description: Scan owner name.
      type: string
    - contextPath: TenableSC.ScanResults.RepositoryName
      description: Scan repository name.
      type: string
    - contextPath: TenableSC.ScanResults.ImportStatus
      description: Scan import status.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether to show group member.
      name: show_users
      predefined:
      - "true"
      - "false"
    - defaultValue: "50"
      description: The number of objects to return in one response.
      name: limit
    description: List all groups. Requires security manager role.
    name: tenable-sc-list-groups
    outputs:
    - contextPath: TenableSC.Group.Name
      description: Group name.
      type: string
    - contextPath: TenableSC.Group.ID
      description: Group ID.
      type: number
    - contextPath: TenableSC.Group.Description
      description: Group description.
      type: string
    - contextPath: TenableSC.Group.Users.Firstname
      description: Group's user's first name.
      type: string
    - contextPath: TenableSC.Group.Users.Lastname
      description: Group's user's last name.
      type: string
    - contextPath: TenableSC.Group.Users.ID
      description: Group's user's ID.
      type: string
    - contextPath: TenableSC.Group.Users.UUID
      description: Group's user's UUID.
      type: string
    - contextPath: TenableSC.Group.Users.Username
      description: Group's user's username.
      type: string
  - arguments:
    - description: The user's first name.
      name: first_name
    - description: The user's last name.
      name: last_name
    - description: The user's username.
      name: user_name
      required: true
    - description: The user's email address. Required if email_notice is given.
      name: email
    - description: The user's postal address.
      name: address
    - description: The user's phone number.
      name: phone
    - description: The city the user is living in.
      name: city
    - description: The state the user is living in.
      name: state
    - description: The country the user is living in.
      name: country
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether the user should be locked.
      name: locked
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: none
      description: If different from None, a valid email address must be given.
      name: email_notice
      predefined:
      - both
      - password
      - id
      - none
    - auto: PREDEFINED
      defaultValue: tns
      description: The authentication type. Tenable (TNS). Lightweight Directory Access
        Protocol (LDAP). Security Assertion Markup Language (SAML). LDAP server or
        SAML authentication needs to be configured in order to select LDAP or SAML.
      name: auth_type
      predefined:
      - ldap
      - legacy
      - linked
      - saml
      - tns
      required: true
    - description: The user's password. Must be at least 3 characters.
      name: password
      required: true
      secret: true
    - description: 'The user timezone, possible values can be found here: https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html.'
      name: time_zone
    - auto: PREDEFINED
      description: The user's role. Only an Administrator can create Administrator
        accounts.
      name: role_id
      predefined:
      - Administrator
      - Security Manager
      - Security Analyst
      - Vulnerability Analyst
      - Executive
      - Credential Manager
      - Auditor
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether the password must be changed. When choosing LDAP or SAML
        auth types, 'must_change_password' must be set to False. For all other cases
        can be either True or False.
      name: must_change_password
      predefined:
      - "false"
      - "true"
    - defaultValue: "0"
      description: Comma-separated list of session user's role that can manage groups.
        Use tenable-sc-list-groups to get all available groups.
      name: managed_users_groups
    - defaultValue: "0"
      description: Comma-separated list of the session user's role that can manage
        groups. Use tenable-sc-list-groups to get all available groups.
      name: managed_objects_groups
    - defaultValue: "0"
      description: Valid group ID whose users can be managed by the created user.
      name: group_id
      required: true
    - defaultValue: "0"
      description: Default is 0. ID of a valid, usable, accessible asset. Use tenable-sc-list-assets
        to get all available assets. -1 is not set, 0 is all assets, and other numbers
        are asset ID.
      name: responsible_asset_id
      required: true
    description: Creates a new user. This command can be executed with both roles
      (admin or security manager) based on the role_id you choose.
    name: tenable-sc-create-user
    outputs:
    - contextPath: TenableSC.User.Address
      description: User address.
      type: String
    - contextPath: TenableSC.User.ApiKeys
      description: User API keys.
      type: Unknown
    - contextPath: TenableSC.User.AuthType
      description: User auth type.
      type: String
    - contextPath: TenableSC.User.CanManage
      description: Whether the user has manage permissions.
      type: Boolean
    - contextPath: TenableSC.User.CanUse
      description: Whether the user has use permissions.
      type: Boolean
    - contextPath: TenableSC.User.City
      description: User city of residence.
      type: String
    - contextPath: TenableSC.User.Country
      description: User country of residence.
      type: String
    - contextPath: TenableSC.User.CreatedTime
      description: User creation time.
      type: Date
    - contextPath: TenableSC.User.Email
      description: User email address.
      type: String
    - contextPath: TenableSC.User.FailedLogins
      description: Number of failed user logins.
      type: String
    - contextPath: TenableSC.User.Fax
      description: User fax.
      type: String
    - contextPath: TenableSC.User.Fingerprint
      description: User fingerprint.
      type: Unknown
    - contextPath: TenableSC.User.Firstname
      description: User first name.
      type: String
    - contextPath: TenableSC.User.group.Description
      description: User group's description.
      type: String
    - contextPath: TenableSC.User.Group.ID
      description: User group's ID.
      type: String
    - contextPath: TenableSC.User.Group.Name
      description: User group's name.
      type: String
    - contextPath: TenableSC.User.ID
      description: User ID.
      type: String
    - contextPath: TenableSC.User.LastLogin
      description: User last login time.
      type: String
    - contextPath: TenableSC.User.LastLoginIP
      description: User last login IP.
      type: String
    - contextPath: TenableSC.User.Lastname
      description: User last name.
      type: String
    - contextPath: TenableSC.User.Ldap.Description
      description: User LDAP description.
      type: String
    - contextPath: TenableSC.User.Ldap.ID
      description: User LDAP ID.
      type: Number
    - contextPath: TenableSC.User.Ldap.Name
      description: User LDAP name.
      type: String
    - contextPath: TenableSC.User.LdapUsername
      description: user LDAP username.
      type: String
    - contextPath: TenableSC.User.Locked
      description: Whether user is locked.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.Description
      description: User managed object groups description.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.ID
      description: User managed object groups ID.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.Name
      description: User managed object groups name.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.Description
      description: User managed users groups description.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.ID
      description: User managed users groups ID.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.Name
      description: User managed users groups name.
      type: String
    - contextPath: TenableSC.User.ModifiedTime
      description: User last modification time.
      type: Date
    - contextPath: TenableSC.User.MustChangePassword
      description: If user must change password.
      type: String
    - contextPath: TenableSC.User.Password
      description: If user password is set.
      type: String
    - contextPath: TenableSC.User.Phone
      description: User phone number.
      type: String
    - contextPath: TenableSC.User.Preferences.Name
      description: User preferences name.
      type: String
    - contextPath: TenableSC.User.Preferences.Tag
      description: User preferences tag.
      type: String
    - contextPath: TenableSC.User.Preferences.Value
      description: User preferences value.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.Description
      description: User responsible asset description.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.ID
      description: User responsible asset ID.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.Name
      description: User responsible asset name.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.UUID
      description: User responsible asset UUID.
      type: Unknown
    - contextPath: TenableSC.User.Role.Description
      description: User role description.
      type: String
    - contextPath: TenableSC.User.Role.ID
      description: User role ID.
      type: String
    - contextPath: TenableSC.User.Role.Name
      description: User role name.
      type: String
    - contextPath: TenableSC.User.State
      description: User state.
      type: String
    - contextPath: TenableSC.User.Status
      description: User status.
      type: String
    - contextPath: TenableSC.User.Title
      description: User title.
      type: String
    - contextPath: TenableSC.User.Username
      description: User username.
      type: String
    - contextPath: TenableSC.User.UUID
      description: User UUID.
      type: String
  - arguments:
    - description: The user's first name.
      name: first_name
    - description: The user's last name.
      name: last_name
    - description: The user's username.
      name: user_name
    - description: The user's email address. Required if email_notice is given.
      name: email
    - description: The user's postal address.
      name: address
    - description: The user's phone number.
      name: phone
    - description: The city the user is living in.
      name: city
    - description: The state the user is living in.
      name: state
    - description: The country the user is living in.
      name: country
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether the user should be locked.
      name: locked
      predefined:
      - "true"
      - "false"
    - description: 'The user timezone. Possible values can be found here: https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html.'
      name: time_zone
    - auto: PREDEFINED
      description: The user's role. Only an Administrator can create Administrator
        accounts.
      name: role_id
      predefined:
      - Administrator
      - Security Manager
      - Security Analyst
      - Vulnerability Analyst
      - Executive
      - Credential Manager
      - Auditor
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether the password must be changed. When choosing LDAP or SAML
        auth types, 'must_change_password' must be set to False. For all other cases
        can be either True or False.
      name: must_change_password
      predefined:
      - "false"
      - "true"
    - defaultValue: "0"
      description: Comma-separated list of session user's role that can manage groups.
        Use tenable-sc-list-groups to get all available groups.
      name: managed_users_groups
    - defaultValue: "0"
      description: Comma-separated list of session user's role that  can manage groups.
        Use tenable-sc-list-groups to get all available groups.
      name: managed_objects_groups
    - defaultValue: "0"
      description: Valid group ID whose users can be managed by the created user.
      name: group_id
    - defaultValue: "0"
      description: ID of a valid, usable, accessible asset. Use tenable-sc-list-assets
        to get all available assets. -1 is not set, 0 is all assets, and other numbers
        are asset ID.
      name: responsible_asset_id
    - description: The new password to set. Must be given with current_password. Must
        be at least 3 characters.
      name: password
      secret: true
    - description: This is the admin/Security Manager password from the instance parameters.
        Required when attempting to change a user's password.
      name: current_password
      secret: true
    - description: The ID of the user whose details you want to update.
      name: user_id
      required: true
    description: Update user details of the given user_id.
    name: tenable-sc-update-user
    outputs:
    - contextPath: TenableSC.User.Address
      description: User address.
      type: String
    - contextPath: TenableSC.User.ApiKeys
      description: User API keys.
      type: Unknown
    - contextPath: TenableSC.User.AuthType
      description: User auth type.
      type: String
    - contextPath: TenableSC.User.CanManage
      description: Whether the user has manage permissions.
      type: Boolean
    - contextPath: TenableSC.User.CanUse
      description: Whether the user has use permissions.
      type: Boolean
    - contextPath: TenableSC.User.City
      description: User city of residence.
      type: String
    - contextPath: TenableSC.User.Country
      description: User country of residence.
      type: String
    - contextPath: TenableSC.User.CreatedTime
      description: User creation time.
      type: Date
    - contextPath: TenableSC.User.Email
      description: User email address.
      type: String
    - contextPath: TenableSC.User.FailedLogins
      description: Number of failed user logins.
      type: String
    - contextPath: TenableSC.User.Fax
      description: User fax.
      type: String
    - contextPath: TenableSC.User.Fingerprint
      description: User fingerprint.
      type: Unknown
    - contextPath: TenableSC.User.Firstname
      description: User first name.
      type: String
    - contextPath: TenableSC.User.group.Description
      description: User group's description.
      type: String
    - contextPath: TenableSC.User.Group.ID
      description: User group's ID.
      type: String
    - contextPath: TenableSC.User.Group.Name
      description: User group's name.
      type: String
    - contextPath: TenableSC.User.ID
      description: User ID.
      type: String
    - contextPath: TenableSC.User.LastLogin
      description: User last login time.
      type: String
    - contextPath: TenableSC.User.LastLoginIP
      description: User last login IP.
      type: String
    - contextPath: TenableSC.User.Lastname
      description: User last name.
      type: String
    - contextPath: TenableSC.User.Ldap.Description
      description: User LDAP description.
      type: String
    - contextPath: TenableSC.User.Ldap.ID
      description: User LDAP ID.
      type: Number
    - contextPath: TenableSC.User.Ldap.Name
      description: User LDAP name.
      type: String
    - contextPath: TenableSC.User.LdapUsername
      description: User LDAP username.
      type: String
    - contextPath: TenableSC.User.Locked
      description: Whether user is locked.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.Description
      description: User managed object groups description.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.ID
      description: User managed object groups ID.
      type: String
    - contextPath: TenableSC.User.ManagedObjectsGroups.Name
      description: User managed object groups name.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.Description
      description: User managed users groups description.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.ID
      description: User managed users groups ID.
      type: String
    - contextPath: TenableSC.User.ManagedUsersGroups.Name
      description: User managed users groups name.
      type: String
    - contextPath: TenableSC.User.ModifiedTime
      description: User last modification time.
      type: Date
    - contextPath: TenableSC.User.MustChangePassword
      description: If user must change password.
      type: String
    - contextPath: TenableSC.User.Password
      description: If user password is set.
      type: String
    - contextPath: TenableSC.User.Phone
      description: User phone number.
      type: String
    - contextPath: TenableSC.User.Preferences.Name
      description: User preferences name.
      type: String
    - contextPath: TenableSC.User.Preferences.Tag
      description: User preferences tag.
      type: String
    - contextPath: TenableSC.User.Preferences.Value
      description: User preferences value.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.Description
      description: User responsible asset description.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.ID
      description: User responsible asset ID.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.Name
      description: User responsible asset name.
      type: String
    - contextPath: TenableSC.User.ResponsibleAsset.UUID
      description: User responsible asset UUID.
      type: Unknown
    - contextPath: TenableSC.User.Role.Description
      description: User role description.
      type: String
    - contextPath: TenableSC.User.Role.ID
      description: User role ID.
      type: String
    - contextPath: TenableSC.User.Role.Name
      description: User role name.
      type: String
    - contextPath: TenableSC.User.State
      description: User state.
      type: String
    - contextPath: TenableSC.User.Status
      description: User status.
      type: String
    - contextPath: TenableSC.User.Title
      description: User title.
      type: String
    - contextPath: TenableSC.User.Username
      description: User username.
      type: String
    - contextPath: TenableSC.User.UUID
      description: User UUID.
      type: String
  - arguments:
    - description: The ID of the user we want to delete.
      name: user_id
      required: true
    description: Delete a user by given user_id. This command can be executed with
      both roles (admin or security manager).
    name: tenable-sc-delete-user
  - arguments:
    - description: The ID of the plugin to search. If given, other arguments will
        be ignored.
      name: plugin_id
    - defaultValue: "50"
      description: The number of objects to return in one response (maximum limit
        is 200). Ignored when plugin_id is given.
      name: limit
    - auto: PREDEFINED
      description: Default is none. none - both active and passive Plugin Families
        are returned. true - Only active Plugin Families will be returned. false -
        Only passive Plugin Families will be returned. Ignored when plugin_id is given.
      name: is_active
      predefined:
      - "true"
      - "false"
    description: List plugin families / return information about a plugin family given
      ID. Requires security manager role.
    name: tenable-sc-list-plugin-family
    outputs:
    - contextPath: TenableSC.PluginFamily.ID
      description: Plugin family ID.
      type: String
    - contextPath: TenableSC.PluginFamily.Name
      description: Plugin family name.
      type: String
    - contextPath: TenableSC.PluginFamily.Count
      description: Number of plugins in a family.
      type: String
    - contextPath: TenableSC.PluginFamily.Plugins
      description: The plugins list.
      type: String
    - contextPath: TenableSC.PluginFamily.Type
      description: Plugin family type.
      type: String
  - arguments:
    - description: The name of the policy to create.
      name: policy_name
    - description: The description of the policy to create.
      name: policy_description
    - defaultValue: "1"
      description: Policy template id. Default is 1.
      name: policy_template_id
      required: true
    - description: 'Possible values: default, all or a comma-separated list of values
        - 21,23,25,80,110.'
      name: port_scan_range
    - auto: PREDEFINED
      defaultValue: "no"
      description: Only possible if you are using Linux or FreeBSD. On Windows or
        macOS, the scanner does not do a TCP scan and instead uses the SYN scanner.
        If you enable this option, you can also set the syn_firewall_detection option.
      name: tcp_scanner
      predefined:
      - "no"
      - "yes"
    - auto: PREDEFINED
      defaultValue: "yes"
      description: Identifies open TCP ports on the target hosts. If you enable this
        option, you can also set the syn_firewall_detection option.
      name: syn_scanner
      predefined:
      - "no"
      - "yes"
    - auto: PREDEFINED
      defaultValue: "no"
      description: Enabling the UDP port scanner may dramatically increase the scan
        time and produce unreliable results. Consider using the netstat or SNMP port
        enumeration options instead if possible.
      name: udp_scanner
      predefined:
      - "no"
      - "yes"
    - description: Family ID. Can be retrieved from the result of the tenable-sc-list-plugin-family
        command.
      name: family_id
      required: true
    - description: Comma-separated list of plugin_ids, Can be retrieved from the result
        of  the tenable-sc-list-plugin-family command  with family_id as the argument.
      name: plugins_id
      required: true
    - auto: PREDEFINED
      defaultValue: Automatic (normal)
      description: Rely on local port enumeration first before relying on network
        port scans.
      name: syn_firewall_detection
      predefined:
      - Automatic (normal)
      - Do not detect RST rate limitation(soft)
      - Ignore closed ports(aggressive)
      - Disabled(softer)
    description: Creates a policy. Requires security manager role. This command is
      prerequisite for creating remediation scan.
    name: tenable-sc-create-policy
    outputs:
    - contextPath: TenableSC.ScanPolicy.AuditFiles
      description: Policy audit files.
      type: Unknown
    - contextPath: TenableSC.ScanPolicy.CanManage
      description: Policy permissions.
      type: String
    - contextPath: TenableSC.ScanPolicy.CanUse
      description: Policy permissions.
      type: String
    - contextPath: TenableSC.ScanPolicy.Context
      description: Policy context.
      type: String
    - contextPath: TenableSC.ScanPolicy.CreatedTime
      description: Policy creation time.
      type: Date
    - contextPath: TenableSC.ScanPolicy.Creator.Firstname
      description: Policy creator first name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Creator.ID
      description: Policy creator ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.Creator.Lastname
      description: Policy creator last name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Creator.Username
      description: Policy creator user name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Creator.UUID
      description: Policy creator UUID.
      type: String
    - contextPath: TenableSC.ScanPolicy.Description
      description: Policy description.
      type: String
    - contextPath: TenableSC.ScanPolicy.Families.Count
      description: Policy number of families.
      type: String
    - contextPath: TenableSC.ScanPolicy.Families.ID
      description: Policy family ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.Families.Name
      description: Policy family name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Families.Plugins
      description: Policy family plugins.
      type: Unknown
    - contextPath: TenableSC.ScanPolicy.GenerateXCCDFResults
      description: Policy generated XCCDF results.
      type: String
    - contextPath: TenableSC.ScanPolicy.Groups
      description: Policy groups.
      type: Unknown
    - contextPath: TenableSC.ScanPolicy.ID
      description: Policy ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.ModifiedTime
      description: Policy last modification time.
      type: Date
    - contextPath: TenableSC.ScanPolicy.Name
      description: Policy name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Owner.Firstname
      description: Policy owner first name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Owner.ID
      description: Policy owner ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.Owner.Lastname
      description: Policy owner last name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Owner.Username
      description: Policy owner username.
      type: String
    - contextPath: TenableSC.ScanPolicy.Owner.UUID
      description: Policy owner UUID.
      type: String
    - contextPath: TenableSC.ScanPolicy.OwnerGroup.Description
      description: Policy owner group description.
      type: String
    - contextPath: TenableSC.ScanPolicy.OwnerGroup.ID
      description: Policy owner group ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.OwnerGroup.Name
      description: Policy owner group name.
      type: String
    - contextPath: TenableSC.ScanPolicy.PolicyTemplate.Agent
      description: Policy template agent.
      type: String
    - contextPath: TenableSC.ScanPolicy.PolicyTemplate.Description
      description: Policy template description.
      type: String
    - contextPath: TenableSC.ScanPolicy.PolicyTemplate.ID
      description: Policy template ID.
      type: String
    - contextPath: TenableSC.ScanPolicy.PolicyTemplate.Name
      description: Policy template name.
      type: String
    - contextPath: TenableSC.ScanPolicy.Preferences.PortscanRange
      description: Policy port scan range.
      type: String
    - contextPath: TenableSC.ScanPolicy.Preferences.SynFirewallDetection
      description: Policy SYN firewall detection.
      type: String
    - contextPath: TenableSC.ScanPolicy.Preferences.SynScanner
      description: Policy SYN scanner.
      type: String
    - contextPath: TenableSC.ScanPolicy.Preferences.TcpScanner
      description: Policy TCP scanner.
      type: String
    - contextPath: TenableSC.ScanPolicy.Preferences.UdpScanner
      description: Policy UDP scanner.
      type: String
    - contextPath: TenableSC.ScanPolicy.Status
      description: Policy status.
      type: String
    - contextPath: TenableSC.ScanPolicy.tags
      description: Policy tags.
      type: String
    - contextPath: TenableSC.ScanPolicy.TargetGroup.Description
      description: Policy target group description.
      type: String
    - contextPath: TenableSC.ScanPolicy.TargetGroup.ID
      description: Policy target group ID.
      type: Number
    - contextPath: TenableSC.ScanPolicy.TargetGroup.Name
      description: Policy target group name.
      type: String
    - contextPath: TenableSC.ScanPolicy.UUID
      description: Policy UUID.
      type: String
  - arguments:
    - description: The ID of the query to search.
      name: query_id
    - auto: PREDEFINED
      description: The query type to retrieve. When no type is set all queries are
        returned.
      name: type
      predefined:
      - alert
      - lce
      - mobile
      - ticket
      - user
    description: Lists the queries. Requires security manager role.
    name: tenable-sc-list-query
    outputs:
    - contextPath: TenableSC.Query.Manageable.BrowseColumns
      description: Relevant only when query_id is not given. Manageable Query browse
        columns.
      type: String
    - contextPath: TenableSC.Query.Manageable.BrowseSortColumn
      description: Relevant only when query_id is not given. Manageable Query browse
        sort column.
      type: String
    - contextPath: TenableSC.Query.Manageable.BrowseSortDirection
      description: Relevant only when query_id is not given. Manageable Query browse
        sort direction.
      type: String
    - contextPath: TenableSC.Query.Manageable.CanManage
      description: Relevant only when query_id is not given. Manageable Query permissions.
      type: String
    - contextPath: TenableSC.Query.Manageable.CanUse
      description: Relevant only when query_id is not given. Manageable Query permissions.
      type: String
    - contextPath: TenableSC.Query.Manageable.Context
      description: Relevant only when query_id is not given. Manageable Query context.
      type: String
    - contextPath: TenableSC.Query.Manageable.CreatedTime
      description: Relevant only when query_id is not given. Manageable Query creation
        time.
      type: Date
    - contextPath: TenableSC.Query.Manageable.Creator.Firstname
      description: Relevant only when query_id is not given. Manageable Query Creator
        first name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Creator.ID
      description: Relevant only when query_id is not given. Manageable Query Creator
        ID.
      type: String
    - contextPath: TenableSC.Query.Manageable.Creator.Lastname
      description: Relevant only when query_id is not given. Manageable Query Creator
        last name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Creator.Username
      description: Relevant only when query_id is not given. Manageable Query Creator
        user name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Creator.UUID
      description: Relevant only when query_id is not given. Manageable Query Creator
        UUID.
      type: String
    - contextPath: TenableSC.Query.Manageable.Description
      description: Relevant only when query_id is not given. Manageable Query description.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.FilterName
      description: Relevant only when query_id is not given. Manageable Query filter
        name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Operator
      description: Relevant only when query_id is not given. Manageable Query filter
        operator.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value
      description: Relevant only when query_id is not given. Manageable Query filter
        value.
      type: String
    - contextPath: TenableSC.Query.Manageable.Groups
      description: Relevant only when query_id is not given. Manageable Query groups.
      type: Unknown
    - contextPath: TenableSC.Query.Manageable.ID
      description: Relevant only when query_id is not given. Manageable Query ID.
      type: String
    - contextPath: TenableSC.Query.Manageable.ModifiedTime
      description: Relevant only when query_id is not given. Manageable Query modification
        time.
      type: Date
    - contextPath: TenableSC.Query.Manageable.Name
      description: Relevant only when query_id is not given. Manageable Query name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Owner.Firstname
      description: Relevant only when query_id is not given. Manageable Query owner
        first name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Owner.ID
      description: Relevant only when query_id is not given. Manageable Query owner
        ID.
      type: String
    - contextPath: TenableSC.Query.Manageable.Owner.Lastname
      description: Relevant only when query_id is not given. Manageable Query owner
        last name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Owner.Username
      description: Relevant only when query_id is not given. Manageable Query owner
        user name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Owner.UUID
      description: Relevant only when query_id is not given. Manageable Query owner
        UUID.
      type: String
    - contextPath: TenableSC.Query.Manageable.OwnerGroup.Description
      description: Relevant only when query_id is not given. Manageable Query owner
        group description.
      type: String
    - contextPath: TenableSC.Query.Manageable.OwnerGroup.ID
      description: Relevant only when query_id is not given. Manageable Query owner
        group ID.
      type: String
    - contextPath: TenableSC.Query.Manageable.OwnerGroup.Name
      description: Relevant only when query_id is not given. Manageable Query owner
        group name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Status
      description: Relevant only when query_id is not given. Manageable Query status.
      type: String
    - contextPath: TenableSC.Query.Manageable.Tags
      description: Relevant only when query_id is not given. Manageable Query tags.
      type: String
    - contextPath: TenableSC.Query.Manageable.TargetGroup.Description
      description: Relevant only when query_id is not given. Manageable Query target
        group description.
      type: String
    - contextPath: TenableSC.Query.Manageable.TargetGroup.ID
      description: Relevant only when query_id is not given. Manageable Query target
        group ID.
      type: Number
    - contextPath: TenableSC.Query.Manageable.TargetGroup.Name
      description: Relevant only when query_id is not given. Manageable Query target
        group name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Tool
      description: Relevant only when query_id is not given. Manageable Query tool.
      type: String
    - contextPath: TenableSC.Query.Manageable.Type
      description: Relevant only when query_id is not given. Manageable Query type.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value.Description
      description: Relevant only when query_id is not given. Manageable Query filter
        value description.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value.ID
      description: Relevant only when query_id is not given. Manageable Query filter
        value ID.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value.Name
      description: Relevant only when query_id is not given. Manageable Query filter
        value name.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value.Type
      description: Relevant only when query_id is not given. Manageable Query filter
        value type.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters.Value.UUID
      description: Relevant only when query_id is not given. Manageable Query filter
        value UUID.
      type: String
    - contextPath: TenableSC.Query.Manageable.Filters
      description: Relevant only when query_id is not given. Manageable Query filters.
      type: Unknown
    - contextPath: TenableSC.Query.Usable.BrowseColumns
      description: Relevant only when query_id is not given. Usable Query browse columns.
      type: String
    - contextPath: TenableSC.Query.Usable.BrowseSortColumn
      description: Relevant only when query_id is not given. Usable Query browse sort
        column.
      type: String
    - contextPath: TenableSC.Query.Usable.BrowseSortDirection
      description: Relevant only when query_id is not given. Usable Query browse sort
        direction.
      type: String
    - contextPath: TenableSC.Query.Usable.CanManage
      description: Relevant only when query_id is not given. Usable Query permissions.
      type: String
    - contextPath: TenableSC.Query.Usable.CanUse
      description: Relevant only when query_id is not given. Usable Query permissions.
      type: String
    - contextPath: TenableSC.Query.Usable.Context
      description: Relevant only when query_id is not given. Usable Query context.
      type: String
    - contextPath: TenableSC.Query.Usable.CreatedTime
      description: Relevant only when query_id is not given. Usable Query creation
        time.
      type: Date
    - contextPath: TenableSC.Query.Usable.Creator.Firstname
      description: Relevant only when query_id is not given. Usable Query Creator
        first name.
      type: String
    - contextPath: TenableSC.Query.Usable.Creator.ID
      description: Relevant only when query_id is not given. Usable Query Creator
        ID.
      type: String
    - contextPath: TenableSC.Query.Usable.Creator.Lastname
      description: Relevant only when query_id is not given. Usable Query Creator
        last name.
      type: String
    - contextPath: TenableSC.Query.Usable.Creator.Username
      description: Relevant only when query_id is not given. Usable Query Creator
        user name.
      type: String
    - contextPath: TenableSC.Query.Usable.Creator.UUID
      description: Relevant only when query_id is not given. Usable Query Creator
        UUID.
      type: String
    - contextPath: TenableSC.Query.Usable.Description
      description: Relevant only when query_id is not given. Usable Query description.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.FilterName
      description: Relevant only when query_id is not given. Usable Query filter name.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Operator
      description: Relevant only when query_id is not given. Usable Query filter operator.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value
      description: Relevant only when query_id is not given. Usable Query filter value.
      type: String
    - contextPath: TenableSC.Query.Usable.Groups
      description: Relevant only when query_id is not given. Usable Query groups.
      type: Unknown
    - contextPath: TenableSC.Query.Usable.ID
      description: Relevant only when query_id is not given. Usable Query ID.
      type: String
    - contextPath: TenableSC.Query.Usable.ModifiedTime
      description: Relevant only when query_id is not given. Usable Query modification
        time.
      type: Date
    - contextPath: TenableSC.Query.Usable.Name
      description: Relevant only when query_id is not given. Usable Query name.
      type: String
    - contextPath: TenableSC.Query.Usable.Owner.Firstname
      description: Relevant only when query_id is not given. Usable Query owner first
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Owner.ID
      description: Relevant only when query_id is not given. Usable Query owner ID.
      type: String
    - contextPath: TenableSC.Query.Usable.Owner.Lastname
      description: Relevant only when query_id is not given. Usable Query owner last
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Owner.Username
      description: Relevant only when query_id is not given. Usable Query owner user
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Owner.UUID
      description: Relevant only when query_id is not given. Usable Query owner UUID.
      type: String
    - contextPath: TenableSC.Query.Usable.OwnerGroup.Description
      description: Relevant only when query_id is not given. Usable Query owner group
        description.
      type: String
    - contextPath: TenableSC.Query.Usable.OwnerGroup.ID
      description: Relevant only when query_id is not given. Usable Query owner group
        ID.
      type: String
    - contextPath: TenableSC.Query.Usable.OwnerGroup.Name
      description: Relevant only when query_id is not given. Usable Query owner group
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Status
      description: Relevant only when query_id is not given. Usable Query status.
      type: String
    - contextPath: TenableSC.Query.Usable.Tags
      description: Relevant only when query_id is not given. Usable Query tags.
      type: String
    - contextPath: TenableSC.Query.Usable.TargetGroup.Description
      description: Relevant only when query_id is not given. Usable Query target group
        description.
      type: String
    - contextPath: TenableSC.Query.Usable.TargetGroup.ID
      description: Relevant only when query_id is not given. Usable Query target group
        ID.
      type: Number
    - contextPath: TenableSC.Query.Usable.TargetGroup.Name
      description: Relevant only when query_id is not given. Usable Query target group
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Tool
      description: Relevant only when query_id is not given. Usable Query tool.
      type: String
    - contextPath: TenableSC.Query.Usable.Type
      description: Relevant only when query_id is not given. Usable Query type.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value.Description
      description: Relevant only when query_id is not given. Usable Query filter value
        description.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value.ID
      description: Relevant only when query_id is not given. Usable Query filter value
        ID.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value.Name
      description: Relevant only when query_id is not given. Usable Query filter value
        name.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value.Type
      description: Relevant only when query_id is not given. Usable Query filter value
        type.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters.Value.UUID
      description: Relevant only when query_id is not given. Usable Query filter value
        UUID.
      type: String
    - contextPath: TenableSC.Query.Usable.Filters
      description: Relevant only when query_id is not given. Usable Query filters.
      type: Unknown
    - contextPath: TenableSC.Query.BrowseColumns
      description: Relevant only when query_id is given. Query browse columns.
      type: String
    - contextPath: TenableSC.Query.BrowseSortColumn
      description: Relevant only when query_id is given. Query browse sort columns.
      type: String
    - contextPath: TenableSC.Query.BrowseSortDirection
      description: Relevant only when query_id is given. Query browse sort direction.
      type: String
    - contextPath: TenableSC.Query.CanManage
      description: Relevant only when query_id is given. Query permissions.
      type: String
    - contextPath: TenableSC.Query.CanUse
      description: Relevant only when query_id is given. Query permissions.
      type: String
    - contextPath: TenableSC.Query.Context
      description: Relevant only when query_id is given. Query context.
      type: String
    - contextPath: TenableSC.Query.CreatedTime
      description: Relevant only when query_id is given. Query creation time.
      type: Date
    - contextPath: TenableSC.Query.Creator.Firstname
      description: Relevant only when query_id is given. Query creator first name.
      type: String
    - contextPath: TenableSC.Query.Creator.ID
      description: Relevant only when query_id is given. Query creator ID.
      type: String
    - contextPath: TenableSC.Query.Creator.Lastname
      description: Relevant only when query_id is given. Query creator last name.
      type: String
    - contextPath: TenableSC.Query.Creator.Username
      description: Relevant only when query_id is given. Query creator user name.
      type: String
    - contextPath: TenableSC.Query.Creator.UUID
      description: Relevant only when query_id is given. Query creator UUID.
      type: String
    - contextPath: TenableSC.Query.Description
      description: Relevant only when query_id is given. Query description.
      type: String
    - contextPath: TenableSC.Query.Filters
      description: Relevant only when query_id is given. Query filters.
      type: Unknown
    - contextPath: TenableSC.Query.Groups
      description: Relevant only when query_id is given. Query groups.
      type: Unknown
    - contextPath: TenableSC.Query.ID
      description: Relevant only when query_id is given. Query ID.
      type: String
    - contextPath: TenableSC.Query.ModifiedTime
      description: Relevant only when query_id is given. Query modification time.
      type: Date
    - contextPath: TenableSC.Query.Name
      description: Relevant only when query_id is given. Query name.
      type: String
    - contextPath: TenableSC.Query.Owner.Firstname
      description: Relevant only when query_id is given. Query owner first name.
      type: String
    - contextPath: TenableSC.Query.Owner.ID
      description: Relevant only when query_id is given. Query owner ID.
      type: String
    - contextPath: TenableSC.Query.Owner.Lastname
      description: Relevant only when query_id is given. Query owner last name.
      type: String
    - contextPath: TenableSC.Query.Owner.Username
      description: Relevant only when query_id is given. Query owner user name.
      type: String
    - contextPath: TenableSC.Query.Owner.UUID
      description: Relevant only when query_id is given. Query owner UUID.
      type: String
    - contextPath: TenableSC.Query.OwnerGroup.Description
      description: Relevant only when query_id is given. Query owner group description.
      type: String
    - contextPath: TenableSC.Query.OwnerGroup.ID
      description: Relevant only when query_id is given. Query owner group ID.
      type: String
    - contextPath: TenableSC.Query.OwnerGroup.Name
      description: Relevant only when query_id is given. Query owner group name.
      type: String
    - contextPath: TenableSC.Query.Status
      description: Relevant only when query_id is given. Query status.
      type: String
    - contextPath: TenableSC.Query.Tags
      description: Relevant only when query_id is given. Query tags.
      type: String
    - contextPath: TenableSC.Query.TargetGroup.Description
      description: Relevant only when query_id is given. Query target group description.
      type: String
    - contextPath: TenableSC.Query.TargetGroup.ID
      description: Relevant only when query_id is given. Query target group ID.
      type: Number
    - contextPath: TenableSC.Query.TargetGroup.Name
      description: Relevant only when query_id is given. Query target group name.
      type: String
    - contextPath: TenableSC.Query.Tool
      description: Relevant only when query_id is given. Query tool.
      type: String
    - contextPath: TenableSC.Query.Type
      description: Relevant only when query_id is given. Query type.
      type: String
  - arguments:
    - description: Asset name.
      name: name
    - description: The ID of the asset to update.
      name: asset_id
      required: true
    - description: The asset description.
      name: description
    - description: The asset owner ID.
      name: owner_id
    - description: The asset tag.
      name: tag
    - description: Comma-separated list of the asset IPs list.
      name: ip_list
    description: Requires security manager role. Update an asset.
    name: tenable-sc-update-asset
    polling: true
  - arguments:
    - description: The name of the policy to create.
      name: policy_name
    - description: The description of the policy to create.
      name: policy_description
    - description: 'Possible values: default, all or a comma-separated list of values
        - 21,23,25,80,110.'
      name: port_scan_range
    - auto: PREDEFINED
      defaultValue: "no"
      description: Only possible if you are using Linux or FreeBSD. On Windows or
        macOS, the scanner does not do a TCP scan and instead uses the SYN scanner..If
        you enable this option, you can also set the syn_firewall_detection.
      name: tcp_scanner
      predefined:
      - "no"
      - "yes"
    - auto: PREDEFINED
      defaultValue: "yes"
      description: Identifies open TCP ports on the target hosts. If you enable this
        option, you can also set the syn_firewall_detection option.
      name: syn_scanner
      predefined:
      - "no"
      - "yes"
    - auto: PREDEFINED
      defaultValue: "no"
      description: Enabling the UDP port scanner may dramatically increase the scan
        time and produce unreliable results. Consider using the netstat or SNMP port
        enumeration options instead if possible.
      name: udp_scanner
      predefined:
      - "no"
      - "yes"
    - auto: PREDEFINED
      defaultValue: Automatic (normal)
      description: Default is Automatic (normal). Rely on local port enumeration first
        before relying on network port scans.
      name: syn_firewall_detection
      predefined:
      - Automatic (normal)
      - Do not detect RST rate limitation(soft)
      - Ignore closed ports(aggressive)
      - Disabled(softer)
    - description: Can be retrieved from the result of the tenable-sc-list-plugin-family
        command.
      name: family_id
      required: true
    - description: Comma-separated list of plugin_ids, Can be retrieved from the result
        of the tenable-sc-list-plugin-family command  with family_id as the argument.
      name: plugins_id
      required: true
    - description: Scan name.
      name: scan_name
      required: true
    - description: Scan description.
      name: description
    - defaultValue: "1"
      description: Scan Repository ID, can be retrieved from the list-repositories
        command.
      name: repository_id
      required: true
    - description: 'The timezone for the given start_time. Possible values can be
        found here: https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html.'
      name: time_zone
    - description: The scan start time, in the format of YYYY-MM-DD:HH:MM:SS or relative
        timestamp (i.e., now, 3 days).
      name: start_time
    - auto: PREDEFINED
      description: Specifies repeating events based on an interval of a repeat_rule_freq
        or more.
      name: repeat_rule_freq
      predefined:
      - HOURLY
      - DAILY
      - WEEKLY
      - MONTHLY
      - YEARLY
    - description: 'The number of repeat_rule_freq between each interval (for example:
        If repeat_rule_freq=DAILY and repeat_rule_interval=8 it means every eight
        days.)'
      name: repeat_rule_interval
    - description: 'A comma-separated list of days of the week to run the schedule.
        Possible values are: SU, MO, TU, WE, TH, FR, SA.'
      isArray: true
      name: repeat_rule_by_day
    - auto: PREDEFINED
      description: Either no assets or comma-separated list of asset IDs to scan.
        Can be retrieved from the list-assets command.
      isArray: true
      name: asset_ids
    - auto: PREDEFINED
      defaultValue: "false"
      description: Default is false. Whether to include virtual hosts.
      name: scan_virtual_hosts
      predefined:
      - "true"
      - "false"
    - description: Comma-separated IPs to scan, e.g., 10.0.0.1,10.0.0.2 .
      name: ip_list
    - description: Comma-separated list of report definition IDs to create post-scan.
        Can be retrieved from the list-report-definitions command.
      isArray: true
      name: report_ids
    - description: Comma-separated credentials IDs to use. Can be retrieved from the
        list-credentials command.
      isArray: true
      name: credentials
    - auto: PREDEFINED
      defaultValue: import
      description: discard - do not import any of the results obtained by the scan
        to the database. import - Import the results of the current scan and discard
        the information for any unscanned targets. rollover-Import the results from
        the scan into the database and create a rollover scan that may be launched
        at a later time to complete the scan.
      name: timeout_action
      predefined:
      - discard
      - import
      - rollover
    - description: Maximum scan run time in hours. Default is 1.
      name: max_scan_time
    - auto: PREDEFINED
      defaultValue: "false"
      description: Track hosts which have been issued new IP address, (e.g., DHCP).
      name: dhcp_tracking
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether the schedule is enabled. The "enabled" field can only be
        set to "false" for schedules of type "ical". For all other schedules types,
        "enabled" is set to "true".
      name: enabled
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: nextDay
      description: Create a rollover scan scheduled to launch the next day at the
        same start time as the just completed scan. template-Create a rollover scan
        as a template for users to launch manually This field is required if the timeout_action
        is set to rollover.
      name: rollover_type
    description: Creates a remediation scan. Requires security manager role. This
      command is a prerequisite for creating remediation scan.
    name: tenable-sc-create-remediation-scan
    outputs:
    - contextPath: TenableSC.Scan.Assets
      description: Scan assets.
      type: Unknown
    - contextPath: TenableSC.Scan.CanManage
      description: Scan permissions.
      type: String
    - contextPath: TenableSC.Scan.CanUse
      description: Scan permissions.
      type: String
    - contextPath: TenableSC.Scan.ClassifyMitigatedAge
      description: Scan classify mitigated age.
      type: String
    - contextPath: TenableSC.Scan.CreatedTime
      description: Scan creation time.
      type: Date
    - contextPath: TenableSC.Scan.Creator.Firstname
      description: Scan creator first name.
      type: String
    - contextPath: TenableSC.Scan.Creator.ID
      description: Scan creator ID.
      type: String
    - contextPath: TenableSC.Scan.Creator.Lastname
      description: Scan creator last name.
      type: String
    - contextPath: TenableSC.Scan.Creator.Username
      description: Scan creator username.
      type: String
    - contextPath: TenableSC.Scan.Creator.UUID
      description: Scan creator UUID.
      type: String
    - contextPath: TenableSC.Scan.Credentials
      description: Scan credentials.
      type: Unknown
    - contextPath: TenableSC.Scan.Description
      description: Scan description.
      type: String
    - contextPath: TenableSC.Scan.DhcpTracking
      description: Scan DHCP tracking.
      type: String
    - contextPath: TenableSC.Scan.EmailOnFinish
      description: Scan email on finish.
      type: String
    - contextPath: TenableSC.Scan.EmailOnLaunch
      description: Scan email on launch.
      type: String
    - contextPath: TenableSC.Scan.ID
      description: Scan ID.
      type: String
    - contextPath: TenableSC.Scan.IpList
      description: Scan IP list.
      type: String
    - contextPath: TenableSC.Scan.MaxScanTime
      description: Scan max scan time.
      type: String
    - contextPath: TenableSC.Scan.ModifiedTime
      description: Scan last modification time.
      type: Date
    - contextPath: TenableSC.Scan.Name
      description: Scan name.
      type: String
    - contextPath: TenableSC.Scan.NumDependents
      description: Scan number of dependents.
      type: Number
    - contextPath: TenableSC.Scan.Owner.Firstname
      description: Scan owner first name.
      type: String
    - contextPath: TenableSC.Scan.Owner.ID
      description: Scan owner ID.
      type: String
    - contextPath: TenableSC.Scan.Owner.Lastname
      description: Scan owner last name.
      type: String
    - contextPath: TenableSC.Scan.Owner.Username
      description: Scan owner username.
      type: String
    - contextPath: TenableSC.Scan.Owner.UUID
      description: Scan owner UUID.
      type: String
    - contextPath: TenableSC.Scan.OwnerGroup.Description
      description: Scan owner group description.
      type: String
    - contextPath: TenableSC.Scan.OwnerGroup.ID
      description: Scan owner group ID.
      type: String
    - contextPath: TenableSC.Scan.OwnerGroup.Name
      description: Scan owner group name.
      type: String
    - contextPath: TenableSC.Scan.Plugin.Description
      description: Scan plugin description.
      type: String
    - contextPath: TenableSC.Scan.Plugin.ID
      description: Scan plugin ID.
      type: String
    - contextPath: TenableSC.Scan.Plugin.Name
      description: Scan plugin name.
      type: String
    - contextPath: TenableSC.Scan.Plugin.Type
      description: Scan plugin type.
      type: String
    - contextPath: TenableSC.Scan.Policy.Context
      description: Scan policy context.
      type: String
    - contextPath: TenableSC.Scan.Policy.Description
      description: Scan policy description.
      type: String
    - contextPath: TenableSC.Scan.Policy.ID
      description: Scan policy ID.
      type: String
    - contextPath: TenableSC.Scan.Policy.Name
      description: Scan policy name.
      type: String
    - contextPath: TenableSC.Scan.Policy.Owner.Firstname
      description: Scan policy owner first name.
      type: String
    - contextPath: TenableSC.Scan.Policy.Owner.ID
      description: Scan policy owner ID.
      type: String
    - contextPath: TenableSC.Scan.Policy.Owner.Lastname
      description: Scan policy owner last name.
      type: String
    - contextPath: TenableSC.Scan.Policy.Owner.Username
      description: Scan policy owner username.
      type: String
    - contextPath: TenableSC.Scan.Policy.Owner.UUID
      description: Scan policy owner UUID.
      type: String
    - contextPath: TenableSC.Scan.Policy.OwnerGroup.Description
      description: Scan policy owner group description.
      type: String
    - contextPath: TenableSC.Scan.Policy.OwnerGroup.ID
      description: Scan policy owner group ID.
      type: String
    - contextPath: TenableSC.Scan.Policy.OwnerGroup.Name
      description: Scan policy owner group name.
      type: String
    - contextPath: TenableSC.Scan.Policy.Tags
      description: Scan policy tags.
      type: String
    - contextPath: TenableSC.Scan.Policy.UUID
      description: Scan policy UUID.
      type: String
    - contextPath: TenableSC.Scan.PolicyPrefs.Name
      description: Scan policy preferation name.
      type: String
    - contextPath: TenableSC.Scan.PolicyPrefs.Value
      description: Scan policy preferation value.
      type: String
    - contextPath: TenableSC.Scan.Reports
      description: Scan reports.
      type: Unknown
    - contextPath: TenableSC.Scan.Repository.Description
      description: Scan repository description.
      type: String
    - contextPath: TenableSC.Scan.Repository.ID
      description: Scan repository ID.
      type: String
    - contextPath: TenableSC.Scan.Repository.Name
      description: Scan repository name.
      type: String
    - contextPath: TenableSC.Scan.Repository.Type
      description: Scan repository type.
      type: String
    - contextPath: TenableSC.Scan.Repository.UUID
      description: Scan repository UUID.
      type: String
    - contextPath: TenableSC.Scan.RolloverType
      description: Scan rollover type.
      type: String
    - contextPath: TenableSC.Scan.ScanResultID
      description: Scan results ID.
      type: String
    - contextPath: TenableSC.Scan.ScanningVirtualHosts
      description: Scan virtual hosts.
      type: String
    - contextPath: TenableSC.Scan.Schedule.Dependent.Description
      description: Scan schedule dependent description.
      type: String
    - contextPath: TenableSC.Scan.Schedule.Dependent.ID
      description: Scan schedule dependent ID.
      type: Number
    - contextPath: TenableSC.Scan.Schedule.Dependent.Name
      description: Scan schedule dependent name.
      type: String
    - contextPath: TenableSC.Scan.Schedule.Enabled
      description: Scan schedule enabled.
      type: String
    - contextPath: TenableSC.Scan.Schedule.ID
      description: Scan schedule ID.
      type: Number
    - contextPath: TenableSC.Scan.Schedule.NextRun
      description: Scan schedule next run.
      type: Number
    - contextPath: TenableSC.Scan.Schedule.ObjectType
      description: Scan schedule object type.
      type: Number
    - contextPath: TenableSC.Scan.Schedule.RepeatRule
      description: Scan schedule repeat rule.
      type: String
    - contextPath: TenableSC.Scan.Schedule.Start
      description: Scan schedule start time.
      type: String
    - contextPath: TenableSC.Scan.Schedule.Type
      description: Scan schedule type.
      type: String
    - contextPath: TenableSC.Scan.Status
      description: Scan status.
      type: String
    - contextPath: TenableSC.Scan.TimeoutAction
      description: Scan timeout action.
      type: String
    - contextPath: TenableSC.Scan.Type
      description: Scan type.
      type: String
    - contextPath: TenableSC.Scan.UUID
      description: Scan UUID.
      type: String
    - contextPath: TenableSC.Scan.Zone.Description
      description: Scan zone description.
      type: String
    - contextPath: TenableSC.Scan.Zone.ID
      description: Scan zone ID.
      type: Number
    - contextPath: TenableSC.Scan.Zone.Name
      description: Scan zone name.
      type: String
  dockerimage: demisto/python3:3.10.13.90168
  isfetch: true
  runonce: false
  script: |
    register_module_line('Tenable.sc', 'start', __line__())
    ### pack version: 1.0.12


    import re
    from requests import Session
    import urllib3
    import functools
    import json
    from datetime import datetime
    from requests import cookies
    import pytz
    from typing import Dict, Any

    # disable insecure warnings
    urllib3.disable_warnings()


    ''' GLOBAL VARIABLES'''
    ACTION_TYPE_TO_VALUE = {
        'notification': 'users.username',
        'email': 'users.username',
        'syslog': 'host',
        'scan': 'scan.name',
        'report': 'report.name',
        'ticket': 'assignee.username'
    }
    FIELDS_TO_INCLUDE = 'id,name,description,type,ownerGroup,owner,tags,modifiedTime'
    API_KEY = "API_KEY"
    USERNAME_AND_PASSWORD = "USERNAME_AND_PASSWORD"
    ROLE_ID_DICT = {
        "Administrator": "1",
        "Security Manager": "2",
        "Security Analyst": "3",
        "Vulnerability Analyst": "4",
        "Executive": "5",
        "Credential Manager": "6",
        "Auditor": "7"
    }


    class Client(BaseClient, object):
        def __init__(self, verify_ssl: bool = True, proxy: bool = False, user_name: str = "",
                     password: str = "", access_key: str = "", secret_key: str = "", url: str = ""):

            if not proxy:
                try:
                    del os.environ['HTTP_PROXY']
                    del os.environ['HTTPS_PROXY']
                    del os.environ['http_proxy']
                    del os.environ['https_proxy']
                except Exception as e:
                    demisto.debug(f"encountered the following issue: {e}")

            self.url = f"{get_server_url(url)}/rest"
            self.verify_ssl = verify_ssl
            self.max_retries = 3
            self.headers: dict[str, Any] = {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
            self.auth_method = API_KEY
            if not (user_name and password) and not (secret_key and access_key):
                raise DemistoException("Please provide either user_name and password or secret_key and access_key")
            if secret_key and access_key:
                self.headers['x-apikey'] = f"accesskey={access_key}; secretkey={secret_key}"
                BaseClient.__init__(self, base_url=self.url, headers=self.headers, verify=verify_ssl, proxy=proxy)
                self.send_request = self.send_request_api_key_auth
            else:
                self.session = Session()
                integration_context = demisto.getIntegrationContext()
                self.token = integration_context.get('token')
                self.cookie = integration_context.get('cookie')
                self.user_name = user_name
                self.password = password
                self.send_request = self.send_request_username_and_password_auth
                self.auth_method = USERNAME_AND_PASSWORD
                if not self.token or not self.cookie:
                    self.login()

        def __enter__(self):
            return self

        def send_request_api_key_auth(self, path, method='GET', body={}, params={}, headers=None):
            """
            Send the requests for access & secret keys authentication method.
            Args:
                path (str): The url suffix.
                method (str): The request method.
                body (dict): The request body.
                params (dict): The request params.
                headers (dict): The request headers.
            Returns:
                Dict: The response.
            """
            headers = headers or self.headers
            return self._http_request(method, url_suffix=path, params=params, data=json.dumps(body), headers=headers)

        def send_request_username_and_password_auth(self, path, method='GET', body=None, params=None, headers=None, try_number=1):
            """
            Send the requests for username & password authentication method.
            Args:
                path (str): The url suffix.
                method (str): The request method.
                body (dict): The request body.
                params (dict): The request params.
                headers (dict): The request headers.
                try_number (int): The request retries counter.
            Returns:
                Dict: The response.
            """
            body = body if body is not None else {}
            params = params if params is not None else {}
            headers = headers if headers is not None else self.headers

            headers['X-SecurityCenter'] = self.token
            url = '{}/{}'.format(self.url, path)

            session_cookie = cookies.create_cookie('TNS_SESSIONID', self.cookie)
            self.session.cookies.set_cookie(session_cookie)  # type: ignore

            res = self.session.request(method, url, data=json.dumps(body), params=params, headers=headers, verify=self.verify_ssl)

            if res.status_code == 403 and try_number <= self.max_retries:
                self.login()
                headers['X-SecurityCenter'] = self.token  # The Token is being updated in the login
                return self.send_request_username_and_password_auth(path, method, body, params, headers, try_number + 1)

            elif res.status_code < 200 or res.status_code >= 300:
                try:
                    error = res.json()
                except Exception:
                    # type: ignore
                    raise DemistoException(
                        f'Error: Got status code {str(res.status_code)} with {url=} \
                        with body {res.content} with headers {str(res.headers)}')   # type: ignore

                raise DemistoException(f"Error: Got an error from TenableSC, code: {error['error_code']}, \
                            details: {error['error_msg']}")  # type: ignore
            return res.json()

        def login(self):
            """
            Set the token for username & password authentication method.
            """
            login_body = {
                'username': self.user_name,
                'password': self.password
            }
            login_response = self.send_login_request(login_body)

            if 'response' not in login_response:
                raise DemistoException('Error: Could not retrieve login token')

            token = login_response['response'].get('token')
            # There might be a case where the API does not return a token because there are too many sessions with the same user
            # In that case we need to add 'releaseSession = true'
            if not token:
                login_body['releaseSession'] = 'true'
                login_response = self.send_login_request(login_body)
                if 'response' not in login_response or 'token' not in login_response['response']:
                    raise DemistoException('Error: Could not retrieve login token')
                token = login_response['response']['token']

            self.token = str(token)
            demisto.setIntegrationContext({'token': self.token})

        def send_login_request(self, login_body):
            """
            Send the request to login for username & password authentication method.
            Args:
                login_body (dict): The request body.
            Returns:
                Dict: The response.
            """
            url = f'{self.url}/token'

            headers = {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
            res = self.session.request('post', url, headers=headers, data=json.dumps(login_body), verify=self.verify_ssl)

            if res.status_code < 200 or res.status_code >= 300:
                raise DemistoException(f'Error: Got status code {str(res.status_code)} with {url=} \
                            with body {res.content} with headers {str(res.headers)}')  # type: ignore

            self.cookie = res.cookies.get('TNS_SESSIONID', self.cookie)
            demisto.setIntegrationContext({'cookie': self.cookie})

            return res.json()

        def __exit__(self, *args):
            """
            Send the request to logout for username & password authentication method.
            """
            if self.auth_method == USERNAME_AND_PASSWORD:
                self.send_request(path='token', method='DELETE')

        def create_scan(self, args: Dict[str, Any]):
            """
            Send the request for create_scan_command and create_remediation_scan_command.
            Args:
                args (dict): The demisto.args() object.
            Returns:
                Dict: The response.
            """
            body = self.create_scan_body(args)

            return self.send_request(path='scan', method='POST', body=body)

        def create_scan_body(self, args):
            """
            Construct the body for the create_scan request.
            Args:
                args (dict): The demisto.args() object.
            Returns:
                Dict: The request body.
            """
            create_scan_mapping_dict = {
                'description': 'description',
                'dhcpTracking': 'dhcp_tracking',
                'timeoutAction': 'timeout_action',
                'scanningVirtualHosts': 'scan_virtual_hosts',
                'rolloverType': 'rollover_type',
                'ipList': 'ip_list'
            }
            body = {key: args.get(value) for key, value in create_scan_mapping_dict.items() if args.get(value)}

            scan_type = args.get("scan_type")
            body["type"] = scan_type if scan_type else ('policy' if args.get("policy_id") else 'plugin')

            body['name'] = args.get('name') or args.get('scan_name')

            body["pluginID"] = args.get('plugin_id') or args.get('plugins_id')

            if repo_id := args.get("repository_id"):
                body["repository"] = {'id': repo_id}

            if policy_id := args.get("policy_id"):
                body["policy"] = {'id': policy_id}

            if zone_id := args.get("zone_id"):
                body["zone"] = {'id': zone_id}

            if report_ids := args.get("report_ids"):
                body['reports'] = [{'id': r_id, 'reportSource': 'individual'} for r_id in argToList(report_ids)]

            if asset_ids := args.get("asset_ids"):
                if str(asset_ids).startswith('All'):
                    manageable = True if asset_ids == 'AllManageable' else False
                    res = self.get_assets(None)
                    assets = get_elements(res['response'], manageable)
                    asset_ids = list(map(lambda a: a['id'], assets))
                body['assets'] = [{'id': a_id} for a_id in argToList(asset_ids)]

            if credentials := args.get("credentials"):
                body['credentials'] = [{'id': c_id} for c_id in argToList(credentials)]

            if max_scan_time := int(args.get('max_scan_time', '1')):
                body['maxScanTime'] = max_scan_time * 3600

            if schedule := args.get('schedule'):
                schedule_body = {
                    'type': schedule
                }

                if dependent := args.get('dependent_id'):
                    schedule_body['dependentID'] = dependent

                if schedule == 'ical':
                    start_time = args.get("start_time")
                    repeat_rule_freq = args.get("repeat_rule_freq", "")
                    repeat_rule_interval = int(args.get("repeat_rule_interval", 0))
                    repeat_rule_by_day = argToList(args.get("repeat_rule_by_day", ""))
                    timestamp_format = "%Y%m%dT%H%M%S"
                    expected_format = "%Y-%m-%d:%H:%M:%S"
                    try:
                        start_time = datetime.strptime(start_time, expected_format)
                        start_time = datetime.strftime(start_time, timestamp_format)
                    except Exception:
                        start_time = parse_date_range(start_time, date_format=timestamp_format)[0]
                    if time_zone := args.get("time_zone") and start_time:
                        schedule_body['start'] = f"TZID={time_zone}:{start_time}"
                    else:
                        raise DemistoException("Please make sure to provide both time_zone and start_time.")
                    if all([repeat_rule_freq, repeat_rule_interval, repeat_rule_by_day]):
                        schedule_body['repeatRule'] = f"FREQ={repeat_rule_freq};INTERVAL={repeat_rule_interval};"
                        f"BYDAY={repeat_rule_by_day}"
                    elif repeat_rule_freq and repeat_rule_interval:
                        schedule_body['repeatRule'] = f"FREQ={repeat_rule_freq};INTERVAL={repeat_rule_interval}"
                    elif any([repeat_rule_freq, repeat_rule_interval, repeat_rule_by_day]):
                        raise DemistoException("Please make sure to provide repeat_rule_freq, repeat_rule_interval with or without "
                                               "repeat_rule_by_day, or don't provide any of them.")
                    schedule_body['enabled'] = argToBoolean(args.get("enabled", True))
                body['schedule'] = schedule_body

            remove_nulls_from_dictionary(body)
            return body

        def get_scan_results(self, scan_results_id):
            """
            Send the request for get_scan_status.
            Args:
                scan_results_id (str): The ID of the scan results to search.
            Returns:
                Dict: The response.
            """
            path = 'scanResult/' + scan_results_id

            return self.send_request(path)

        def launch_scan(self, scan_id, scan_target):
            """
            Send the request for launch_scan_command and launch_scan_report_command.
            Args:
                scan_id (str): The ID of the scan to launch.
                scan_target (str): Optional body parameters.
            Returns:
                Dict: The response.
            """
            path = 'scan/' + scan_id + '/launch'
            body = None
            if scan_target:
                body = {
                    'diagnosticTarget': scan_target['address'],
                    'diagnosticPassword': scan_target['password']
                }

            return self.send_request(path, 'post', body=body)

        def get_query(self, query_id):
            """
            Send the request for get_alert_command and list_query_command.
            Args:
                query_id (str): The ID of the query to retrieve.
            Returns:
                Dict: The response.
            """
            path = f'query/{query_id}'

            return self.send_request(path)

        def list_queries(self, type):
            """
            Send the request for list_query_command and list_queries.
            Args:
                type (str): The query type to retrieve.
            Returns:
                Dict: The response.
            """
            path = 'query'
            params = {}
            if type:
                params["type"] = type

            return self.send_request(path=path, method="GET", params=params)

        def get_all_scan_results(self):
            """
            Send the request for get_all_scan_results_command.
            Returns:
                Dict: The response.
            """
            params = {
                'fields': 'name,description,details,status,scannedIPs,startTime,scanDuration,importStart,'
                'finishTime,completedChecks,owner,ownerGroup,repository,importStatus'
            }
            return self.send_request(path='scanResult', params=params)

        def get_alerts(self, fields=None, alert_id=None):
            """
            Send the request for list_alerts_command and get_alert_command.
            Args:
                fields (str): The fields to include in the response.
                alert_id (str): The ID of the alert to search.
            Returns:
                Dict: The response.
            """
            path = 'alert'
            params = {}  # type: Dict[str, Any]

            if alert_id:
                path += '/' + alert_id

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path, params=params)

        def get_system_licensing(self):
            """
            Send the request for get_system_licensing_command.
            Returns:
                Dict: The response.
            """
            return self.send_request(path='status')

        def get_scans(self, fields):
            """
            Send the request for list_scans_command.
            Args:
                fields (str): The fields to include in the response.
            Returns:
                Dict: The response.
            """
            params = None

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path='scan', params=params)

        def get_policies(self, fields):
            """
            Send the request for list_policies_command.
            Args:
                fields (str): The fields to include in the response.
            Returns:
                Dict: The response.
            """
            params = None

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path='policy', params=params)

        def get_repositories(self):
            """
            Send the request for list_repositories_command.
            Returns:
                Dict: The response.
            """
            return self.send_request(path='repository')

        def get_assets(self, fields):
            """
            Send the request for list_assets_command and create_scan.
            Args:
                fields (str): The fields to include in the response.
            Returns:
                Dict: The response.
            """
            params = None

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path='asset', params=params)

        def get_credentials(self):
            """
            Send the request for list_credentials_command.
            Returns:
                Dict: The response.
            """
            params = {
                'fields': FIELDS_TO_INCLUDE
            }

            return self.send_request(path='credential', params=params)

        def get_asset(self, asset_id):
            """
            Send the request for list_assets_command.
            Args:
                asset_id (str): The ID of the asset to search.
            Returns:
                Dict: The response.
            """
            params = {
                'fields': 'id,name,description,status,createdTime,modifiedTime,viewableIPs,ownerGroup,tags,owner'
            }

            return self.send_request(path=f'asset/{asset_id}', params=params)

        def create_asset(self, name, description, owner_id, tags, ips):
            """
            Send the request for create_asset_command.
            Args:
                name (str): The name for the asset.
                description (str): The description for the asset.
                owner_id (str): The ID of the owner of the asset.
                tags (str): The tags for the asset.
                ips (str): The IP list for the asset.
            Returns:
                Dict: The response.
            """
            body = {
                'name': name,
                'definedIPs': ips,
                'type': 'static'
            }

            if description:
                body['description'] = description

            if owner_id:
                body['ownerID'] = owner_id

            if tags:
                body['tags'] = tags

            return self.send_request(path='asset', method='POST', body=body)

        def delete_asset(self, asset_id):
            """
            Send the request for delete_asset_command.
            Args:
                asset_id (str): The ID of the asset to delete.
            Returns:
                Dict: The response.
            """
            return self.send_request(path=f'asset/{asset_id}', method='DELETE')

        def get_report_definitions(self, fields):
            """
            Send the request for list_report_definitions_command.
            Args:
                fields (str): The fields to include in the response.
            Returns:
                Dict: The response.
            """
            params = None

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path='reportDefinition', params=params)

        def get_zones(self):
            """
            Send the request for list_zones_command.
            Returns:
                Dict: The response.
            """
            return self.send_request(path='zone')

        def get_scan_report(self, scan_results_id):
            """
            Send the request for get_scan_report_command and launch_scan_report_command.
            Args:
                scan_results_id (str): The ID of the scan_results to search for.
            Returns:
                Dict: The response.
            """
            path = 'scanResult/' + scan_results_id

            params = {
                'fields': 'name,description,details,status,scannedIPs,progress,startTime,scanDuration,importStart,'
                          'finishTime,completedChecks,owner,ownerGroup,repository,policy,importStatus,running'
            }

            return self.send_request(path, params=params)

        def create_query(self, scan_id, tool):
            """
            Send the request for get_vulnerabilities.
            Args:
                scan_id (str): The ID of the scan_results to create the query for.
                tool (str): the tool to use.
            Returns:
                Dict: The response.
            """
            path = 'query'

            body = {
                'name': f'scan {scan_id} query',
                'type': 'vuln',
                'tool': tool,
                'scanID': scan_id
            }

            return self.send_request(path, method='POST', body=body)

        def delete_query(self, query_id):
            """
            Send the request for get_vulnerabilities.
            Args:
                query_id (str): The ID of the query to delete.
            Returns:
                Dict: The response.
            """
            if not query_id:
                raise DemistoException('query id returned None')
            path = 'query/' + str(query_id)
            self.send_request(path, method='DELETE')

        def get_analysis(self, body=None, args={}):
            """
            Send the request for get_vulnerability_command and get_vulnerabilities.
            Args:
                args (dict): Either an empty dict if passed from get_vulnerabilities, otherwise, the demisto.results() object.
                body (str): The request body (if function is called from get_vulnerabilities).
            Returns:
                Dict: The response.
            """
            body = body or self.create_get_vulnerability_request_body(args)

            return self.send_request(path='analysis', method='POST', body=body)

        def create_get_vulnerability_request_body(self, args={}):
            """
            Create the body for the request made in get_analysis.
            Args:
                args (dict): Either an empty dict if passed from get_vulnerabilities, otherwise, the demisto.results() object.
            Returns:
                Dict: The prepared request body.
            """
            vuln_id = args.get('vulnerability_id')
            scan_results_id = args.get('scan_results_id')
            sort_field = args.get('sort_field', 'severity')
            query_id = args.get('query_id')
            query = {'id': query_id}
            sort_direction = args.get('sort_direction', "ASC")
            source_type = args.get('source_type', "individual")
            page = int(args.get('page', '0'))
            limit = int(args.get('limit', '50'))
            if limit > 200:
                limit = 200
            body = {
                'type': 'vuln',
                'view': 'all',
                'sourceType': source_type,
                'startOffset': page,  # Lower bound for the results list (must be specified)
                'endOffset': page + limit,  # Upper bound for the results list (must be specified)
                'sortField': sort_field,
                'sortDir': sort_direction,
                'tool': 'vulndetails',
            }
            if source_type == 'individual':
                if scan_results_id:
                    body['scanID'] = scan_results_id
                else:
                    raise DemistoException("When choosing source_type = individual - scan_results_id must be provided.")
                vuln_filter = [{
                    'filterName': 'pluginID',
                    'operator': '=',
                    'value': vuln_id
                }]
                query["filters"] = vuln_filter
                query["tool"] = 'vulndetails'
                query["type"] = 'vuln'
            else:
                body['sourceType'] = source_type
                if not query_id:
                    raise DemistoException(f"When choosing source_type = {source_type} - query_id must be provided.")
            body["query"] = query

            return body

        def get_system_diagnostics(self):
            """
            Send the request for get_system_information_command.
            Returns:
                Dict: The response.
            """
            return self.send_request(path='system/diagnostics')

        def get_system(self):
            """
            Send the request for get_system_information_command.
            Returns:
                Dict: The response.
            """
            return self.send_request(path='system')

        def list_groups(self, show_users):
            """
            Send the request for list_groups_command.
            Args:
                show_users (str): Optional filtering argument.
            Returns:
                Dict: The response.
            """
            params = {}
            if show_users:
                params['fields'] = 'users'

            return self.send_request(path='group', method='GET', params=params)

        def get_vulnerability(self, vuln_id):
            """
            Send the request for get_vulnerability_command.
            Args:
                vuln_id (str): The ID of the vulnerability to search.
            Returns:
                Dict: The response.
            """
            path = f'plugin/{vuln_id}'

            params = {
                'fields': 'name,description,family,type,cpe,riskFactor,solution,synopsis,exploitEase,exploitAvailable,'
                          'cvssVector,baseScore,pluginPubDate,pluginModDate,vulnPubDate,temporalScore,xrefs,checkType'
            }

            return self.send_request(path, params=params)

        def delete_scan(self, scan_id):
            """
            Send the request for delete_scan_command.
            Args:
                scan_id (str): The ID of the scan to delete.
            Returns:
                Dict: The response.
            """
            return self.send_request(path=f'scan/{scan_id}', method='DELETE')

        def get_device(self, uuid, ip, dns_name, repo):
            """
            Send the request for get_device_command.
            Args:
                uuid (str): The UUID of the device to search.
                ip (str): Optional filtering argument.
                dns_name (str): Optional filtering argument.
                repo (str): Optional filtering argument.
            Returns:
                Dict: The response.
            """
            path, params = create_get_device_request_params_and_path(uuid, ip, dns_name, repo)

            return self.send_request(path, params=params)

        def get_users(self, fields='id,username,firstname,lastname,title,email,createdTime,modifiedTime,lastLogin,role',
                      user_id=None):
            """
            Send the request for list_users_command.
            Args:
                fields (str): The fields to include in the response.
                user_id (str): The ID of the user to search.
            Returns:
                Dict: The response.
            """
            path = 'user'

            if user_id:
                path += '/' + user_id

            params = None

            if fields:
                params = {
                    'fields': fields
                }

            return self.send_request(path, params=params)

        def create_user(self, args):
            """
            Send the request for create_user_command.
            Args:
                args (Dict): The demisto.args() object.
            Returns:
                Dict: The response.
            """
            body = create_user_request_body(args)

            return self.send_request(path='user', body=body, method='POST')

        def update_user(self, args, user_id):
            """
            Send the request for update_user_command.
            Args:
                args (Dict): The demisto.args() object.
                user_id (str): The ID of the user to update.
            Returns:
                Dict: The response.
            """
            body = create_user_request_body(args)

            return self.send_request(path=f'user/{user_id}', body=body, method='PATCH')

        def update_asset(self, args, asset_id):
            """
            Send the request for update_asset_command.
            Args:
                args (Dict): The demisto.args() object.
                asset_id (str): The ID of the asset to update.
            Returns:
                Dict: The response.
            """
            body = {
                "name": args.get("name"),
                "description": args.get("description"),
                "tags": args.get("tags"),
                "ownerID": args.get("owner_id"),
                "definedIPs": args.get("ip_list")
            }
            remove_nulls_from_dictionary(body)
            return self.send_request(path=f'asset/{asset_id}', body=body, method='PATCH')

        def delete_user(self, user_id):
            """
            Send the request for delete_user_command.
            Args:
                user_id (str): The ID of the user to delete.
            Returns:
                Dict: The response.
            """
            return self.send_request(path=f'user/{user_id}', method='DELETE')

        def list_plugin_family(self, plugin_id, is_active):
            """
            Send the request for list_plugin_family_command.
            Args:
                plugin_id (str): The id of the plugin to get.
                is_active (str): Wether to filter by active / passive plugins.
            Returns:
                Dict: The response.
            """
            path = "pluginFamily"
            if plugin_id:
                path += f"/{plugin_id}"
            else:
                if is_active == 'true':
                    path += "?fields=active"
                elif is_active == 'false':
                    path += "?fields=passive"
            return self.send_request(path=path, method='GET')

        def create_policy(self, args):
            """
            Send the request for create_policy_command.
            Args:
                args (Dict): the demisto.args() object.
            Returns:
                Dict: The response.
            """
            body = create_policy_request_body(args)

            return self.send_request(path="policy", method='POST', body=body)


    ''' HELPER FUNCTIONS '''


    def create_get_device_request_params_and_path(uuid: str, ip: str, dns_name: str, repo: str):
        """
        Construct the url suffix and params dict for get_device request.
        Args:
            uuid (str): UUID extracted from args.
            ip (str): IP extracted from args.
            dns_name (str): Dns extracted from args.
            repo (str): Repo name extracted from args.
        Returns:
            str: The url suffix for the request.
            Dict: The params for the request.
        """
        path = f'repository/{repo}/' if repo else ''
        path += 'deviceInfo'
        params = {
            'fields': 'ip,uuid,macAddress,netbiosName,dnsName,os,osCPE,lastScan,repository,total,severityLow,'
                      'severityMedium,severityHigh,severityCritical'
        }
        if uuid:
            params['uuid'] = uuid
        else:
            params['ip'] = ip
            if dns_name:
                params['dnsName'] = dns_name
        return path, params


    def create_policy_request_body(args: Dict[str, Any]):
        """
        Construct the body for create_policy request.
        Args:
            args (Dict): The demisto.args() object.
        Returns:
            Dict: The body for the request.
        """
        body = {
            "name": args.get("policy_name"),
            "description": args.get("policy_description"),
            "context": "scan",
            "preferences": {
                "portscan_range": args.get("port_scan_range", 'default'),
                "tcp_scanner": args.get("tcp_scanner", "no"),
                "syn_scanner": args.get("syn_scanner", "yes"),
                "udp_scanner": args.get("udp_scanner", "no"),
                "syn_firewall_detection": args.get("syn_firewall_detection", 'Automatic (normal)')
            },
            "policyTemplate": {
                "id": args.get("policy_template_id", '1')
            },
        }
        family = {"id": args.get("family_id", "")}
        if plugins_id := args.get("plugins_id"):
            family["plugins"] = [{"id": id for id in plugins_id.split(',')}]
        body["families"] = [family]
        remove_nulls_from_dictionary(body)
        return body


    def create_user_request_body(args: Dict[str, Any]):
        """
        Create user request body for update or create user commands.
        Args:
            args (Dict): the demisto.args() object.
        Returns:
            Dict: The request body.
        """
        user_query_mapping_dict: dict[str, str] = {
            "firstname": "first_name",
            "lastname": "last_name",
            "username": "user_name",
            "email": "email",
            "city": "city",
            "state": "state",
            "address": "address",
            "country": "country",
            "authType": "auth_type",
            "emailNotice": "email_notice",
            "phone": "phone",
            "locked": "locked",
            "mustChangePassword": "must_change_password",
            "currentPassword": "current_password",
            "password": "password",
            "groupID": "group_id",
            "responsibleAssetID": "responsible_asset_id"
        }
        body = {key: args.get(value) for key, value in user_query_mapping_dict.items() if args.get(value)}

        if role_id := args.get("role_id", ""):
            body["roleID"] = ROLE_ID_DICT.get(role_id, "")

        if args.get('managed_users_groups'):
            body["managedUsersGroups"] = [{"id": managed_users_group} for
                                          managed_users_group in args.get('managed_users_groups', "").split(',')]
        if args.get('managed_objects_groups'):
            body["managedObjectsGroups"] = [{"id": int(managed_objects_group)} for
                                            managed_objects_group in args.get('managed_objects_groups', "").split(',')]
        if time_zone := args.get('time_zone'):
            body["preferences"] = [{"name": "timezone", "value": time_zone, "tag": ""}]

        return body


    def get_server_url(url):
        """
        Remove redundant '/' from the url the server url.
        For example: www.example.com/ - > www.example.com.
        Args:
            url (str): The server url.
        Returns:
            str: The server url.
        """
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    def validate_user_body_params(args: Dict[str, Any], command_type: str):
        """
        Validate all given arguments are valid according to the command type (update or create).
        Args:
            args (Dict): the demisto.args() object.
            command_type (Dict): the command type the function is called from (update or create)
        Returns:
            None: return error if arguments are invalid.
        """
        numbers_args_ls = ["group_id", "user_id", "responsible_asset_id"]

        time_zone = args.get("time_zone")
        password = args.get("password")
        email_notice = args.get("email_notice")
        email = args.get("email")
        auth_type = args.get("auth_type")

        for number_arg in numbers_args_ls:
            try:
                int(args.get(number_arg, '0'))
            except Exception:
                raise DemistoException(f"{number_arg} must be a valid number.")

        if time_zone and time_zone not in pytz.all_timezones:
            raise DemistoException("Invalid time zone ID. Please choose one of the following: "
                                   "https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html")

        if command_type == "create" and (auth_type == 'Ldap' or auth_type == 'saml'):
            args["must_change_password"] = "false"

        if password:
            if command_type == 'update' and not args.get("current_password"):
                raise DemistoException("current_password must be provided when attempting to update password.")
            if len(password) < 3:
                raise DemistoException("Password length must be at least 3 characters.")

        if email and not re.compile(emailRegex).match(email):
            raise DemistoException(f"Error: The given email address: {email} is not in the correct format.")

        if command_type == 'create' and not email_notice == 'none' and not email:
            raise DemistoException("When email_notice is different from none, an email must be given as well.")


    def timestamp_to_utc(timestamp_str, default_returned_value=''):
        """
        Convert timestamp string to UTC date time.
        Args:
            timestamp_str (str): timestamp string.
            default_returned_value (str): the default return value
        Returns:
            str: UTC date time string.
        """
        if timestamp_str and (int(timestamp_str) > 0):  # no value is when timestamp_str == '-1'
            return datetime.utcfromtimestamp(int(timestamp_str)).strftime(
                '%Y-%m-%dT%H:%M:%SZ')
        return default_returned_value


    def scan_duration_to_demisto_format(duration, default_returned_value=''):
        """
        Convert duration to demisto format time.
        Args:
            duration (str): Scan duration in tenable sc format.
            default_returned_value (str): the default return value
        Returns:
            Int / str: the scan duration in demisto format.
        """
        if duration:
            return float(duration) / 60
        return default_returned_value


    ''' FUNCTIONS '''


    def list_scans_command(client: Client, args: Dict[str, Any]):
        """
        List scans.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_scans('id,name,description,policy,ownerGroup,owner')
        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No scans found')

        scans_dicts = get_elements(res['response'], manageable)

        if len(scans_dicts) == 0:
            raise DemistoException('No scans found')

        headers = ['ID', 'Name', 'Description', 'Policy', 'Group', 'Owner']

        mapped_scans = [{
            'Name': s['name'],
            'ID': s['id'],
            'Description': s['description'],
            'Policy': s['policy'].get('name'),
            'Group': s['ownerGroup'].get('name'),
            'Owner': s['owner'].get('username')
        } for s in scans_dicts]

        return CommandResults(
            outputs=createContext(mapped_scans, removeNull=True),
            outputs_prefix='TenableSC.Scan',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Scans', mapped_scans, headers, removeNull=True)
        )


    def list_policies_command(client: Client, args: Dict[str, Any]):
        """
        List policies.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_policies('id,name,description,tags,modifiedTime,owner,ownerGroup,policyTemplate')

        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No policies found')

        policies = get_elements(res['response'], manageable)

        if len(policies) == 0:
            raise DemistoException('No policies found')

        headers = ['ID', 'Name', 'Description', 'Tag', 'Type', 'Group', 'Owner', 'LastModified']

        mapped_policies = [{
            'ID': p['id'],
            'Name': p['name'],
            'Description': p['description'],
            'Tag': p['tags'],
            'Type': p.get('policyTemplate', {}).get('name'),
            'Group': p.get('ownerGroup', {}).get('name'),
            'Owner': p.get('owner', {}).get('username'),
            'LastModified': timestamp_to_utc(p['modifiedTime'])
        } for p in policies]

        return CommandResults(
            outputs=createContext(mapped_policies, removeNull=True),
            outputs_prefix='TenableSC.ScanPolicy',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Scan Policies', mapped_policies, headers, removeNull=True)
        )


    def list_repositories_command(client: Client, args: Dict[str, Any]):
        """
        List repositories.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_repositories()

        if not (res and res.get('response')):
            raise DemistoException('No repositories found')

        repositories = res['response']

        if len(repositories) == 0:
            raise DemistoException('No repositories found')

        headers = [
            'ID',
            'Name',
            'Description'
        ]

        mapped_repositories = [{'ID': r['id'], 'Name': r['name'], 'Description': r['description']} for r in repositories]

        return CommandResults(
            outputs=createContext(mapped_repositories, removeNull=True),
            outputs_prefix='TenableSC.ScanRepository',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Scan Repositories', mapped_repositories, headers, removeNull=True)
        )


    def list_credentials_command(client: Client, args: Dict[str, Any]):
        """
        List credentials.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_credentials()

        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No credentials found')

        credentials = get_elements(res['response'], manageable)

        if len(credentials) == 0:
            raise DemistoException('No credentials found')

        headers = ['ID', 'Name', 'Description', 'Type', 'Tag', 'Group', 'Owner', 'LastModified']

        mapped_credentials = [{
            'ID': c['id'],
            'Name': c['name'],
            'Description': c['description'],
            'Type': c['type'],
            'Tag': c['tags'],
            'Group': c.get('ownerGroup', {}).get('name'),
            'Owner': c.get('owner', {}).get('name'),
            'LastModified': timestamp_to_utc(c['modifiedTime'])
        } for c in credentials]

        return CommandResults(
            outputs=createContext(mapped_credentials, removeNull=True),
            outputs_prefix='TenableSC.Credential',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Credentials', mapped_credentials, headers, removeNull=True)
        )


    def list_assets_command(client: Client, args: Dict[str, Any]):
        """
        List assets.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_assets('id,name,description,ipCount,type,tags,modifiedTime,groups,owner')

        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No assets found')

        assets = get_elements(res['response'], manageable)

        if len(assets) == 0:
            raise DemistoException('No assets found')

        headers = ['ID', 'Name', 'Tag', 'Owner', 'Group', 'Type', 'HostCount', 'LastModified']

        mapped_assets = [{
            'ID': a['id'],
            'Name': a['name'],
            'Tag': a['tags'],
            'Owner': a.get('owner', {}).get('username'),
            'Type': a['type'],
            'Group': a.get('ownerGroup', {}).get('name'),
            'HostCount': a['ipCount'],
            'LastModified': timestamp_to_utc(a['modifiedTime'])
        } for a in assets]

        return CommandResults(
            outputs=createContext(mapped_assets, removeNull=True),
            outputs_prefix='TenableSC.Asset',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Assets', mapped_assets, headers, removeNull=True)
        )


    def get_asset_command(client: Client, args: Dict[str, Any]):
        """
        Retrieve an asset by a given asset ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        asset_id = args.get('asset_id')

        res = client.get_asset(asset_id)

        if not res or 'response' not in res:
            raise DemistoException('Asset not found')

        asset = res['response']

        ips = []  # type: List[str]
        ip_lists = [v['ipList'] for v in asset.get('viewableIPs', '')]

        for ip_list in ip_lists:
            # Extract IPs
            ips += re.findall('[0-9]+(?:\.[0-9]+){3}', ip_list)

        headers = ['ID', 'Name', 'Description', 'Tag', 'Created', 'Modified', 'Owner', 'Group', 'IPs']

        mapped_asset = {
            'ID': asset['id'],
            'Name': asset['name'],
            'Description': asset['description'],
            'Tag': asset['tags'],
            'Created': timestamp_to_utc(asset['createdTime']),
            'Modified': timestamp_to_utc(asset['modifiedTime']),
            'Owner': asset.get('owner', {}).get('username'),
            'Group': asset.get('ownerGroup', {}).get('name'),
            'IPs': ips
        }

        return CommandResults(
            outputs=createContext(mapped_asset, removeNull=True),
            outputs_prefix='TenableSC.Asset',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Asset', mapped_asset, headers, removeNull=True)
        )


    def create_asset_command(client: Client, args: Dict[str, Any]):
        """
        Create an asset.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        name = args.get('name')
        description = args.get('description')
        owner_id = args.get('owner_id')
        tags = args.get('tags')
        ips = args.get('ip_list')

        res = client.create_asset(name, description, owner_id, tags, ips)

        if not res or 'response' not in res:
            raise DemistoException('Error: Could not retrieve the asset')

        asset = res['response']

        mapped_asset = {
            'ID': asset['id'],
            'Name': asset['name'],
            'OwnerName': asset['owner'].get('username'),
            'Tags': asset['tags'],
        }

        headers = [
            'ID',
            'Name',
            'OwnerName',
            'Tags'
        ]

        return CommandResults(
            outputs=createContext(mapped_asset, removeNull=True),
            outputs_prefix='TenableSC.Asset',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Asset created successfully', mapped_asset, headers=headers, removeNull=True)
        )


    def delete_asset_command(client: Client, args: Dict[str, Any]):
        """
        Delete an asset by a given asset ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response and the human readable section.
        """
        asset_id = args.get('asset_id')

        res = client.delete_asset(asset_id)

        if not res:
            raise DemistoException('Error: Could not delete the asset')

        return CommandResults(
            raw_response=res,
            readable_output=f"Asset {asset_id} was deleted successfully."
        )


    def list_report_definitions_command(client: Client, args: Dict[str, Any]):
        """
        Lists report definitions.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_report_definitions('id,name,description,modifiedTime,type,ownerGroup,owner')

        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No report definitions found')

        reports = get_elements(res['response'], manageable)
        # Remove duplicates, take latest
        reports = [functools.reduce(lambda x, y: x if int(x['modifiedTime']) > int(y['modifiedTime']) else y,
                                    filter(lambda e: e['name'] == n, reports)) for n in {r['name'] for r in reports}]

        if len(reports) == 0:
            raise DemistoException('No report definitions found')

        headers = ['ID', 'Name', 'Description', 'Type', 'Group', 'Owner']

        mapped_reports = [{
            'ID': r['id'],
            'Name': r['name'],
            'Description': r['description'],
            'Type': r['type'],
            'Group': r.get('ownerGroup', {}).get('name'),
            'Owner': r.get('owner', {}).get('username')
        } for r in reports]

        hr = tableToMarkdown('Tenable.sc Report Definitions', mapped_reports, headers, removeNull=True)
        for r in mapped_reports:
            del r['Description']

        return CommandResults(
            outputs=createContext(mapped_reports, removeNull=True),
            outputs_prefix='TenableSC.ReportDefinition',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def list_zones_command(client: Client, args: Dict[str, Any]):
        """
        Lists zones
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_zones()
        if not res or 'response' not in res:
            raise DemistoException('No zones found')
        zones = res['response']
        if len(zones) == 0:
            zones = [{
                'id': 0,
                'name': 'All Zones',
                'description': '',
                'ipList': '',
                'activeScanners': ''
            }]
        headers = ['ID', 'Name', 'Description', 'IPList', 'activeScanners']

        mapped_zones = [{
            'ID': z.get('id', ""),
            'Name': z.get('name', ""),
            'Description': z.get('description', ""),
            'IPList': z.get('ipList', ""),
            'activeScanners': z.get('activeScanners', "")
        } for z in zones]

        hr = tableToMarkdown('Tenable.sc Scan Zones', mapped_zones, headers, removeNull=True)

        mapped_scanners_total, found_ids = [], []
        for index, zone in enumerate(zones):
            if scanners := zone.get('scanners'):
                mapped_scanners = [{
                    'ID': scanner['id'],
                    'Name': scanner['name'],
                    'Description': scanner['description'],
                    'Status': scanner['status']
                } for scanner in scanners]
                mapped_zones[index]['Scanner'] = mapped_scanners
                for scanner in mapped_scanners:
                    if scanner.get("ID") not in found_ids:
                        found_ids.append(scanner.get("ID"))
                        mapped_scanners_total.append(scanner)
            headers = ['ID', 'Name', 'Description', 'Status']

        if mapped_scanners_total:
            hr += tableToMarkdown('Tenable.sc Scanners', mapped_scanners_total, headers, removeNull=True)

        return CommandResults(
            outputs=createContext(mapped_zones, removeNull=True),
            outputs_prefix='TenableSC.ScanZone',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def get_elements(elements, manageable):
        """
        Extracts a list from the given dictionary by given filter
        Args:
            elements (Dict): The dictionary to extract from
            manageable (str): Wether to retrieve manageable or usable list
        Returns:
            List: The desired extracted list.
        """
        if manageable == 'false':
            return elements.get('usable', [])

        return elements.get('manageable', [])


    def create_scan_command(client: Client, args: Dict[str, Any]):
        """
        Creates a scan.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        validate_create_scan_inputs(args)

        res = client.create_scan(args)

        if not res or 'response' not in res:
            raise DemistoException('Error: Could not retrieve the scan')

        scan = res['response']

        headers = [
            'ID', 'CreatorID', 'Name', 'Type', 'CreationTime', 'OwnerName', 'Reports'
        ]

        mapped_scan = {
            'ID': scan['id'],
            'CreatorID': scan['creator'].get('id'),
            'Name': scan['name'],
            'Type': scan['type'],
            'CreationTime': timestamp_to_utc(scan['createdTime']),
            'OwnerName': scan['owner'].get('name'),
            'Reports': demisto.dt(scan['reports'], 'id')
        }

        return CommandResults(
            outputs=createContext(mapped_scan, removeNull=True),
            outputs_prefix='TenableSC.Scan',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Scan created successfully', mapped_scan, headers, removeNull=True)
        )


    def validate_create_scan_inputs(args: Dict[str, Any]):
        """
        Validate all given arguments are valid for create scan command.
        Args:
            args (Dict): the demisto.args() object.
        Returns:
            None: return error if arguments are invalid.
        """
        schedule = args.get('schedule')
        asset_ids = args.get('asset_ids')
        ips = args.get('ip_list')
        dependent = args.get('dependent_id')
        time_zone = args.get("time_zone")

        if time_zone and time_zone not in pytz.all_timezones:
            raise DemistoException("Invalid time zone ID. Please choose one of the following: "
                                   "https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html")
        if not asset_ids and not ips:
            raise DemistoException('Error: Assets and/or IPs must be provided')

        if schedule == 'dependent' and not dependent:
            raise DemistoException('Error: Dependent schedule must include a dependent scan ID')


    def process_launch_scan_response(res: Dict[str, Any]):
        """
        Process the launch scan response.
        Args:
            res (Dict): the launch scan response.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        scan_result = res['response']['scanResult']

        headers = [
            'Name',
            'ID',
            'OwnerID',
            'JobID',
            'Status'
        ]

        mapped_scan = {
            'Name': scan_result['name'],
            'ID': scan_result['id'],
            'OwnerID': scan_result['ownerID'],
            'JobID': scan_result['jobID'],
            'Status': scan_result['status']
        }

        return CommandResults(
            outputs=createContext(mapped_scan, removeNull=True),
            outputs_prefix='TenableSC.ScanResults',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Scan', mapped_scan, headers, removeNull=True)
        )


    @polling_function(name='tenable-sc-launch-scan',
                      requires_polling_arg=True,
                      poll_message="Scan in progress.",
                      timeout=arg_to_number(demisto.args().get("timeout_in_seconds", '10800')))
    def launch_scan_command(args: Dict[str, Any], client: Client):
        """
        Polling command. Launch a scan by a given scan ID, following the scan status and retrieve the scan report.
        Args:
            args (Dict): demisto.args() object.
            client (Client): The tenable.sc client object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        first_execution = not args.get("scan_results_id")
        if first_execution:
            res = launch_scan(client, args)
            if not argToBoolean(args.get("polling", "false")):
                return PollResult(process_launch_scan_response(res))
            scan_results_id = res.get("response", {}).get("scanResult", {}).get("id")
            args["scan_results_id"] = scan_results_id
            demisto.info(f"Running poll command for results id: {scan_results_id}")
        else:
            scan_results_id = args.get("scan_results_id")
            args["hide_polling_output"] = True
        scan_results, _ = get_scan_status(client, args)
        scan_status = scan_results[0].get("status")
        if scan_status == "Error":
            raise DemistoException(f"Encountered the following error during the execution {scan_results[0].get('errorDetails')}")
        elif scan_status != "Completed":
            return PollResult(continue_to_poll=True, response=scan_results, args_for_next_run=args)
        else:
            return PollResult(get_scan_report_command(client, args))


    def launch_scan(client: Client, args: Dict[str, Any]):
        """
        Launching a scan with a given scan ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            Dict: The response for the launch scan request.
        """
        scan_id = args.get('scan_id')
        target_address = args.get('diagnostic_target')
        target_password = args.get('diagnostic_password')

        if (target_address and not target_password) or (target_password and not target_address):
            raise DemistoException("Error: If one of diagnostic target or password is provided, both of them must be provided.")

        res = client.launch_scan(scan_id, {'address': target_address, 'password': target_password})

        if not res or 'response' not in res or not res['response'] or 'scanResult' not in res['response']:
            raise DemistoException('Error: Could not retrieve the scan.')

        return res


    def get_scan_status_command(client: Client, args: Dict[str, Any]):
        """
        Return information about the scan status by a given scan results ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        scans_results, res = get_scan_status(client, args)

        headers = ['ID', 'Name', 'Status', 'Description', 'Error']

        mapped_scans_results = [{
            'ID': scan_result['id'],
            'Name': scan_result['name'],
            'Status': scan_result['status'],
            'Description': scan_result['description'],
            'Error': scan_result['errorDetails'] if scan_result['status'] == 'Error' else ""
        } for scan_result in scans_results]

        return CommandResults(
            outputs=createContext(mapped_scans_results, removeNull=True),
            outputs_prefix='TenableSC.ScanResults',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Scan Status', mapped_scans_results, headers, removeNull=True)
        )


    def get_scan_status(client: Client, args: Dict[str, Any]):
        """
        Return information about the scan status by a given scan results ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            Dict: The relevant extracted section from the response.
            Dict: The response.
        """
        scan_results_ids = argToList(args.get('scan_results_id'))

        scans_results = []
        for scan_results_id in scan_results_ids:
            res = client.get_scan_results(scan_results_id)
            if not (res and res.get('response')):
                raise DemistoException('Scan results not found')

            scans_results.append(res['response'])
        return scans_results, res


    def get_scan_report_command(client: Client, args: Dict[str, Any]):
        """
        Return scan report information by a given scan results ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        scan_results_id = args.get('scan_results_id')
        vulnerabilities_to_get = argToList(args.get('vulnerability_severity', []))

        res = client.get_scan_report(scan_results_id)

        if not (res and res.get('response')):
            raise DemistoException('Scan results not found')

        scan_results = res['response']

        headers = ['ID', 'Name', 'Description', 'Policy', 'Group', 'Owner', 'ScannedIPs',
                   'StartTime', 'EndTime', 'Duration', 'Checks', 'ImportTime', 'RepositoryName', 'Status',
                   'Scan Type', 'ImportStatus', 'IsScanRunning', 'CompletedIPs']
        vuln_headers = ['ID', 'Name', 'Family', 'Severity', 'Total']

        mapped_results = {
            'Scan Type': res.get('type', ''),
            'ID': scan_results.get('id', ''),
            'Name': scan_results.get('name', ''),
            'Status': scan_results.get('status', ''),
            'Description': scan_results.get('description', ''),
            'Policy': scan_results.get('details', ''),
            'Group': scan_results.get('ownerGroup', {}).get('name'),
            'Checks': scan_results.get('completedChecks', ''),
            'StartTime': timestamp_to_utc(scan_results.get('startTime', '')),
            'EndTime': timestamp_to_utc(scan_results.get('finishTime', '')),
            'Duration': scan_duration_to_demisto_format(scan_results.get('scanDuration', '')),
            'ImportTime': timestamp_to_utc(scan_results.get('importStart', '')),
            'ScannedIPs': scan_results.get('scannedIPs', ''),
            'Owner': scan_results.get('owner', {}).get('username', ''),
            'RepositoryName': scan_results.get('repository', {}).get('name', ''),
            'ImportStatus': scan_results.get('importStatus', ''),
            'IsScanRunning': scan_results.get('running', '')
        }

        if progress := scan_results.get('progress', {}):
            mapped_results["Completed IPs"] = progress.get('completedIPs', '')

        hr = tableToMarkdown('Tenable.sc Scan ' + mapped_results['ID'] + ' Report',
                             mapped_results, headers, removeNull=True)

        if len(vulnerabilities_to_get) > 0 and scan_results.get("importStatus", "") != "Error":
            vulns = get_vulnerabilities(client, scan_results_id)

            if isinstance(vulns, list):
                vulnerabilities = list(filter(lambda v: v['Severity'] in vulnerabilities_to_get, vulns))
                if vulnerabilities and len(vulnerabilities) > 0:
                    hr += tableToMarkdown('Vulnerabilities', vulnerabilities, vuln_headers, removeNull=True)
                    mapped_results['Vulnerability'] = vulnerabilities

        return CommandResults(
            outputs=createContext(mapped_results, removeNull=True),
            outputs_prefix='TenableSC.ScanResults',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def get_vulnerabilities(client: Client, scan_results_id):
        """
        Lists vulnerabilities from a scan by a given scan results ID.
        Args:
            client (Client): The tenable.sc client object.
            scan_results_id (str): The ID of the scan results to get the information from.
        Returns:
            List: Sorted vulnerabilities list.
        """
        query = client.create_query(scan_results_id, 'vulnipdetail')

        if not query or 'response' not in query:
            return 'Could not get vulnerabilites query'

        body = {
            'type': 'vuln',
            'view': 'all',
            'sourceType': 'individual',
            'scanID': scan_results_id,
            'query': {"id": query.get('response', {}).get('id')}
        }

        analysis = client.get_analysis(body=body)

        client.delete_query(query.get('response', {}).get('id'))

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'No vulnerabilities found'

        mapped_vulns = []

        for vuln in results:
            mapped_vuln = {
                'ID': vuln['pluginID'],
                'Name': vuln['name'],
                'Description': vuln['pluginDescription'],
                'Family': vuln['family'].get('name'),
                'Severity': vuln['severity'].get('name'),
                'Total': vuln['total']
            }

            mapped_vulns.append(mapped_vuln)

        sv_level = {
            'Critical': 4,
            'High': 3,
            'Medium': 2,
            'Low': 1,
            'Info': 0
        }

        mapped_vulns.sort(key=lambda r: sv_level[r['Severity']])

        return mapped_vulns


    def get_vulnerability_command(client: Client, args: Dict[str, Any]):
        """
        Return information about a vulnerability by a given vulnerability ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        vuln_id = args.get('vulnerability_id')
        scan_results_id = args.get('scan_results_id')

        analysis = client.get_analysis(args=args)

        if not analysis or 'response' not in analysis:
            raise DemistoException('Error: Could not get vulnerability analysis')

        results = analysis['response']['results']

        if not results or len(results) == 0:
            raise DemistoException('Error: Vulnerability not found in the scan results')

        vuln_response = client.get_vulnerability(vuln_id)

        if not vuln_response or 'response' not in vuln_response:
            raise DemistoException('Vulnerability not found')

        vuln = vuln_response['response']
        vuln['severity'] = results[0]['severity']  # The vulnerability severity is the same in all the results

        hosts = get_vulnerability_hosts_from_analysis(results)

        cves = None
        cves_output = []  # type: List[dict]
        if vuln.get('xrefs'):
            # Extract CVE
            cve_filter = list(filter(lambda x: x.strip().startswith('CVE'), vuln['xrefs'].split(',')))
            if cve_filter and len(cve_filter) > 0:
                cves = list(map(lambda c: c.replace('CVE:', '').strip(), cve_filter))
                cves_output += map(lambda c: {
                    'ID': c
                }, cves)

        mapped_vuln = {
            'ID': vuln['id'],
            'Name': vuln['name'],
            'Description': vuln['description'],
            'Type': vuln['type'],
            'Severity': vuln.get('severity', {}).get('name'),
            'Synopsis': vuln['synopsis'],
            'Solution': vuln['solution']
        }

        vuln_info = {
            'Published': timestamp_to_utc(vuln['vulnPubDate']),
            'CPE': vuln['cpe'],
            'CVE': cves
        }

        exploit_info = {
            'ExploitAvailable': vuln['exploitAvailable'],
            'ExploitEase': vuln['exploitEase']
        }

        risk_info = {
            'RiskFactor': vuln['riskFactor'],
            'CVSSBaseScore': vuln['baseScore'],
            'CVSSTemporalScore': vuln['temporalScore'],
            'CVSSVector': vuln['cvssVector']
        }

        plugin_details = {
            'Family': vuln['family'].get('name'),
            'Published': timestamp_to_utc(vuln['pluginPubDate']),
            'Modified': timestamp_to_utc(vuln['pluginModDate']),
            'CheckType': vuln['checkType']
        }

        hr = '## Vulnerability: {} ({})\n'.format(mapped_vuln['Name'], mapped_vuln['ID'])
        hr += '### Synopsis\n{}\n### Description\n{}\n### Solution\n{}\n'.format(
            mapped_vuln['Synopsis'], mapped_vuln['Description'], mapped_vuln['Solution'])
        hr += tableToMarkdown('Hosts', hosts, removeNull=True)
        hr += tableToMarkdown('Risk Information', risk_info, removeNull=True)
        hr += tableToMarkdown('Exploit Information', exploit_info, removeNull=True)
        hr += tableToMarkdown('Plugin Details', plugin_details, removeNull=True)
        hr += tableToMarkdown('Vulnerability Information', vuln_info, removeNull=True)

        mapped_vuln.update(vuln_info)
        mapped_vuln.update(exploit_info)
        mapped_vuln.update(risk_info)
        mapped_vuln['PluginDetails'] = plugin_details
        mapped_vuln['Host'] = hosts

        scan_result = {
            'ID': scan_results_id,
            'Vulnerability': mapped_vuln,
        }
        command_results = [
            CommandResults(
                outputs=createContext(scan_result['Vulnerability'], removeNull=True),
                outputs_prefix='TenableSC.ScanResults.Vulnerability',
                raw_response=vuln_response,
                outputs_key_field='ID',
                readable_output=hr
            )
        ]

        if len(cves_output) > 0:
            command_results.append(CommandResults(outputs=createContext(cves_output), outputs_prefix='CVE', outputs_key_field='ID'))

        return command_results


    def get_vulnerability_hosts_from_analysis(results):
        """
        Lists the vulnerability hosts from given analysis.
        Args:
            results (Dict): The analysis results.
        Returns:
            List: list of all the vulnerability hosts extracted from the results.
        """
        return [{
            'IP': host.get('ip'),
            'MAC': host.get('macAddress'),
            'Port': host.get('port'),
            'Protocol': host.get('protocol')
        } for host in results]


    def delete_scan_command(client: Client, args: Dict[str, Any]):
        """
        Deletes a scan.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, and the human readable section.
        """
        scan_id = args.get('scan_id')

        res = client.delete_scan(scan_id)

        if not res:
            raise DemistoException('Error: Could not delete the scan')

        return CommandResults(
            raw_response=res,
            readable_output=f"Scan {scan_id} was deleted successfully."
        )


    def get_device_command(client: Client, args: Dict[str, Any]):
        """
        Returns device info by a given device UUID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        uuid = args.get('uuid')
        ip = args.get('ip')
        dns_name = args.get('dns_name')
        repo = args.get('repository_id')

        res = client.get_device(uuid, ip, dns_name, repo)

        if not res or 'response' not in res:
            raise DemistoException('Device not found')

        device = res['response']

        headers = [
            'IP', 'UUID', 'MacAddress', 'RepositoryID', 'RepositoryName', 'NetbiosName', 'DNSName', 'OS', 'OsCPE', 'LastScan',
            'TotalScore', 'LowSeverity', 'MediumSeverity', 'HighSeverity', 'CriticalSeverity'
        ]

        mapped_device = {
            'IP': device['ip'],
            'UUID': device.get('uuid'),
            'MacAddress': device.get('macAddress'),
            'RepositoryID': device.get('repository', {}).get('id'),
            'RepositoryName': device.get('repository', {}).get('name'),
            'NetbiosName': device.get('netbiosName'),
            'DNSName': device.get('dnsName'),
            'OS': re.sub('<[^<]+?>', ' ', device['os']).lstrip() if device.get('os') else '',
            'OsCPE': device.get('osCPE'),
            'LastScan': timestamp_to_utc(device.get('lastScan')),
            'TotalScore': device.get('total'),
            'LowSeverity': device.get('severityLow'),
            'MediumSeverity': device.get('severityMedium'),
            'HighSeverity': device.get('severityHigh'),
            'CriticalSeverity': device.get('severityCritical')
        }

        endpoint = {
            'IPAddress': mapped_device['IP'],
            'MACAddress': mapped_device['MacAddress'],
            'Hostname': mapped_device['DNSName'],
            'OS': mapped_device['OS']
        }

        command_results = [
            CommandResults(
                outputs=createContext(mapped_device, removeNull=True),
                outputs_prefix='TenableSC.Device',
                raw_response=res,
                outputs_key_field='UUID',
                readable_output=tableToMarkdown('Tenable.sc Device', mapped_device, headers=headers, removeNull=True)
            ),
            CommandResults(
                outputs=createContext(endpoint, removeNull=True),
                outputs_prefix='Endpoint',
                outputs_key_field='IP'
            )
        ]

        return command_results


    def list_users_command(client: Client, args: Dict[str, Any]):
        """
        Lists all users.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        user_id = args.get('id')
        username = args.get('username')
        email = args.get('email')

        res = client.get_users('id,username,firstname,lastname,title,email,createdTime,modifiedTime,lastLogin,role', user_id)

        if not res or 'response' not in res:
            raise DemistoException('No users found')

        users = res['response']

        if not isinstance(users, list):
            users = [users]

        if not user_id:
            if username:
                users = list(filter(lambda u: u['username'] == username, users))
            elif email:
                users = list(filter(lambda u: u['email'] == email, users))

        if len(users) == 0:
            raise DemistoException('No users found')

        headers = [
            'ID', 'Username', 'Firstname', 'Lastname', 'Title', 'Email', 'Created', 'Modified', 'LastLogin', 'Role'
        ]

        mapped_users = [{
            'ID': user['id'],
            'Username': user['username'],
            'FirstName': user['firstname'],
            'LastName': user['lastname'],
            'Title': user['title'],
            'Email': user['email'],
            'Created': timestamp_to_utc(user['createdTime']),
            'Modified': timestamp_to_utc(user['modifiedTime']),
            'LastLogin': timestamp_to_utc(user['lastLogin']),
            'Role': user['role'].get('name')
        } for user in users]

        return CommandResults(
            outputs=createContext(mapped_users, removeNull=True),
            outputs_prefix='TenableSC.User',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Users', mapped_users, headers=headers, removeNull=True)
        )


    def get_system_licensing_command(client: Client, args: Dict[str, Any]):
        """
        Returns system licensing information.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_system_licensing()

        if not res or 'response' not in res:
            raise DemistoException('Error: Could not retrieve system licensing')

        status = res['response']

        mapped_licensing = {
            'License': status['licenseStatus'],
            'LicensedIPS': status['licensedIPs'],
            'ActiveIPS': status['activeIPs']
        }

        headers = [
            'License',
            'LicensedIPS',
            'ActiveIPS'
        ]

        return CommandResults(
            outputs=createContext(mapped_licensing, removeNull=True),
            outputs_prefix='TenableSC.Status',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Licensing information', mapped_licensing, headers=headers, removeNull=True)
        )


    def get_system_information_command(client: Client, args: Dict[str, Any]):
        """
        Return system information.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        sys_res = client.get_system()

        if not sys_res or 'response' not in sys_res:
            raise DemistoException('Error: Could not retrieve system information')

        diag_res = client.get_system_diagnostics()

        if not diag_res or 'response' not in diag_res:
            raise DemistoException('Error: Could not retrieve system information')

        sys_res.update(diag_res)
        diagnostics = diag_res['response']
        system = sys_res['response']

        mapped_information = {
            'Version': system.get('version'),
            'BuildID': system.get('buildID'),
            'ReleaseID': system.get('releaseID'),
            'License': system.get('licenseStatus'),
            'RPMStatus': diagnostics.get('statusRPM'),
            'JavaStatus': diagnostics.get('statusJava'),
            'DiskStatus': diagnostics.get('statusDisk'),
            'DiskThreshold': diagnostics.get('statusThresholdDisk'),
            'LastCheck': timestamp_to_utc(diagnostics.get('statusLastChecked')),
        }

        headers = [
            'Version', 'BuildID', 'ReleaseID', 'License', 'RPMStatus', 'JavaStatus', 'DiskStatus', 'DiskThreshold', 'LastCheck'
        ]

        return CommandResults(
            outputs=createContext(mapped_information, removeNull=True),
            outputs_prefix='TenableSC.System',
            raw_response=sys_res,
            outputs_key_field='BuildID',
            readable_output=tableToMarkdown('Tenable.sc System information', mapped_information, headers=headers, removeNull=True)
        )


    def list_alerts_command(client: Client, args: Dict[str, Any]):
        """
        Lists all alerts.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_alerts(fields='id,name,description,didTriggerLastEvaluation,lastTriggered,'
                                'action,lastEvaluated,ownerGroup,owner')
        manageable = args.get('manageable', 'false').lower()

        if not (res and res.get('response')):
            raise DemistoException('No alerts found')

        alerts = get_elements(res['response'], manageable)

        if len(alerts) == 0:
            raise DemistoException('No alerts found')

        headers = ['ID', 'Name', 'Actions', 'State', 'LastTriggered', 'LastEvaluated', 'Group', 'Owner']
        mapped_alerts = [{
            'ID': a['id'],
            'Name': a['name'],
            'State': 'Triggered' if a['didTriggerLastEvaluation'] == 'true' else 'Not Triggered',
            'Actions': demisto.dt(a['action'], 'type'),
            'LastTriggered': timestamp_to_utc(a['lastTriggered'], default_returned_value='Never'),
            'LastEvaluated': timestamp_to_utc(a['lastEvaluated']),
            'Group': a['ownerGroup'].get('name'),
            'Owner': a['owner'].get('username')
        } for a in alerts]

        return CommandResults(
            outputs=createContext(mapped_alerts, removeNull=True),
            outputs_prefix='TenableSC.Alert',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Tenable.sc Alerts', mapped_alerts, headers=headers, removeNull=True)
        )


    def get_alert_command(client: Client, args: Dict[str, Any]):
        """
        Return information about an alert by a given alert ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        alert_id = args.get('alert_id')
        res = client.get_alerts(alert_id=alert_id)

        if not (res and res.get('response')):
            raise DemistoException('Alert not found')

        alert = res['response']
        query_res = client.get_query(alert.get('query', {}).get('id'))
        query = query_res.get('response')

        alert_headers = ['ID', 'Name', 'Description', 'LastTriggered', 'State', 'Behavior', 'Actions']
        query_headers = ['Trigger', 'Query']
        action_headers = ['Type', 'Values']

        filter_headers = ['Name', 'Values']
        mapped_alert = {
            'ID': alert['id'],
            'Name': alert['name'],
            'Description': alert['description'],
            'LastTriggered': timestamp_to_utc(alert['lastTriggered'], default_returned_value='Never'),
            'State': 'Triggered' if alert['didTriggerLastEvaluation'] == 'true' else 'Not Triggered',
            'Behavior': 'Execute on every trigger ' if alert['executeOnEveryTrigger'] == 'true' else 'Execute only on'
                                                                                                     ' first trigger'
        }

        mapped_condition = {
            'Trigger': '{} {} {}'.format(alert['triggerName'], alert['triggerOperator'], alert['triggerValue']),
            'Query': alert['query'].get('name')
        }

        mapped_filters = None
        if query:
            mapped_filters = [{
                'Name': f['filterName'],
                'Values': demisto.dt(f['value'], 'name') if isinstance(f['value'], list) else f['value']
            } for f in query.get('filters', [])]
            mapped_condition['Filter'] = mapped_filters

        mapped_actions = [{
            'Type': a['type'],
            'Values': demisto.dt(a, '{}.{}'.format('definition', ACTION_TYPE_TO_VALUE[a['type']]))
        } for a in alert['action']]

        hr = tableToMarkdown('Tenable.sc Alert', mapped_alert, headers=alert_headers, removeNull=True)
        hr += tableToMarkdown('Condition', mapped_condition, headers=query_headers, removeNull=True)
        if mapped_filters:
            hr += tableToMarkdown('Filters', mapped_filters, headers=filter_headers, removeNull=True)
        if mapped_actions:
            hr += tableToMarkdown('Actions', mapped_actions, headers=action_headers, removeNull=True)
            mapped_alert['Action'] = mapped_actions

        mapped_alert['Condition'] = mapped_condition

        return CommandResults(
            outputs=createContext(mapped_alert, removeNull=True),
            outputs_prefix='TenableSC.Alert',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def fetch_incidents(client: Client, first_fetch: str = '3 days'):
        """
        fetches incidents and upload them to demisto.incidents().
        Args:
            client (Client): The tenable.sc client object.
            first_fetch (str): The first_fetch integration param.
        """
        incidents = []
        last_run = demisto.getLastRun()
        if not last_run:
            last_run = {}
        if 'time' not in last_run:
            # get timestamp in seconds
            timestamp, _ = parse_date_range(first_fetch, to_timestamp=True)
            timestamp /= 1000
        else:
            timestamp = last_run['time']

        max_timestamp = timestamp
        res = client.get_alerts(
            fields='id,name,description,lastTriggered,triggerName,triggerOperator,'
                   'triggerValue,action,query,owner,ownerGroup,schedule,canManage')

        alerts = get_elements(res.get('response', {}), manageable='false')
        for alert in alerts:
            # 0 corresponds to never triggered
            if int(alert.get('lastTriggered', 0)) > timestamp:
                incidents.append({
                    'name': 'Tenable.sc Alert Triggered - ' + alert['name'],
                    'occurred': timestamp_to_utc(alert['lastTriggered']),
                    'rawJSON': json.dumps(alert)
                })

                if int(alert['lastTriggered']) > max_timestamp:
                    max_timestamp = int(alert['lastTriggered'])

        demisto.incidents(incidents)
        demisto.setLastRun({'time': max_timestamp})


    def list_groups_command(client: Client, args: Dict[str, Any]):
        """
        Lists all groups
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        show_users = argToBoolean(args.get("show_users", True))
        limit = int(args.get('limit', '50'))
        res = client.list_groups(show_users)
        if not res or not res.get('response', []):
            raise DemistoException('No groups found')
        groups = res.get('response', [])
        if len(groups) > limit:
            groups = groups[:limit]
        mapped_groups = [{
            'ID': group.get('id'),
            'Name': group.get('name'),
            'Description': group.get('description')
        } for group in groups]
        headers = ['ID', 'Name', 'Description']
        hr = tableToMarkdown('Tenable.sc groups', mapped_groups, headers, removeNull=True)
        if show_users:
            headers = ['Username', 'Firstname', 'Lastname']
            users = []
            for index, group in enumerate(groups):
                users = [{
                    'Username': user.get('username', ""),
                    'Firstname': user.get('firstname', ""),
                    'Lastname': user.get('lastname', ""),
                    'ID': user.get('id', ""),
                    'UUID': user.get('UUID', "")
                } for user in group.get('users')]
                mapped_groups[index]['Users'] = users
                group_id = group.get('id')
                hr += f"{tableToMarkdown(f'Group id:{group_id}', users, headers, removeNull=True)}\n"
        return CommandResults(
            outputs=createContext(response_to_context(groups), removeNull=True),
            outputs_prefix='TenableSC.Group',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def get_all_scan_results_command(client: Client, args: Dict[str, Any]):
        """
        Lists all scan results.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.get_all_scan_results()
        get_manageable_results = args.get('manageable', 'false').lower()  # 'true' or 'false'
        page = int(args.get('page', '0'))
        limit = int(args.get('limit', '50'))
        if limit > 200:
            limit = 200

        if not (res and res.get('response')):
            raise DemistoException('Scan results not found')

        elements = get_elements(res['response'], get_manageable_results)

        headers = ['ID', 'Name', 'Status', 'Description', 'Policy', 'Group', 'Owner', 'ScannedIPs',
                   'StartTime', 'EndTime', 'Duration', 'Checks', 'ImportTime', 'RepositoryName']

        scan_results = [{
            'ID': elem['id'],
            'Name': elem['name'],
            'Status': elem['status'],
            'Description': elem.get('description', None),
            'Policy': elem['details'],
            'Group': elem.get('ownerGroup', {}).get('name'),
            'Checks': elem.get('completedChecks', None),
            'StartTime': timestamp_to_utc(elem['startTime']),
            'EndTime': timestamp_to_utc(elem['finishTime']),
            'Duration': scan_duration_to_demisto_format(elem['scanDuration']),
            'ImportTime': timestamp_to_utc(elem['importStart']),
            'ScannedIPs': elem['scannedIPs'],
            'Owner': elem['owner'].get('username'),
            'RepositoryName': elem['repository'].get('name'),
            'ImportStatus': elem.get('importStatus', '')
        } for elem in elements[page:page + limit]]

        readable_title = 'Tenable.sc Scan results - {0}-{1}'.format(page, page + limit - 1)
        hr = tableToMarkdown(readable_title, scan_results, headers, removeNull=True,
                             metadata='Total number of elements is {}'.format(len(elements)))

        return CommandResults(
            outputs=createContext(scan_results, removeNull=True),
            outputs_prefix='TenableSC.ScanResults',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def create_user_command(client: Client, args: Dict[str, Any]):
        """
        Create a user.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        validate_user_body_params(args, "create")
        res = client.create_user(args)
        hr_header = f'User {args.get("user_name")} was created successfully.'
        return process_update_and_create_user_response(res, hr_header)


    def update_user_command(client: Client, args: Dict[str, Any]):
        """
        Update a user by given user ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        user_id = args.get('user_id')
        validate_user_body_params(args, "update")
        res = client.update_user(args, user_id)
        hr_header = f'user {args.get("user_id")} was updated successfully.'
        return process_update_and_create_user_response(res, hr_header)


    def process_update_and_create_user_response(res, hr_header):
        """
        Process the response returned from the update and create user requests
        Args:
            res (Dict): The response returned from the request
            hr_header (Dict): The header to add to the hr section.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        if not res or not res.get('response', {}):
            raise DemistoException("User wasn't created successfully.")
        headers = ["User type", "User ID", "User Status", "User Name", "First Name", "Lat Name ", "Email ", "User Role Name",
                   "User Group Name", "User  LDAP  Name"]
        response = res.get("response", {})
        mapped_response = {
            "User type": res.get("type"),
            "User ID": response.get("id"),
            "User Status": response.get("status"),
            "User Name": response.get("username"),
            "First Name": response.get("firstname"),
            "Lat Name ": response.get("lastname"),
            "Email ": response.get("email"),
            "User Role Name": response.get("role", {}).get("name"),
            "User Group Name": response.get("group", {}).get("name"),
            "User  LDAP  Name": response.get("ldap", {}).get("name")
        }

        return CommandResults(
            outputs=createContext(response_to_context(response), removeNull=True),
            outputs_prefix='TenableSC.User',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown(hr_header, mapped_response, headers, removeNull=True)
        )


    def delete_user_command(client: Client, args: Dict[str, Any]):
        """
       Delete a user by a given user ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, and human readable section.
        """
        user_id = args.get('user_id')
        res = client.delete_user(user_id)

        return CommandResults(
            raw_response=res,
            readable_output=f"User {user_id} was deleted successfully."
        )


    def list_plugin_family_command(client: Client, args: Dict[str, Any]):
        """
        return info about a query / list of queries.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        is_active = args.get('is_active')
        limit = int(args.get('limit', '50'))
        plugin_id = args.get('plugin_id', '')
        res = client.list_plugin_family(plugin_id, is_active)
        if not res or not res.get('response', []):
            raise DemistoException('No plugins found')
        plugins = res.get('response')
        if isinstance(plugins, dict):
            if plugin_type := plugins.get("type") in ["active", "passive"]:
                is_active = "false" if plugin_type == "passive" else "true"
            plugins = [plugins]
        if len(plugins) > limit:
            plugins = plugins[:limit]
        mapped_plugins = [{"Plugin ID": plugin.get("id"), "Plugin Name": plugin.get("name")} for plugin in plugins]
        if is_active:
            for mapped_plugin in mapped_plugins:
                mapped_plugin["Is Active"] = is_active
        headers = ["Plugin ID", "Plugin Name", "Is Active"]
        return CommandResults(
            outputs=createContext(response_to_context(plugins), removeNull=True),
            outputs_prefix='TenableSC.PluginFamily',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Plugin families:', mapped_plugins, headers, removeNull=True)
        )


    def create_policy_command(client: Client, args: Dict[str, Any]):
        """
        Creates a policy.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        res = client.create_policy(args)
        created_policy = res.get("response")
        mapped_created_policy = {
            "Policy type": res.get("type"),
            "Policy ID": created_policy.get("id"),
            "name": created_policy.get("name"),
            "Description": created_policy.get("description"),
            "Created Time": created_policy.get("createdTime"),
            "Plugin Families": created_policy.get("families"),
            "Policy  Status": created_policy.get("status"),
            "Policy UUID": created_policy.get("uuid"),
            "Policy can Manage": created_policy.get("canManage"),
            "Creator Username": created_policy.get("creator", {}).get("username"),
            "Owner ID": created_policy.get("ownerID"),
            "policyTemplate ID": created_policy.get("policyTemplate", {}).get("id"),
            "policyTemplate Name": created_policy.get("policyTemplate", {}).get("name")
        }
        headers = ["Policy type", "Policy ID", "name", "Description", "Created Time", "Plugin Families", "Policy  Status",
                   "Policy UUID", "Policy can Manage", "Creator Username", "Owner ID", "policyTemplate id",
                   "policyTemplate Name"]

        return CommandResults(
            outputs=createContext(response_to_context(created_policy), removeNull=True),
            outputs_prefix='TenableSC.ScanPolicy',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Policy was created successfully:', mapped_created_policy, headers, removeNull=True)
        )


    def create_remediation_scan_command(client: Client, args: Dict[str, Any]):
        """
        Creates remediation scan.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        args["policy_template_id"] = '1'
        args["scan_type"] = "policy"
        args["schedule"] = "now"
        validate_create_scan_inputs(args)
        res = client.create_policy(args)
        created_policy = res.get("response")
        args["policy_id"] = created_policy.get("id")
        res = client.create_scan(args)
        if not res or 'response' not in res:
            raise DemistoException('Error: Could not retrieve the scan')

        scan = res.get('response', {})

        headers = ['Scan ID', 'Scan Name', 'Scan Description', 'Scan Type', 'Dhcp Tracking status', 'Created Time', 'Modified Time',
                   'Max Scan Time', 'Policy id ', 'Policy context', 'Policy description', 'Schedule type', 'Start Time', 'Group',
                   'Owner']

        mapped_scan = {
            'Scan ID': scan['id'],
            'Scan Name': scan['name'],
            'Scan Description': scan['description'],
            'Scan Type': scan['type'],
            'Dhcp Tracking status': scan["dhcpTracking"],
            'Created Time': timestamp_to_utc(scan['createdTime']),
            'Modified Time': scan["modifiedTime"],
            'Max Scan Time': scan["maxScanTime"],
            'Policy id ': scan["policy"]["id"],
            'Policy context': scan["policy"]["context"],
            'Policy description': scan["policy"]["description"],
            'Schedule type': scan["schedule"]["type"],
            'Start Time': scan["schedule"]["start"],
            'Group': scan["ownerGroup"]["name"],
            'Owner': scan["owner"]["username"],
        }

        return CommandResults(
            outputs=createContext(response_to_context(scan), removeNull=True),
            outputs_prefix='TenableSC.Scan',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=tableToMarkdown('Remediation scan created successfully', mapped_scan, headers, removeNull=True)
        )


    def list_query_command(client: Client, args: Dict[str, Any]):
        """
        return info about a query / list of queries.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response, human readable section, and the context entries to add.
        """
        type = args.get('type')
        query_id = args.get('query_id', '')
        if query_id:
            res, hr, ec = get_query(client, query_id)
        else:
            res, hr, ec = list_queries(client, type)

        return CommandResults(
            outputs=createContext(response_to_context(ec), removeNull=True),
            outputs_prefix='TenableSC.Query',
            raw_response=res,
            outputs_key_field='ID',
            readable_output=hr
        )


    def update_asset_command(client: Client, args: Dict[str, Any]):
        """
        Update an asset by a given asset ID.
        Args:
            client (Client): The tenable.sc client object.
            args (Dict): demisto.args() object.
        Returns:
            CommandResults: command results object with the response and human readable.
        """
        asset_id = args.get('asset_id')
        res = client.update_asset(args, asset_id)
        if not res or not res.get('response', []):
            raise DemistoException("Couldn't update asset.")

        return CommandResults(
            raw_response=res,
            readable_output=f'asset {asset_id} was updated successfully.'
        )


    def get_query(client: Client, query_id):
        """
        get a query by ID and return the processed results.
        Args:
            client (Client): The tenable.sc client object.
            query_id (str): The query ID to search.
        Returns:
            Dict: The response from the server.
            str: The processed human readable.
            Dict: The relevant section from the response.
        """
        res = client.get_query(query_id)
        if not res or not res.get('response', []):
            raise DemistoException(f"The query {query_id} wasn't found")
        query = res.get('response')
        mapped_query = {
            "Query ID": query_id,
            "Query  Name": query.get("name"),
            "Query Description": query.get("description"),
            "Query Filters": query.get("filters")
        }
        headers = ["Query ID", "Query  Name", "Query Description", "Query Filters"]
        hr = tableToMarkdown(f'Query {query_id}', mapped_query, headers, removeNull=True)
        return res, hr, query


    def list_queries(client: Client, type):
        """
        Lists queries and return the processed results.
        Args:
            client (Client): The tenable.sc client object.
            type (str): query time to filter by.
        Returns:
            Dict: The response from the server.
            str: The processed human readable.
            Dict: The relevant section from the response.
        """
        res = client.list_queries(type)
        if not res or not res.get('response', []):
            raise DemistoException("No queries found.")
        queries = res.get('response')
        manageable_queries = queries.get("manageable", [])
        usable_queries = queries.get("usable", [])
        mapped_queries, mapped_usable_queries = [], []
        found_ids = []

        for manageable_query in manageable_queries:
            query_id = manageable_query.get("id")
            mapped_queries.append({
                "Query ID": query_id,
                "Query  Name": manageable_query.get("name"),
                "Query Description": manageable_query.get("description"),
                "Query Filters": manageable_query.get("filters"),
                "Query Manageable": "True"
            })
            found_ids.append(query_id)
        for usable_query in usable_queries:
            query_id = usable_query.get("id")
            if query_id not in found_ids:
                mapped_usable_queries.append({
                    "Query ID": usable_query.get("id"),
                    "Query  Name": usable_query.get("name"),
                    "Query Description": usable_query.get("description"),
                    "Query Filters": usable_query.get("filters"),
                    "Query Usable": "True",
                    "Query Manageable": "False"
                })
            else:
                for mapped_query in mapped_queries:
                    if query_id == mapped_query["Query ID"]:
                        mapped_query["Query Usable"] = "True"

        for mapped_query in mapped_queries:
            if not mapped_query.get("Query Usable"):
                mapped_query["Query Usable"] = "False"

        mapped_queries.extend(mapped_usable_queries)
        headers = ["Query ID", "Query  Name", "Query Description", "Query Filters", "Query Manageable", "Query Usable"]
        hr = tableToMarkdown('Queries:', mapped_queries, headers, removeNull=True)
        return res, hr, queries


    def test_module(client: Client, args: Dict[str, Any]):
        """
        Lists queries and return the processed results.
        Args:
            client (Client): The tenable.sc client object.
            type (str): query time to filter by.
        Returns:
            Dict: The response from the server.
            str: The processed human readable.
            Dict: The relevant section from the response.
        """
        try:
            client.get_users()
            return "ok"
        except Exception:
            raise Exception("Authorization Error: make sure your API Key and Secret Key are correctly set")


    def main():  # pragma: no cover
        params = demisto.params()
        command = demisto.command()
        args = demisto.args()
        verify_ssl = not params.get('unsecure', False)
        proxy = params.get('proxy', False)
        user_name = params.get('credentials', {}).get('identifier')
        password = params.get('credentials', {}).get('password')
        access_key = params.get('creds_keys', {}).get('identifier')
        secret_key = params.get('creds_keys', {}).get('password')
        url = params.get('server')

        demisto.info(f'Executing command {command}')

        command_dict = {
            'test-module': test_module,
            'tenable-sc-list-scans': list_scans_command,
            'tenable-sc-list-policies': list_policies_command,
            'tenable-sc-list-repositories': list_repositories_command,
            'tenable-sc-list-credentials': list_credentials_command,
            'tenable-sc-list-zones': list_zones_command,
            'tenable-sc-list-report-definitions': list_report_definitions_command,
            'tenable-sc-list-assets': list_assets_command,
            'tenable-sc-get-asset': get_asset_command,
            'tenable-sc-create-asset': create_asset_command,
            'tenable-sc-delete-asset': delete_asset_command,
            'tenable-sc-create-scan': create_scan_command,
            'tenable-sc-get-scan-status': get_scan_status_command,
            'tenable-sc-get-scan-report': get_scan_report_command,
            'tenable-sc-delete-scan': delete_scan_command,
            'tenable-sc-list-users': list_users_command,
            'tenable-sc-list-alerts': list_alerts_command,
            'tenable-sc-get-alert': get_alert_command,
            'tenable-sc-get-system-information': get_system_information_command,
            'tenable-sc-get-system-licensing': get_system_licensing_command,
            'tenable-sc-get-all-scan-results': get_all_scan_results_command,
            'tenable-sc-list-groups': list_groups_command,
            'tenable-sc-create-user': create_user_command,
            'tenable-sc-update-user': update_user_command,
            'tenable-sc-delete-user': delete_user_command,
            'tenable-sc-list-plugin-family': list_plugin_family_command,
            'tenable-sc-create-policy': create_policy_command,
            'tenable-sc-list-query': list_query_command,
            'tenable-sc-update-asset': update_asset_command,
            'tenable-sc-get-vulnerability': get_vulnerability_command,
            'tenable-sc-get-device': get_device_command,
            'tenable-sc-create-remediation-scan': create_remediation_scan_command
        }

        try:
            with Client(verify_ssl=verify_ssl, proxy=proxy, user_name=user_name, password=password, access_key=access_key,
                        secret_key=secret_key, url=url) as client:
                if command == 'fetch-incidents':
                    first_fetch = params.get('fetch_time').strip()
                    fetch_incidents(client, first_fetch)
                elif command == 'tenable-sc-launch-scan':
                    return_results(launch_scan_command(args, client))
                else:
                    return_results(command_dict[command](client, args))
        except Exception as e:
            return_error(
                f'Failed to execute {command} command. Error: {str(e)}'
            )


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Tenable.sc', 'end', __line__())
  subtype: python3
  type: python
system: true
