category: Network Security
commonfields:
  id: FireEyeNX
  version: -1
configuration:
- additionalinfo: URL to connect to the FireEye NX.
  display: URL
  name: url
  required: true
  section: Connect
  type: 0
- display: Username
  name: credentials
  required: true
  section: Connect
  type: 9
- additionalinfo: The FireEye NX API calls timeout if the response is not returned
    within the configured time interval. Default is 120 seconds.
  advanced: true
  defaultvalue: "120"
  display: HTTP(S) Request Timeout (in seconds)
  name: request_timeout
  required: false
  section: Connect
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: The time range to consider for the initial data fetch.(<number>
    <unit>, e.g., 1 hour, 2 hours, 6 hours, 12 hours, 48 hours). Default is 12 hours.
    The API supports up to 48 hours. More than 48 hours will produce an error.
  defaultvalue: 12 hours
  display: First fetch time interval
  name: first_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: The maximum number of alerts to fetch. A maximum of 200 alerts is
    fetched. Default is 50.
  defaultvalue: "50"
  display: Fetch Limit
  name: max_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: Fetches Alerts and/or IPS Events.
  display: Fetch Types
  name: fetch_type
  options:
  - Alerts
  - IPS Events
  required: false
  section: Collect
  type: 16
- additionalinfo: Fetches MVX-correlated events only. Works only for events defined
    in Fetch Types.
  display: Fetches MVX-correlated events only
  name: fetch_mvx_correlated_events
  required: false
  section: Collect
  type: 8
- additionalinfo: The type of malware object to fetch alerts.
  display: Alert Malware Type
  name: malware_type
  options:
  - domain_match
  - malware_callback
  - malware_object
  - web_infection
  - infection_match
  required: false
  section: Collect
  type: 15
- additionalinfo: Replaces the domain of the alert URL key to the instance URL for
    fetch incident and command.
  display: Use instance URL for all the fetched alerts URL.
  name: replace_alert_url
  required: false
  section: Collect
  type: 8
- display: Fetch artifacts for each alert
  name: fetch_artifacts
  required: false
  section: Collect
  type: 8
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.1.33
    packID: FireEyeNX
    packName: FireEye Network Security (NX)
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: FireEye NX
defaultmapperin: FireEye NX-mapper
description: FireEye Network Security is an effective cyber threat protection solution
  that helps organizations minimize the risk of costly breaches by accurately detecting
  and immediately stopping advanced, targeted, and other evasive attacks hiding in
  internet traffic.
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/fire-eye-nx)'
display: FireEye NX
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADKFJREFUeAHtWntwVcUZ38c55948bgISiORFsAGBm4SHYBWnxQd1Oo5o61C1TuvoPzpKRQKooK2mUtRCgAAVWh06Ustoy3TG2s4UQQsDvlpAQpILoUASwqNAeCUhN/dxzm5/e/Hgzc29IcGBP+zuzM2es/vtt7u/77l7QoguGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI/BNRIBezqYkudVoKDg92jHEBOnQ6ymTQUHZtrLmuq1gKC+Hpx5zZRDol4B355cXmNx5SBJ6vySyzKTMUgzUzyEyFKZk3tjm+uWfFtycZlknrImNjW1XZtmaa18R6JOAPy8pycqIeCsYJU9YhObaMFJbQsRxs3BCYcxyj+W1b+aO4w1GvDMMn3zFHwhE4sj041VGwLjUfLuK/eOsCH3DonRSBELtIiI2RGkGhEog9JgFM1QOIUWhqHeo2WEfo145xe4kTSBbe6k5dP+VQwBySV3qikq/Z0n6gUHJpC4pCIUwvZQRCFsNCkHUTVEiPg9L+UGXoBukkJ9YMhLuMs8KWHc7E3ROYLA/M/UM/1c9tLKysle8k6EhpVRgxwBP1n+ptpQDdxeNuQMx9i8gyFZEym4htQYIbhMjcqvDWL3liRwdtW9fR+IknxYUpGXzAa9nEPZABxOPljXV/zmRxn0HP/7FMP+UNMkeF0QMxzzd1qReQINGcdxMM2eO2lfbtJkQI7uwdJzJ5POOKReMO7Bnl+IXKPBfIyhZZDA6NgpvE19iTCURnNFWPP++M8fzt4k7d0Zri4oGmsQ3XVL6mAo7qQrDCjglh2xClpYdqv/0qaeeLTAsOoMyPtWx0ZqiMK6CF/mXYPY7VPAykN2Efa6rrvr1h5SiJ0mBIhjnOoJ3Y8b7qBQfOg5pZCZ7GKTjBV5SFQbDQ+DcB0Gtrq5e/ImiS+qia4rG+A3K1nkIzYblYu9kAyT8WyfCPxp7orYz1QTx7ZgqhHcLhv8gdrEeoPbYzGbMv6fQf5eXsHeAQoMjyC7MpXTpYnEFjMFnBTMVT+KDvDMpGehQeguLkoEucUcwbGdmevajGzy6T6fesCbuSFpoULnScyo8HG3L9nT5ok6ac5wTE0rSfYzLV9VQaoQkdryTky8VmocBfjPWHVOueNr459hKuDwowuQk53Ib3ODtnPGXZs2dp6z5g3ha9aysHML9ASN8HhZcIwX9mFLhQSzcT+3U61NjhYqTghymlLWrd1Viin3h8cLf3bnlGczjbPExPrFTiK2w2oVlh+s3xtNc6llZcBbJrvZw9liXlEcjhpw8sTHQkjiuIed6XyTd+AhxPNzutN05+ciRrkSaZO87CDHTi8qmRKlYB619oKy5fksyumRtas5ourkAG78FBvsg9nYwGd2Vaps5c26p4bFeJELkwtv8srrqtX+6cyl3PGvOc9M45S9AlAFY4q+WLXut0e2/nLpHTGAe8YKHspLz0pnRNdgztb/CVYsoxA+Lz1T6ZsLSLMHGq/bEAiuKwmrWUGnM76twE3n09/38qX0hWOIXUCqLSTmov+O/Lv2KFVX1Ihp9BZH1LJP0+YqKZ77j8qyYO+/7nBrPAZP9ERl+7esKV/Ht5qJr8keNhA8fcV7KWya0BPaQQ+7U/avPRKOMWSRHHaQ4pTwqRTk4/DWRy3DSHCIt5Hdu+/6SEo/7nKwuOXAgAsvr1U/tuOEGM7utrYfiKn6toRDLMHJyHWnfK6Rstb1Wk2oHQ36gpMSAb++1DPN45JhAwMYaVBhRSRM/ffo073UQOsPhsMjLy3NAr8YRxMeap5+es5CZnpcoM1+YOXP2y5xb6QhP82HFR+xI9JXXVy79j8tXue1jQ4dyT3190n25dKpOnKubgIVFwzTIH5mAOFs3rHQydn5dWUv9H+MZ9OW508zxZFFSoNIB7B7hiymjTlqUuzWLy6cbQjwVisgCgA38ehYoy7G91437CWmsSSmHvfmjBtmnQr9xiHcSkiwrnhee7SxqRWxhD8CaDguDzZtwYFdrbVHZwL1SPEQi5Ol85AwAOen8sSQrSg7uHuZfQA4FNs+ePbvgXEdojuX13WXbdkrFZJwR08r85GxHaBl2td3d2fLlS7bPmjV3IWHsRW561iD/o0LQeuJEF65cuWSPS6fq9vbgjZmdzT+TVsbNQohuMouno5gr3UgPgH4x2jervm7EE5r2HlKN2MSTJqFVNhV2IM+/1X+sZ/xUdMlKJQTqIxSCkkUOghwyT4iMpiejvRBLSx9EXrUGeehGuK1/4JZM5Qo9Cq5D20OMnuvREdcgItyUhiy2JT0rKH3vKz4yDQKa7GFsYliI1abDV45pqT2ihspw0BSe9CGcyjQq5To0nY9jGfcokecYp5AxH1aNts29xBT5OArilEjeRkIMHUpSsCnBZRO3+fHE3urqqs9mzZq3GNl4JURxPhyNLlq5vKo2kQ5WnYV4nA+DO0AYErWYH0ikAsyOJA6jx6mgsTUqim4CVg21haO/a0i6wsGyLJx5Q4Z4Gc2PqL6+lLvJDZyx0E3IwjPDSKGVQX6ZUfcYnplzvRep6AwuyIaylsA9PQgup0GSKOL/9rGH6hfGD9+d+60hYcv7lmR06IijF4Sr+pGJQzBSOsiIDR9dhJu3M/Hjen2WMiKks2tF9aIFvdL13tlo285BINVJbN6UihSWG4TRbFyxdPHyVDTJ2r9S8ou9bKIHcVO51xAEZFL6cG2h/5GL3Zd6yPuvKQSZ5pJhAoQ72eq+x9fnLenhkgwSktXEt3+dZ0gLXlZFhu4leuIgrJotxdFmamBY+e1uL79wkQDrpLSzk1hue19qDIF2xC4ikuDYFw6xxSKESa5+jMGiUhe1L9WvfGKfSw+GaNiGo41KJGIFxyRqMLK8tqBsyqW4VmIBXjpwBOVkChKrGDnwg7ekKeMmiCCT/i06xriffyYSEsWQnVjV+4I4T+4uL89QLAzTi73KLoPQNJzHB/SVrRDASCJnYWxgRUVFyhjcV3690Qm4RPRjKjbgViR2vdEm9vVw0aWHA9tri0rXpFP2eBBCwlci+HGaxZl8t6bAf++4I4F/JzJx36cUF1uIAz+1CPepO2ulJCEiIoLw3i4DoJkxK3DZ9Ll2lTBhgGpO2lXWUtcWyPevloyspe3Oj0D31skjgfYhReU7cLv0KBK9qtriMW/i+NIOD9aNhwGnQG0S7PBF9n+7oeE0PGYr4QO2MSEWIJgtmVnxzPvwHWG8dx9nGMSm7AyJBpurq6tT5BDIEBhU74JNJGxHHTWdBpubDbDy6ePbQkfLZz97EPMow+heMBcygY50iza++uqrp1VnDwtWjUEr9CyseFPalx5DXeHh3Hitxcl7tUWjpyqaxFIJXtfa3hG49nr0QuyFn8QVDHKP+gyzs1tW6I7NQOaEVUYApbKufpUorpCw+JCq3YHqig3qHUaukfTuEMgLGiEHVTIHPH/8ReH4vNtUvhQmn+Pz2M/haQqZZOtx27UJer0x/iek2MgNscYb4pPUfKtWrTofFOH3pRBLoQvTkGn8HSvZhP0jWfzqh0RzIzD4NcTkd9cZX3Nu4K5Q4kqf4NtM8kvCqqqqk1jvaqznQ4SEJVCHDfFzuM+Q7kYgurqrS9zoztFN29xGVe8qHjfAFNE3kWhNj8CSlXIZytYkCQLTX5w8NHjFbWTLRSB35I3MsQzzXSjFHerDhCpplHcFqfPE2ObA2lhDwh9cUPPRhaXFUY/Zro4sCd29vgYGD86M+PKHsk5xzL0+3YwlZg8fne+RmWF/8/YeWavL8OOcHN9Ab24uyR583B/YcjFr3pGXl+7h1wyF2ieNxV5BIpGsnBPxY9QZ9dy5c1mMpQ0RwkniPi3i8UQ7z6alnXqjsjLorsGtMd46dSqYk5aGLK95Uuv69fer9CdpAa1x7GxXns9g6Y7jJJWdbYiQyMxsXVVZGdtXUiKX+2b858agota5OOo8b+L0oyxTDUDiBYVXHx3o/NEtdTsVfd2Q4bnSk77UZGQabop8sJJoyJF/MLLkk/qbsIvo1a97FbC7nNg3YUHnIx+6BxbtVXEZwoUflG1wS2ujjK4ub65rqISbvi9v5EjDssaCoq1rkPmR+mLj8tH11UegTwJ2l1VXUFrOGPkh4sCdCHxj8FluQDoiYQdxQpD5uzhdvd3mnPnsat0ru+vSdWoE+iXgeDb78f9ZjkFGOsQuFoRdx6icSh22CUnPn8Yerq2Pp9XPGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0Ah8cxH4H9aAFXVhrGASAAAAAElFTkSuQmCC
name: FireEyeNX
script:
  commands:
  - arguments:
    - description: Universally unique ID (UUID) of the alert. To retrieve the UUID,
        execute the fireeye-nx-get-alerts command.
      name: uuid
      required: true
    description: Gets malware artifacts metadata for the specified UUID.
    name: fireeye-nx-get-artifacts-metadata-by-alert
    outputs:
    - contextPath: FireEyeNX.Alert.Uuid
      description: Universally unique ID (UUID) of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.ArtifactsMetadata.ArtifactType
      description: The artifact type.
      type: String
    - contextPath: FireEyeNX.Alert.ArtifactsMetadata.ArtifactName
      description: The artifact name.
      type: String
    - contextPath: FireEyeNX.Alert.ArtifactsMetadata.ArtifactSize
      description: The artifact size.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The type of report to be queried.
      name: report_type
      predefined:
      - Website Callback Server Report
      - Website Executive Summary
      - Website Infected Host Trends
      - Website Malware Activity
      - Website Antivirus Report
      - IPS Executive Summary Report
      - IPS Top N Attacks Report
      - IPS Top N Attackers Report
      - IPS Top N Victims Report
      - IPS Top N MVX-Correlated Report
      - Alert Details Report
      required: true
    - auto: PREDEFINED
      description: 'The output format of the report. Possible values are: "csv" and
        "pdf", or both depending upon the report type.'
      name: type
      predefined:
      - pdf
      - csv
    - description: The start time of the search. The search occurs between the start
        and end times. When specifying a\ \ start_time value, you must specify both
        a start_time and an end_ time value.\n\ Formats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours.
      name: start_time
    - description: The end time of the search. The search occurs between the start
        and end times. When specifying an\ \ end_ time value, you must specify both
        a start_time and an end_time value.\n\ Formats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours.
      name: end_time
    - auto: PREDEFINED
      description: The time frame in which reports are searched.
      name: time_frame
      predefined:
      - pastWeek
      - pastMonth
      - pastThreeMonth
      - between
      - today
      - oneDayAgo
      - twoDaysAgo
      - threeDaysAgo
      - fourDaysAgo
      - fiveDaysAgo
      - sixDaysAgo
      - pastHour
      - pastDay
    - auto: PREDEFINED
      description: 'The maximum number (N) of items covered by each IPS Top N report.
        This argument is required only for IPS Top N reports. Possible values are:
        "25", "50", "75", and "100".'
      name: limit
      predefined:
      - "25"
      - "50"
      - "75"
      - "100"
    - auto: PREDEFINED
      description: 'The internet interface. Possible values are: "A", "B", "C", "D",
        "AB", and "All". This option is required only for IPS reports.'
      name: interface
      predefined:
      - A
      - B
      - C
      - D
      - AB
      - All
    - description: The alert ID. To retrieve the alert ID, execute the fireeye-nx-get-alerts
        command. Use the combination of infection_id and infection_type arguments
        to specify a unique alert to describe in the Alert Details Report. If one
        option is used alone and does not specify a unique alert, an error message
        is produced.
      name: infection_id
    - auto: PREDEFINED
      description: 'The type of the infection. Use the combination of infection_id
        and infection_type arguments to specify a unique alert to describe in the
        Alert Details Report. If one option is used alone and does not specify a unique
        alert, an error message is produced. Possible values are: "malware-object",
        "malware-callback", "infection-match", "domain-match", and "web-infection".'
      name: infection_type
      predefined:
      - malware-object
      - malware-callback
      - infection-match
      - domain-match
      - web-infection
    description: Returns reports on selected alerts by specifying a time_frame value
      or a start_time and end_time of the search range.
    name: fireeye-nx-get-reports
    outputs:
    - contextPath: InfoFile.Name
      description: The file name.
      type: String
    - contextPath: InfoFile.EntryID
      description: The ID for locating the file in the War Room.
      type: String
    - contextPath: InfoFile.Size
      description: The size of the file (in bytes).
      type: Number
    - contextPath: InfoFile.Type
      description: The file type, as determined by libmagic (same as displayed in
        the file entries).
      type: String
    - contextPath: InfoFile.Extension
      description: The file extension.
      type: String
    - contextPath: InfoFile.Info
      description: Basic information about the file.
      type: String
  - arguments:
    - description: The ID number of the alert to retrieve. To retrieve the alert ID,
        execute the fireeye-nx-get-alerts command without specifying the alert_id.
      name: alert_id
    - description: The source IPv4 address related to the malware alert to retrieve.
      name: src_ip
    - description: The destination IPv4 address related to the malware alert to retrieve.
      name: dst_ip
    - auto: PREDEFINED
      description: 'The time interval to search. This filter is used with either the
        start_time or end_time filter. If duration, start time, and end time are not
        specified, the system defaults to duration=12_hours, end_time=current_time.
        If only the duration is specified, the end_time defaults to the current_time.
        Possible values are: "1_hour", "2_hours", "6_hours", "12_hours", "24_hours",
        and "48_hours".'
      name: duration
      predefined:
      - 1_hour
      - 2_hours
      - 6_hours
      - 12_hours
      - 24_hours
      - 48_hours
    - description: "The start time of the search. This filter is used with the duration
        filter. If the start_time is specified but not the duration, the system defaults
        to duration=12_hours, starting at the specified start_time.\nFormats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours."
      name: start_time
    - description: "The end time of the search. This filter is used with the duration
        filter. If the end_time is specified but not the duration, the system defaults
        to duration=12_hours, ending at the specified end_time.\nFormats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours."
      name: end_time
    - description: The name of the malware file to retrieve.
      name: file_name
    - description: The malware file type to retrieve.
      name: file_type
    - auto: PREDEFINED
      defaultValue: concise
      description: 'The level of information to retrieve. Possible values are: "concise",
        "normal", and "extended".'
      name: info_level
      predefined:
      - concise
      - normal
      - extended
    - description: The name of the malware object to retrieve.
      name: malware_name
    - auto: PREDEFINED
      description: 'The type of the malware object to retrieve. Possible values are:
        "domain_match", "malware_callback", "malware_object", "web_infection", and
        "infection_match".'
      name: malware_type
      predefined:
      - domain_match
      - malware_callback
      - malware_object
      - web_infection
      - infection_match
    - description: The MD5 hash of the alert to retrieve. This filter is not time
        dependent; it does not default to duration=12_hours.
      name: md5
    - description: A specific alert URL to retrieve.
      name: url
    description: Search and retrieve FireEye alerts based on several filters.
    name: fireeye-nx-get-alerts
    outputs:
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Md5Sum
      description: The md5sum of malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Sha256
      description: The SHA256 hash of malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Application
      description: The application of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.HttpHeader
      description: The HTTP header of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Original
      description: The filename of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Name
      description: The name of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Sid
      description: The SID of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Type
      description: The file type of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Stype
      description: The STYPE of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Url
      description: The URL of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.MalwareDetected.Malware.Content
      description: The content of the malware associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.CncServices.CncService.Address
      description: The CNC service IP address associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.CncServices.CncService.Channel
      description: The CNC service channel associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.CncServices.CncService.Port
      description: The CNC service port address associated with the alert.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.CncServices.CncService.Protocol
      description: The CNC service protocol associated with the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Totalmemory
      description: The total memory of heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Lastbytesreceived
      description: The last byte received in heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Processinfo.Imagepath
      description: The image path of the process in heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Processinfo.Md5sum
      description: The md5sum of the process in heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Processinfo.Pid
      description: The PID of the process in heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.IncrementCount
      description: The increment count in heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Name
      description: The name of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Bytesreceived
      description: The bytes received in heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Lasttotalmemory
      description: The last total memory in heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Type
      description: The type of heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Timestamp
      description: The timestamp of the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.RCount
      description: The RCount of the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.TotalSize
      description: The total size of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.RUnit
      description: The RUnit of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Mode
      description: The mode of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Pattern
      description: The pattern of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Entry.Percentage
      description: The entry percentage of the bytes list in the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Entry.Byte
      description: The entry byte of the bytes list in the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Entry.Count
      description: The entry count of the bytes list in the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Entry.FirstOffset
      description: The entry offset of the bytes list in the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Entry.IsNOP
      description: If entry NOP appears in the bytes list in the heap spraying then
        yes, otherwise no.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Distinct
      description: The distinct number of the byte list in the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.BytesList.Count
      description: The number of the byte list in the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Javascript
      description: If heap spraying has javascript then yes, otherwise no.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.DNA
      description: The DNA of the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.TotalRCount
      description: The total row count of the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.ProcessedRCount
      description: The processed row count of the heap spraying.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Heapspraying.Processed
      description: The processed memory of the heap spraying.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Fid.Ads
      description: The FID ads of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Fid.Content
      description: The FID content of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.ParentUserAccount.UserSid
      description: The parent user account SID of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.ParentUserAccount.SessionId
      description: The parent user account session ID of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.ParentUserAccount.UserAccountName
      description: The parent user account name of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.ParentUserAccount.AuthenticationId
      description: The parent user account authentication ID of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.ParentUserAccount.SuperPrivilegesPresent
      description: If super privileges are present in this process then 1, otherwise
        0.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Parentname
      description: The path of the parent process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Sha256sum
      description: The sha256sum of the parent process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Pid
      description: The PID of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Filesize
      description: File size of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Ppid
      description: The PPID of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Mode
      description: The mode of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Cmdline
      description: The path of the command associated with the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Sha1sum
      description: The sha1sum of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Md5sum
      description: The md5sum of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.SrcThread
      description: The source thread name of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.osChanges.Process.Value
      description: The value of the path in the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.UserAccount.UserSid
      description: The SID of the user account for the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.UserAccount.SessionId
      description: The session ID of the user account for the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.UserAccount.UserAccountName
      description: The name of the user account for the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.UserAccount.AuthenticationId
      description: The authentication ID of the user account for the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.UserAccount.SuperPrivilegesPresent
      description: If super privileges are present in this user account then 1, otherwise
        0.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.Timestamp
      description: The timestamp of the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.MemoryData
      description: The memory data of the process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.LocalThreadCount
      description: The local thread count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.FileOpenCount
      description: The file open count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.FileModifyCount
      description: The file modify count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.FileCreateCount
      description: The file created count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.ChildProcessCount
      description: The file process count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.FileFailedCount
      description: The file failed count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.HttpReqCount
      description: The HTTP request count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.RemoteThreadCount
      description: The remote thread count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Process.TelemetryData.MutexCreateCount
      description: The mutex-created count of the telemetry data in the process.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Mode
      description: The mode of the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Processinfo.Imagepath
      description: The image path of the process in the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Processinfo.Md5sum
      description: The md5sum of the process in the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Processinfo.Pid
      description: The PID of the process in the registry key.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Ntstatus
      description: The NTSTATUS of the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Suppressed
      description: If the registry key was suppressed then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Value
      description: The value of the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Timestamp
      description: The timestamp of the registry key.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.SrcThread
      description: The source thread name of the registry key.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Randomized
      description: If the registry key was randomized then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.Buffered
      description: If the registry key was buffered then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Regkey.NoExtend
      description: If the registry key has no_extend then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Os.Name
      description: The name of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Os.Arch
      description: The architecture of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Os.Version
      description: The version of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Os.Sp
      description: The service pack version of the operating system.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.OsMonitor.Date
      description: The monitored date of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.OsMonitor.Build
      description: The monitored build of the operating system.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.OsMonitor.Time
      description: The monitored time of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.OsMonitor.Version
      description: The monitored version of the operating system.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Analysis.Mode
      description: The mode of the analysis.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Analysis.Product
      description: The product name of the analysis.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Analysis.Ftype
      description: The file type of the analysis.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Analysis.Version
      description: The version of the analysis.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Mode
      description: The mode of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.ProtocolType
      description: The protocol type of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Ipaddress
      description: The IP address of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.DestinationPort
      description: The destination port address of the network.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Processinfo.Imagepath
      description: The image path of the process in the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Processinfo.Tainted
      description: If the process state is tainted then true, otherwise false for
        the network.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Processinfo.Md5sum
      description: The md5sum of the process in the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Processinfo.Pid
      description: The PID of the process in the network.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.HttpRequest
      description: The HTTP request of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Timestamp
      description: The timestamp of the network.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Hostname
      description: The hostname of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.Qtype
      description: The QTYPE of the network.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.AnswerNumber
      description: The answer number of the network.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Network.DnsResponseCode
      description: The DNS response code of the network.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.Mode
      description: The mode of opening the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.Ext
      description: The extension of opening the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.Buffered
      description: If the opened file was buffered then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.NoExtend
      description: If the opened file has no_extend then true, otherwise false.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.Name
      description: The name of the action for opening the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.ActionFopen.Timestamp
      description: The timestamp of opening the file.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Dllname
      description: The DLL file name of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Apiname
      description: The API name of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Address
      description: The address of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Processinfo.Imagepath
      description: The image path of the process in the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Processinfo.Md5sum
      description: The md5sum of the process in the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Processinfo.Pid
      description: The PID of the process in the exploit code.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.SrcThread
      description: The source thread name of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Protection
      description: The protection number of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Callstack.CallstackEntry.SymbolName
      description: The symbol name of the call stack entry in the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Callstack.CallstackEntry.FrameNumber
      description: The frame number of the call stack entries in the exploit code.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Callstack.CallstackEntry.ModuleName
      description: The module name of the call stack entry in the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Callstack.CallstackEntry.InstructionAddress
      description: The instruction address of the call stack entry in the exploit
        code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Callstack.CallstackEntry.SymbolDisplacement
      description: The symbol displacement of the call stack entry in the exploit
        code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Params.Param.Id
      description: The ID parameter of the exploit code.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Params.Param.Content
      description: The path parameter of the exploit code.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Exploitcode.Timestamp
      description: The timestamp of the exploit codes.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Mode
      description: The mode of the folder.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Processinfo.Imagepath
      description: The image path of the process in the folder.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Processinfo.Md5sum
      description: The md5sum of the process in the folder.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Processinfo.Pid
      description: The PID of the process in the folder.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.SrcThread
      description: The source thread name of the folder.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Value
      description: The path of the folder.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Folder.Timestamp
      description: The timestamp of the folder.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Mode
      description: The mode of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Fid.Ads
      description: The Alternate Data Stream (ADS) of the FID for the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Fid.Content
      description: The content of the FID in the file.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Processinfo.Imagepath
      description: The image path of the process for the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Processinfo.Md5sum
      description: The md5sum of the process for the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Processinfo.Pid
      description: The PID of the process for the file.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Processinfo.Tainted
      description: If the process state is tainted then true, otherwise false for
        the file.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.SrcThread
      description: The source thread name of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Ntstatus
      description: The NTSTATUS of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Filesize
      description: The size of the file.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Value
      description: The value of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.CreateOptions
      description: The created option of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Timestamp
      description: The timestamp of the file.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Type
      description: The type of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Sha256sum
      description: The sha256sum of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Sha1sum
      description: The sha1sum of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.InspectionType
      description: The inspection type of the portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.TimeDateStamp
      description: The time date stamp of the portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Characteristics.Names.Name
      description: The list of characteristic names in the portable executable file.
      type: Unknown
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Characteristics.Value
      description: The characteristic value in the portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.DllCharacteristics.Names
      description: The characteristic name in the DLL portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.DllCharacteristics.Value
      description: The characteristic value in the DLL portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Dll
      description: If the portable file is a DLL file then yes, otherwise no file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Magic
      description: The magic hex value of the portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Subsystem
      description: The subsystem of the portable executable file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.PE.Machine
      description: The hexadecimal address of the machine in the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.File.Md5sum
      description: The md5sum of the file.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Application.AppName
      description: The app name of the application.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.Processinfo.Imagepath
      description: The image path of the queried system process.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.Processinfo.Md5sum
      description: The system time process info of the md5sum that is queried.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.Processinfo.Pid
      description: The system time process info of the PID (process ID) that is queried.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.Ntstatus
      description: The NTSTATUS of the system time that is queried.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.Timestamp
      description: The timestamp of the system that is queried.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.SystemTime.Value
      description: The time value of the system that is queried.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.QuerySystemTime.SystemTime.Time
      description: The time of the system that is queried.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.EndOfReport
      description: The end of the report.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.MaliciousAlert.Classtype
      description: The class type of the malicious alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.MaliciousAlert.DisplayMsg
      description: The display message of the malicious alert.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.Hwnd
      description: The hexadecimal address of the dialog detected.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.Processinfo.Imagepath
      description: The image path of the process for the dialog detected.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.Processinfo.Pid
      description: The PID of the process for the dialog detected.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.Buffered
      description: A flag indicating whether the dialog detected is buffered.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.NoExtend
      description: A flag indicating whether NoExtend is true in the dialog detected.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.Timestamp
      description: The timestamp of the dialog detected.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDetected.DlgId
      description: The dialog ID of the dialog detected.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Note
      description: A note in the dismissed dialog.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Hwnd
      description: The hexadecimal address of the dismissed dialog.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Processinfo.Imagepath
      description: The image path of the process for the dismissed dialog.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Processinfo.Pid
      description: The PID of the process for the dismissed dialog.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Buffered
      description: A flag indicating whether the dismissed dialog is buffered.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.NoExtend
      description: A flag indicating whether NoExtend is true in the dismissed dialog.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.Timestamp
      description: The timestamp of the dismissed dialog.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.DialogDismissed.DlgId
      description: The dialog ID of the dismissed dialog.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Processinfo.Imagepath
      description: The image path of the process for the Windows Management Instrumentation
        (WMI) query.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Processinfo.Md5sum
      description: The md5sum of the process for the WMI query.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Processinfo.Pid
      description: The PID of the process for the WMI query.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Wmicontents.Wmiconent.Query
      description: The query for the WMI content for WMI query.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Wmicontents.Wmicontent.Lang
      description: Language of the WMI content for the WMI query.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Timestamp
      description: The timestamp of the WMI query.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.Buffered
      description: A flag indicating whether the WMI query is buffered.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Wmiquery.NoExtend
      description: A flag indicating whether NoExtend is true in the WMI query.
      type: Boolean
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Uac.Mode
      description: The mode of the User Account Control (UAC).
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Uac.Value
      description: The value of the User Account Control.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Uac.Timestamp
      description: The timestamp of the User Account Control.
      type: Number
    - contextPath: FireEyeNX.Alert.Explanation.OsChanges.Uac.Status
      description: The status of the User Account Control.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.StaticAnalysis.Static.Value
      description: The value of the static analysis.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.StolenData.Info.Field
      description: The information field of the stolen data.
      type: Unknown
    - contextPath: FireEyeNX.Alert.Explanation.StolenData.Info.Type
      description: The information type of the stolen data.
      type: String
    - contextPath: FireEyeNX.Alert.Explanation.StolenData.EventId
      description: The event ID of the stolen data.
      type: Number
    - contextPath: FireEyeNX.Alert.Src.Ip
      description: The source IP address of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Src.Mac
      description: The source MAC address of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Src.Port
      description: The source port address of the alert.
      type: Number
    - contextPath: FireEyeNX.Alert.Src.Host
      description: The source host of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.AlertUrl
      description: The alert URL.
      type: String
    - contextPath: FireEyeNX.Alert.Action
      description: The action of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Occurred
      description: The time when the alert occurred.
      type: String
    - contextPath: FireEyeNX.Alert.AttackTime
      description: The time when an attack occurred.
      type: String
    - contextPath: FireEyeNX.Alert.Dst.Mac
      description: The destination MAC address of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Dst.Port
      description: The destination port address of the alert.
      type: Number
    - contextPath: FireEyeNX.Alert.Dst.Ip
      description: The destination IP address of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.ApplianceId
      description: The appliance ID of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Id
      description: The ID of the alert.
      type: Number
    - contextPath: FireEyeNX.Alert.Name
      description: The type of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Severity
      description: The severity of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Uuid
      description: The universally unique identifier (UUID) of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Ack
      description: A flag indicating whether an acknowledgment is received.
      type: String
    - contextPath: FireEyeNX.Alert.Product
      description: The product name of the alert.
      type: String
    - contextPath: FireEyeNX.Alert.Vlan
      description: The virtual LAN (VLAN) of the alert.
      type: Number
    - contextPath: FireEyeNX.Alert.Malicious
      description: A flag indicating whether the alert is malicious.
      type: String
    - contextPath: FireEyeNX.Alert.ScVersion
      description: The SC version of the alert.
      type: String
  - arguments:
    - description: The universally unique ID (UUID) of the alert. To get the UUID,
        execute the fireeye-nx-get-alerts command.
      name: uuid
      required: true
    description: Downloads malware artifacts data for the specified UUID as a zip
      file.
    name: fireeye-nx-get-artifacts-by-alert
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: Number
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: The entry ID of the file.
      type: String
    - contextPath: File.Info
      description: The file information.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The file extension.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The time interval to search. This filter is used with the end_time
        filter. If the duration is not specified, the system defaults to duration=12_hours,
        end_time=current_time.
      name: duration
      predefined:
      - 1_hour
      - 2_hours
      - 6_hours
      - 12_hours
      - 24_hours
      - 48_hours
    - description: "The start time of the search. This filter is used with the duration
        filter. If the start_time is specified but not the duration, the system defaults
        to duration=12_hours, starting at the specified start_time.\nFormats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours."
      name: start_time
    - description: "The end time of the search. This filter is used with the duration
        filter. If the end_time is specified but not the duration, the system defaults
        to duration=12_hours, ending at the specified end_time. \nFormats:\nYYYY-MM-dd\nYYYY-MM-ddTHH:mm:ss\nN
        days \nN hours\nExample:\n 2020-05-01 \n 2020-05-01T00:00:00 \n 2 days \n
        5 hours."
      name: end_time
    - auto: PREDEFINED
      description: 'Whether to include all IPS events or MVX-correlated events only.
        Default: false.'
      name: mvx_correlated_only
      predefined:
      - "true"
      - "false"
    description: Search and retrieve FireEye events based on several filters.
    name: fireeye-nx-get-events
    outputs:
    - contextPath: FireEyeNX.Event.EventId
      description: The ID of the event.
      type: Number
    - contextPath: FireEyeNX.Event.Occurred
      description: The date and time when the event occurred.
      type: String
    - contextPath: FireEyeNX.Event.SrcIp
      description: The IP address of the victim.
      type: String
    - contextPath: FireEyeNX.Event.SrcPort
      description: The port number of the victim.
      type: Number
    - contextPath: FireEyeNX.Event.DstIp
      description: The IP address of the attacker.
      type: String
    - contextPath: FireEyeNX.Event.DstPort
      description: The port number of the attacker.
      type: Number
    - contextPath: FireEyeNX.Event.Severity
      description: The severity level of the event.
      type: Number
    - contextPath: FireEyeNX.Event.SignatureRev
      description: The signature revision number of the event.
      type: Number
    - contextPath: FireEyeNX.Event.SignatureIden
      description: The signature identity number of the event.
      type: Number
    - contextPath: FireEyeNX.Event.SignatureMatchCnt
      description: The signature match count number of the event.
      type: Number
    - contextPath: FireEyeNX.Event.Vlan
      description: The virtual LAN (VLAN) of the event.
      type: Number
    - contextPath: FireEyeNX.Event.VmVerified
      description: Whether the event VM was verified.
      type: Boolean
    - contextPath: FireEyeNX.Event.SrcMac
      description: The MAC address of the source machine.
      type: String
    - contextPath: FireEyeNX.Event.DstMac
      description: The MAC address of the destination machine.
      type: String
    - contextPath: FireEyeNX.Event.RuleName
      description: The rule name for the event.
      type: String
    - contextPath: FireEyeNX.Event.SensorId
      description: The sensor ID of the FireEye machine.
      type: String
    - contextPath: FireEyeNX.Event.CveId
      description: The CVE ID found in the event.
      type: String
    - contextPath: FireEyeNX.Event.ActionTaken
      description: The IPS blocking action taken on the event.
      type: Number
    - contextPath: FireEyeNX.Event.AttackMode
      description: The attack mode mentioned in the event.
      type: String
    - contextPath: FireEyeNX.Event.InterfaceId
      description: The interface ID of the event.
      type: Number
    - contextPath: FireEyeNX.Event.Protocol
      description: The protocol used in the event.
      type: Number
    - contextPath: FireEyeNX.Event.IncidentId
      description: The incident ID of the event on FireEye.
      type: Number
  dockerimage: demisto/python3:3.11.9.104657
  isfetch: true
  runonce: false
  script: |
    register_module_line('FireEyeNX', 'start', __line__())
    ### pack version: 1.1.33


    """ IMPORTS """

    import dateparser
    from requests import Response
    from typing import Any
    from requests.exceptions import (
        MissingSchema,
        InvalidSchema,
        InvalidURL,
        SSLError,
    )
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    """ CONSTANTS """

    DEFAULT_REQUEST_TIMEOUT = 120
    REQUEST_TIMEOUT_MAX_VALUE = 9223372036

    API_VERSION = 'v2.0.0'

    DEFAULT_SESSION_TIMEOUT = 15 * 60  # In Seconds
    DEFAULT_FETCH_LIMIT = '50'
    CONTENT_TYPE_JSON = 'application/json'
    CONTENT_TYPE_ZIP = 'application/zip'
    DATE_FORMAT_OF_YEAR_MONTH_DAY = '%Y-%m-%d'
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    DATE_FORMAT_WITH_MICROSECOND = '%Y-%m-%dT%H:%M:%S.%fZ'
    API_SUPPORT_DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.000-00:00'
    ALERT_DETAILS_REPORT = 'Alert Details Report'
    VICTIM_IP = 'Victim IP'
    TIME_UTC = 'Time (UTC)'
    DEFAULT_FIRST_FETCH = '12 hours'
    ALERT_INCIDENT_TYPE = 'FireEye NX Alert'
    IPS_EVENT_INCIDENT_TYPE = 'FireEye NX IPS Event'

    MESSAGES: dict[str, str] = {
        'BAD_REQUEST_ERROR': 'An error occurred while fetching the data.',
        'AUTHENTICATION_ERROR': 'Unauthenticated. Check the configured Username and Password.',
        'PROXY_ERROR': "Proxy Error - cannot connect to proxy. Either try clearing the 'Use system proxy' check-box or "
                       'check the host, authentication details and connection details for the proxy.',
        'BLANK_PROXY_ERROR': 'https proxy value is empty. Check XSOAR server configuration ',
        'SSL_CERT_ERROR': "SSL Certificate Verification Failed - try selecting 'Trust any certificate' checkbox in the "
                          'integration configuration.',
        'INTERNAL_SERVER_ERROR': 'The server encountered an internal error for FireEye NX and was unable to complete '
                                 'your request.',
        'MISSING_SCHEMA_ERROR': 'Invalid API URL. No schema supplied: http(s).',
        'INVALID_SCHEMA_ERROR': 'Invalid API URL. Supplied schema is invalid, supports http(s).',
        'INVALID_API_URL': 'Invalid API URL.',
        'CONNECTION_ERROR': 'Connectivity failed. Check your internet connection or the API URL.',
        'INVALID_ALERT_DETAILS': 'For fetching Alert Details Report, "infection_id" and "infection_type" '
                                 'arguments are required.',
        'INVALID_REPORT_TYPE': 'The given value for report_type is invalid.',
        'INVALID_REPORT_OUTPUT_TYPE': "The given value for the argument type (report's format) is invalid. Valid value("
                                      's): {}.',
        'NO_RECORDS_FOUND': 'No {} were found for the given argument(s).',
        'INVALID_INT_VALUE': 'The given value for {} is invalid. Expected integer value.',
        'FETCH_LIMIT_VALIDATION': 'Value of Fetch Limit should be an integer and between range 1 to 200.',
        'INVALID_BOOLEAN_VALUE_ERROR': 'The given value for {0} argument is invalid. Valid values: true, false.',
        'REQUEST_TIMEOUT_VALIDATION': 'HTTP(S) Request timeout parameter must be a positive integer.',
        'REQUEST_TIMEOUT_EXCEED_ERROR': 'Value is too large for HTTP(S) Request Timeout.',
        'REQUEST_TIMEOUT': 'Request timed out. Check the configured HTTP(S) Request Timeout (in seconds) value.',
        'FIRST_FETCH_ARG_VALIDATION': 'The First fetch time interval should be up to 48 hour as per API limitation.',
        'INVALID_TIME_VALIDATION': 'The given value for {0} argument is invalid.',
        'INVALID_FETCH_TYPE': 'The given value for Fetch Types is invalid. Expected Alerts or/and IPS Events ',
    }

    URL_SUFFIX: dict[str, str] = {
        'GET_TOKEN': '/auth/login',
        'GET_ARTIFACTS_METADATA': '/artifacts/{}/meta',
        'GET_ARTIFACTS': '/artifacts/{}',
        'GET_REPORTS': '/reports/report',
        'GET_ALERTS': '/alerts',
        'GET_EVENTS': '/events',
    }

    REPORT_TYPE_LABEL_NAME = {
        'Website Callback Server Report': 'mpsCallBackServer',
        'Website Executive Summary': 'mpsExecutiveSummary',
        'Website Infected Host Trends': 'mpsInfectedHostsTrend',
        'Website Malware Activity': 'mpsMalwareActivity',
        'Website Antivirus Report': 'mpsWebAVReport',
        'IPS Executive Summary Report': 'ipsExecutiveSummary',
        'IPS Top N Attacks Report': 'ipsTopNAttack',
        'IPS Top N Attackers Report': 'ipsTopNAttacker',
        'IPS Top N Victims Report': 'ipsTopNVictim',
        'IPS Top N MVX-Correlated Report': 'ipsTopNMvxVerified',
        ALERT_DETAILS_REPORT: 'alertDetailsReport',
    }
    REPORT_TYPE_ALLOWED_FORMAT = {
        'Website Callback Server Report': ['csv'],
        'Website Executive Summary': ['pdf'],
        'Website Infected Host Trends': ['csv'],
        'Website Malware Activity': ['pdf', 'csv'],
        'Website Antivirus Report': ['csv'],
        'IPS Executive Summary Report': ['pdf', 'csv'],
        'IPS Top N Attacks Report': ['pdf', 'csv'],
        'IPS Top N Attackers Report': ['pdf', 'csv'],
        'IPS Top N Victims Report': ['pdf', 'csv'],
        'IPS Top N MVX-Correlated Report': ['pdf', 'csv'],
        ALERT_DETAILS_REPORT: ['pdf'],
    }

    PLATFORM_SEVERITY_TO_SEVERITY_MAP = {
        '10': 4,
        '9': 4,
        '8': 3,
        '7': 3,
        '6': 2,
        '5': 2,
        '4': 2,
        '3': 1,
        '2': 1,
        '1': 1,
        '0': 0,
    }


    def strip_blank(args: dict) -> dict:
        nargs = {}
        for key, value in args.items():
            if isinstance(value, str):
                value = value.strip()
            nargs[key] = value
        return nargs


    class Client(BaseClient):
        """
        Client to use in integration with powerful http_request.
        It extends the base client and uses the http_request method for the API request.
        Handle some exceptions externally.
        """

        def __init__(
            self,
            base_url: str,
            verify: bool,
            proxy: bool,
            auth: tuple[str, str],
            request_timeout: int,
        ):
            super().__init__(
                base_url=base_url, verify=verify, proxy=proxy, auth=auth
            )
            self.request_timeout = request_timeout

        def http_request(
            self,
            method: str,
            url_suffix: str,
            json_data=None,
            params=None,
            headers=None,
            ok_codes=None,
        ):
            """
                Override http_request method from BaseClient class. This method will print an error based on status code
                and exceptions.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :type ok_codes: ``tuple``
            :param ok_codes: The tuple of acceptable status codes. Default is None.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """
            resp = Response()
            try:
                resp = super()._http_request(
                    method=method,
                    url_suffix=url_suffix,
                    json_data=json_data,
                    params=params,
                    headers=headers,
                    resp_type='response',
                    timeout=self.request_timeout,
                    ok_codes=ok_codes or (200, 201),
                    error_handler=self.handle_error_response,
                )
            except MissingSchema:
                raise ValueError(MESSAGES['MISSING_SCHEMA_ERROR'])
            except InvalidSchema:
                raise ValueError(MESSAGES['INVALID_SCHEMA_ERROR'])
            except InvalidURL:
                raise ValueError(MESSAGES['INVALID_API_URL'])
            except DemistoException as e:
                self.handle_demisto_exception(e)

            if resp.ok:
                content_type = resp.headers.get('Content-Type', '')
                if content_type == CONTENT_TYPE_JSON:
                    # Handle empty response
                    if resp.text == '':
                        return resp
                    else:
                        return resp.json()
                elif self.is_supported_context_type(content_type):
                    return resp
                return None
            return None

        @staticmethod
        def is_supported_context_type(content_type: str):
            """
            Check whether content type is supported or not.
            :param content_type: content type of header.
            :return: boolean flag, whether content type is supported or not.
            """
            return (
                content_type == 'application/pdf'
                or content_type == 'text/csv'
                or content_type == CONTENT_TYPE_ZIP
                or content_type == 'application/octet-stream'
            )

        @staticmethod
        def handle_demisto_exception(e):
            """
            Handle Demisto exception based on string.

            :param e: Demisto Exception
            :return: Error message
            """
            if 'Proxy Error' in str(e):
                raise ConnectionError(MESSAGES['PROXY_ERROR'])
            elif 'ReadTimeoutError' in str(e):
                raise ConnectionError(MESSAGES['REQUEST_TIMEOUT'])
            elif 'ConnectionError' in str(e) or 'ConnectTimeoutError' in str(e):
                raise ConnectionError(MESSAGES['CONNECTION_ERROR'])
            elif 'SSLError' in str(e):
                raise SSLError(MESSAGES['SSL_CERT_ERROR'])
            else:
                raise e

        @staticmethod
        def handle_error_response(resp):
            """
            Handle error response and display user specific error message based on status code.

            :param resp: response from API.
            :return: raise DemistoException based on status code.
            """
            error_message = ''
            error_message_with_reason = ''
            try:
                error_message = (
                    resp.json()
                    .get('fireeyeapis', {})
                    .get('description', '')
                    .strip()
                )
                error_message = error_message.replace('\n', '')
                if error_message:
                    error_message_with_reason = f'Reason: {error_message}'
            except ValueError:  # ignoring json parsing errors
                pass
            if resp.headers.get('Content-Type', '') == CONTENT_TYPE_ZIP:
                error_message = error_message_with_reason = resp.text

            status_code_messages = {
                400: f"{MESSAGES['BAD_REQUEST_ERROR']} {error_message_with_reason}",
                401: MESSAGES['AUTHENTICATION_ERROR'],
                403: error_message,
                404: error_message,
                406: error_message,
                407: MESSAGES['PROXY_ERROR'],
                500: MESSAGES['INTERNAL_SERVER_ERROR'],
                503: MESSAGES['INTERNAL_SERVER_ERROR'],
            }

            if resp.status_code in status_code_messages:
                demisto.debug(
                    f'Response Code: {resp.status_code}, Reason: {status_code_messages[resp.status_code]}'
                )
                raise DemistoException(status_code_messages[resp.status_code])
            else:
                raise DemistoException(resp.raise_for_status())

        def get_api_token(self):
            """
            Retrieve new api token and set it to integration context.
            if api token is not not found or expired, making api call to retrieve api token and set it to integration
            context.

            :return: api-token
            """
            integration_context = demisto.getIntegrationContext()
            api_token = integration_context.get('api_token')
            valid_until = integration_context.get('valid_until')

            # Return api token from integration context, if found and not expired
            if api_token and valid_until and time.time() < valid_until:
                demisto.debug('Retrieved api-token from integration cache.')
                return api_token

            headers = {'Accept': CONTENT_TYPE_JSON}

            demisto.debug('Calling authentication API for retrieve api-token')
            resp = self.http_request(
                method='POST', url_suffix=URL_SUFFIX['GET_TOKEN'], headers=headers
            )
            integration_context = self.set_integration_context(resp)

            return integration_context.get('api_token')

        @staticmethod
        def set_integration_context(resp):
            """
            set api token and expiry time in integration configuration context.
            Will raise value error if api-token is not found.

            :param resp: resp from API.
            :return: integration context
            """
            integration_context = demisto.getIntegrationContext()
            api_token = resp.headers.get('X-FeApi-Token')
            if api_token:
                integration_context['api_token'] = api_token
                integration_context['valid_until'] = (
                    time.time() + DEFAULT_SESSION_TIMEOUT
                )
            else:
                raise ValueError('No api token found. Please try again')
            demisto.setIntegrationContext(integration_context)
            return integration_context


    """ HELPER FUNCTION"""


    def set_attachment_file(client, incident: dict, uuid: str, headers: dict):
        """
        Set attachment in incident entry.

        :param client: Client object.
        :param incident: Incident entry.
        :param uuid: uuid of alert.
        :param headers: Header of API which will pass to get artifact API.
        """

        # Call get artifacts data api
        headers['Accept'] = CONTENT_TYPE_ZIP
        artifacts_resp = client.http_request(
            'GET',
            url_suffix=URL_SUFFIX['GET_ARTIFACTS'].format(uuid),
            headers=headers,
            ok_codes=(200, 201, 404),
        )
        if artifacts_resp and int(artifacts_resp.headers.get('Content-Length', '0')) > 0:
            # Create file from Content
            file_name = f'{uuid}.zip'

            attachment_file = fileResult(
                filename=file_name, data=artifacts_resp.content
            )

            incident['attachment'] = [
                {'path': attachment_file['FileID'], 'name': file_name}
            ]


    def get_incidents_for_alert(**kwargs) -> tuple[list[dict[str, Any]], dict[str, Any]]:
        """
        Return List of incidents for alert.

        :param kwargs: Contains all required arguments.
        :return: Incident List for alert.
        """
        incidents: list[dict[str, Any]] = []
        last_run = kwargs['last_run']
        next_run = last_run.get('alerts', {})

        headers = {
            'X-FeApi-Token': kwargs['client'].get_api_token(),
            'Accept': CONTENT_TYPE_JSON,
        }

        params = {
            'start_time': time.strftime(
                API_SUPPORT_DATE_FORMAT, time.localtime(kwargs['start_time'])
            ),
            'duration': '48_hours',
        }

        if kwargs['malware_type']:
            params['malware_type'] = kwargs['malware_type']

        # http call
        resp = kwargs['client'].http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_ALERTS'],
            params=params,
            headers=headers,
        )

        total_records = resp.get('alertsCount', 0)
        if total_records > 0:
            if kwargs['replace_alert_url']:
                replace_alert_url_key_domain_to_instance_url(
                    resp.get('alert', []), kwargs['instance_url']
                )
            count = kwargs['fetch_count']

            next_incidents_ids: List[str] = []
            alerts = resp.get('alert', [])
            alerts.sort(key=lambda x: x.get("occurred"))
            last_alert_start_time = last_run.get('alerts', {}).get('start_time')
            last_alert_ids = last_run.get('alerts', {}).get('alert_ids', [])
            next_alert_start_time = alerts[:kwargs['fetch_limit']][-1].get('occurred', '')

            for alert in alerts:
                # skip on duplicate incident
                if (last_alert_start_time
                    and last_alert_ids
                    and last_alert_start_time == alert.get('occurred', '')
                        and alert.get('id', '') in last_alert_ids):
                    continue
                # set incident
                context_alert = remove_empty_entities(alert)
                context_alert['incidentType'] = ALERT_INCIDENT_TYPE
                if count >= kwargs['fetch_limit']:
                    break

                occurred_date = dateparser.parse(context_alert.get('occurred', ''))
                assert occurred_date is not None
                if ((alert_occurred_time := alert.get('occurred'))
                        and next_alert_start_time == alert_occurred_time) and (alert_id := alert.get('id')):
                    # Save the alert id for the next fetch dedup
                    next_incidents_ids.append(alert_id)

                incident = {
                    'name': context_alert.get('name', ''),
                    'occurred': occurred_date.strftime(
                        DATE_FORMAT_WITH_MICROSECOND
                    ),
                    'rawJSON': json.dumps(context_alert),
                    'dbotMirrorId': str(alert.get('id')),
                }

                if (
                    not kwargs['is_test']
                    and alert.get('uuid', '')
                    and kwargs['fetch_artifacts']
                ):
                    set_attachment_file(
                        client=kwargs['client'],
                        incident=incident,
                        uuid=alert.get('uuid', ''),
                        headers=headers,
                    )

                remove_nulls_from_dictionary(incident)
                incidents.append(incident)
                count += 1

            parsed_incidents_str = [f"Incident name: {incident.get('name')} Incident date: {incident.get('occurred')}\n" for
                                    incident in incidents]
            demisto.debug(
                f"FireeyeNX Alerts: {parsed_incidents_str}")
            if next_incidents_ids:
                next_run = {'start_time': next_alert_start_time, 'alert_ids': next_incidents_ids}
        return incidents, next_run


    def get_incidents_for_event(
        client: Client, start_time: float, fetch_limit: int, mvx_correlated: bool, last_run: dict
    ):
        """
        Return List of incidents for event.

        :param client: Client object.
        :param start_time: It contains the timestamp in milliseconds on when to start fetching incidents.
        :param fetch_limit: limit for number of fetch incidents per fetch.
        :param mvx_correlated: The boolean flag that tell us to fetch events which only mvx correlated.
        :param last_run: The last run object.
        :return: Incident List for event.
        """
        incidents: list[dict[str, Any]] = []
        next_run = last_run.get('events', {})

        # Preparing header and parameters
        headers = {
            'X-FeApi-Token': client.get_api_token(),
            'Accept': CONTENT_TYPE_JSON,
        }

        params = {
            'start_time': time.strftime(
                API_SUPPORT_DATE_FORMAT, time.localtime(start_time)
            ),
            'duration': '48_hours',
            'event_type': 'Ips Event',
        }

        if mvx_correlated:
            params['mvx_correlated_only'] = 'true'

        # http call
        resp = client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_EVENTS'],
            params=params,
            headers=headers,
        )

        total_records = len(resp.get('events', []))
        count = 0
        if total_records > 0:
            next_incidents_ids = []
            events = resp.get('events', [])
            events.sort(key=lambda x: x.get("occurred"))
            last_event_start_time = last_run.get('events', {}).get('start_time')
            last_event_ids = last_run.get('events', {}).get('event_ids', [])
            next_event_start_time = events[:fetch_limit][-1].get('occurred', '')

            for event in events:
                # skip on duplicate incident
                if last_event_start_time and last_event_ids and last_event_start_time == event.get('occurred', '') and event.get(
                        'eventId', '') in last_event_ids:
                    continue

                # set incident
                context_event = remove_empty_entities(event)
                context_event['incidentType'] = IPS_EVENT_INCIDENT_TYPE
                if count >= fetch_limit:
                    break
                if ((event_occurred_time := event.get('occurred'))
                        and next_event_start_time == event_occurred_time) and (event_id := event.get('eventId')):
                    # Save the event id for the next fetch dedup
                    next_incidents_ids.append(event_id)
                incident = {
                    'name': context_event.get('ruleName', ''),
                    'occurred': context_event.get('occurred', ''),
                    'severity': PLATFORM_SEVERITY_TO_SEVERITY_MAP.get(
                        str(context_event.get('severity', 0)), 0
                    ),
                    'rawJSON': json.dumps(context_event),
                    'dbotMirrorId': str(event.get('eventId')),
                }
                remove_nulls_from_dictionary(incident)
                incidents.append(incident)
                count += 1
            parsed_incidents_str = [f"Incident name: {incident.get('name')} Incident date: {incident.get('occurred')}\n" for
                                    incident in incidents]
            demisto.debug(
                f"FireeyeNX IPS Events: {parsed_incidents_str}")
            if next_incidents_ids:
                next_run = {'start_time': next_event_start_time, 'event_ids': next_incidents_ids}
        return incidents, count, next_run


    def validate_fetch_type(fetch_type):
        """
        Validate fetch type.

        :param fetch_type: A list contain types which user want to fetch.
        :return:
        """
        if type(fetch_type) == list:
            if len(fetch_type) == 0:
                raise ValueError(MESSAGES['INVALID_FETCH_TYPE'])

            if 'Alerts' not in fetch_type and 'IPS Events' not in fetch_type:
                raise ValueError(MESSAGES['INVALID_FETCH_TYPE'])


    def validate_date_range(fetch_time: str):
        """
        Validate date range and it should be up to 2 days as per API limitation.
        Will raise ValueError() if date is not in range.

        :param fetch_time: A time in format of (<number> <unit>). eg. 1 hour.
        """
        two_days_before_time = datetime.utcnow() - timedelta(hours=48)

        start_time, _ = parse_date_range(fetch_time, utc=True)

        if start_time < two_days_before_time:
            raise ValueError(MESSAGES['FIRST_FETCH_ARG_VALIDATION'])


    def pascal_case(st) -> str:
        """
        Covert string to pascal case.

        :param st: string
        :return: pascal case string.
        """
        if st.find('-') != -1 or st.find('_') != -1:
            st = ''.join(a.capitalize() for a in re.split('-|_', st))
        return st[:1].upper() + st[1: len(st)]


    def remove_dash_and_underscore_from_key(d):  # type: ignore
        """
        Recursively traverse dict and change keys into pascal case.

        :param d: Input dictionary.
        :return: Dictionary with pascal case key.
        """

        if not isinstance(d, dict | list):
            return d
        elif isinstance(d, list):
            return (
                [remove_dash_and_underscore_from_key(value) for value in d]
            )
        else:
            return {
                pascal_case(key): remove_dash_and_underscore_from_key(value)
                for key, value in d.items()
            }


    def get_request_timeout(request_timeout: str) -> int:
        """
        Validate and return the request timeout parameter.
        The parameter must be a positive integer.
        Default value is set to 60 seconds for API request timeout.
        Will raise ValueError if inappropriate input given.

        :params req_timeout: Request timeout value.
        :return: boolean
        """
        try:
            request_timeout_str = (
                request_timeout if request_timeout else str(DEFAULT_REQUEST_TIMEOUT)
            )
            request_timeout_int = int(request_timeout_str)
        except ValueError:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])

        if request_timeout_int <= 0:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])
        elif request_timeout_int > REQUEST_TIMEOUT_MAX_VALUE:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_EXCEED_ERROR'])

        return request_timeout_int


    def get_fetch_limit(fetch_limit):
        """
        Retrieve fetch limit from demisto arguments and validate it.
        Will raise ValueError if inappropriate input given.

        :param fetch_limit: The maximum number of incident want to fetch.
        :return: fetch limit
        """
        fetch_limit = fetch_limit if fetch_limit else DEFAULT_FETCH_LIMIT
        try:
            fetch_limit_int = int(fetch_limit)
            if not 1 <= fetch_limit_int <= 200:
                raise ValueError
        except ValueError:
            raise ValueError(MESSAGES['FETCH_LIMIT_VALIDATION'])

        return fetch_limit_int


    def generate_report_file_name(args: dict[str, Any]) -> str:
        """
        Create the filename of the info file of report.

        :param args: Input arguments
        :return: The report file name
        """
        return (
            f"{args.get('report_type', '').lower().replace(' ', '_')}_fireeye_"
            f"{datetime.now().strftime('%Y-%m-%d_%H:%M:%S')}."
            f"{args.get('type', REPORT_TYPE_ALLOWED_FORMAT[args.get('report_type', '')][0])}"
        )


    def validate_alert_report_type_arguments(
        args: dict[str, Any], params: dict[str, Any]
    ) -> dict[str, Any]:
        """
        Validates the arguments required for alert details report type from input arguments of reports command.
        Will raise ValueError if inappropriate input given.

        :param args: Input arguments
        :param params: Params to be passed in API call
        :return: Params to be passed in API call
        """
        arg_keys = args.keys()

        if 'infection_id' in arg_keys and 'infection_type' in arg_keys:
            params['infection_id'] = args.get('infection_id', '')
            params['infection_type'] = args.get('infection_type', '')
        else:
            raise ValueError(MESSAGES['INVALID_ALERT_DETAILS'])
        return params


    def validate_ips_report_type_arguments(
        args: dict[str, Any], params: dict[str, Any]
    ) -> dict[str, Any]:
        """
        Validates the arguments required for IPS report types from input arguments of reports command.
        Will raise ValueError if inappropriate input given.

        :param args: Input arguments
        :param params: Params to be passed in API call
        :return: Params to be passed in API call
        """
        arg_keys = args.keys()

        if 'limit' in arg_keys:
            limit = args.get('limit', '')
            try:
                params['limit'] = int(limit)
            except ValueError:
                raise ValueError(MESSAGES['INVALID_INT_VALUE'].format('limit'))
        if 'interface' in arg_keys:
            params['interface'] = (
                args.get('interface', '')
                if args.get('interface', '') != 'All'
                else 'all'
            )
        return params


    def validate_time_parameters(
        args: dict[str, Any], params: dict[str, Any]
    ) -> dict[str, Any]:
        """
        Validates the time arguments from input arguments of reports command.

        :param args: Input arguments
        :param params: Params to be passed in API call
        :return: Params to be passed in API call
        """
        arg_keys = args.keys()

        if 'time_frame' in arg_keys:
            params['time_frame'] = args.get('time_frame', '')

        if 'start_time' in arg_keys:
            start_time = args.get('start_time', '')
            date_time = dateparser.parse(start_time)
            if date_time:
                params['start_time'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                params['start_time'] = start_time

        if 'end_time' in arg_keys:
            end_time = args.get('end_time', '')
            date_time = dateparser.parse(end_time)
            if date_time:
                params['end_time'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                params['end_time'] = end_time

        return params


    def get_reports_params(args: dict[str, Any]) -> dict[str, Any]:
        """
        Validates the input arguments of command and returns parameter dictionary. This function validates the
        report_type, output format(type), time arguments.
        Will raise ValueError if inappropriate input given.

        :param args: Input arguments of command
        :return: Params dict or error message
        """
        params: dict[str, Any] = {}
        arg_keys = args.keys()

        report_type = args.get('report_type', '')
        if report_type not in REPORT_TYPE_LABEL_NAME:
            raise ValueError(MESSAGES['INVALID_REPORT_TYPE'])
        params['report_type'] = REPORT_TYPE_LABEL_NAME[report_type]

        if 'type' in arg_keys:
            output_type = args.get('type', '')
            if output_type not in REPORT_TYPE_ALLOWED_FORMAT[report_type]:
                raise ValueError(
                    MESSAGES['INVALID_REPORT_OUTPUT_TYPE'].format(
                        ', '.join(REPORT_TYPE_ALLOWED_FORMAT[report_type])
                    )
                )
            params['type'] = output_type

        params = validate_time_parameters(args, params)

        params = validate_ips_report_type_arguments(args, params)

        if report_type == ALERT_DETAILS_REPORT:
            params = validate_alert_report_type_arguments(args, params)

        return params


    def add_time_suffix_into_arguments(args: dict[str, Any]):
        """
        Add time suffix into arguments.

        :param args: arguments of alerts.
        :return: Add suffix to date format if full format is not given.
        """
        arg_keys = args.keys()
        if 'start_time' in arg_keys:
            start_time = args.get('start_time', '')
            date_time = dateparser.parse(start_time)
            if date_time:
                args['start_time'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('start_time')
                )

        if 'end_time' in arg_keys:
            end_time = args.get('end_time', '')
            date_time = dateparser.parse(end_time)
            if date_time:
                args['end_time'] = str(date_time.strftime(API_SUPPORT_DATE_FORMAT))
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('end_time')
                )


    def get_events_params(args: dict[str, Any]) -> dict[str, Any]:
        """
        Validates the input arguments of command and returns parameter dictionary
        or raises ValueError in case of validation failed.

        :param args: Input arguments of command
        :return: Params dict or error message
        """
        params: dict[str, Any] = {'event_type': 'Ips Event'}
        arg_keys = args.keys()

        if 'duration' in arg_keys:
            params['duration'] = args.get('duration', '')

        if 'start_time' in arg_keys:
            start_time = args.get('start_time', '')
            date_time = dateparser.parse(start_time)
            if date_time:
                params['start_time'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('start_time')
                )

        if 'end_time' in arg_keys:
            end_time = args.get('end_time', '')
            date_time = dateparser.parse(end_time)
            if date_time:
                params['end_time'] = str(
                    date_time.strftime(API_SUPPORT_DATE_FORMAT)
                )
            else:
                raise ValueError(
                    MESSAGES['INVALID_TIME_VALIDATION'].format('end_time')
                )

        if 'mvx_correlated_only' in arg_keys:
            mvx_correlated_only = args.get('mvx_correlated_only', '').lower()
            try:
                mvx_correlated_only = argToBoolean(mvx_correlated_only)
                params['mvx_correlated_only'] = mvx_correlated_only
            except ValueError:
                raise ValueError(
                    MESSAGES['INVALID_BOOLEAN_VALUE_ERROR'].format(
                        'mvx_correlated_only'
                    )
                )

        return params


    def prepare_hr_for_artifact_metadata(
        artifacts_info: list[dict[str, Any]]
    ) -> str:
        """
        Prepare Human readable for get artifact metadata.

        :param artifacts_info: List contain artifact metadata information.
        :return: Markdown format in string.
        """
        artifacts_info_hr_list = []

        for artifact in artifacts_info:
            artifacts_dict = {
                'Artifact Type': artifact.get('artifactType', ''),
                'Artifact Name': artifact.get('artifactName', ''),
                'Artifact Size (Bytes)': artifact.get('artifactSize', ''),
            }
            artifacts_info_hr_list.append(artifacts_dict)

        return tableToMarkdown(
            'Artifacts Metadata',
            artifacts_info_hr_list,
            headers=['Artifact Type', 'Artifact Name', 'Artifact Size (Bytes)'],
            removeNull=True,
        )


    def remove_empty_entities(d):
        """
        Recursively remove empty lists, empty dicts, or None elements from a dictionary.
        Note. This is extended feature of CommonServerPython.py remove_empty_elements() method as it was not removing
        empty character x == ''.

        :param d: Input dictionary.
        :return: Dictionary with all empty lists, and empty dictionaries removed.
        """

        def empty(x):
            return x is None or x == {} or x == [] or x == ''

        if not isinstance(d, dict | list):
            return d
        elif isinstance(d, list):
            return [
                value
                for value in (remove_empty_entities(value) for value in d)
                if not empty(value)
            ]
        else:
            return {
                key: value
                for key, value in (
                    (key, remove_empty_entities(value)) for key, value in d.items()
                )
                if not empty(value)
            }


    def prepare_hr_for_alert_response(resp: dict) -> str:
        """
        Prepare human readable for alert response.

        :param resp: Dictionary of API response
        :return: Markdown format for human readable.
        """
        alert_hr_list = []

        for alert in resp.get('alert', []):
            artifacts_dict = {
                'ID': alert.get('id', ''),
                'Distinguisher(UUID)': alert.get('uuid', ''),
                'Malware Name': alert.get('explanation', {})
                .get('malwareDetected', {})
                .get('malware', [{}])[0]
                .get('name', ''),
                'Alert Type': alert.get('name', ''),
                VICTIM_IP: alert.get('src', {}).get('ip', ''),
                TIME_UTC: alert.get('occurred', ''),
                'Severity': alert.get('severity', ''),
                'Malicious': alert.get('malicious', ''),
                'SC Version': alert.get('scVersion', ''),
                'Victim Port': alert.get('src', {}).get('port', ''),
                'Victim MAC Address': alert.get('src', {}).get('mac', ''),
                'Target IP': alert.get('dst', {}).get('ip', ''),
                'Target Port': alert.get('dst', {}).get('port', ''),
                'Target MAC Address': alert.get('dst', {}).get('mac', ''),
            }
            alert_hr_list.append(artifacts_dict)
        headers = [
            'ID',
            'Distinguisher(UUID)',
            'Malware Name',
            'Alert Type',
            VICTIM_IP,
            TIME_UTC,
            'Severity',
            'Malicious',
            'SC Version',
            'Victim Port',
            'Victim MAC Address',
            'Target IP',
            'Target Port',
            'Target MAC Address',
        ]
        return tableToMarkdown(
            'Alert(s) Information', alert_hr_list, headers=headers, removeNull=True
        )


    def prepare_hr_for_events(events_info) -> str:
        """
        Prepare the Human readable info for events command.

        :param events_info: The events data.
        :return: Human readable.
        """
        hr_list = []
        for record in events_info:
            hr_record = {
                'Event ID': record.get('eventId', None),
                TIME_UTC: record.get('occurred', ''),
                VICTIM_IP: record.get('srcIp', ''),
                'Attacker IP': record.get('dstIp', ''),
                'CVE ID': record.get('cveId', ''),
                'Severity': record.get('severity', None),
                'Rule': record.get('ruleName', ''),
                'Protocol': record.get('protocol', None),
            }
            hr_list.append(hr_record)

        return tableToMarkdown(
            'IPS Events',
            hr_list,
            [
                'Event ID',
                TIME_UTC,
                VICTIM_IP,
                'Attacker IP',
                'CVE ID',
                'Severity',
                'Rule',
                'Protocol',
            ],
            removeNull=True,
        )


    def replace_alert_url_key_domain_to_instance_url(
        alerts_resp: list, instance_url: str
    ):
        """
        Change domain of 'alertUrl' to the instance URL.

        :param alerts_resp: List contain dictionary of alerts.
        :param instance_url: URL to connect to the FireEye NX.
        """

        def replace_url(alert_url: str, prefix_url: str) -> str:
            """
            Replace alert url domain to prefix url.

            :param alert_url: Actual url that getting from response.
            :param prefix_url: URL to connect to the FireEye NX.
            :return:
            """
            if alert_url.startswith('http://'):  # NOSONAR
                alert_url = alert_url.replace('http://', '')  # NOSONAR

            elif alert_url.startswith('https://'):
                alert_url = alert_url.replace('https://', '')

            if alert_url.startswith('www.'):
                alert_url = alert_url.replace('www.', '')

            elif alert_url.startswith('WWW.'):
                alert_url = alert_url.replace('WWW.', '')

            if not prefix_url.endswith('/'):
                prefix_url = f"{prefix_url + '/'}"

            alert_url_split = alert_url.split('/', 1)

            suffix_url = ''.join(
                alert_url_split[count]
                for count in range(len(alert_url_split))
                if count != 0
            )

            return f'{prefix_url + suffix_url}'

        for alert_index in range(len(alerts_resp)):
            if alerts_resp[alert_index].get('alertUrl'):
                alerts_resp[alert_index]['alertUrl'] = replace_url(
                    alerts_resp[alert_index]['alertUrl'], instance_url
                )


    """ REQUESTS FUNCTIONS """


    def test_function(**kwargs) -> str:
        """
        Performs test connectivity by valid http response.

        :param kwargs: Contains all required parameters.
        :return: raise ValueError if any error occurred during connection
        """
        if kwargs['is_fetch']:
            fetch_limit = get_fetch_limit(kwargs['fetch_limit'])

            # getting numeric value from string representation
            start_time, _ = parse_date_range(
                kwargs['first_fetch_time'], date_format=DATE_FORMAT, utc=True
            )

            # validate start_time should be less then 48 hour as per API limitation
            validate_date_range(kwargs['first_fetch_time'])
            validate_fetch_type(kwargs['fetch_type'])

            first_fetch = (
                date_to_timestamp(start_time, date_format=DATE_FORMAT) / 1000
            )
            fetch_incidents(
                client=kwargs['client'],
                last_run=demisto.getLastRun(),
                first_fetch=first_fetch,
                fetch_limit=fetch_limit,
                malware_type=kwargs['malware_type'],
                is_test=True,
                fetch_type=kwargs['fetch_type'],
                mvx_correlated=kwargs['mvx_correlated'],
                replace_alert_url=kwargs['replace_alert_url'],
                instance_url=kwargs['instance_url'],
                fetch_artifacts=kwargs['fetch_artifacts'],
            )
        else:
            headers = {'Accept': CONTENT_TYPE_JSON}
            kwargs['client'].http_request(
                method='POST', url_suffix=URL_SUFFIX['GET_TOKEN'], headers=headers
            )

        return 'ok'


    @logger
    def get_artifacts_metadata_by_alert_command(
        client: Client, args: dict[str, Any]
    ) -> str | CommandResults:
        """
        Gets malware artifacts metadata for the specified UUID.

        :param client: The Client object used for request
        :param args: The command arguments
        :return: CommandResults
        """
        uuid = args.get('uuid', '')
        uuid = uuid.lower()

        # Preparing header
        headers = {
            'Accept': CONTENT_TYPE_JSON,
            'X-FeApi-Token': client.get_api_token(),
        }

        # Call get artifacts metadata api
        resp = client.http_request(
            'GET',
            url_suffix=URL_SUFFIX['GET_ARTIFACTS_METADATA'].format(uuid),
            headers=headers,
        )

        artifacts_info = resp.get('artifactsInfoList', [])
        if len(artifacts_info) == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('artifacts metadata')

        # Create entry context
        artifacts_metadata_custom_ec = createContext(
            artifacts_info, removeNull=True
        )

        # Prepare human readable
        hr = prepare_hr_for_artifact_metadata(artifacts_info)

        custom_ec_for_artifact_metadata = {
            'ArtifactsMetadata': artifacts_metadata_custom_ec,
            'Uuid': uuid,
        }

        # Remove dash, underscore from key and make it pascal case.
        custom_ec = remove_dash_and_underscore_from_key(
            custom_ec_for_artifact_metadata
        )

        return CommandResults(
            outputs_prefix='FireEyeNX.Alert',
            outputs_key_field='Uuid',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        )


    @logger
    def get_artifacts_by_alert_command(
        client: Client, args: dict[str, Any]
    ) -> str | dict[str, Any]:
        """
        Downloads malware artifacts data for the specified UUID as a zip file.

        :param client: The Client object used for request
        :param args: The command arguments
        :return: Dictionary of file info or empty result message
        """
        uuid = args.get('uuid', '')
        uuid = uuid.lower()

        # Preparing header
        headers = {
            'Content-Type': CONTENT_TYPE_ZIP,
            'X-FeApi-Token': client.get_api_token(),
        }

        # Call get artifacts data api
        artifacts_resp = client.http_request(
            'GET',
            url_suffix=URL_SUFFIX['GET_ARTIFACTS'].format(uuid),
            headers=headers,
        )

        # Create file from Content
        if int(artifacts_resp.headers.get('Content-Length', '0')) > 0:
            file_name = f'{uuid}.zip'
            file_entry = fileResult(
                filename=file_name, data=artifacts_resp.content
            )
            return file_entry
        else:
            return MESSAGES['NO_RECORDS_FOUND'].format('artifacts data')


    @logger
    def get_reports_command(
        client: Client, args: dict[str, Any]
    ) -> str | dict[str, Any]:
        """
        Returns reports on selected alerts by specifying a time_frame value or a start_time and end_time
        of the search range.
        Will raise ValueError if inappropriate input given.

        :param client: client object which is used to get response from api
        :param args:The command arguments
        :return: Dictionary of file info or empty result message
        """
        # Validate arguments
        params = get_reports_params(args)

        # Preparing header
        headers = {
            'X-FeApi-Token': client.get_api_token(),
            'Accept': CONTENT_TYPE_JSON,
        }

        # API call
        resp: Response = client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_REPORTS'],
            params=params,
            headers=headers,
        )

        # Create file from Content
        if int(resp.headers.get('Content-Length', '')) > 0:
            file_entry = fileResult(
                filename=generate_report_file_name(args),
                data=resp.content,
                file_type=EntryType.ENTRY_INFO_FILE,
            )
            return file_entry
        else:
            return MESSAGES['NO_RECORDS_FOUND'].format('report contents')


    @logger
    def get_alerts_command(
        client: Client,
        args: dict[str, Any],
        replace_alert_url: bool,
        instance_url: str,
    ) -> str | CommandResults:
        """
        Retrieve list of alerts based on various argument(s).

        :param client: Client object
        :param args: The command arguments provided by user.
        :param replace_alert_url: Replace the domain of the alert URL key to the Instance URL.
        :param instance_url: URL to connect to the FireEye NX.
        :return: Standard command result or no records found message
        """
        add_time_suffix_into_arguments(args)

        # Preparing header
        headers = {
            'X-FeApi-Token': client.get_api_token(),
            'Accept': CONTENT_TYPE_JSON,
        }

        # http call
        resp = client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_ALERTS'],
            params=args,
            headers=headers,
        )

        total_records = resp.get('alertsCount', 0)
        if total_records <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('alert(s)')

        alerts_resp = resp.get('alert', [])

        # Replace the domain of the alertUrl key to Instance URL if it is true.
        if replace_alert_url:
            replace_alert_url_key_domain_to_instance_url(alerts_resp, instance_url)

        # Creating human-readable
        hr = prepare_hr_for_alert_response(resp)

        # Creating entry context
        custom_ec_for_alerts = remove_empty_entities(alerts_resp)

        # Remove dash, underscore from key and make it pascal case.
        custom_ec = remove_dash_and_underscore_from_key(custom_ec_for_alerts)

        return CommandResults(
            outputs_prefix='FireEyeNX.Alert',
            outputs_key_field='Uuid',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        )


    @logger
    def fetch_incidents(
        **kwargs,
    ) -> tuple[dict[str, Any] | None, list[dict[str, Any]] | None]:
        """
        This function retrieves new incidents every interval.

        :param kwargs : Dictionary contain all required arguments.
        :return: Tuple containing two elements. incidents list and timestamp.
        """
        # Retrieving last run time if not none, otherwise first_fetch will be considered.
        last_run = kwargs['last_run']
        start_time = kwargs['first_fetch']
        next_run = last_run

        incidents = []
        fetch_count = 0
        if 'IPS Events' in (kwargs['fetch_type'] or []):
            if (events_start_time := last_run.get('events', {}).get('start_time')) and \
                    (parsed_start_time := dateparser.parse(events_start_time)):
                start_time = parsed_start_time.timestamp()
            demisto.debug(f"FireeyeNX IPS Events Start Time: {start_time}")
            incidents, fetch_count, next_run_events = get_incidents_for_event(
                kwargs['client'],
                start_time,
                kwargs['fetch_limit'],
                kwargs['mvx_correlated'],
                last_run,
            )
            next_run['events'] = next_run_events

        # reset start time before next fetch type
        start_time = kwargs['first_fetch']
        if 'Alerts' in (kwargs['fetch_type'] or []) and (
            fetch_count < kwargs['fetch_limit']
        ):
            if (alerts_start_time := last_run.get('alerts', {}).get('start_time')) and \
                    (parsed_start_time := dateparser.parse(alerts_start_time)):
                start_time = parsed_start_time.timestamp()
            demisto.debug(f"FireeyeNX Alerts Start Time: {start_time}")
            alert_incidents, next_run_alerts = get_incidents_for_alert(
                client=kwargs['client'],
                malware_type=kwargs['malware_type'],
                start_time=start_time,
                fetch_limit=kwargs['fetch_limit'],
                replace_alert_url=kwargs['replace_alert_url'],
                instance_url=kwargs['instance_url'],
                is_test=kwargs['is_test'],
                fetch_artifacts=kwargs['fetch_artifacts'],
                fetch_count=fetch_count,
                last_run=last_run,
            )
            incidents.extend(
                alert_incidents
            )
            next_run['alerts'] = next_run_alerts

        if kwargs['is_test']:
            return None, None
        return next_run, incidents


    @logger
    def get_events_command(
        client: Client, args: dict[str, Any]
    ) -> str | CommandResults:
        """
        Retrieve list of events based on various argument(s).
        Will raise an exception if validation fails.

        :param client: Client object
        :param args: The command arguments provided by user.
        :return: Standard command result or no records found message
        """

        # Validate arguments
        params = get_events_params(args)

        # Preparing header
        headers = {
            'X-FeApi-Token': client.get_api_token(),
            'Accept': CONTENT_TYPE_JSON,
        }

        # http call
        resp = client.http_request(
            method='GET',
            url_suffix=URL_SUFFIX['GET_EVENTS'],
            params=params,
            headers=headers,
        )

        total_records = resp.get('events', [])
        if not total_records:
            return MESSAGES['NO_RECORDS_FOUND'].format('event(s)')

        # Creating entry context
        custom_ec_for_event = createContext(total_records, removeNull=True)
        custom_ec = remove_dash_and_underscore_from_key(custom_ec_for_event)

        # Creating human-readable
        hr = prepare_hr_for_events(total_records)

        return CommandResults(
            outputs_prefix='FireEyeNX.Event',
            outputs_key_field='EventId',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        )


    def main() -> None:
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # Commands dict
        commands = {
            'fireeye-nx-get-artifacts-metadata-by-alert': get_artifacts_metadata_by_alert_command,
            'fireeye-nx-get-reports': get_reports_command,
            'fireeye-nx-get-artifacts-by-alert': get_artifacts_by_alert_command,
            'fireeye-nx-get-events': get_events_command,
        }
        commands_with_params = {'fireeye-nx-get-alerts': get_alerts_command}

        command = demisto.command()
        demisto.info(f'Command being called is {command}')

        try:
            url = demisto.params().get('url')
            username = demisto.params().get('credentials', {}).get('identifier')
            password = demisto.params().get('credentials', {}).get('password')
            if password:
                password = password.encode('utf-8')

            verify_certificate = not demisto.params().get('insecure', False)
            proxy = demisto.params().get('proxy', False)
            request_timeout = demisto.params().get('request_timeout')
            request_timeout = get_request_timeout(request_timeout)

            base_url = f'{url}/wsapis/{API_VERSION}'

            # prepare client class object
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                proxy=proxy,
                auth=(username, password),
                request_timeout=request_timeout,
            )

            # Trim the arguments
            args = strip_blank(demisto.args())

            # This is the call made when pressing the integration Test button.
            if demisto.command() == 'test-module':
                is_fetch = demisto.params().get('isFetch')
                first_fetch_time = demisto.params().get('first_fetch')

                # Set first fetch time as default if user leave empty
                first_fetch_time = (
                    first_fetch_time if first_fetch_time else DEFAULT_FIRST_FETCH
                )

                malware_type = demisto.params().get('malware_type')

                fetch_limit = demisto.params().get('max_fetch')

                fetch_type = demisto.params().get('fetch_type')

                mvx_correlated = demisto.params().get(
                    'fetch_mvx_correlated_events', False
                )

                replace_alert_url = demisto.params().get(
                    'replace_alert_url', False
                )

                fetch_artifacts = demisto.params().get('fetch_artifacts', False)

                result = test_function(
                    client=client,
                    first_fetch_time=first_fetch_time,
                    fetch_limit=fetch_limit,
                    malware_type=malware_type,
                    is_fetch=is_fetch,
                    fetch_type=fetch_type,
                    mvx_correlated=mvx_correlated,
                    replace_alert_url=replace_alert_url,
                    instance_url=url,
                    fetch_artifacts=fetch_artifacts,
                )
                demisto.results(result)

            elif demisto.command() == 'fetch-incidents':
                malware_type = demisto.params().get('malware_type', '')

                first_fetch_time = demisto.params().get('first_fetch')

                # Set first fetch time as default if user leave empty
                first_fetch_time = (
                    first_fetch_time if first_fetch_time else DEFAULT_FIRST_FETCH
                )

                fetch_limit = demisto.params().get('max_fetch')

                fetch_limit = get_fetch_limit(fetch_limit)
                demisto.debug(f'Fetch Limit {fetch_limit}')

                fetch_type = demisto.params().get('fetch_type')

                mvx_correlated = demisto.params().get(
                    'fetch_mvx_correlated_events', False
                )

                # Getting numeric value from string representation
                start_time, _ = parse_date_range(
                    first_fetch_time, date_format=DATE_FORMAT, utc=True
                )

                # Validate start_time should be less then 48 hour as per API limitation
                validate_date_range(first_fetch_time)

                validate_fetch_type(fetch_type)
                # Flag indicate to replace the 'alertUrl' domain to Integration URL or not.
                replace_alert_url = demisto.params().get(
                    'replace_alert_url', False
                )

                fetch_artifacts = demisto.params().get('fetch_artifacts', False)

                next_run, incidents = fetch_incidents(
                    client=client,
                    malware_type=malware_type,
                    last_run=demisto.getLastRun(),
                    fetch_limit=fetch_limit,
                    first_fetch=date_to_timestamp(
                        start_time, date_format=DATE_FORMAT
                    )
                    / 1000,
                    fetch_type=fetch_type,
                    mvx_correlated=mvx_correlated,
                    replace_alert_url=replace_alert_url,
                    instance_url=url,
                    fetch_artifacts=fetch_artifacts,
                    is_test=False,
                )
                # saves next_run for the time fetch-incidents is invoked.
                demisto.debug(f"FireEyeNX setting next run to: {next_run}")
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif command in commands:
                return_results(commands[command](client, args))

            elif command in commands_with_params:
                # Flag indicate to replace alertUrl domain to Integration URL or not.
                replace_alert_url = demisto.params().get(
                    'replace_alert_url', False
                )

                return_results(
                    commands_with_params[command](
                        client, args, replace_alert_url, url
                    )
                )

        # Log exceptions
        except Exception as e:
            return_error(f'Error: {str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('FireEyeNX', 'end', __line__())
  subtype: python3
  type: python
system: true
