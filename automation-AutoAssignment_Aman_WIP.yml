commonfields:
  id: c85ad3c3-5e4d-4c6e-888b-4fd1fe2a5b07
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/python3:3.9.7.24076
enabled: true
engineinfo: {}
mainengineinfo: {}
name: AutoAssignment_Aman_WIP
pswd: ""
runas: DBotWeakRole
runonce: false
script: |+
  from datetime import datetime
  import json
  import pprint
  import re

  usernames=[0]
  seniorL1=["Medha Mannur","Ravi Gupta","Pallavi Barad","Kishor Bansi","Aamir Pasha","Kaustubh Bondane","Aman Sinha","Prathamesh Khande","Kamali Renganathan","Mustafa Rampurawala","Supriya Patil","PRAJAKTA MISAL","Nita Sahane","Mayuri Nikam","Hitesh Poojari"]
  incidents=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

  profile={}



  AvailableAnalyst=demisto.executeCommand("GetUsersOnCall", { "include_OOO_users": "true" });
  table: List[Dict] =(AvailableAnalyst[0]['Contents'])




  #wworking ====================================================================================================


  #Create a profile of available candidate in shift with below details name,role(senior,l1,oplead,assignmentop,half day),assigned will contain the values of all the incident assigned to user
  #and will dump it somewhere at the end of shift for logging and also when later if the user is not present in shift will reassign the given incident that are assigned
  #to him before the op lead declares leaves. using the jobs that will run at the shift start time to get users and update the list outside.


  def counter_func(name, role, assigned, condition,scan):
          temp={}
          temp["name"] = name
          temp["role"] = role
          temp["assigned"] = assigned
          temp["seniorl1"] = condition
          temp["scan"]=scan
          return temp



  def dict_func(name, role, assigned, condition):
          temp={}
          temp["name"] = name
          temp["role"] = role
          temp["assigned"] = assigned
          temp["condition"] = condition
          return temp

  my_objects = [counter_func("Counter","indexing",0,0,0)]


  data=table.split('\n')
  for i in data:
      res=re.sub(r'\|.*',"",i)
      names=re.sub("[']","",res).strip()
      if(names in ['On-Call Team members','Username','-']):
          continue
      else:
          if names in seniorL1:
              role="Senior"
          else:
              role="L1"
          #my_objects.append(dict_func(names,role,"","Perfect"))
          my_objects.append(dict_func(names,role,[],"Perfect"))


  my_objects.pop()
  print(my_objects)

  # in place of print statement it will set the my_objects list to a outside list and this code will run at every start of shift

  #=============================================================done with profile===================================================


  # fetch the list stored outside and set it back.
  #add a condition if the tactics and techniq is falcon intel assign to people with role senior
  #add a condition to check the condition of user if user is perfect then no problem if anything else assign low incident by fetching the severity.
  #add in shiftschedule automation operator lead,mail assignement operator name so it can remove those people name from the list created or assign role here so no inc assigned

  ###Issues: database lock needs to be implemented if creating a issue.

  def autoassig(my_objects,count):
      for inc in incidents:

          def assigning(count,my_objects):
              # demisto.executeCommand("AssignAnalystToIncident", {"username": my_objects[count].get('name')})
              #add a condition if the tactics and techniq is falcon intel assign to people with role senior
              oldinc=my_objects[int(count)].get('assigned')
              #temp=f'{oldinc} {inc},'
              print(type(oldinc))
              oldinc.append(inc)
              my_objects[int(count)]['assigned']=oldinc
              count+=1
              return count



          if count+1 >len(my_objects):
              #print("count out of bound",count)
              count=assigning(1,my_objects)
              #my_objects[0]['assigned']=count

          else:
              if count==0:
                  count=assigning(1,my_objects)
                  #my_objects[0]['assigned']=count
              else:
                  count=assigning(count,my_objects)
                  #my_objects[0]['assigned']=count






  #count=my_objects[0].get('assigned')
  lis=my_objects[0].get('assigned')
  count=lis[0]
  autoassig(my_objects,count)
  print(my_objects)

scripttarget: 0
subtype: python3
tags: []
type: python
