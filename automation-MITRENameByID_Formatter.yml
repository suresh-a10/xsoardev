args:
- description: The MITRE ATT&CK object ID.
  name: input
  required: true
comment: Get a MITRE ATT&CK object name by its ID. The script is using TIMs IOCs to
  find the correct name. (MITRE ATT&CK IOCs must exist in the Threat Intel data).
commonfields:
  id: MITRENameByID_Formatter
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.10.0
    itemVersion: 1.18.2
    packID: CommonScripts
    packName: Common Scripts
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
dockerimage: demisto/python3:3.11.10.113941
enabled: true
engineinfo: {}
mainengineinfo: {}
name: MITRENameByID_Formatter
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('MITRENameByID_Formatter', 'start', __line__())
  demisto.debug('pack name = Common Scripts, pack version = 1.18.2')




  def get_mitre_technique_name(mitre_id: str) -> dict[str, str]:
      """
      Searches XSOAR TIM for an 'Attack Pattern' indicator matching the given MITRE ID and returns the indicator value.

      Args:
          mitre_id (str): The MITRE ATT&CK ID to search for (e.g., T1562).
          indicator_type (str): The XSOAR indicator type (e.g. Attack Pattern)

      Returns:
          str: The indicator value if found, else an empty string.
      """
      try:
          technique_names = {}
          query = f'mitreid:{mitre_id}'
          demisto.debug(f'Querying for {query} in TIM')

          success, response = execute_command(command="SearchIndicator",
                                              args={"query": query, "add_fields_to_context": "mitreid"},
                                              fail_on_error=False)

          if not success:
              demisto.debug(f"Failed to execute findIndicators command: {get_error(response)}")
              return {}

          if response and isinstance(response, list):
              demisto.debug(f"Search indicators response: {response}")
              for indicator in response:
                  if isinstance(indicator, str):
                      indicator = json.loads(indicator)

                  technique_names[indicator["mitreid"]] = indicator["value"]

          else:
              success, response = execute_command(command="IsIntegrationAvailable",
                                                  args={"brandname": "MITRE ATT&CK v2"},
                                                  fail_on_error=False)

              if isinstance(response, str) and response.lower() == "no":
                  demisto.debug("Please set an instance of MITRE Att&ck Feed.")

          return technique_names

      except Exception as e:
          demisto.debug(f"Error searching for Attack Pattern indicator: {str(e)}")
          return {}


  def is_valid_attack_pattern(items) -> list:
      mitre_ids = argToList(items)
      results = []
      techniques = get_mitre_technique_name(mitre_id=" or ".join(mitre_ids))
      for mitre_id in mitre_ids:
          if mitre_id not in techniques:
              demisto.debug(f"Invalid MITRE ID: {mitre_id}")
              results.append("")
          else:
              results.append(techniques[mitre_id])

      return results


  def main():
      the_input = demisto.args().get('input')

      entries_list = is_valid_attack_pattern(the_input)

      if entries_list:
          return_results(entries_list)
      else:
          return_results([])


  if __name__ in ("__builtin__", "builtins"):
      main()

  register_module_line('MITRENameByID_Formatter', 'end', __line__())
scripttarget: 0
subtype: python3
system: true
tags:
- indicator-format
type: python
