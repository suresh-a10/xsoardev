args:
- name: vendor
- isArray: true
  name: objects
- name: feed_tags
- auto: PREDEFINED
  defaultValue: "False"
  name: create_indicator_in_xsoar
  predefined:
  - "True"
  - "False"
  required: true
commonfields:
  id: f112b32c-8ac8-4433-8346-392c403fbf81
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/python3:3.10.9.40422
enabled: true
engineinfo: {}
mainengineinfo: {}
name: GenericSTIX21Parser
outputs:
- contextPath: STIX21Parsed
pswd: '{TOMMED}zhbg0i8+1DPGooT/1l/E4rXuTgGGyUpaI1WTt4cm7gLUM61xpgHlAHjEf7SxcuPB4ZSJsCHyjP6JdJ10jdoG2f29bqs8whRwrdGUmmdxq7dexn2Vclfe+QbPprBVul/cZ7T+0nIG7ocgK5WJmFRxE6OddDPw/wvitEyeeorI0lTbJuHd+z8yiJwLWwaNvkeNB+61GNQhNmKVawO3swo5tMNHtCJA/YoVEbY30a8iCr6jmgjB5J8UqtXuTBybIMwS'
runas: DBotWeakRole
runonce: false
script: |
  STIX2_INDICATOR_TYPES = {
      'ipv4-addr': FeedIndicatorType.IP,
      'ipv6-addr': FeedIndicatorType.IPv6,
      'domain': FeedIndicatorType.Domain,
      'domain-name': FeedIndicatorType.Domain,
      'url': FeedIndicatorType.URL,
      'md5': FeedIndicatorType.File,
      'sha-1': FeedIndicatorType.File,
      'sha-256': FeedIndicatorType.File,
      'file:hashes': FeedIndicatorType.File,
  }

  THREAT_INTEL_TYPE_TO_DEMISTO_TYPES = {
      'campaign': ThreatIntel.ObjectsNames.CAMPAIGN,
      'attack-pattern': ThreatIntel.ObjectsNames.ATTACK_PATTERN,
      'report': ThreatIntel.ObjectsNames.REPORT,
      'malware': ThreatIntel.ObjectsNames.MALWARE,
      'course-of-action': ThreatIntel.ObjectsNames.COURSE_OF_ACTION,
      'intrusion-set': ThreatIntel.ObjectsNames.INTRUSION_SET
  }

  MITRE_CHAIN_PHASES_TO_DEMISTO_FIELDS = {
      'build-capabilities': ThreatIntel.KillChainPhases.BUILD_CAPABILITIES,
      'privilege-escalation': ThreatIntel.KillChainPhases.PRIVILEGE_ESCALATION,
      'adversary-opsec': ThreatIntel.KillChainPhases.ADVERSARY_OPSEC,
      'credential-access': ThreatIntel.KillChainPhases.CREDENTIAL_ACCESS,
      'exfiltration': ThreatIntel.KillChainPhases.EXFILTRATION,
      'lateral-movement': ThreatIntel.KillChainPhases.LATERAL_MOVEMENT,
      'defense-evasion': ThreatIntel.KillChainPhases.DEFENSE_EVASION,
      'persistence': ThreatIntel.KillChainPhases.PERSISTENCE,
      'collection': ThreatIntel.KillChainPhases.COLLECTION,
      'impact': ThreatIntel.KillChainPhases.IMPACT,
      'initial-access': ThreatIntel.KillChainPhases.INITIAL_ACCESS,
      'discovery': ThreatIntel.KillChainPhases.DISCOVERY,
      'execution': ThreatIntel.KillChainPhases.EXECUTION,
      'installation': ThreatIntel.KillChainPhases.INSTALLATION,
      'delivery': ThreatIntel.KillChainPhases.DELIVERY,
      'weaponization': ThreatIntel.KillChainPhases.WEAPONIZATION,
      'act-on-objectives': ThreatIntel.KillChainPhases.ACT_ON_OBJECTIVES,
      'command-and-control': ThreatIntel.KillChainPhases.COMMAND_AND_CONTROL
  }

  RELATIONSHIP_TYPES = EntityRelationship.Relationships.RELATIONSHIPS_NAMES.keys()


  class Client(BaseClient):

      def __init__(self):
          self.objects_data = {}

      def processSTIXObjects(self, objects):
          '''
          Input should be the individual STIX objects

          '''
          data = {}

          if not objects:
              return_error("Please provide a objects input")

          if type(objects) == dict:
              objects = objects[objects]
          for obj in objects:
              if not data.get(obj['type']):
                  data[obj['type']] = []
              data[obj['type']].append(obj)

          self.objects_data = data
          #print(data)


  def get_ioc_value_from_ioc_name(ioc_obj):
      """
      Extract SHA-256 from string:
      ([file:name = 'blabla' OR file:name = 'blabla'] AND [file:hashes.'SHA-256' = '1111'])" -> 1111
      """
      ioc_value = ioc_obj.get('name')
      try:
          ioc_value = re.search("(?<='SHA-256' = ').*?(?=')", ioc_value).group(0)  # type:ignore # guardrails-disable-line
      except AttributeError:
          ioc_value = None
      return ioc_value

  def parse_indicators(indicator_objects: list, feed_tags: list = [], tlp_color: Optional[str] = None, vendor="STIX 2.1") -> list:
      """Parse the IOC objects retrieved from the feed.
      Args:
        indicator_objects: a list of objects containing the indicators.
        feed_tags: feed tags.
        tlp_color: Traffic Light Protocol color.
      Returns:
          A list of processed indicators.
      """
      indicators = []
      if indicator_objects:
          for indicator_object in indicator_objects:
              pattern = indicator_object.get('pattern')
              for key in STIX2_INDICATOR_TYPES.keys():
                  if pattern.startswith(f'[{key}'):  # retrieve only Demisto indicator types
                      tags = feed_tags
                      if indicator_object.get('labels'):
                          if type(indicator_object.get('labels')) == str:
                              tags.append(indicator_object.get('labels'))
                          else:
                              tags.extend(indicator_object.get('labels'))

                      ind_name = indicator_object.get('name')
                      val = indicator_object.get('name')
                      if ":" in indicator_object.get('name'):
                          ind_name = indicator_object.get('name').split(":")[0]
                          val = indicator_object.get('name').split(":")[1]
                      indicator_obj = {
                          "value": val,
                          "type": STIX2_INDICATOR_TYPES[key],
                          "rawJSON": indicator_object,
                          "fields": {
                              "firstseenbysource": indicator_object.get('created'),
                              "indicatoridentification": indicator_object.get('id'),
                              "tags": tags,
                              "modified": indicator_object.get('modified'),
                              "reportedby": vendor,
                          }
                      }

                      if "file:hashes.'SHA-256' = '" in indicator_obj['value']:
                          if get_ioc_value_from_ioc_name(indicator_object):
                              indicator_obj['value'] = get_ioc_value_from_ioc_name(indicator_object)

                      if tlp_color:
                          indicator_obj['fields']['trafficlightprotocol'] = tlp_color

                      indicators.append(indicator_obj)

      return indicators


  def get_campaign_from_sub_reports(report_object, id_to_object, vendor):
      report_relationships = []
      object_refs = report_object.get('object_refs', [])
      for obj in object_refs:
          if obj.startswith('report--'):
              sub_report_obj = id_to_object.get(obj, {})
              for sub_report_obj_ref in sub_report_obj.get('object_refs', []):
                  if sub_report_obj_ref.startswith('campaign--'):
                      related_campaign = id_to_object.get(sub_report_obj_ref)

                      if related_campaign:
                          entity_relation = EntityRelationship(name='related-to',
                                                               entity_a=f"{vendor} {report_object.get('name')}",
                                                               entity_a_type='Report',
                                                               entity_b=related_campaign.get('name'),
                                                               entity_b_type='Campaign')
                          report_relationships.append(entity_relation.to_indicator())
      return report_relationships


  def is_sub_report(report_obj):
      obj_refs = report_obj.get('object_refs', [])
      for obj_ref in obj_refs:
          if obj_ref.startswith('report--'):
              return False
      return True

  def parse_reports_and_report_relationships(report_objects: list, feed_tags: list = [],
                                             tlp_color: Optional[str] = None, id_to_object={}, vendor = "STIX2.1"):
      """Parse the Reports objects retrieved from the feed.

      Args:
        report_objects: a list of report objects containing the reports.
        feed_tags: feed tags.
        tlp_color: Traffic Light Protocol color.
        id_to_object: a dict in the form of - id: stix_object.

      Returns:
          A list of processed reports.
      """
      reports = []
      #print("In Reports")

      for report_object in report_objects:
          # if is_sub_report(report_object):
          #     continue

          tags = feed_tags

          if report_object.get('labels'):
              if type(report_object.get('labels')) == str:
                  tags.append(report_object.get('labels'))
              else:
                  tags.extend(report_object.get('labels'))

          report = dict()  # type: Dict[str, Any]

          report['type'] = ThreatIntel.ObjectsNames.REPORT
          report['value'] = f"{vendor} {report_object.get('name')}"
          report['score'] = ThreatIntel.ObjectsScore.REPORT
          report['fields'] = {
              'stixid': report_object.get('id'),
              "firstseenbysource": report_object.get('created'),
              'published': report_object.get('published'),
              'description': report_object.get('description', ''),
              "reportedby": vendor,
              "tags": tags,
          }
          if tlp_color:
              report['fields']['trafficlightprotocol'] = tlp_color

          report['rawJSON'] = {
              f'{vendor}_id': report_object.get('id'),
              f'{vendor}_labels': report_object.get('labels'),
              f'{vendor}_published': report_object.get('published'),
              f'{vendor}_created_date': report_object.get('created'),
              f'{vendor}_modified_date': report_object.get('modified'),
              f'{vendor}_description': report_object.get('description'),
              f'{vendor}_object_refs': report_object.get('object_refs')
          }

          report['relationships'] = get_campaign_from_sub_reports(report_object, id_to_object, vendor)

          reports.append(report)

      return reports


  def parse_campaigns(campaigns_obj, feed_tags, tlp_color, vendor):
      """Parse the Campaign objects retrieved from the feed.

      Args:
        campaigns_obj: a list of campaign objects containing the campaign.
        feed_tags: feed tags.
        tlp_color: Traffic Light Protocol color.

      Returns:
          A list of processed campaign.
      """
      campaigns_indicators = []
      for campaign in campaigns_obj:
          indicator_obj = {
              "value": campaign.get('name'),
              "type": ThreatIntel.ObjectsNames.CAMPAIGN,
              "rawJSON": campaign,
              "score": ThreatIntel.ObjectsScore.CAMPAIGN,
              "fields": {
                  'stixid': campaign.get('id'),
                  "firstseenbysource": campaign.get('created'),
                  "modified": campaign.get('modified'),
                  'description': campaign.get('description'),
                  "reportedby": vendor,
                  "tags": [tag for tag in feed_tags],
              }
          }

          if tlp_color:
              indicator_obj['fields']['trafficlightprotocol'] = tlp_color

          campaigns_indicators.append(indicator_obj)

      return campaigns_indicators

  def handle_multiple_dates_in_one_field(field_name: str, field_value: str):
      """Parses datetime fields to handle one value or more

      Args:
          field_name (str): The field name that holds the data (created/modified).
          field_value (str): Raw value returned from feed.

      Returns:
          str. One datetime value (min/max) according to the field name.
      """
      dates_as_string = field_value.splitlines()
      dates_as_datetime = [datetime.strptime(date, '%Y-%m-%dT%H:%M:%S.%fZ') for date in dates_as_string]

      if field_name == 'created':
          return f"{min(dates_as_datetime).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]}Z"
      else:
          return f"{max(dates_as_datetime).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3]}Z"


  def get_indicator_publication(indicator):
      """
      Build publications grid field from the indicator external_references field

      Args:
          indicator: The indicator with publication field

      Returns:
          list. publications grid field
      """
      publications = []
      for external_reference in indicator.get('external_references', []):
          if external_reference.get('external_id'):
              continue
          url = external_reference.get('url')
          description = external_reference.get('description')
          source_name = external_reference.get('source_name')
          publications.append({'link': url, 'title': description, 'source': source_name})
      return publications

  def get_attack_id_and_value_from_name(attack_indicator):
      """
      Split indicator name into MITRE ID and indicator value: 'T1108: Redundant Access' -> MITRE ID = T1108,
      indicator value = 'Redundant Access'.
      """
      ind_id = ""
      ind_name = ""
      try:
          demisto.error(str(attack_indicator))
          ind_name = attack_indicator.get('name')
          idx = ind_name.index(':')
          ind_id = ind_name[:idx]
          value = ind_name[idx + 2:]
      except Exception as e:
          demisto.error(f"Falling back to default execution. Exception: {e}")
          ind_id=""
          val = attack_indicator.get('name')
      return ind_id, val

  def change_attack_pattern_to_stix_attack_pattern(indicator: dict):
      kill_chain_phases = indicator['fields']['killchainphases']
      del indicator['fields']['killchainphases']
      description = indicator['fields']['description']
      del indicator['fields']['description']

      indicator_type = indicator['type']
      indicator['type'] = f'STIX {indicator_type}'
      indicator['fields']['stixkillchainphases'] = kill_chain_phases
      indicator['fields']['stixdescription'] = description

      return indicator

  def create_attack_pattern_indicator(attack_indicator_objects, feed_tags, tlp_color, is_up_to_6_2, vendor) -> List:
      """Parse the Attack Pattern objects retrieved from the feed.

      Args:
        attack_indicator_objects: a list of Attack Pattern objects containing the Attack Pattern.
        feed_tags: feed tags.
        tlp_color: Traffic Light Protocol color.
        is_up_to_6_2: is the server version is up to 6.2

      Returns:
          A list of processed Attack Pattern.
      """

      attack_pattern_indicators = []

      for attack_indicator in attack_indicator_objects:

          publications = get_indicator_publication(attack_indicator)
          mitre_id, value = get_attack_id_and_value_from_name(attack_indicator)

          kill_chain_mitre = [chain.get('phase_name', '') for chain in attack_indicator.get('kill_chain_phases', [])]
          kill_chain_phases = [MITRE_CHAIN_PHASES_TO_DEMISTO_FIELDS.get(phase) for phase in kill_chain_mitre]

          indicator = {
              "value": value,
              "type": ThreatIntel.ObjectsNames.ATTACK_PATTERN,
              "score": ThreatIntel.ObjectsScore.ATTACK_PATTERN,
              "fields": {
                  'stixid': attack_indicator.get('id'),
                  "killchainphases": kill_chain_phases,
                  "firstseenbysource": handle_multiple_dates_in_one_field('created', attack_indicator.get('created')),
                  "modified": handle_multiple_dates_in_one_field('modified', attack_indicator.get('modified')),
                  'description': attack_indicator.get('description'),
                  'operatingsystemrefs': attack_indicator.get('x_mitre_platforms'),
                  "publications": publications,
                  "mitreid": mitre_id,
                  "reportedby": vendor,
                  "tags": [tag for tag in feed_tags],
              }
          }
          indicator['fields']['tags'].extend([mitre_id])
          if tlp_color:
              indicator['fields']['trafficlightprotocol'] = tlp_color

          if not is_up_to_6_2:
              # For versions less than 6.2 - that only support STIX and not the newer types - Malware, Tool, etc.
              indicator = change_attack_pattern_to_stix_attack_pattern(indicator)

          attack_pattern_indicators.append(indicator)
      return attack_pattern_indicators

  def create_course_of_action_indicators(course_of_action_objects, feed_tags, tlp_color, vendor):
      """Parse the Course of Action objects retrieved from the feed.

      Args:
        course_of_action_objects: a list of Course of Action objects containing the Course of Action.
        feed_tags: feed tags.
        tlp_color: Traffic Light Protocol color.

      Returns:
          A list of processed campaign.
      """
      course_of_action_indicators = []

      for coa_indicator in course_of_action_objects:

          publications = get_indicator_publication(coa_indicator)

          indicator = {
              "value": coa_indicator.get('name'),
              "type": ThreatIntel.ObjectsNames.COURSE_OF_ACTION,
              "score": ThreatIntel.ObjectsScore.COURSE_OF_ACTION,
              "fields": {
                  'stixid': coa_indicator.get('id'),
                  "firstseenbysource": handle_multiple_dates_in_one_field('created', coa_indicator.get('created')),
                  "modified": handle_multiple_dates_in_one_field('modified', coa_indicator.get('modified')),
                  'description': coa_indicator.get('description', ''),
                  "publications": publications,
                  "reportedby": vendor,
                  "tags": [tag for tag in feed_tags],
              }
          }
          if tlp_color:
              indicator['fields']['trafficlightprotocol'] = tlp_color

          course_of_action_indicators.append(indicator)

      return course_of_action_indicators


  def create_intrusion_sets(intrusion_sets_objects, feed_tags, tlp_color, vendor):
      course_of_action_indicators = []

      for intrusion_set in intrusion_sets_objects:

          publications = get_indicator_publication(intrusion_set)

          indicator = {
              "value": intrusion_set.get('name'),
              "type": ThreatIntel.ObjectsNames.INTRUSION_SET,
              "score": ThreatIntel.ObjectsScore.INTRUSION_SET,
              "fields": {
                  'stixid': intrusion_set.get('id'),
                  "firstseenbysource": handle_multiple_dates_in_one_field('created', intrusion_set.get('created')),
                  "modified": handle_multiple_dates_in_one_field('modified', intrusion_set.get('modified')),
                  'description': intrusion_set.get('description', ''),
                  "publications": publications,
                  "reportedby": vendor,
                  "tags": [tag for tag in feed_tags],
              }
          }
          if tlp_color:
              indicator['fields']['trafficlightprotocol'] = tlp_color

          course_of_action_indicators.append(indicator)

      return course_of_action_indicators


  def get_ioc_type(indicator, id_to_object):
      """
      Get IOC type by extracting it from the pattern field.

      Args:
          indicator: the indicator to get information on.
          id_to_object: a dict in the form of - id: stix_object.

      Returns:
          str. the IOC type.
      """
      ioc_type = ''
      indicator_obj = id_to_object.get(indicator, {})
      pattern = indicator_obj.get('pattern', '')
      for ind_type in STIX2_INDICATOR_TYPES:
          if pattern.startswith(f'[{ind_type}'):
              ioc_type = STIX2_INDICATOR_TYPES.get(ind_type)  # type: ignore
              break
      return ioc_type


  def get_ioc_value(ioc, id_to_obj, vendor):
      """
      Get IOC value from the indicator name field.

      Args:
          ioc: the indicator to get information on.
          id_to_obj: a dict in the form of - id: stix_object.

      Returns:
          str. the IOC value. if its reports we add to it Vendor Name to prefix,
          if its attack pattern remove the id from the name.
      """
      ioc_obj = id_to_obj.get(ioc)
      if ioc_obj:
          if ioc_obj.get('type') == 'report':
              return f"{vendor} {ioc_obj.get('name')}"
          elif ioc_obj.get('type') == 'attack-pattern':
              _, value = get_attack_id_and_value_from_name(ioc_obj)
              return value
          elif "file:hashes.'SHA-256' = '" in ioc_obj.get('name'):
              return get_ioc_value_from_ioc_name(ioc_obj)
          else:
              return ioc_obj.get('name')


  def create_list_relationships(relationships_objects, id_to_object, vendor):
      """Parse the Relationships objects retrieved from the feed.

      Args:
        relationships_objects: a list of relationships objects containing the relationships.
        id_to_object: a dict in the form of - id: stix_object.

      Returns:
          A list of processed relationships.
      """
      relationships_list = []

      for relationships_object in relationships_objects:

          relationship_type = relationships_object.get('relationship_type')
          if relationship_type not in RELATIONSHIP_TYPES:
              if relationship_type == 'indicates':
                  relationship_type = 'indicated-by'
              else:
                  demisto.debug(f"Invalid relation type: {relationship_type}")
                  continue

          a_threat_intel_type = relationships_object.get('source_ref').split('--')[0]
          a_type = ''
          if a_threat_intel_type in THREAT_INTEL_TYPE_TO_DEMISTO_TYPES.keys():
              a_type = THREAT_INTEL_TYPE_TO_DEMISTO_TYPES.get(a_threat_intel_type)  # type: ignore
          elif a_threat_intel_type == 'indicator':
              a_type = get_ioc_type(relationships_object.get('source_ref'), id_to_object)

          b_threat_intel_type = relationships_object.get('target_ref').split('--')[0]
          b_type = ''
          if b_threat_intel_type in THREAT_INTEL_TYPE_TO_DEMISTO_TYPES.keys():
              b_type = THREAT_INTEL_TYPE_TO_DEMISTO_TYPES.get(b_threat_intel_type)  # type: ignore
          if b_threat_intel_type == 'indicator':
              b_type = get_ioc_type(relationships_object.get('target_ref'), id_to_object)

          if not a_type or not b_type:
              continue

          mapping_fields = {
              'lastseenbysource': relationships_object.get('modified'),
              'firstseenbysource': relationships_object.get('created')
          }

          entity_a = get_ioc_value(relationships_object.get('source_ref'), id_to_object, vendor)
          entity_b = get_ioc_value(relationships_object.get('target_ref'), id_to_object, vendor)

          entity_relation = EntityRelationship(name=relationship_type,
                                               entity_a=entity_a,
                                               entity_a_type=a_type,
                                               entity_b=entity_b,
                                               entity_b_type=b_type,
                                               fields=mapping_fields)
          relationships_list.append(entity_relation.to_indicator())
      return relationships_list




  def main():
      vendor = demisto.args().get("vendor")
      if not vendor:
          vendor = "STIX2.1"
      objects = demisto.args().get("objects")
      feed_tags = demisto.args().get("feed_tags")
      if type(feed_tags) == str:
          feed_tags = [feed_tags]
      tlp_color = "RED"

      create_indicator_in_xsoar = demisto.args().get("create_indicator_in_xsoar")

      if not objects:
          return_error("Please provide objects input") #guard condition

      client = Client()
      client.processSTIXObjects(objects)
      indicators = []

      is_up_to_6_2 = is_demisto_version_ge('6.2.0')

      for type_, objects in client.objects_data.items():
          demisto.info(f'Fetched {len(objects)} {vendor} {type_} objects.')

      id_to_object = {}
      for k,v in client.objects_data.items():
          for obj in v:
              id_to_object[obj.get('id')] = obj

      # id_to_object = {
      #     obj.get('id'): obj for obj in
      #     client.objects_data.get('report') + client.objects_data.get('indicator') + client.objects_data.get('malware')
      #     + client.objects_data.get('campaign') + client.objects_data.get('attack-pattern')
      #     + client.objects_data.get('course-of-action') + client.objects_data.get('intrusion-set')
      # }
      #print(str(client.objects_data))
      if client.objects_data.get('indicator'):
          ioc_indicators = parse_indicators(client.objects_data['indicator'], feed_tags, tlp_color, vendor)
          indicators.extend(ioc_indicators)
      if client.objects_data.get('report'):
          reports = parse_reports_and_report_relationships(client.objects_data['report'], feed_tags, tlp_color, id_to_object, vendor)
          indicators.extend(reports)
      if client.objects_data.get('campaign'):
          campaigns = parse_campaigns(client.objects_data['campaign'], feed_tags, tlp_color, vendor)
          indicators.extend(campaigns)
      if client.objects_data.get('attack-pattern'):
          attack_patterns = create_attack_pattern_indicator(client.objects_data['attack-pattern'],feed_tags, tlp_color, is_up_to_6_2, vendor)
          indicators.extend(attack_patterns)
      if client.objects_data.get('intrusion-set'):
          intrusion_sets = create_intrusion_sets(client.objects_data['intrusion-set'], feed_tags, tlp_color, vendor)
          indicators.extend(intrusion_sets)
      if client.objects_data.get('course-of-action'):
          course_of_actions = create_course_of_action_indicators(client.objects_data['course-of-action'], feed_tags, tlp_color, vendor)
          indicators.extend(course_of_actions)
      if client.objects_data.get('relationship'):
          dummy_indicator = {}
          list_relationships = create_list_relationships(client.objects_data['relationship'], id_to_object, vendor)
          dummy_indicator = {
              "value": "$$DummyIndicator$$",
              "relationships": list_relationships
          }
          if dummy_indicator:
              ioc_indicators.extend(dummy_indicator)

      #print(indicators)

      readable_output = tableToMarkdown('STIX2.1 Indicators:', t=indicators, headers=['type', 'value', 'fields'])
      #print(f"readable output: {readable_output}")

      command_results = CommandResults(
          outputs_prefix='',
          outputs_key_field='',
          outputs={},
          readable_output=readable_output,
          raw_response=indicators
      )

      return command_results



  return_results(main())
scripttarget: 0
subtype: python3
tags: []
type: python
