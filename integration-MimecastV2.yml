category: Email
commonfields:
  id: MimecastV2
  version: -1
configuration:
- defaultvalue: https://api.mimecast.com
  display: BaseUrl - API url including region, For example https://eu-api.mimecast.com
  name: baseUrl
  required: true
  type: 0
- display: App ID
  name: appId
  required: true
  type: 0
- display: User Email Address (Use for auto token refresh)
  displaypassword: Password
  name: credentials
  required: false
  type: 9
- display: User Email Address (Use for auto token refresh)
  hidden: true
  name: email
  required: false
  type: 0
- display: Password
  hidden: true
  name: password
  required: false
  type: 4
- display: App Key
  displaypassword: App Key
  hiddenusername: true
  name: appKey_creds
  required: false
  type: 9
- display: App key
  hidden: true
  name: appKey
  required: false
  type: 4
- display: AccessKey
  name: accessKey
  required: false
  type: 0
- display: Secret Key
  displaypassword: Secret Key
  hiddenusername: true
  name: secretKey_creds
  required: false
  type: 9
- display: SecretKey
  hidden: true
  name: secretKey
  required: false
  type: 4
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Fetch URL incidents
  hidden: true
  name: fetchURL
  required: false
  type: 8
- display: Fetch attachment incidents
  hidden: true
  name: fetchAttachments
  required: false
  type: 8
- display: Fetch impersonation incidents
  hidden: true
  name: fetchImpersonations
  required: false
  type: 8
- additionalinfo: Fetch specific incident types. Default value is "All".
  defaultvalue: All
  display: Fetch incident types
  name: incidentsToFetch
  options:
  - All
  - Impersonation
  - Attachments
  - Url
  - Held Messages
  required: false
  type: 16
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "24"
  display: Hours before first fetch to retrieve incidents
  name: fetchDelta
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: new_insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.2.6
    packID: Mimecast
    packName: Mimecast
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Mimecast unified email management offers cloud email services for email
  security, continuity and archiving emails. Please read detailed instructions in
  order to understand how to set the integration's parameters.
detaileddescription: "1. In order to refresh token / discover auth types of the account
  / create new access & secret keys, \nyou are required to provide: App ID, Account
  email address & password.\nThese parameters support the following integration commands:
  \nmimecast-login -> fetches new access key & secret key\nmimecast-discover -> lists
  supported auth types of user\nmimecast-refresh-token -> refreshes the validity duration
  of access key & secret key (3 days)\n\n2. In order to use the rest of the commands,
  you are required to provide: App ID, App Key, Access Key & Secret Key.\nFor detailed
  information about creating these fields, please refer to the [Mimecast Documentation](https://integrations.mimecast.com/documentation/api-overview/authentication-scripts-server-apps/).\n\n3.
  Fetch Incidents - the integration has the ability to fetch 3 types of incidents:
  url, attachment & impersonation.\nIn order to activate them first tick \"fetch incidents\"
  box, then tick the relevant boxes for each fetch type you want.\n\n---\n[View Integration
  Documentation](https://xsoar.pan.dev/docs/reference/integrations/mimecast-v2)"
display: Mimecast v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAQCAYAAADdw7vlAAAL9ElEQVR42u1ZeViU1RrHkm5Fdnuq+5gtakop2FWzoHJFUzPKSg2XTNmRRWWRfScYkAEZGGAY1gFm2JkZEIZl2B0EFWRRQbPU65LJVW5eNSq5+d3fOc43zzAi4X18uv/4Pc/7nOF7z/ue9zu/824HvYf9XPzx2kSvSBF36Ze+rdvdeBx5zaGn9B49D+2pbete5BMv7vRNkPTlK1S7/3QD6lt7psw2c2ReMbFiXn53O2O9J8FF79Hz0J4wYXGQbYiAsQ5OYvz5kt4/3YBSRasBvLftVVOr228sdRhy8E221Hv0PLQnWFDoueMbIWMflsIEJuW3/1+MEEqq9Ret956+zTVuit6j56E+kRmyBIDLAtxX196jrzunoEr1Fk9SYXL+8tWJerFp8q+2ucXl23gn5Nt48u+SFxlHJ3vfxPx1dhzJis0BfDsv/hZpVfuzugtkFdVteP9zT+niDT6lYlnTGvb9hcv/fGZncGqcuWWo/DObcNl4aL1DpOzj7aESUAwnucRsrI+X17Q/6xIstPjCLlJg4RRdstZaowc6QmQBMeKQc5cGHh9NtrC69YPY7PLIEEGhOFokl3LSS2WEItJL5THZ5YlnLv74HDv30sCgPr+gKuib1GI5nZehISoTmSEtDk8r5ecpVCvvZ2ue4oBJeFpJTFSmrADzITdCB0j3t1QanlpSsysq47ZjuJBxjEhlnEABifkdhL83Sy44e+nKX+vaj23hpEtVsFlZ3ngkSG+Zhe/pv83fyrxiaoW8aclMQd6c8g4I46umliArDb1sQnh4/54VM32hLTPtAxtm8Xqf/qrGo7O1jV+4zqvutfesKd9wiYNYc7LKW1YT+alqHubQdV4GsfOnguj4vjWxBzxL+ns6ef++DePknyK6eWvonlPrszfbbKmF70nYhflqvSbUfnybJVmD6v3o6+DntOUGBq8/k5CnyHZA2LMLFVDPsA1JJkTznFVQImOD0S9BsoKVUbb3vOYUkcZsD+BTPkgzzwZyIKqH6ATQkguXrz6hvWZzxwlbgHObrGernm8bSkddYvka2gFwIUsJIKtlBXT9wprWL9Ok9VH8fIUsNmd/dYasPkbPbKNfvxoIkD3z9seuV975xP3cgo9dryGHMizNXGzPzPnQ5d/vmLudf2uly82Zi+0YQ7x/acE2ZpMzt+6HK4MT2A+Ad+9/HRsNOQBjK2LfZ5c0fAKQyFpU3+zljr+S9Zdv8u+bvcLpF/LOUL3eDPzGQfmeEObfmYH1ZsI+AlRkYrGz9obVqXqMjT90vkkOyeuL7CjBhrPQ3WK61qMakURhunZPlUd4ZviZ8z9qPPjW0C+PJRVWyywDExl4BQC5G/p2RqX/4h4jukRCIDykH4VN9dH+M5p0c/HKNX1BcW0wPEoODyReTkiKueV79mU37I7OHIQuCgDRLa07FMLKdpz47nno/hfApXyXyPTfXLlZrZCp8eblKjzjchQYKfnwxApUzJrRKy63FrYNOYbfBdeJk8oEJRc0Ya2s6Cx5FCLLc2Qtfn5VLk9SmZVaWpeqRzaX9ZivXfeVhvEKXtjkwn06hJf/ktlG/z54BN0wbPQFn705b2xxiTGI4BdOW7klsJ7wZoA3f83uG8oD3ZPZj/jcNkI2FUACKMLPYt/nlDaYYy0KlCEoPKFwU3qBUj85R6EfGCtZY7TcaZjwyJzNLlxhUo7iqdD4gidjhDIzk0/dr0EXtRPhukwb4K2790mIlxI+DuANlwDhhqjkEgA59tN4+Njn8ACyWRRcbPyV5KIaT4TPmXHiikmKA0f1lW3d+g+aJ+GhL8JzD9uF3Y0IPvGSk82dJybSLuNQ71wnThrxROrhsvpD2x5E977c/VHQSe31T8zrh40TtPlXf7rxbFZZo6OwpNa5q//MSxRghD8K4lqbcA/tybPMHJUAiYJhvMJZqc0DOF8RIIhnwaP/E5Mqn8PykPPGApjKoJW6U1nfYczy4tLLJ/999c6b4FGAkatHtFewU4loQHXiEDSy7/PLWp5fYO56ldhP+J9ahTWvs4+cPmOJ/ZtvLtthhEhgBBuMEFGMCsoPjAjPe7NkJSQEkqrUNTrzZs+3595+kM2uVnVNRCicAZDmdvZ/P//w8dPzj5z4bl5777dzkFfzATAFwisu50JlS6cBkVF19c9CeCUAU168pDI7r0q1sKT2oEmJ8qBpRUvn3NK69hfvt2ZqiXKnPfSOt4pmPZie/lVbg3y1eQiNDWyIBsgN2jz0t0sRUiFHAR7mpsiMtQGGTir3+n0AngWAZdXt81ledIp06lurXG6xADv6Cdy01/tqV2wmvJfqRBjX2GK+PXQWgLwNW1k7hyE/jJES5lJCtBnG93UIcqvoxUvXyTOPh6YUddM8CEKoVY4X2J+HfpsgrW938Y4XH3OOTBty5qT9DmJYoh6qDqNqgM/LGw9TgAev39BHdKi1DOQzO8CjoRpzWTnQHTdu1kBsTrmoreeUse7aKcW1bizAQcn5hx8IYBQgIwDGhjWwORGkDTDCMGcRNvYuwKsAsHD8AM8kHvxHAAeMBBjpgUeKJkMdW5AejPH3MIj1boZGJJpaQBgJkYgyd/Wuq1/v3jeJyLX1npyI/NXPthyoRCXjBbiiudPdOjiRYUMlm0/Zyhahl/KctAAubzpiwMqf+2FgEnJ/DFLCZXI4ME8jj2iCA0eLKwL2rYM9Jy1GAZjqRV7ueCCAV+sAbDgGwOsdohaPCfA4QrSsZvwAe0dlawCGt2psEcubJ8/7aNd1rIODQ1PJkHNQioc/N3f7Hk6WtUdEJqVdIanWEfyiBdo6uaKyalt1xevPzzs+XoDh+e0AgYKBTb4Un1dpj9ZkSamyzRTh1QQhezlaoA4AoQG4oqXD4N5WSfVCWVPHPEFRzUIcsMXQsQjF0ipudpkUchRkP77k3LHT5zStKOa6a/Tyck8hpD82prG0kNL2YN0QPRbAS/9HD37wEE0BRss0qi0oyGpQXVPvRboYEuQqPhgPUDn7mx3R2iBEUq+7I65s8VYd7ZswlgxaqgluMaITAJe2KKhUBaPNQ17lkDZLA3AzAB7nU6XqWolDR/M0quzhKlXnNJaH1sfNDofLEbydkelDKLLm/SHAGg/eqguwPevB8BodgO0jiQc/tBy8V1A6AuAdugBHUg8e1Zbalq7VyM8kFFMvNlrh9OsyC7+incFCLi43ovyic6P2RGRGhSUUbhy4dl0DIC49DHBZ0QsgNEUPrgLb0RalwaMFgYn5Kb7xYiFADRy8fvNpVi6xoLoI7Q+VIfkyXVYf58fPC4WeUBsQZKPQ5lwGXwNwmToHX/vpxgT0q5+hGo6LE+/nUZJU8FBs8bBOHC4skjC/n8jahQhIIXWq/8zFJ9m1u0+eXYqUQKIH1Y21zkImQlTWZPHTjZ//cg/AS770PYsNpXkLvWOwNg+FSSs2nFbR+N02MgdHLAN4FCxsKAMPnqNV+CgABt1w/NMhT+uG61Pyfqa6py1THtKEzNhU+TT0xVjHhva69t5JXtrreXJEyZNxSaJuow7e41lZFS6IKEMEaJZweUN1YU16QQN7f8c9+YhK+vjp80YIs+piK5kBQHTE5qlJSEMletzlrMwPA4NTcAiayaU/5OiFBypmCjiIvrNX/028zSM2+yo8jQIsKm+aRHpZHJBRLjaS6EiLKPUlCCp1a91vLalt83IIS7mDddjLEGpztKhs8z0Aox3Zi9uePnhhd1GF6sMRCV1cZYNc2QuvOOEWlu6jzVMd6X91xaaAFtw29Zlbhu0/1HVKkyc4icXuC8zdTr/7ifsp/xixg6ataDo65aNtIUpsft+abSGVtc1dL2i86eKVJzc6RYtgR++SDT5t+K/UiDDrzxWvm73cqReH7XjQvjzP0aJRfEb5/C/sODzUFY3om7vh7X2GasIB7dvszC2QVbU9oSuH6z2DnIpmS3hCHoBsBSA9KHj6CAHkPlxfNvd++4/XdHrdJzLkDbaBSQVS8NtwwdHtESsCYWQpRtSNQqoLHs/DJQTNlce/Oz8RlyRCtGUj5u7RlsP60NuAfH7fHrlE2bYMlys58OCDWKMHBWMLWrQ5uvP+C43Zu2S9pik3AAAAAElFTkSuQmCC
name: MimecastV2
script:
  commands:
  - arguments:
    - default: true
      description: The query string xml for the search using Mimecast Unified Search
        Experience (MUSE) - read more on https://community.mimecast.com/docs/DOC-2262,
        using this will override other query arguments.
      name: queryXml
    - description: Search for this text in messages.
      name: text
    - auto: PREDEFINED
      defaultValue: "false"
      description: Will not execute the query, but just return the query string built.
      name: dryRun
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Search in specific dates only.
      name: date
      predefined:
      - today
      - yesterday
      - last_week
      - last_month
      - last_year
    - description: Search emails from date, format YYYY-MM-DDTHH:MM:SZ (e.g. 2015-09-21T23:00:00Z).
      name: dateFrom
    - description: Search emails to date, format YYYY-MM-DDTHH:MM:SZ (e.g. 2015-09-21T23:00:00Z).
      name: dateTo
    - description: Filter on messages to a specific address.
      name: sentTo
    - description: Filter on messages from a specific address.
      name: sentFrom
    - description: Search email by subject, will override the text argument.
      name: subject
    - auto: PREDEFINED
      description: 'These are the attachment types available: optional - messages
        with and without attachments any - messages with any attachment documents
        - messages with doc, dot, docx, docm, dotx, dotm, pdf, rtf, html attachments
        spreadsheets - messages with xls, xlt, xlsx, xlsm, xltx, xltm, xlsb, xlam,
        csv attachments presentations - messages with ppt, pptx, pptm, potx, potm,
        ppam, ppsx, ppsm, sldx, sldm, thms, pps attachments text - messages with txt,
        text, html, log attachments images - messages with jpg, jpeg, png, bmp, gif,
        psd, tif, tiff attachments media - messages with mp3, mp4, m4a, mpg, mpeg,
        avi, wav, aac, wma, mov attachments zips - messages with zip, rar, cab, gz,
        gzip, 7z attachments none - No attachments are to be present in the results.'
      name: attachmentType
      predefined:
      - optional
      - any
      - documents
      - spreadsheets
      - presentations
      - text
      - images
      - media
      - zips
      - none
    - description: Search for text in attachments.
      name: attachmentText
    - description: Search email by text in body, will override the text and subject
        arguments.
      name: body
    - description: Number of results per page to display.
      name: pageSize
    - description: Sets the result to start returning results (default 0).
      name: startRow
    - auto: PREDEFINED
      defaultValue: "false"
      description: Defines if the search should query recently received messages that
        are not fully processed yet (default false). You can search by mailbox and
        date time across active messages.
      name: active
      predefined:
      - "true"
      - "false"
    - defaultValue: "20"
      description: The maximum number of results to return.
      name: limit
      predefined:
      - ""
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    description: Query Mimecast emails. This is an archive search command.
    name: mimecast-query
    outputs:
    - contextPath: Mimecast.Message.ID
      description: Message ID.
      type: string
    - contextPath: Mimecast.Message.Subject
      description: Message subject.
      type: string
    - contextPath: Mimecast.Message.Sender
      description: Message sender address.
      type: string
    - contextPath: Mimecast.Message.Recipient
      description: Message recipient address.
      type: string
    - contextPath: Mimecast.Message.RecievedDate
      description: Message received date.
      type: date
    - contextPath: Mimecast.Message.Size
      description: The size of the message in bytes.
      type: number
    - contextPath: Mimecast.Message.AttachmentCount
      description: Message attachments count.
      type: number
    - contextPath: Mimecast.Message.Status
      description: Message status.
      type: string
  - arguments: []
    description: List all existing Mimecast blocked sender policies.
    name: mimecast-list-blocked-sender-policies
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID.
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address.
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain.
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group.
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is bidirectional or not.
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to receiver type address.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to receiver type domain.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to receiver type group.
      type: string
    - contextPath: Mimecast.Policy.FromDate
      description: Policy validation start date.
      type: date
    - contextPath: Mimecast.Policy.ToDate
      description: Policy expiration date.
      type: date
    - contextPath: Mimecast.Policy.Sender.Type
      description: Block emails to sender type.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Type
      description: Block emails to receiver type.
      type: string
  - arguments:
    - description: Filter by policy ID.
      name: policyID
      required: true
    description: Get a blocked sender policy by ID.
    name: mimecast-get-policy
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID.
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address.
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain.
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group.
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is bidirectional or not.
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to receiver type address.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to receiver type domain.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to receiver type group.
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date.
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date.
      type: date
  - arguments:
    - description: Policy description.
      name: description
      required: true
    - auto: PREDEFINED
      defaultValue: envelope_from
      description: Addresses based on.
      name: fromPart
      predefined:
      - envelope_from
      - header_from
      - both
    - auto: PREDEFINED
      description: Blocked Sender type.
      name: fromType
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - individual_email_address
      required: true
    - description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If fromType is email_domain, a domain name
        without the @ symbol. If fromType is profile_group, the ID of the profile
        group. If fromType is individual_email_address, an email address.'
      name: fromValue
    - auto: PREDEFINED
      description: Receiver type.
      name: toType
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - address_attribute_value
      - individual_email_address
      - free_mail_domains
      - header_display_name
      required: true
    - description: 'Required if fromType is one of email domain, profile group, individual
        email address. Expected values: If toType is email_domain, a domain name without
        the @ symbol. If toType is profile_group, the ID of the profile group. If
        toType is individual_email_address, an email address.'
      name: toValue
    - auto: PREDEFINED
      description: 'The block option, must be one of: no_action, block_sender.'
      name: option
      predefined:
      - no_action
      - block_sender
      required: true
    description: Create a Blocked Sender Policy.
    name: mimecast-create-policy
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID.
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block Sender by email address.
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block Sender by domain.
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block Sender by group.
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Blocked policy is bidirectional or not.
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to receiver type address.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to receiver type domain.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to receiver type group.
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: Policy validation start date.
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: Policy expiration date.
      type: date
    - contextPath: Mimecast.Policy.Sender.Type
      description: The sender type.
      type: String
    - contextPath: Mimecast.Policy.Receiver.Type
      description: The receiver type.
      type: String
  - arguments:
    - description: Policy ID.
      name: policyID
      required: true
    description: Delete a Blocked Sender Policy.
    name: mimecast-delete-policy
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID.
      type: string
  - arguments:
    - description: The email address of sender to permit or block.
      name: sender
      required: true
    - description: The email address of recipient to permit or block.
      name: recipient
      required: true
    - auto: PREDEFINED
      description: Choose to either "permit" (to bypass spam checks) or "block" (to
        reject the email).
      name: action
      predefined:
      - permit
      - block
      required: true
    - defaultValue: "20"
      description: The maximum number of results to return.
      name: limit
      predefined:
      - ""
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    description: Permit or block a specific sender.
    name: mimecast-manage-sender
    outputs:
    - contextPath: Mimecast.Managed.Sender
      description: The email address of the sender.
      type: string
    - contextPath: Mimecast.Managed.Recipient
      description: The email address of the recipient.
      type: string
    - contextPath: Mimecast.Managed.Action
      description: Chosen action.
      type: string
    - contextPath: Mimecast.Managed.ID
      description: The Mimecast secure ID of the managed sender object.
      type: string
  - arguments:
    - description: Filter results by specific URL.
      name: url
    description: Get a list of all managed URLs.
    name: mimecast-list-managed-url
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain.
      type: string
    - contextPath: Mimecast.URL.Disablelogclick
      description: If logging of user clicks on the URL is disabled.
      type: boolean
    - contextPath: Mimecast.URL.Action
      description: Either block of permit.
      type: string
    - contextPath: Mimecast.URL.Path
      description: The path of the managed URL.
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain.
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL.
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled.
      type: boolean
  - arguments:
    - description: The URL to block or permit. Do not include a fragment (#).
      name: url
      required: true
    - auto: PREDEFINED
      description: Set to "block" to block list the URL, "permit" to add to allow
        list.
      name: action
      predefined:
      - block
      - permit
      required: true
    - auto: PREDEFINED
      defaultValue: explicit
      description: Set to "explicit" to block or permit only instances of the full
        URL. Set to "domain" to block or permit any URL with the same domain.
      name: matchType
      predefined:
      - explicit
      - domain
    - auto: PREDEFINED
      defaultValue: "false"
      description: Disable rewriting of this URL in emails. Applies only if action
        = "permit". Default false.
      name: disableRewrite
      predefined:
      - "true"
      - "false"
    - description: Add a comment about the managed URL.
      name: comment
    - auto: PREDEFINED
      defaultValue: "false"
      description: Disable User Awareness challenges for this URL. Applies only if
        action = "permit". Default false.
      name: disableUserAwareness
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: Disable logging of user clicks on the URL. Default is false.
      name: disableLogClick
      predefined:
      - "true"
      - "false"
    description: Create a managed URL on Mimecast.
    name: mimecast-create-managed-url
    outputs:
    - contextPath: Mimecast.URL.Domain
      description: The managed domain.
      type: string
    - contextPath: Mimecast.URL.Action
      description: Either block of permit.
      type: string
    - contextPath: Mimecast.URL.disableLogClick
      description: If logging of user clicks on the URL is disabled.
      type: string
    - contextPath: Mimecast.URL.matchType
      description: Either explicit - applies to the full URL or domain - applies to
        all URL values in the domain.
      type: string
    - contextPath: Mimecast.URL.ID
      description: The Mimecast secure ID of the managed URL.
      type: string
    - contextPath: Mimecast.URL.disableRewrite
      description: If rewriting of this URL in emails is disabled.
      type: boolean
  - arguments:
    - description: The email address to return the message list for.
      name: mailbox
    - description: The start date of messages to return, in the following format,
        2015-11-16T14:49:18+0000. Default is the last calendar month.
      name: startTime
    - description: The end date of messages to return, in the following format, 2015-11-16T14:49:18+0000.
        Default is the end of the current day.
      name: endTime
    - auto: PREDEFINED
      defaultValue: INBOX
      description: 'The message list type, must be one of: inbox or sent, default
        is inbox.'
      name: view
      predefined:
      - INBOX
      - SENT
    - description: Filter by message subject.
      name: subject
    - defaultValue: "100"
      description: The maximum number of results to return.
      name: limit
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    description: Get a list of messages for a given user. This is an archive search
      command.
    name: mimecast-list-messages
    outputs:
    - contextPath: Mimecast.Message.Subject
      description: Message Subject.
      type: string
    - contextPath: Mimecast.Message.ID
      description: Message ID.
      type: string
    - contextPath: Mimecast.Message.Size
      description: The size of the message in bytes.
      type: number
    - contextPath: Mimecast.Message.RecievedDate
      description: The date the message was received.
      type: date
    - contextPath: Mimecast.Message.From
      description: The mail Sender.
      type: string
    - contextPath: Mimecast.Message.AttachmentCount
      description: The number of attachments on the message.
      type: string
  - arguments:
    - description: The number of results to request. Default is all.
      name: resultsNumber
    - description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day.
      name: fromDate
    - description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request.
      name: toDate
    - auto: PREDEFINED
      defaultValue: malicious
      description: Filters logs by scan result, default is malicious.
      name: resultType
      predefined:
      - safe
      - malicious
      - timeout
      - error
      - unsafe
      - all
    - defaultValue: "100"
      description: The maximum number of results to return.
      name: limit
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    description: Returns Attachment Protect logs for a Mimecast customer account.
    name: mimecast-get-attachment-logs
    outputs:
    - contextPath: Mimecast.AttachmentLog.Result
      description: 'The result of the attachment analysis: clean, malicious, unknown,
        or timeout.'
      type: string
    - contextPath: Mimecast.AttachmentLog.Date
      description: The time at which the attachment was released from the sandbox.
      type: date
    - contextPath: Mimecast.AttachmentLog.Sender
      description: The sender of the attachment.
      type: string
    - contextPath: Mimecast.AttachmentLog.FileName
      description: The file name of the original attachment.
      type: string
    - contextPath: Mimecast.AttachmentLog.Action
      description: The action triggered for the attachment.
      type: string
    - contextPath: Mimecast.AttachmentLog.Recipient
      description: The address of the user that received the attachment.
      type: string
    - contextPath: Mimecast.AttachmentLog.FileType
      description: The file type of the attachment.
      type: string
    - contextPath: Mimecast.AttachmentLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external.'
      type: string
  - arguments:
    - description: This parameter is ignored, use the 'limit' parameter instead.
      name: resultsNumber
    - description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day.
      name: fromDate
    - description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request.
      name: toDate
    - auto: PREDEFINED
      defaultValue: malicious
      description: Filters logs by scan result.
      name: resultType
      predefined:
      - clean
      - malicious
      - all
    - defaultValue: "100"
      description: The maximum number of results to return.
      name: limit
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    description: Returns URL protect logs for a Mimecast customer account. Default
      value of scanResult as malicious.
    name: mimecast-get-url-logs
    outputs:
    - contextPath: Mimecast.UrlLog.Category
      description: The category of the URL clicked.
      type: string
    - contextPath: Mimecast.UrlLog.UserAddress
      description: The email address of the user who clicked the link.
      type: string
    - contextPath: Mimecast.UrlLog.URL
      description: The url clicked.
      type: string
    - contextPath: Mimecast.UrlLog.Awareness
      description: The action taken by the user if user awareness was applied.
      type: string
    - contextPath: Mimecast.UrlLog.AdminOverride
      description: The action defined by the administrator for the URL.
      type: string
    - contextPath: Mimecast.UrlLog.Date
      description: The date that the URL was clicked.
      type: date
    - contextPath: Mimecast.UrlLog.Result
      description: The result of the URL scan.
      type: string
    - contextPath: Mimecast.UrlLog.Action
      description: The action that was taken for the click.
      type: string
    - contextPath: Mimecast.UrlLog.Route
      description: 'The route of the original email containing the attachment, either:
        inbound, outbound, internal, or external.'
      type: string
    - contextPath: Mimecast.UrlLog. userOverride
      description: The action requested by the user.
      type: string
  - arguments:
    - description: The number of results to request. Default is all.
      name: resultsNumber
    - auto: PREDEFINED
      defaultValue: "true"
      description: Filters for messages tagged malicious (true) or not tagged malicious
        (false). Omit for no tag filtering. Default is true.
      name: taggedMalicious
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: The field to search. Default is all (meaning all of the preceding
        fields).
      name: searchField
      predefined:
      - senderAddress
      - recipientAddress
      - subject
      - policy
      - all
    - description: Required if searchField exists. A character string to search for
        in the logs.
      name: query
    - auto: PREDEFINED
      description: Filters logs by identifiers, can include any of newly_observed_domain,
        internal_user_name, repy_address_mismatch, and targeted_threat_dictionary.
        you can choose more then one identifier separated by comma.
      isArray: true
      name: identifiers
      predefined:
      - newly_observed_domain
      - internal_user_name
      - repy_address_mismatch
      - targeted_threat_dictionary
    - description: Start date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is the start of the current day.
      name: fromDate
    - description: End date of logs to return in the following format 2015-11-16T14:49:18+0000.
        Default is time of request.
      name: toDate
    - auto: PREDEFINED
      description: Filters logs by action, you can choose more then one action separated
        by comma.
      isArray: true
      name: actions
      predefined:
      - delete
      - hold
      - bounce
      - smart_folder
      - disable_smart_folder
      - content_expire
      - meta_expire
      - stationery
      - gcc
      - secure_delivery
      - delivery_route
      - document_policy
      - disable_document_policy
      - attach_set_policy
      - remove_email
    - defaultValue: "100"
      description: The maximum number of results to return.
      name: limit
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    description: Returns Impersonation Protect logs for a Mimecast customer account.
    name: mimecast-get-impersonation-logs
    outputs:
    - contextPath: Mimecast.Impersonation.ResultCount
      description: The total number of IMPERSONATION log lines found for the request.
      type: number
    - contextPath: Mimecast.Impersonation.Hits
      description: The number of identifiers that the message triggered.
      type: number
    - contextPath: Mimecast.Impersonation.Malicious
      description: Whether the message was tagged as malicious.
      type: boolean
    - contextPath: Mimecast.Impersonation.SenderIP
      description: The source IP address of the message.
      type: string
    - contextPath: Mimecast.Impersonation.SenderAddress
      description: The email address of the sender of the message.
      type: string
    - contextPath: Mimecast.Impersonation.Subject
      description: The subject of the email.
      type: string
    - contextPath: Mimecast.Impersonation.Identifiers
      description: 'The properties of the message that triggered the action: similar_internal_domain,
        newly_observed_domain, internal_user_name, reply_address_mismatch, and/or
        targeted_threat_dictionary.'
      type: string
    - contextPath: Mimecast.Impersonation.Date
      description: The time at which the log was recorded.
      type: date
    - contextPath: Mimecast.Impersonation.Action
      description: The action triggered by the email.
      type: string
    - contextPath: Mimecast.Impersonation.Policy
      description: The name of the policy definition that triggered the log.
      type: string
    - contextPath: Mimecast.Impersonation.ID
      description: Impersonation Log ID.
      type: string
    - contextPath: Mimecast.Impersonation.RecipientAddress
      description: The email address of the recipient of the email.
      type: string
    - contextPath: Mimecast.Impersonation.External
      description: Whether the message was tagged as coming from an external address.
      type: boolean
  - arguments:
    - description: URL to decode.
      name: url
      required: true
    description: Decodes a given url from mimecast.
    name: mimecast-url-decode
    outputs:
    - contextPath: URL.Data
      description: The encoded url to parse.
      type: string
    - contextPath: URL.Mimecast.DecodedURL
      description: Parsed url.
      type: string
  - arguments: []
    description: discover authentication types that are supported for your account
      and which base URL to use for the requesting user.
    name: mimecast-discover
    outputs:
    - contextPath: Mimecast.Authentication.AuthenticationTypes
      description: List of authentication types available to the user.
      type: string
    - contextPath: Mimecast.Authentication.EmailAddress
      description: Email address of the request sender.
      type: string
    - contextPath: Mimecast.Authentication.EmailToken
      description: Email token of the request sender.
      type: string
  - arguments: []
    description: Refresh access key validity.
    name: mimecast-refresh-token
  - arguments: []
    description: Login to generate Access Key and  Secret Key.
    name: mimecast-login
  - arguments:
    - description: Message ID.
      name: messageID
      required: true
    - auto: PREDEFINED
      description: 'Defines which copy of the message part to return, must be one
        of: "delivered" the copy that has been processed by the Mimecast MTA with
        policies such as URL rewriting applied, OR "received" - the copy of the message
        that Mimecast originally received. (Only relevant for part argument = message
        or all).'
      name: context
      predefined:
      - DELIVERED
      - RECEIVED
      required: true
    - auto: PREDEFINED
      defaultValue: PLAIN
      description: The message type to return. (Only relevant for part argument =
        message or all).
      name: type
      predefined:
      - HTML
      - PLAIN
      - RFC822
      - TRANSMISSION_MESSAGE_BODY
    - auto: PREDEFINED
      defaultValue: all
      description: Define what message part to return - download message, get metadata
        or both.
      name: part
      predefined:
      - message
      - metadata
      - all
    description: Get the contents or metadata of a given message. This is an archive
      search command.
    name: mimecast-get-message
    outputs:
    - contextPath: Mimecast.Message.ID
      description: Message ID.
      type: string
    - contextPath: Mimecast.Message.Subject
      description: The message subject.
      type: string
    - contextPath: Mimecast.Message.HeaderDate
      description: The date of the message as defined in the message headers.
      type: date
    - contextPath: Mimecast.Message.Size
      description: The message size.
      type: number
    - contextPath: Mimecast.Message.From
      description: Sender of the message as defined in the message header.
      type: string
    - contextPath: Mimecast.Message.To.EmailAddress
      description: Recipient of the message.
      type: string
    - contextPath: Mimecast.Message.ReplyTo
      description: The value of the Reply-To header.
      type: string
    - contextPath: Mimecast.Message.CC.EmailAddress
      description: Each CC recipient of the message.
      type: string
    - contextPath: Mimecast.Message.EnvelopeFrom
      description: Sender of the message as defined in the message envelope.
      type: string
    - contextPath: Mimecast.Message.Headers.Name
      description: Header's name.
      type: string
    - contextPath: Mimecast.Message.Headers.Values
      description: Header's value.
      type: string
    - contextPath: Mimecast.Message.Attachments.FileName
      description: Message attachment's file name.
      type: string
    - contextPath: Mimecast.Message.Attachments.SHA256
      description: Message attachment's SHA256.
      type: string
    - contextPath: Mimecast.Message.Attachments.ID
      description: Message attachment's ID.
      type: string
    - contextPath: Mimecast.Message.Attachments.Size
      description: Message attachment's file size.
      type: number
    - contextPath: Mimecast.Message.Attachments.Extension
      description: Message attachment's file extension.
      type: string
    - contextPath: Mimecast.Message.Processed
      description: The date the message was processed by Mimecast in ISO 8601 format.
      type: date
    - contextPath: Mimecast.Message.HasHtmlBody
      description: If the message has an HTML body part.
      type: boolean
    - contextPath: File.Size
      description: File Size.
      type: number
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: File.Name
      description: The sample name.
      type: string
    - contextPath: File.SSDeep
      description: SSDeep hash of the file.
      type: string
    - contextPath: File.EntryID
      description: War-Room Entry ID of the file.
      type: string
    - contextPath: File.Info
      description: Basic information of the file.
      type: string
    - contextPath: File.Type
      description: File type e.g., "PE".
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - description: The Mimecast ID of the message attachment to return. (Can be retrieved
        from mimecast-get-message).
      name: attachmentID
      required: true
    - description: The Mimecast attachment name. When used, the file name and its
        extension will be included in the context data. Can be retrieved from mimecast-get-message
        command.
      name: attachmentName
    description: Download attachments from a specified message. This is an archive
      search command.
    name: mimecast-download-attachments
    outputs:
    - contextPath: File.Size
      description: File size.
      type: number
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: File.Name
      description: The sample name.
      type: string
    - contextPath: File.SSDeep
      description: SSDeep hash of the file.
      type: string
    - contextPath: File.EntryID
      description: War-Room Entry ID of the file.
      type: string
    - contextPath: File.Info
      description: Basic information of the file.
      type: string
    - contextPath: File.Type
      description: File type e.g., "PE".
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - description: The string to query.
      name: query_string
    - auto: PREDEFINED
      description: The group source by which to filter.
      name: query_source
      predefined:
      - cloud
      - ldap
    - description: The maximum number of results to return.
      name: limit
    description: Returns the list of groups according to the specified query.
    name: mimecast-find-groups
    outputs:
    - contextPath: Mimecast.Group.Name
      description: The name of the group.
      type: String
    - contextPath: Mimecast.Group.Source
      description: The source of the group.
      type: String
    - contextPath: Mimecast.Group.ID
      description: The Mimecast ID of the group.
      type: String
    - contextPath: Mimecast.Group.NumberOfUsers
      description: The number of members in the group.
      type: Number
    - contextPath: Mimecast.Group.ParentID
      description: The Mimecast ID of the group's parent.
      type: String
    - contextPath: Mimecast.Group.NumberOfChildGroups
      description: The number of child groups.
      type: Number
  - arguments:
    - description: The Mimecast ID of the group to return.
      name: group_id
      required: true
    - description: The maximum number of results to return.
      name: limit
    description: Returns the members list for the specified group.
    name: mimecast-get-group-members
    outputs:
    - contextPath: Mimecast.Group.Users.Name
      description: The user's display name.
      type: String
    - contextPath: Mimecast.Group.Users.EmailAddress
      description: The user's email address.
      type: String
    - contextPath: Mimecast.Group.Users.Domain
      description: The domain name of the user's email address.
      type: String
    - contextPath: Mimecast.Group.Users.Type
      description: The user type.
      type: String
    - contextPath: Mimecast.Group.Users.InternalUser
      description: Whether the user is internal.
      type: Boolean
    - contextPath: Mimecast.Group.Users.IsRemoved
      description: Whether the user is part of the group.
      type: Boolean
  - arguments:
    - description: The Mimecast ID of the group to add the user to.
      name: group_id
      required: true
    - description: The email address of the user to add to a group.
      name: email_address
    - description: A domain to add to a group.
      name: domain_address
    description: Adds a user to a group. The email_address and domain_address arguments
      are optional, but one of them must be supplied.
    name: mimecast-add-group-member
    outputs:
    - contextPath: Mimecast.Group.Users.EmailAddress
      description: The user's email address.
      type: String
    - contextPath: Mimecast.Group.Users.IsRemoved
      description: Whether the user is part of the group.
      type: Boolean
  - arguments:
    - description: The Mimecast ID of the group from which to remove the user.
      name: group_id
      required: true
    - description: The email address of the user to remove from the group.
      name: email_address
    - description: A domain of the user to remove from a group.
      name: domain_address
    description: Removes a user from a group. The email_address and domain_address
      arguments are optional, but one of them must be supplied.
    name: mimecast-remove-group-member
    outputs:
    - contextPath: Mimecast.Group.Users.EmailAddress
      description: The user's email address.
      type: String
    - contextPath: Mimecast.Group.Users.IsRemoved
      description: Whether the user part of the group.
      type: Boolean
  - arguments:
    - description: The name of the new group.
      name: group_name
      required: true
    - description: The Mimecast ID of the new group's parent. Default will be root
        level.
      name: parent_id
    description: Creates a new Mimecast group.
    name: mimecast-create-group
    outputs:
    - contextPath: Mimecast.Group.Name
      description: The name of the group.
      type: String
    - contextPath: Mimecast.Group.Source
      description: The source of the group.
      type: String
    - contextPath: Mimecast.Group.ID
      description: The Mimecast ID of the group.
      type: String
    - contextPath: Mimecast.Group.NumberOfUsers
      description: The number of members in the group.
      type: Number
    - contextPath: Mimecast.Group.ParentID
      description: The Mimecast ID of the group's parent.
      type: String
    - contextPath: Mimecast.Group.NumberOfChildGroups
      description: The number of child groups.
      type: Number
  - arguments:
    - description: The new name for the group.
      name: group_name
    - description: The Mimecast ID of the group to update.
      name: group_id
      required: true
    - description: The new parent group.
      name: parent_id
    description: Updates an existing Mimecast group.
    name: mimecast-update-group
    outputs:
    - contextPath: Mimecast.Group.Name
      description: The name of the group.
      type: String
    - contextPath: Mimecast.Group.ID
      description: The Mimecast ID of the group.
      type: String
    - contextPath: Mimecast.Group.ParentID
      description: The Mimecast ID of the group's parent.
      type: String
  - arguments:
    - description: The file hash or messageId value.
      name: hash_message_id
      required: true
    - description: The reason for creating the remediation incident.
      name: reason
      required: true
    - auto: PREDEFINED
      description: The message component by which to search. Default is "hash".
      name: search_by
      predefined:
      - hash
      - messageId
    - description: 'The start date of messages to remediate. Default value is the
        previous month. (Format: yyyy-mm-ddThh:mm:ss+0000).'
      name: start_date
    - description: 'The end date of messages to remediate. Default value is the end
        of the current day. (Format: yyyy-mm-ddThh:mm:ss+0000).'
      name: end_date
    description: Creates a new Mimecast remediation incident.
    name: mimecast-create-remediation-incident
    outputs:
    - contextPath: Mimecast.Incident.ID
      description: The secure Mimecast remediation ID.
      type: String
    - contextPath: Mimecast.Incident.Code
      description: The incident code generated at creation.
      type: String
    - contextPath: Mimecast.Incident.Type
      description: The incident type.
      type: String
    - contextPath: Mimecast.Incident.Reason
      description: The reason provided at the creation of the remediation incident.
      type: String
    - contextPath: Mimecast.Incident.IdentifiedMessages
      description: The number of messages identified based on the search criteria.
      type: Number
    - contextPath: Mimecast.Incident.SuccessfullyRemediatedMessages
      description: The number successfully remediated messages.
      type: Number
    - contextPath: Mimecast.Incident.FailedRemediatedMessages
      description: The number of messages that failed to remediate.
      type: Number
    - contextPath: Mimecast.Incident.MessagesRestored
      description: The number of messages that were restored from the incident.
      type: Number
    - contextPath: Mimecast.Incident.LastModified
      description: The date and time that the incident was last modified.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.From
      description: The sender email address or domain.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.To
      description: The recipient email address or domain.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.MessageID
      description: The message ID used when creating the remediation incident.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.FileHash
      description: The file hash used when creating the remediation incident.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.StartDate
      description: The start date of included messages.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.EndDate
      description: The end date of included messages.
      type: String
  - arguments:
    - description: The Mimecast ID for a remediation incident.
      name: incident_id
      required: true
    description: Returns a Mimecast remediation incident.
    name: mimecast-get-remediation-incident
    outputs:
    - contextPath: Mimecast.Incident.ID
      description: The secure Mimecast remediation ID.
      type: String
    - contextPath: Mimecast.Incident.Code
      description: The incident code generated at creation.
      type: String
    - contextPath: Mimecast.Incident.Type
      description: The incident type.
      type: String
    - contextPath: Mimecast.Incident.Reason
      description: The reason provided when the remediation incident was created.
      type: String
    - contextPath: Mimecast.Incident.IdentifiedMessages
      description: The number of messages identified based on the search criteria.
      type: Number
    - contextPath: Mimecast.Incident.SuccessfullyRemediatedMessages
      description: The number of successfully remediated messages.
      type: Number
    - contextPath: Mimecast.Incident.FailedRemediatedMessages
      description: The number of messages that failed to remediate.
      type: Number
    - contextPath: Mimecast.Incident.MessagesRestored
      description: The number of messages that were restored from the incident.
      type: Number
    - contextPath: Mimecast.Incident.LastModified
      description: The date and time that the incident was last modified.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.From
      description: The sender email address or domain.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.To
      description: The recipient email address or domain.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.MessageID
      description: The message ID used when creating the remediation incident.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.FileHash
      description: The file hash used when creating the remediation incident.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.StartDate
      description: The start date of included messages.
      type: String
    - contextPath: Mimecast.Incident.SearchCriteria.EndDate
      description: The end date of included messages.
      type: String
  - arguments:
    - description: List of file hashes to check if they were seen in an account.
      isArray: true
      name: hashes_to_search
      required: true
    description: Searches for one or more file hashes in the account. Maximum is 100.
    name: mimecast-search-file-hash
    outputs:
    - contextPath: Mimecast.Hash.HashValue
      description: The file hash value.
      type: String
    - contextPath: Mimecast.Hash.Detected
      description: Whether the hash was found in the account.
      type: Boolean
  - arguments:
    - description: The ID of the policy to update.
      name: policy_id
      required: true
    - description: A new description for the policy.
      name: description
    - auto: PREDEFINED
      description: The sender type by which to block senders in the policy. This argument
        must match the fromValue argument. For example, if you specify email_domain,
        the fromValue must be an email domain.
      name: fromType
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - address_attribute_value
      - individual_email_address
      - free_mail_domains
      - header_display_name
    - auto: PREDEFINED
      description: The blocked receiver type by which to block receivers in the policy.
        This argument must match the toValue argument. For example, if you specify
        email_domain, the fromType must be an email domain.
      name: toType
      predefined:
      - everyone
      - internal_addresses
      - external_addresses
      - email_domain
      - profile_group
      - individual_email_address
    - auto: PREDEFINED
      description: The block action.
      name: option
      predefined:
      - no_action
      - block_sender
    - description: The value of the fromType argument. For example, if you specify
        email_domain for fromType, the fromValue must be an email domain.
      name: fromValue
    - description: The value of the toType argument. For example, if you specify email_domain
        for toType, the toValue must be an email domain.
      name: toValue
    - auto: PREDEFINED
      description: The part from where addresses are pulled.
      name: fromPart
      predefined:
      - envelope_from
      - header_from
      - both
    description: Updates the specified policy.
    name: mimecast-update-policy
    outputs:
    - contextPath: Mimecast.Policy.ID
      description: Policy ID.
      type: string
    - contextPath: Mimecast.Policy.Sender.Address
      description: Block sender by email address value.
      type: string
    - contextPath: Mimecast.Policy.Sender.Domain
      description: Block sender by domain value.
      type: string
    - contextPath: Mimecast.Policy.Sender.Group
      description: Block sender by group value.
      type: string
    - contextPath: Mimecast.Policy.Bidirectional
      description: Whether the blocked policy is bidirectional.
      type: boolean
    - contextPath: Mimecast.Policy.Receiver.Address
      description: Block emails to receiver type address.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Domain
      description: Block emails to receiver type domain.
      type: string
    - contextPath: Mimecast.Policy.Receiver.Group
      description: Block emails to receiver type group.
      type: string
    - contextPath: Mimecast.Policy.Fromdate
      description: The policy validation start date.
      type: date
    - contextPath: Mimecast.Policy.Todate
      description: The policy expiration date.
      type: date
    - contextPath: Mimecast.Policy.Sender.Type
      description: The sender type.
      type: String
    - contextPath: Mimecast.Policy.Receiver.Type
      description: The receiver type.
      type: String
  - arguments:
    - description: Reason for tracking the email.
      name: search_reason
      predefined:
      - ""
    - description: API start parameter. Datetime format is ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: from_date
      predefined:
      - ""
    - description: API end parameter  Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: to_date
      predefined:
      - ""
    - description: The internet message ID of the message to track.
      name: message_id
      predefined:
      - ""
    - description: 'Part of advancedTrackAndTraceOptions object: The sending email
        address or domain of the messages to track.'
      name: from
      predefined:
      - ""
    - description: 'Part of advancedTrackAndTraceOptions object: The recipient email
        address or domain of the messages to track.'
      name: to
      predefined:
      - ""
    - description: 'Part of advancedTrackAndTraceOptions object: The subject of the
        messages to track.'
      name: subject
      predefined:
      - ""
    - description: 'Part of advancedTrackAndTraceOptions object: The source IP address
        of the messages to track.'
      name: sender_ip
      predefined:
      - ""
    - auto: PREDEFINED
      description: A comma-separated list of routes to filter by.
      isArray: true
      name: route
      predefined:
      - internal
      - outbound
      - inbound
    description: Searches a message.
    name: mimecast-search-message
    outputs:
    - contextPath: Mimecast.SearchMessage.info
      description: Info regarding the message.
      type: String
    - contextPath: Mimecast.SearchMessage.id
      description: The Mimecast ID of the message. Used to load more information about
        the message.
      type: String
    - contextPath: Mimecast.SearchMessage.status
      description: The status of the message.
      type: String
    - contextPath: Mimecast.SearchMessage.fromEnv.emailAddress
      description: The email address of the sender.
      type: String
    - contextPath: Mimecast.SearchMessage.fromHdr.displayableName
      description: The display name of the recipient.
      type: String
    - contextPath: Mimecast.SearchMessage.fromHdr.emailAddress
      description: The email address of the recipient.
      type: String
    - contextPath: Mimecast.SearchMessage.to.displayableName
      description: The display name of the recipient.
      type: String
    - contextPath: Mimecast.SearchMessage.to.emailAddress
      description: The email address of the recipient.
      type: String
    - contextPath: Mimecast.SearchMessage.received
      description: The date and time the message was received by Mimecast.
      type: Date
    - contextPath: Mimecast.SearchMessage.subject
      description: The subject of the message.
      type: String
    - contextPath: Mimecast.SearchMessage.senderIP
      description: The source IP address of the message.
      type: String
    - contextPath: Mimecast.SearchMessage.attachments
      description: If the message has attachments.
      type: Boolean
    - contextPath: Mimecast.SearchMessage.route
      description: The route of the message.
      type: String
    - contextPath: Mimecast.SearchMessage.sent
      description: The date and time that the message was sent / processed by Mimecast.
      type: Date
    - contextPath: Mimecast.SearchMessage.spamScore
      description: Spam score of the email.
      type: Number
    - contextPath: Mimecast.SearchMessage.detectionLevel
      description: Detection level of the email.
      type: String
  - arguments:
    - description: A comma-separated list of the Mimecast IDs of the messages to load.
        This is returned by the /api/message-finder/search endpoint. (mimecast-search-message
        command).
      isArray: true
      name: ids
      predefined:
      - ""
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: When argument is true all data from recipientInfo object is presented
        at command response.
      name: show_recipient_info
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: When argument is true all data from deliveredMessage object is
        presented at command response.
      name: show_delivered_message
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: When argument is true all data from retentionInfo object is presented
        at command response.
      name: show_retention_info
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: When argument is true all spamInfo block is presented at command
        response.
      name: show_spam_info
      predefined:
      - "true"
      - "false"
    description: Retrieves detailed information about a specific message.
    name: mimecast-get-message-info
    outputs:
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.extension
      description: Component extension type.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.hash
      description: Component hash.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.mimeType
      description: Component MIME type.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.name
      description: Component name.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.size
      description: Component size.
      type: Number
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.components.type
      description: Component type.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.deliveryEvent
      description: Description of delivery event.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.emailAddress
      description: Email address of recipient.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.encryptionInfo
      description: Encryption type.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.messageExpiresIn
      description: Expiration time of message.
      type: Number
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.processingServer
      description: Processing server address.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.receiptAcknowledgement
      description: Recipient acknowledgement.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.remoteHost
      description: Remote host address.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.remoteIp
      description: Remote IP address.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.remoteServerGreeting
      description: Remote server greeting.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.transmissionEnd
      description: Transmission end date.
      type: Date
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.transmissionSize
      description: Transmission size.
      type: Number
    - contextPath: Mimecast.MessageInfo.deliveredMessage.deliveryMetaInfo.transmissionStart
      description: Transmission start date.
      type: Date
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.fromEnvelope
      description: Sender mail. (From envelope).
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.fromHeader
      description: Sender mail. (From header).
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.processed
      description: Processed time and date.
      type: Date
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.route
      description: Message route.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.sent
      description: Message sent time and date.
      type: Date
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.subject
      description: Message subject.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.to
      description: Recipients info.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.messageInfo.transmissionInfo
      description: Transmission info.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.policyInfo.inherited
      description: Whether policy is inherited.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.deliveredMessage.policyInfo.policyName
      description: Policy name.
      type: String
    - contextPath: Mimecast.MessageInfo.deliveredMessage.policyInfo.policyType
      description: Policy type.
      type: String
    - contextPath: Mimecast.MessageInfo.id
      description: Message ID.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.binaryEmailSize
      description: Email size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.extension
      description: Component extension type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.hash
      description: Component hash.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.mimeType
      description: Component MIME type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.name
      description: Component name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.size
      description: Component size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.components.type
      description: Component type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.encryptionInfo
      description: Encryption information.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.fromEnvelope
      description: The routable email address (From envelope).
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.fromHeader
      description: The routable email address (From header).
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.messageExpiresIn
      description: Expiry time of message.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.processed
      description: Message processed time.
      type: Date
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.processingServer
      description: Message processing server.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.receiptAcknowledgement
      description: Recipient acknowledgement.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.receiptEvent
      description: Receipt event name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.remoteHost
      description: Remote host address.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.remoteIp
      description: Remote IP address.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.remoteServerGreeting
      description: Remote server greeting.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.sent
      description: Message send time and date.
      type: Date
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.spamEvent
      description: Spam event name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.subject
      description: Message subject.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.to
      description: Recipient info.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.transmissionEnd
      description: Transmission end date.
      type: Date
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.transmissionInfo
      description: Transmission info.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.transmissionSize
      description: Transmission size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.messageInfo.transmissionStart
      description: Transmission start date.
      type: Date
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.binaryEmailSize
      description: Email size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.extension
      description: Component extension type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.hash
      description: Component hash type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.mimeType
      description: Component MIME type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.name
      description: Component name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.size
      description: Component size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.components.type
      description: Component type.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.encryptionInfo
      description: Encryption information.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.messageExpiresIn
      description: Expiration time of message.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.processingServer
      description: Processing server address.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.receiptAcknowledgement
      description: Recipient acknowledgement.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.receiptEvent
      description: Receipt event name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.remoteHost
      description: Remote host address.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.remoteIp
      description: Remote IP address.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.remoteServerGreeting
      description: Remote server greeting.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.spamEvent
      description: Spam event name.
      type: String
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.transmissionEnd
      description: Transmission end date.
      type: Date
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.transmissionSize
      description: Transmission size.
      type: Number
    - contextPath: Mimecast.MessageInfo.recipientInfo.recipientMetaInfo.transmissionStart
      description: Transmission start date.
      type: Date
    - contextPath: Mimecast.MessageInfo.retentionInfo.currentPurgeDate
      description: Current purge date and time.
      type: Date
    - contextPath: Mimecast.MessageInfo.retentionInfo.originalPurgeDate
      description: Original purge date and time.
      type: Date
    - contextPath: Mimecast.MessageInfo.retentionInfo.purgeBasedOn
      description: Value that purge is based on.
      type: String
    - contextPath: Mimecast.MessageInfo.retentionInfo.retentionAdjustmentDays
      description: Retention adjustment days.
      type: Number
    - contextPath: Mimecast.MessageInfo.spamInfo.detectionLevel
      description: Spam detection level.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.dkim.allow
      description: Is DomainKeys Identified Mail (DKIM) allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.dkim.info
      description: DKIM info.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.dmarc.allow
      description: Is Domain-based Message Authentication, Reporting & Conformance
        (DMARC) allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.dmarc.info
      description: DMARC info.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.greyEmail
      description: Is grey email allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.managedSender.allow
      description: Is Managed Sender allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.managedSender.info
      description: Managed Sender info.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.permittedSender.allow
      description: Is Permitted Sender allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.permittedSender.info
      description: Permitted Sender info.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.rbl.allow
      description: Is Real-time blackhole list (RBL) allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.rbl.info
      description: RBL info.
      type: String
    - contextPath: Mimecast.MessageInfo.spamInfo.spamScore
      description: Spam score.
      type: Number
    - contextPath: Mimecast.MessageInfo.spamInfo.spf.allow
      description: Is Sender Policy Framework (SPF) allowed.
      type: Boolean
    - contextPath: Mimecast.MessageInfo.spamInfo.spf.info
      description: SPF info.
      type: String
    - contextPath: Mimecast.MessageInfo.status
      description: Message status.
      type: String
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether only results for the currently authenticated user will
        be returned.
      name: admin
      predefined:
      - "true"
      - "false"
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: from_date
      predefined:
      - ""
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: to_date
      predefined:
      - ""
    - description: Free text to filter results by.
      name: value
      predefined:
      - ""
    - auto: PREDEFINED
      description: Message fields to filter based on.
      name: field_name
      predefined:
      - all
      - subject
      - sender
      - recipient
      - reason_code
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: The maximum number of results to return.
      name: limit
      predefined:
      - ""
    description: Get information about held messages, including the reason, hold level,
      sender and recipients.
    name: mimecast-list-held-message
    outputs:
    - contextPath: Mimecast.HeldMessage.dateReceived
      description: The timestamp of the message transmission.
      type: Date
    - contextPath: Mimecast.HeldMessage.from.displayableName
      description: The sender name.
      type: String
    - contextPath: Mimecast.HeldMessage.from.emailAddress
      description: The sender email.
      type: String
    - contextPath: Mimecast.HeldMessage.fromHeader.displayableName
      description: The display name of the sender (From header).
      type: String
    - contextPath: Mimecast.HeldMessage.fromHeader.emailAddress
      description: The email address of the sender (From header).
      type: String
    - contextPath: Mimecast.HeldMessage.hasAttachments
      description: Returns true if the message contains attachments. False indicates
        no attachments.
      type: Boolean
    - contextPath: Mimecast.HeldMessage.id
      description: The Mimecast secure ID for a message.
      type: String
    - contextPath: Mimecast.HeldMessage.policyInfo
      description: Information or definition name triggering the message hold action.
      type: String
    - contextPath: Mimecast.HeldMessage.reason
      description: The summary reason for holding the message.
      type: String
    - contextPath: Mimecast.HeldMessage.reasonCode
      description: Reason code for holding the message.
      type: String
    - contextPath: Mimecast.HeldMessage.reasonId
      description: Mirrors the reason field, formatted without spaces. However, reasonCode
        should be used instead.
      type: String
    - contextPath: Mimecast.HeldMessage.route
      description: 'Direction of message being held. Possible values are: INBOUND,
        OUTBOUND, INTERNAL, EXTERNAL.'
      type: String
    - contextPath: Mimecast.HeldMessage.size
      description: The size of the message in bytes.
      type: Number
    - contextPath: Mimecast.HeldMessage.subject
      description: The message subject.
      type: String
    - contextPath: Mimecast.HeldMessage.to.displayableName
      description: The display name of the recipient.
      type: String
    - contextPath: Mimecast.HeldMessage.to.emailAddress
      description: The email address of the recipient.
      type: String
  - arguments: []
    description: Get counts of currently held messages for each hold reason.
    name: mimecast-held-message-summary
    outputs:
    - contextPath: Mimecast.HeldMessageSummary.numberOfItems
      description: The number of messages currently held for this reason.
      type: Number
    - contextPath: Mimecast.HeldMessageSummary.policyInfo
      description: The name of the policy or definition that held a message.
      type: String
  - arguments:
    - description: A comma-separated list of Mimecast secure IDs IDs are extracted
        from the mimecast-list-held-message command.
      isArray: true
      name: ids
      predefined:
      - ""
      required: true
    - description: Rejection message to be returned to the sender.
      name: message
      predefined:
      - ""
    - auto: PREDEFINED
      description: User can choose reason.
      name: reason_type
      predefined:
      - MESSAGE CONTAINS UNDESIRABLE CONTENT,MESSAGE CONTAINS CONFIDENTIAL INFORMATION,REVIEWER
        DISAPPROVES OF CONTENT.
      - INAPPROPRIATE COMMUNICATIONMESSAGE GOES AGAINST EMAIL POLICIES
      - ""
    - auto: PREDEFINED
      description: Whether to deliver rejection notificationd.
      name: notify
      predefined:
      - "true"
      - "false"
    description: Reject a currently held message.
    name: mimecast-reject-held-message
  - arguments:
    - description: Mimecast secure ID. ID can be extracted from the mimecast-list-held-message
        command.
      name: id
      predefined:
      - ""
      required: true
    description: Release a currently held message.
    name: mimecast-release-held-message
  - arguments:
    - auto: PREDEFINED
      description: The method used to sort the messages.
      name: sort_order
      predefined:
      - asc
      - desc
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: from_date
      predefined:
      - ""
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: to_date
      predefined:
      - ""
    - description: The search value to be used.
      name: value
      predefined:
      - ""
    - auto: PREDEFINED
      description: The field to be searched.
      name: field_name
      predefined:
      - ALL
      - fromAddress
      - toAddress
      - subject
      - info
      - remoteIp
    - description: The presence of an attachment in the message.
      name: attachments
      predefined:
      - ""
    - auto: PREDEFINED
      description: The message route.
      name: route
      predefined:
      - all
      - internal
      - outbound
      - inbound
      - external
    - description: Number of results per page to display.
      name: page_size
      predefined:
      - ""
    - description: Page number you would like to view. Each page contains page_size
        values. Must be used along with page_size.
      name: page
      predefined:
      - ""
    - description: The maximum number of results to return.
      name: limit
      predefined:
      - ""
    description: Return messages currently being processed by Mimecast. Note that
      most of the time, no results are returned.
    name: mimecast-search-processing-message
    outputs:
    - contextPath: Mimecast.ProcessingMessage.messages.id
      description: The Mimecast secure ID of the message.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.fromEnv.emailAddress
      description: The routable email address (From evelope).
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.fromHeader.emailAddress
      description: The routable email address (From header).
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.to.emailAddress
      description: The routable email address.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.subject
      description: The message subject.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.attachment
      description: Whether there is an attachment in the message.
      type: Boolean
    - contextPath: Mimecast.ProcessingMessage.messages.routing
      description: The directional route of the message. Possible values are internal,
        outbound, inbound or external.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.size
      description: The size of the message in bytes.
      type: Number
    - contextPath: Mimecast.ProcessingMessage.messages.remoteIp
      description: The connecting IP address.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.attempts
      description: The number of processing attempts of the message.
      type: Number
    - contextPath: Mimecast.ProcessingMessage.messages.nextAttempt
      description: The date of the next process attempt for the message.
      type: Date
    - contextPath: Mimecast.ProcessingMessage.messages.created
      description: The date of the processing request creation.
      type: Date
    - contextPath: Mimecast.ProcessingMessage.messages.info
      description: Current processing status of the message.
      type: String
    - contextPath: Mimecast.ProcessingMessage.messages.priority
      description: Message priority.
      type: String
  - arguments:
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: from_date
      predefined:
      - ""
      required: true
    - description: Datetime format ISO 8601. e.g., 2022-07-11T14:49:18+0000.
      name: to_date
      predefined:
      - ""
      required: true
    description: Get the count of the inbound and outbound email queues at specified
      times.
    name: mimecast-list-email-queues
    outputs:
    - contextPath: Mimecast.EmailQueue.inboundEmailQueue.count
      description: The number of inbound messages currently queued.
      type: Number
    - contextPath: Mimecast.EmailQueue.inboundEmailQueue.date
      description: The date for the displayed number of messages.
      type: Date
    - contextPath: Mimecast.EmailQueue.outboundEmailQueue.count
      description: The number of outbound messages currently queued.
      type: Number
    - contextPath: Mimecast.EmailQueue.outboundEmailQueue.date
      description: The date for the displayed number of messages.
      type: Date
  dockerimage: demisto/python3:3.10.13.84405
  isfetch: true
  runonce: false
  script: |
    register_module_line('MimecastV2', 'start', __line__())
    ### pack version: 2.2.6




    ''' IMPORTS '''

    import hmac
    import uuid
    import json
    import base64
    import hashlib
    import requests

    from datetime import timedelta
    from urllib.error import HTTPError
    from xml.etree import ElementTree


    ''' GLOBALS/PARAMS '''

    BASE_URL = demisto.params().get('baseUrl')
    ACCESS_KEY = demisto.params().get('accessKey')
    SECRET_KEY = demisto.params().get('secretKey') or demisto.params().get('secretKey_creds', {}).get('password', '')
    APP_ID = demisto.params().get('appId')
    APP_KEY = demisto.params().get('appKey') or demisto.params().get('appKey_creds', {}).get('password', '')
    USE_SSL = None  # assigned in determine_ssl_usage
    PROXY = bool(demisto.params().get('proxy'))
    # Flags to control which type of incidents are being fetched
    FETCH_PARAMS = argToList(demisto.params().get('incidentsToFetch'))
    FETCH_ALL = 'All' in FETCH_PARAMS
    FETCH_URL = 'Url' in FETCH_PARAMS or FETCH_ALL
    FETCH_ATTACHMENTS = 'Attachments' in FETCH_PARAMS or FETCH_ALL
    FETCH_IMPERSONATIONS = 'Impersonation' in FETCH_PARAMS or FETCH_ALL
    FETCH_HELD_MESSAGES = 'Held Messages' in FETCH_PARAMS or FETCH_ALL
    # Used to refresh token / discover available auth types / login
    EMAIL_ADDRESS = demisto.params().get('email') or demisto.params().get('credentials', {}).get('identifier', '')
    PASSWORD = demisto.params().get('password') or demisto.params().get('credentials', {}).get('password', '')
    FETCH_DELTA = int(demisto.params().get('fetchDelta', 24))


    LOG(f"command is {demisto.command()}")

    # default query xml template for test module
    default_query_xml = "<?xml version=\"1.0\"?> \n\
        <xmlquery trace=\"iql,muse\">\n\
        <metadata query-type=\"emailarchive\" archive=\"true\" active=\"false\" page-size=\"25\" startrow=\"0\">\n\
            <smartfolders/>\n\
            <return-fields>\n\
                <return-field>attachmentcount</return-field>\n\
                <return-field>status</return-field>\n\
                <return-field>subject</return-field>\n\
                <return-field>size</return-field>\n\
                <return-field>receiveddate</return-field>\n\
                <return-field>displayfrom</return-field>\n\
                <return-field>id</return-field>\n\
                <return-field>displayto</return-field>\n\
                <return-field>smash</return-field>\n\
            </return-fields>\n\
        </metadata>\n\
        <muse>\n\
            <text></text>\n\
            <date select=\"last_year\"/>\n\
            <sent></sent>\n\
            <docs select=\"optional\"></docs>\n\
            <route/>\n\
        </muse>\n\
    </xmlquery>"

    ''' API COMMUNICATION FUNCTIONS'''


    def request_with_pagination(api_endpoint: str, data: list, response_param: str = None, limit: int = 100,
                                page: int = None,
                                page_size: int = None, use_headers: bool = False, is_file: bool = False):
        """

        Creates paging response for relevant commands.

        """
        headers = None
        if page and page_size:
            limit = page * page_size
        pagination = {'page_size': limit}
        payload = {
            'meta': {
                'pagination': pagination
            },
            'data': data
        }  # type: Dict[str, Any]

        if use_headers:
            headers = generate_user_auth_headers(api_endpoint)
        response = http_request('POST', api_endpoint, payload, headers=headers, is_file=is_file)

        next_page = str(response.get('meta', {}).get('pagination', {}).get('next', ''))
        len_of_results = 0
        results = []
        while True:
            if response.get('fail'):
                raise Exception(json.dumps(response.get('fail')[0].get('errors')))
            if response_param:
                response_data = response.get('data')[0].get(response_param)
            else:
                response_data = response.get('data')
            for entry in response_data:
                # If returning this log will not exceed the specified limit
                if not limit or len_of_results < limit:
                    len_of_results += 1
                    results.append(entry)
            # If limit is reached or there are no more pages
            if not next_page or (limit and len_of_results >= limit):
                break
            pagination = {'page_size': page_size,  # type: ignore
                          'pageToken': next_page}  # type: ignore
            payload['meta']['pagination'] = pagination
            response = http_request('POST', api_endpoint, payload, headers=headers)
            next_page = str(response.get('meta', {}).get('pagination', {}).get('next', ''))
        if page and page_size:
            return results[(-1 * page_size):], page_size

        return results, len_of_results


    def http_request(method, api_endpoint, payload=None, params={}, user_auth=True, is_file=False, headers=None):
        is_user_auth = True
        url = BASE_URL + api_endpoint
        # 2 types of auth, user and non user, mostly user is needed
        if user_auth:
            headers = headers or generate_user_auth_headers(api_endpoint)

        else:
            # This type of auth is only supported for basic commands: login/discover/refresh-token
            is_user_auth = False
            auth = base64.b64encode((EMAIL_ADDRESS + ':' + PASSWORD).encode("utf-8")).decode()
            auth_type = 'Basic-Cloud'
            auth_header = auth_type + ' ' + auth
            headers = {
                'x-mc-app-id': APP_ID,
                'Content-Type': 'application/json',
                'Authorization': auth_header
            }

        LOG('running {} request with url={}\tparams={}\tdata={}\tis user auth={}'.format(
            method, url, json.dumps(params), json.dumps(payload), is_user_auth))
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                headers=headers,
                json=payload
            )

            res.raise_for_status()
            if is_file:
                return res
            return res.json()

        except HTTPError as e:
            LOG(e)
            if e.response.status_code == 418:  # type: ignore  # pylint: disable=no-member
                if not APP_ID or not EMAIL_ADDRESS or not PASSWORD:
                    raise Exception(
                        'Credentials provided are expired, could not automatically refresh tokens.'
                        ' App ID + Email Address '
                        '+ Password are required.')
            else:
                raise

        except Exception as e:
            LOG(e)
            raise


    def search_message_request(args):
        """
        Builds payload for the request of search message command.
        Args:
            args: arguments given to command.

        Returns: the payload to be sent to the API.

        """
        search_reason = args.get('search_reason')
        from_date = arg_to_datetime(args.get('from_date')).isoformat() if args.get('from_date') else None  # type: ignore
        to_date = arg_to_datetime(args.get('to_date')).isoformat() if args.get('to_date') else None  # type: ignore
        message_id = args.get('message_id')
        advanced = {
            'senderIP': args.get('sender_ip'),
            'to': args.get('to'),
            'from': args.get('from'),
            'subject': args.get('subject'),
            'route': args.get('route')
        }
        advanced_is_none = all(value is None for value in advanced.values())
        payload = {'data': [
            {
                'start': from_date,
                'end': to_date,
                'searchReason': search_reason
            }
        ]}
        if advanced_is_none and message_id is None:
            raise Exception('Advanced Track And Trace Options or message ID must be given in order to execute the command.')
        elif advanced_is_none:
            payload.get('data')[0].update({'messageId': message_id})  # type: ignore
        elif message_id is None:
            payload.get('data')[0].update({'advancedTrackAndTraceOptions': advanced})  # type: ignore
        else:
            raise Exception('Only one of message id and advance options can contain value.')

        return http_request(method='POST',
                            api_endpoint='/api/message-finder/search',
                            payload=payload)


    def get_message_info_request(id):
        """

        Builds payload for the request of get message info command.
        Args:
            args: arguments given to command.

        Returns: the payload to be sent to the API.


        """

        payload = {
            'data': [
                {
                    'id': id
                }
            ]
        }
        return http_request(method='POST',
                            api_endpoint='/api/message-finder/get-message-info',
                            payload=payload)


    def list_held_messages_request(args):
        """

            Builds payload for the request of list hold messages command.
            Args:
                args: arguments given to command.

            Returns: the payload to be sent to the API.


            """
        admin = argToBoolean(args.get('admin'))
        from_date = arg_to_datetime(args.get('from_date')).isoformat() if args.get('from_date') else None  # type: ignore
        to_date = arg_to_datetime(args.get('to_date')).isoformat() if args.get('to_date') else None  # type: ignore
        value = args.get('value', '')
        field_name = args.get('field_name', '')
        limit = arg_to_number(args.get('limit')) or 20
        page = arg_to_number(args.get('page'))
        page_size = arg_to_number(args.get('page_size'))
        data = [
            {
                'admin': admin,
                'start': from_date,
                'end': to_date
            }
        ]
        if field_name or value:
            data[0].update({'searchBy': {
                'fieldName': field_name,
                'value': value
            }})
        return request_with_pagination(api_endpoint='/api/gateway/get-hold-message-list',
                                       data=data,
                                       limit=limit,
                                       page=page,
                                       page_size=page_size)


    def reject_held_message_request(args):
        """

            Builds payload for the request of reject hold messages command.
            Args:
                args: arguments given to command.

            Returns: the payload to be sent to the API.


        """
        ids = argToList(args.get('ids'))
        message = args.get('message')
        reason_type = args.get('reason_type')
        notify = argToBoolean(args.get('notify'))
        payload = {'data': [
            {
                'message': message,
                'ids': ids,
                'reasonType': reason_type,
                'notify': notify
            }
        ]
        }
        return http_request('POST',
                            api_endpoint='/api/gateway/hold-reject',
                            payload=payload)


    def release_held_message_request(id):
        """

          Builds payload for the request of release hold messages command.
          Args:
              args: arguments given to command.

          Returns: the payload to be sent to the API.

          """
        payload = {
            'data': [
                {
                    'id': id
                }
            ]
        }
        return http_request('POST',
                            api_endpoint='/api/gateway/hold-release',
                            payload=payload)


    def search_processing_message_request(args):
        """

          Builds payload for the request of search processing message command.
          Args:
              args: arguments given to command.

          Returns: the payload to be sent to the API.

          """
        sort_order = args.get('sort_order')
        from_date = arg_to_datetime(args.get('from_date')).isoformat() if args.get('from_date') else None  # type: ignore
        to_date = arg_to_datetime(args.get('to_date')).isoformat() if args.get('to_date') else None  # type: ignore
        attachments = argToBoolean(args.get('attachments')) if args.get('attachments') else None
        value = args.get('value')
        field_name = args.get('field_name')
        route = args.get('route')
        limit = arg_to_number(args.get('limit')) or 20
        page = arg_to_number(args.get('page'))
        page_size = arg_to_number(args.get('page_size'))
        data = [
            {
                'sortOrder': sort_order,
            }
        ]
        if to_date:
            data[0].update({'end': to_date})
        if from_date:
            data[0].update({'start': from_date})
        if value or field_name:
            data[0].update({'searchBy': {
                'fieldName': field_name,
                'value': value
            }})
        if attachments or route:
            data[0].update({'filterBy': [
                {
                    'attachments': attachments,
                    'route': route
                }
            ]})
        return request_with_pagination(api_endpoint='/api/gateway/find-processing-messages',
                                       data=data,
                                       response_param='messages',
                                       limit=limit,
                                       page=page,
                                       page_size=page_size)


    def list_email_queues_request(args):
        """

          Builds payload for the request of list email queues command.
          Args:
              args: arguments given to command.

          Returns: the payload to be sent to the API.

          """

        from_date = arg_to_datetime(args.get('from_date')).isoformat() if args.get('from_date') else None  # type: ignore
        to_date = arg_to_datetime(args.get('to_date')).isoformat() if args.get('to_date') else None  # type: ignore
        payload = {'data': [{
            'start': from_date,
            'end': to_date
        }]}

        return http_request('POST',
                            api_endpoint='/api/email/get-email-queues',
                            payload=payload)


    ''' HELPER FUNCTIONS '''


    def determine_ssl_usage():
        global USE_SSL

        old_insecure = demisto.params().get('insecure', None)
        if old_insecure:
            USE_SSL = bool(old_insecure)
            return

        USE_SSL = not demisto.params().get('new_insecure')


    def epoch_seconds(d=None):
        """
        Return the number of seconds for given date. If no date, return current.
        """
        if not d:
            d = datetime.utcnow()
        return int((d - datetime.utcfromtimestamp(0)).total_seconds())


    def auto_refresh_token():
        """
        Check if we have a valid token, if not automatically renew validation time for 3 days when necessary params are provided
        """
        if APP_ID and EMAIL_ADDRESS and PASSWORD:
            integration_context = demisto.getIntegrationContext()
            last_update_ts = integration_context.get('token_last_update')
            current_ts = epoch_seconds()
            if (last_update_ts and current_ts - last_update_ts > 60 * 60 * 24 * 3 - 1800) or last_update_ts is None:
                refresh_token_request()
                current_ts = epoch_seconds()
                demisto.setIntegrationContext({'token_last_update': current_ts})


    def generate_user_auth_headers(api_endpoint):
        # type: (str) -> dict
        """
            Generate headers for a request
            Args:
                api_endpoint: The request's endpoint

            Returns:
                A dict of headers for the request
            """
        # Generate request header values
        request_id = str(uuid.uuid4())
        hdr_date = datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S") + " UTC"

        # DataToSign is used in hmac_sha1
        dataToSign = ':'.join([hdr_date, request_id, api_endpoint, APP_KEY])

        # Create the HMAC SHA1 of the Base64 decoded secret key for the Authorization header
        hmac_sha1 = hmac.new(base64.b64decode(SECRET_KEY), dataToSign.encode(), digestmod=hashlib.sha1).digest()

        # Use the HMAC SHA1 value to sign the hdrDate + ":" requestId + ":" + URI + ":" + appkey
        signature = base64.b64encode(hmac_sha1).rstrip()
        # Create request headers
        headers = {
            'Authorization': 'MC ' + ACCESS_KEY + ':' + signature.decode(),
            'x-mc-app-id': APP_ID,
            'x-mc-date': hdr_date,
            'x-mc-req-id': request_id,
            'Content-Type': 'application/json'
        }
        return headers


    def parse_query_args(args):
        query_xml = default_query_xml
        if args.get('pageSize'):
            query_xml = query_xml.replace('page-size=\"25\"', 'page-size=\"' + args.get('pageSize') + '\"')
        if args.get('startRow'):
            query_xml = query_xml.replace('startrow=\"0\"', 'startrow=\"' + args.get('startRow') + '\"')
        if args.get('active') == 'true':
            query_xml = query_xml.replace('active=\"false\"', 'active=\"true\"')
        if args.get('body'):
            query_xml = query_xml.replace('<text></text>', '<text>(body: ' + args.get('body') + ')</text>')
        if args.get('subject'):
            query_xml = query_xml.replace('<text></text>', '<text>(subject: ' + args.get('subject') + ')</text>')
        if args.get('text'):
            query_xml = query_xml.replace('<text></text>', '<text>' + args.get('text') + '</text>')
        if args.get('date'):
            query_xml = query_xml.replace('<date select=\"last_year\"/>', '<date select=\"' + args.get('date') + '\"/>')

            if args.get('dateTo') or args.get('dateFrom'):
                raise Exception('Cannot use both date and dateFrom/dateTo arguments')

        date_to = ""
        date_from = ""

        if args.get('dateTo'):
            date_to = args.get('dateTo')
        if args.get('dateFrom'):
            date_from = args.get('dateFrom')
        if date_to and date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>',
                                          '<date select=\"between\" from=\"' + date_from + '\" to=\"' + date_to + '\" />')
        elif date_from:
            query_xml = query_xml.replace('<date select=\"last_year\"/>',
                                          '<date select=\"between\" from=\"' + date_from + '\" />')
        elif date_to:
            query_xml = query_xml.replace('<date select=\"last_year\"/>',
                                          '<date select=\"between\" to=\"' + date_to + '\" />')

        if args.get('sentFrom'):
            query_xml = query_xml.replace('<sent></sent>', '<sent select=\"from\" >' + args.get('sentFrom') + '</sent>')
        if args.get('sentTo'):
            query_xml = query_xml.replace('<sent></sent>', '<sent select=\"to\" >' + args.get('sentTo') + '</sent>')
        query_xml = query_xml.replace('<sent></sent>', '')  # no empty tag
        if args.get('attachmentText'):
            query_xml = query_xml.replace('</docs>', args.get('attachmentText') + '</docs>')
        if args.get('attachmentType'):
            query_xml = query_xml.replace('<docs select=\"optional\">',
                                          '<docs select=\"' + args.get('attachmentType') + '\">')

        return query_xml


    def build_recipient_info(recipient_info: dict):
        """
        Builds markdown table for recipient info part of the response for get-message-info command

        """
        message_info = recipient_info.get('messageInfo', {})
        meta_info = recipient_info.get('recipientMetaInfo', {})
        message_info.update(meta_info)

        headers = {'fromEnv': 'From (Header)',
                   'remoteIp': 'Remote Ip',
                   'senderIP': 'IP Address',
                   'remoteHost': 'Remote Host',
                   'encryptionInfo': 'Recipient Encryption Info'}
        return tableToMarkdown('Recipient Info', t=message_info,
                               headerTransform=lambda header: headers.get(
                                   header) if header in headers else header.capitalize(), removeNull=True,
                               headers=['fromHeader', 'subject', 'sent', 'remoteIp', 'remoteHost', 'encryptionInfo'])


    def build_delivered_message(delivered_messgae: dict, to: List):
        """
        Builds markdown table for delivered message part of the response for get-message-info command
        Args:
            to: list of recipients that received the message.


        """
        markdown_per_recipient = '### Delivered Message Info\n'
        for to_mail in to:
            delivered = delivered_messgae.get(to_mail, {})
            message_info = delivered.get('messageInfo', {})
            to_cc_transformer = JsonTransformer(func=lambda data: ', '.join(data))
            table_json_transformer = {'to': to_cc_transformer,
                                      'cc': to_cc_transformer
                                      }
            markdown_per_recipient += tableToMarkdown(to_mail, t=message_info,
                                                      headerTransform=lambda header: header.capitalize(),
                                                      json_transform_mapping=table_json_transformer,
                                                      removeNull=True,
                                                      headers=['to', 'cc', 'subject', 'sent'])

        return markdown_per_recipient


    def build_retention_info(retention_info: dict):
        """
        Builds markdown table for retention info part of the response for get-message-info command
        """
        arr_transformer = JsonTransformer(func=lambda arr: ', '.join(arr))
        table_json_transformer = {'litigationHoldInfo': arr_transformer,
                                  'fbrStamps': arr_transformer,
                                  'smartTags': arr_transformer,
                                  'fbrExpireCheck': arr_transformer,
                                  'audits': arr_transformer
                                  }

        return tableToMarkdown('Retention Info', t=retention_info,
                               headerTransform=string_to_table_header,
                               json_transform_mapping=table_json_transformer,
                               removeNull=True)


    def build_spam_info(spam_info: dict):
        """
        Builds markdown table for spam info part of the response for get-message-info command

        """
        spam_processing_detail = spam_info.get('spamProcessingDetail', {})
        spam_info.update(spam_processing_detail)
        spam_info.pop('spamProcessingDetail', None)

        headers = {'spamScore': 'Spam Score',
                   'detectionLevel': 'Spam Detection Level',
                   'permittedSender': 'PermittedSender'
                   }
        return tableToMarkdown('Spam Info', t=spam_info,
                               headerTransform=lambda header: headers.get(
                                   header) if header in headers else header.capitalize(),
                               removeNull=True,
                               )


    def transformer_get_value(value):
        """
        Returns a transformer function to use in table_to_markdown function to get a value from a dict in a cell.
        Args:
            value: the value key to get his value from the dict.

        Returns: transformer function

        """

        def transformer(dict_value):
            return dict_value.get(value)

        return transformer


    def build_get_message_info_outputs(outputs: dict):
        """

        Args:
            response: response from API

        Returns: outputs dictionary without dynamic keys.

        """

        delivered_message = outputs.get('deliveredMessage', {})
        result_emails = []
        for email in delivered_message:
            info_for_mail = delivered_message.get(email)
            info_for_mail.update({'mail_address': email})
            result_emails.append(info_for_mail)
        outputs.update({'deliveredMessage': result_emails})


    def build_get_message_info_for_specific_id(id, show_recipient_info, show_delivered_message, show_retention_info,
                                               show_spam_info):
        """

        Args:
            id: message id to search.
            show_recipient_info: boolean deciding if to show recipient info in the readable output.
            show_delivered_message: boolean deciding if to show delivered info in the readable output.
            show_retention_info: boolean deciding if to show terention info in the readable output.
            show_spam_info: boolean deciding if to show spam info in the readable output.

        Returns:
            CommandResults object with data for the specific id.

        """
        total_markdown = ''
        outputs = {}

        response = get_message_info_request(id)

        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))

        response_data = response.get('data')[0]
        recipient_info = response_data.get('recipientInfo', {})
        delivered_message = response_data.get('deliveredMessage', {})
        retention_info = response_data.get('retentionInfo', {})
        spam_info = response_data.get('spamInfo', {})
        to_list = recipient_info.get('messageInfo', {}).get('to', [])

        outputs.update({'status': response_data.get('status', '')})
        outputs.update({'id': response_data.get('id', '')})
        total_markdown += tableToMarkdown('Message Information', t=outputs)
        if show_recipient_info:
            total_markdown += build_recipient_info(recipient_info)
            outputs.update({'recipientInfo': recipient_info})
        if show_delivered_message:
            total_markdown += build_delivered_message(delivered_message, to_list)
            outputs.update({'deliveredMessage': delivered_message})
        if show_retention_info:
            total_markdown += build_retention_info(retention_info)
            outputs.update({'retentionInfo': retention_info})
        if show_spam_info:
            total_markdown += build_spam_info(spam_info)
            outputs.update({'spamInfo': spam_info})

        build_get_message_info_outputs(outputs)

        return CommandResults(
            outputs_prefix='Mimecast.MessageInfo',
            outputs_key_field='id',
            readable_output=total_markdown,
            outputs=outputs,
            raw_response=response
        )


    '''COMMANDS '''


    def test_module():
        if not ACCESS_KEY:
            raise Exception('Cannot test valid connection without the Access Key parameter.')
        list_managed_url()


    def parse_queried_fields(query_xml: str) -> tuple[str, ...]:
        if not query_xml:
            return ()

        if not (fields := ElementTree.fromstring(query_xml).find('.//return-fields')):  # noqa:S314 - argument set by user
            demisto.debug("could not find a 'return-fields' section - will only return default fields")
            return ()
        return tuple(field.text for field in fields if field is not None and field.text)


    DEFAULT_QUERY_KEYS = frozenset(('subject', 'displayfrom', 'displayto', 'receiveddate', 'size', 'attachmentcount', 'status', 'id'))


    def query(args: dict):

        if args.get('queryXml'):
            query_xml = args.get('queryXml', '')
        else:
            query_xml = parse_query_args(args)

        additional_keys = sorted(set(parse_queried_fields(query_xml)).difference(DEFAULT_QUERY_KEYS))  # non-default keys in query)
        headers = ['Subject', 'Display From', 'Display To', 'Received Date', 'Size', 'Attachment Count', 'Status',
                   'ID'] + additional_keys
        contents = []
        messages_context = []
        limit = arg_to_number(args.get('limit')) or 20
        page = arg_to_number(args.get('page'))
        page_size = arg_to_number(args.get('page_size'))

        if args.get('dryRun') == 'true':
            return query_xml

        # API request demands admin boolean, since we don't have any other support but admin we simply pass true.
        data = [{
            'admin': True,
            'query': query_xml
        }]
        messages, _ = request_with_pagination(api_endpoint='/api/archive/search',
                                              data=data,
                                              response_param='items',
                                              limit=limit,
                                              page=page,
                                              page_size=page_size)

        for message in messages:
            additional_dict = {k: message[k] for k in additional_keys}

            contents.append({
                'Subject': message.get('subject'),
                'Display From': message.get('displayfrom'),
                'Display To': message.get('displayto'),
                'Received Date': message.get('receiveddate'),
                'Size': message.get('size'),
                'Attachment Count': message.get('attachmentcount'),
                'Status': message.get('status'),
                'ID': message.get('id')
            } | additional_dict)
            messages_context.append({
                'Subject': message.get('subject'),
                'Sender': message.get('displayfrom'),
                'Recipient': message.get('displayto'),
                'ReceivedDate': message.get('receiveddate'),
                'Size': message.get('size'),
                'AttachmentCount': message.get('attachmentcount'),
                'Status': message.get('status'),
                'ID': message.get('id')
            } | additional_dict)

        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast archived emails', contents, headers),
            'EntryContext': {'Mimecast.Message(val.ID && val.ID == obj.ID)': messages_context}
        }


    def url_decode():
        headers = []  # type: List[str]
        contents = {}
        context = {}
        protected_url = demisto.args().get('url')
        decoded_url = url_decode_request(protected_url)
        contents['Decoded URL'] = decoded_url
        context[outputPaths['url']] = {
            'Data': protected_url,
            'Mimecast': {
                'DecodedURL': decoded_url
            }
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Decoded URL:', contents, headers),
            'EntryContext': context
        }

        return results


    def url_decode_request(url):
        # Setup required variables
        api_endpoint = '/api/ttp/url/decode-url'
        payload = {
            'data': [
                {
                    'url': url
                }
            ]
        }
        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        if not response.get('data')[0].get('url'):
            raise Exception('No URL has been returned from the service')
        return response.get('data')[0].get('url')


    def get_policy():
        headers = ['Policy ID', 'Sender', 'Reciever', 'Bidirectional', 'Start', 'End']
        contents = []
        context = {}
        title = 'Mimecast list blocked sender policies: \n These are the existing Blocked Sender Policies:'
        policy_id = demisto.args().get('policyID')
        if policy_id:
            title = 'Mimecast Get Policy'

        policies_list = get_policy_request(policy_id)
        policies_context = []
        for policy_list in policies_list:
            policy = policy_list.get('policy')
            sender = policy.get('from')
            reciever = policy.get('to')
            contents.append({
                'Policy ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Email Address': sender.get('emailAddress'),
                    'Domain': sender.get('emailDomain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Email Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('emailDomain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'Start': policy.get('fromDate'),
                'End': policy.get('toDate')
            })
            policies_context.append({
                'ID': policy_list['id'],
                'Sender': {
                    'Group': sender.get('groupId'),
                    'Address': sender.get('emailAddress'),
                    'Domain': sender.get('emailDomain'),
                    'Type': sender.get('type')
                },
                'Reciever': {
                    'Group': reciever.get('groupId'),
                    'Address': reciever.get('emailAddress'),
                    'Domain': reciever.get('emailDomain'),
                    'Type': reciever.get('type')
                },
                'Bidirectional': policy.get('bidirectional'),
                'FromDate': policy.get('fromDate'),
                'ToDate': policy.get('toDate')
            })

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def get_policy_request(policy_id=None):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/get-policy'
        data = []
        if policy_id:
            data.append({
                'id': policy_id
            })
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def get_arguments_for_policy_command(args):
        # type: (dict) -> tuple[dict, str]
        """
          Args:
              args: Demisto arguments

          Returns:
              tuple. policy arguments, and option to choose from the policy configuration.
         """

        description = args.get('description', '')
        from_part = args.get('fromPart', '')
        from_type = args.get('fromType', '')
        from_value = args.get('fromValue', '')
        to_type = args.get('toType', '')
        to_value = args.get('toValue', '')
        option = str(args.get('option', ''))
        policy_obj = {
            'description': description,
            'fromPart': from_part,
            'fromType': from_type,
            'fromValue': from_value,
            'toType': to_type,
            'toValue': to_value
        }

        return policy_obj, option


    def create_policy():
        headers = ['Policy ID', 'Description', 'Sender', 'Receiver', 'Bidirectional', 'Start', 'End']
        context = {}
        policy_args = demisto.args()
        policy_obj, option = get_arguments_for_policy_command(policy_args)
        policy_list = create_or_update_policy_request(policy_obj, option)
        policy = policy_list.get('policy')
        policy_id = policy_list.get('id')
        title = 'Mimecast Create Policy: \n Policy Was Created Successfully!'
        sender = policy.get('from')
        receiver = policy.get('to')
        description = policy.get('description')
        content = {
            'Policy ID': policy_id,
            'Description': description,
            'Sender': {
                'Group': sender.get('groupId'),
                'Email Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Receiver': {
                'Group': receiver.get('groupId'),
                'Email Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Reciever': {
                'Group': receiver.get('groupId'),
                'Email Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'Start': policy.get('fromDate'),
            'End': policy.get('toDate')
        }  # type: Dict[Any, Any]
        policies_context = {
            'ID': policy_id,
            'Description': description,
            'Sender': {
                'Group': sender.get('groupId'),
                'Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Receiver': {
                'Group': receiver.get('groupId'),
                'Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Reciever': {
                'Group': receiver.get('groupId'),
                'Email Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'FromDate': policy.get('fromDate'),
            'ToDate': policy.get('toDate')
        }  # type: Dict[Any, Any]

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': policy_list,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, content, headers),
            'EntryContext': context
        }

        return results


    def set_empty_value_args_policy_update(policy_obj, option, policy_id):
        """
        The function use the get policy request function to fill the empty arguments in the policy

        Args:
            policy_obj (Dict): Dict of policy details
            option: (str) Policy option
            policy_id: (str) Policy ID

        Returns:
              Tuple. Policy object, the option to configure on the policy, policy id.
         """
        empty_args_list = []
        # Add the empty arguments to empty args list
        for arg, value in policy_obj.items():
            if value == '':
                empty_args_list.append(arg)
        if option == '':
            empty_args_list.append("option")
        # Check if there are any empty arguments
        if len(empty_args_list) > 0:
            # Fill the empty arguments with the current data using get policy request function
            policy_details = get_policy_request(policy_id)[0]
            for arg in empty_args_list:
                if arg == "option":
                    option = policy_details["option"]
                else:
                    policy_obj[arg] = policy_details["policy"][arg]

        return policy_obj, option, policy_id


    def update_policy():
        """
              Update policy according to policy ID
         """
        headers = ['Policy ID', 'Description', 'Sender', 'Receiver', 'Bidirectional', 'Start', 'End']
        context = {}
        policy_args = demisto.args()
        policy_obj, option = get_arguments_for_policy_command(policy_args)
        policy_id = str(policy_args.get('policy_id', ''))
        if not policy_id:
            raise Exception("You need to enter policy ID")
        policy_obj, option, policy_id = set_empty_value_args_policy_update(policy_obj, option, policy_id)
        response = create_or_update_policy_request(policy_obj, option, policy_id=policy_id)
        policy = response.get('policy')
        title = 'Mimecast Update Policy: \n Policy Was Updated Successfully!'
        sender = policy.get('from')
        receiver = policy.get('to')
        description = policy.get('description')
        contents = {
            'Policy ID': policy_id,
            'Description': description,
            'Sender': {
                'Group': sender.get('groupId'),
                'Email Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Receiver': {
                'Group': receiver.get('groupId'),
                'Email Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'Start': policy.get('fromDate'),
            'End': policy.get('toDate')
        }  # type: Dict[Any, Any]
        policies_context = {
            'ID': policy_id,
            'Description': description,
            'Sender': {
                'Group': sender.get('groupId'),
                'Address': sender.get('emailAddress'),
                'Domain': sender.get('emailDomain'),
                'Type': sender.get('type')
            },
            'Receiver': {
                'Group': receiver.get('groupId'),
                'Address': receiver.get('emailAddress'),
                'Domain': receiver.get('emailDomain'),
                'Type': receiver.get('type')
            },
            'Bidirectional': policy.get('bidirectional'),
            'FromDate': policy.get('fromDate'),
            'ToDate': policy.get('toDate')
        }  # type: Dict[Any, Any]

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = policies_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def create_or_update_policy_request(policy, option, policy_id=None):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/create-policy'
        payload = {
            'data': [{
                'policy': policy,
                'option': option
            }]
        }
        # Policy ID isnt None if it is an update policy request cause its required to
        # write a policy ID on update policy command
        if policy_id:
            payload['data'][0]['id'] = policy_id
        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def delete_policy():
        contents = []  # type: List[Any]
        context = {}
        policy_id = demisto.args().get('policyID')

        delete_policy_request(policy_id)

        context['Mimecast.Policy(val.ID && val.ID == obj.ID)'] = {
            'ID': policy_id,
            'Deleted': True
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': f'Mimecast Policy {policy_id} deleted successfully!',
            'EntryContext': context
        }

        return results


    def delete_policy_request(policy_id=None):
        # Setup required variables
        api_endpoint = '/api/policy/blockedsenders/delete-policy'
        data = [{
            'id': policy_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        if response.get('data')[0].get('id') != policy_id:
            raise Exception('Policy was not deleted.')
        return response.get('data')[0]


    def manage_sender():
        headers = []  # type: List[str]
        context = {}
        sender = demisto.args().get('sender')
        recipient = demisto.args().get('recipient')
        action = demisto.args().get('action')
        title_action = 'permitted' if action == 'permit' else 'blocked'
        title = f'Mimecast messages from {sender} to {recipient} will now be {title_action}!'

        req_obj = {
            'sender': sender,
            'to': recipient,
            'action': action
        }

        managed_sender = manage_sender_request(req_obj)

        contents = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        context['Mimecast.Managed(val.ID && val.ID == obj.ID)'] = {
            'Sender': managed_sender.get('sender'),
            'Recipient': managed_sender.get('to'),
            'Action': managed_sender.get('type'),
            'ID': managed_sender.get('id')
        }

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, contents, headers),
            'EntryContext': context
        }

        return results


    def manage_sender_request(req_obj):
        # Setup required variables
        api_endpoint = '/api/managedsender/permit-or-block-sender'
        data = []
        data.append(req_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_managed_url():
        headers = ['URL', 'Action', 'Match Type', 'User Awareness', 'URL Rewriting', 'Comment']
        contents = []
        context = {}
        managed_urls_context = []
        full_url_response = ''
        url = demisto.args().get('url')

        managed_urls = list_managed_url_request()
        for managed_url in managed_urls:
            query_string = ''
            scheme = ''
            if managed_url.get('queryString'):
                query_string = '?' + managed_url.get('queryString')
            if managed_url.get('scheme'):
                scheme = managed_url.get('scheme') + '://'
            full_url_response = scheme + managed_url.get('domain', '') + managed_url.get('path', '') + query_string
            if (url and url in full_url_response) or not url:
                contents.append({
                    'URL': full_url_response,
                    'Match Type': managed_url.get('matchType'),
                    'Comment': managed_url.get('comment'),
                    'Action': managed_url.get('action'),
                    'URL Rewriting': managed_url.get('disableRewrite'),
                    'User Awareness': managed_url.get('disableUserAwareness')
                })
                managed_urls_context.append({
                    'Domain': managed_url.get('domain'),
                    'disableLogClick': managed_url.get('disableLogClick'),
                    'Action': managed_url.get('action'),
                    'Path': managed_url.get('path'),
                    'matchType': managed_url.get('matchType'),
                    'ID': managed_url.get('id'),
                    'disableRewrite': managed_url.get('disableRewrite')
                })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context
        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Managed URLs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def list_managed_url_request():
        # Setup required variables
        api_endpoint = '/api/ttp/url/get-all-managed-urls'
        data = []  # type: List[Any]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')


    def create_managed_url():
        context = {}
        contents = {}  # type: Dict[Any, Any]
        managed_urls_context = []
        url = demisto.args().get('url')
        action = demisto.args().get('action')
        match_type = demisto.args().get('matchType')
        disable_rewrite = demisto.args().get('disableRewrite')
        disable_user_awareness = demisto.args().get('disableUserAwareness')
        disable_log_click = demisto.args().get('disableLogClick')
        comment = demisto.args().get('comment')

        url_req_obj = {
            'comment': comment,
            'disableRewrite': disable_rewrite,
            'url': url,
            'disableUserAwareness': disable_user_awareness,
            'disableLogClick': disable_log_click,
            'action': action,
            'matchType': match_type
        }

        managed_url = create_managed_url_request(url_req_obj)
        managed_urls_context.append({
            'Domain': managed_url.get('domain'),
            'disableLogClick': managed_url.get('disableLogClick'),
            'Action': managed_url.get('action'),
            'Path': managed_url.get('path'),
            'matchType': managed_url.get('matchType'),
            'ID': managed_url.get('id'),
            'disableRewrite': managed_url.get('disableRewrite')
        })

        context['Mimecast.URL(val.ID && val.ID == obj.ID)'] = managed_urls_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': f'Managed URL {url} created successfully!',
            'EntryContext': context
        }

        return results


    def create_managed_url_request(url_obj):
        # Setup required variables
        api_endpoint = '/api/ttp/url/create-managed-url'
        data = []
        data.append(url_obj)
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def list_messages():
        headers = ['Subject', 'Size', 'Recieved Date', 'From', 'Attachment Count', 'Message ID']
        context = {}
        contents = []
        messages_context = []
        search_params = {}

        limit = arg_to_number(demisto.args().get('limit')) or 20
        page = arg_to_number(demisto.args().get('page'))
        page_size = arg_to_number(demisto.args().get('page_size'))

        # can't send null values for keys, so if optional value not sent by user, do not add to request.
        mailbox = demisto.args().get('mailbox', '')
        if mailbox:
            search_params['mailbox'] = mailbox
        view = demisto.args().get('view', '')
        if view:
            search_params['view'] = view
        end_time = demisto.args().get('endTime', '')
        if end_time:
            search_params['end'] = end_time
        start_time = demisto.args().get('startTime', '')
        if start_time:
            search_params['start'] = start_time
        subject = demisto.args().get('subject')

        messages_list, _ = request_with_pagination(api_endpoint='/api/archive/get-message-list',
                                                   data=[search_params],
                                                   limit=limit,
                                                   page=page,
                                                   page_size=page_size)
        for message in messages_list:
            if subject == message.get('subject') or not subject:
                contents.append({
                    'Message ID': message.get('id'),
                    'Subject': message.get('subject'),
                    'Size': message.get('size'),
                    'Recieved Date': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'Attachment Count': message.get('attachmentCount')
                })
                messages_context.append({
                    'Subject': message.get('subject'),
                    'ID': message.get('id'),
                    'Size': message.get('size'),
                    'RecievedDate': message.get('received'),
                    'From': message.get('from').get('emailAddress'),
                    'AttachmentCount': message.get('attachmentCount')
                })

        context['Mimecast.Message(val.ID && val.ID == obj.ID)'] = messages_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast messages list', contents, headers),
            'EntryContext': context
        }

        return results


    def get_url_logs():
        """
        Getting logs using pagination as specified here
        https://www.mimecast.com/tech-connect/documentation/endpoint-reference/logs-and-statistics/get-ttp-url-logs/

        Returns: TTP URl logs command results

        """
        headers = []  # type: List[Any]
        contents = []
        context = {}
        url_logs_context = []
        search_params = {}
        from_date = demisto.args().get('fromDate', '')
        to_date = demisto.args().get('toDate', '')
        scan_result = demisto.args().get('resultType', '')
        limit = arg_to_number(demisto.args().get('limit')) or 20
        page = arg_to_number(demisto.args().get('page'))
        page_size = arg_to_number(demisto.args().get('page_size'))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if scan_result:
            search_params['scanResult'] = scan_result
        url_logs, _ = request_with_pagination(api_endpoint='/api/ttp/url/get-logs',
                                              data=[search_params],
                                              response_param='clickLogs',
                                              limit=limit,
                                              page=page,
                                              page_size=page_size)
        for url_log in url_logs:
            contents.append({
                'Action': url_log.get('action'),
                'Admin Override': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Scan Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'User Awareness Action': url_log.get('userAwarenessAction'),
                'User Email Address': url_log.get('userEmailAddress'),
                'User Override': url_log.get('userOverride')
            })
            url_logs_context.append({
                'Action': url_log.get('action'),
                'AdminOverride': url_log.get('adminOverride'),
                'Category': url_log.get('category'),
                'Date': url_log.get('date'),
                'Route': url_log.get('route'),
                'Result': url_log.get('scanResult'),
                'URL': url_log.get('url'),
                'Awareness': url_log.get('userAwarenessAction'),
                'Address': url_log.get('userEmailAddress'),
                'UserOverride': url_log.get('userOverride')
            })

        context['Mimecast.UrlLog'] = url_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast URL logs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def get_attachment_logs():
        headers = []  # type: List[Any]
        contents = []
        context = {}
        attachment_logs_context = []
        search_params = {}
        from_date = demisto.args().get('fromDate', '')
        to_date = demisto.args().get('toDate', '')
        result = demisto.args().get('resultType', '')
        limit = arg_to_number(demisto.args().get('limit')) or arg_to_number(demisto.args().get('resultsNumber')) or 20
        page = arg_to_number(demisto.args().get('page'))
        page_size = arg_to_number(demisto.args().get('page_size'))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if result:
            search_params['result'] = result

        attachment_logs, _ = request_with_pagination(api_endpoint='/api/ttp/attachment/get-logs',
                                                     data=[search_params],
                                                     response_param='attachmentLogs',
                                                     limit=limit,
                                                     page=page,
                                                     page_size=page_size)

        for attachment_log in attachment_logs:
            contents.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender Address': attachment_log.get('senderAddress'),
                'File Name': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient Address': attachment_log.get('recipientAddress'),
                'File Type': attachment_log.get('fileType')
            })
            attachment_logs_context.append({
                'Result': attachment_log.get('result'),
                'Date': attachment_log.get('date'),
                'Sender': attachment_log.get('senderAddress'),
                'FileName': attachment_log.get('fileName'),
                'Action': attachment_log.get('actionTriggered'),
                'Route': attachment_log.get('route'),
                'Details': attachment_log.get('details'),
                'Recipient': attachment_log.get('recipientAddress'),
                'FileType': attachment_log.get('fileType')
            })

        context['Mimecast.AttachmentLog'] = attachment_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast attachment logs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def get_impersonation_logs():
        headers = []  # type: List[Any]
        contents = []
        context = {}
        impersonation_logs_context = []
        search_params = {}
        from_date = demisto.args().get('fromDate', '')
        to_date = demisto.args().get('toDate', '')
        tagged_malicious = demisto.args().get('taggedMalicious', '')
        search_field = demisto.args().get('searchField', '')
        query = demisto.args().get('query', '')
        identifiers = argToList(demisto.args().get('identifiers', ''))
        actions = argToList(demisto.args().get('actions', ''))
        limit = arg_to_number(demisto.args().get('limit')) or arg_to_number(demisto.args().get('resultsNumber')) or 20
        page = arg_to_number(demisto.args().get('page'))
        page_size = arg_to_number(demisto.args().get('pageSize'))

        if from_date:
            search_params['from'] = from_date
        if to_date:
            search_params['to'] = to_date
        if tagged_malicious:
            search_params['taggedMalicious'] = tagged_malicious
        if search_field:
            search_params['searchField'] = search_field
        if query:
            search_params['query'] = query
        if identifiers:
            search_params['identifiers'] = identifiers
        if actions:
            search_params['actions'] = actions

        impersonation_logs, result_count = request_with_pagination(api_endpoint='/api/ttp/impersonation/get-logs',
                                                                   data=[search_params],
                                                                   response_param='impersonationLogs',
                                                                   limit=limit,
                                                                   page=page,
                                                                   page_size=page_size)

        for impersonation_log in impersonation_logs:
            contents.append({
                'Result Count': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'Sender IP': impersonation_log.get('senderIpAddress'),
                'Sender Address': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'Recipient Address': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })
            impersonation_logs_context.append({
                'ResultCount': result_count,
                'Hits': impersonation_log.get('hits'),
                'Malicious': impersonation_log.get('taggedMalicious'),
                'SenderIP': impersonation_log.get('senderIpAddress'),
                'SenderAddress': impersonation_log.get('senderAddress'),
                'Subject': impersonation_log.get('subject'),
                'Identifiers': impersonation_log.get('identifiers'),
                'Date': impersonation_log.get('eventTime'),
                'Action': impersonation_log.get('action'),
                'Policy': impersonation_log.get('definition'),
                'ID': impersonation_log.get('id'),
                'RecipientAddress': impersonation_log.get('recipientAddress'),
                'External': impersonation_log.get('taggedExternal')
            })

        context['Mimecast.Impersonation'] = impersonation_logs_context

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast impersonation logs: ', contents, headers),
            'EntryContext': context
        }

        return results


    def fetch_incidents():
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('time')

        # handle first time fetch
        if last_fetch is None:
            last_fetch = datetime.now() - timedelta(hours=FETCH_DELTA)
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        else:
            last_fetch = datetime.strptime(last_fetch, '%Y-%m-%dT%H:%M:%SZ')
            last_fetch_date_time = last_fetch.strftime("%Y-%m-%dT%H:%M:%S") + '+0000'
        current_fetch = last_fetch

        incidents = []  # type: List[Any]
        if FETCH_URL:
            search_params = {
                'from': last_fetch_date_time,
                'scanResult': 'malicious'
            }
            url_logs, _ = request_with_pagination(api_endpoint='/api/ttp/url/get-logs',
                                                  data=[search_params],
                                                  response_param='clickLogs')
            for url_log in url_logs:
                incident = url_to_incident(url_log)
                temp_date = datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')
                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_ATTACHMENTS:
            search_params = {
                'from': last_fetch_date_time,
                'result': 'malicious'
            }
            attachment_logs, _ = request_with_pagination(api_endpoint='/api/ttp/attachment/get-logs',
                                                         data=[search_params],
                                                         response_param='attachmentLogs')
            for attachment_log in attachment_logs:
                incident = attachment_to_incident(attachment_log)
                temp_date = datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        if FETCH_IMPERSONATIONS:
            search_params = {
                'from': last_fetch_date_time,
                'taggedMalicious': True
            }
            impersonation_logs, _ = request_with_pagination(api_endpoint='/api/ttp/impersonation/get-logs',
                                                            data=[search_params],
                                                            response_param='impersonationLogs')
            for impersonation_log in impersonation_logs:
                incident = impersonation_to_incident(impersonation_log)
                temp_date = datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)
        if FETCH_HELD_MESSAGES:
            search_params = {
                'start': last_fetch_date_time,
                'admin': True
            }
            held_messages, _ = request_with_pagination(api_endpoint='/api/gateway/get-hold-message-list',
                                                       data=[search_params])
            for held_message in held_messages:
                incident = held_to_incident(held_message)
                temp_date = datetime.strptime(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

                # update last run
                if temp_date > last_fetch:
                    last_fetch = temp_date + timedelta(seconds=1)

                # avoid duplication due to weak time query
                if temp_date > current_fetch:
                    incidents.append(incident)

        demisto.setLastRun({'time': last_fetch.isoformat().split('.')[0] + 'Z'})
        demisto.incidents(incidents)


    def url_to_incident(url_log):
        incident = {}
        incident['name'] = 'Mimecast malicious URL: ' + url_log.get('url')
        incident['occurred'] = url_log.get('date').replace('+0000', 'Z')
        incident['rawJSON'] = json.dumps(url_log)
        return incident


    def attachment_to_incident(attachment_log):
        incident = {}
        incident['name'] = 'Mimecast malicious attachment: ' + attachment_log.get('fileName')
        incident['occurred'] = attachment_log.get('date').replace('+0000', 'Z')
        incident['rawJSON'] = json.dumps(attachment_log)
        return incident


    def impersonation_to_incident(impersonation_log):
        incident = {}
        incident['name'] = 'Mimecast malicious impersonation: ' + impersonation_log.get('subject')
        incident['occurred'] = impersonation_log.get('eventTime').replace('+0000', 'Z')
        incident['rawJSON'] = json.dumps(impersonation_log)
        incident['dbotMirrorId'] = impersonation_log.get('id')
        return incident


    def held_to_incident(held_message):
        incident = {}
        incident['name'] = f'Mimecast held message: {held_message.get("subject")}'
        incident['occurred'] = held_message.get('dateReceived').replace('+0000', 'Z')
        incident['rawJSON'] = json.dumps(held_message)
        incident['dbotMirrorId'] = held_message.get('id')
        return incident


    def discover():
        headers = []  # type: List[Any]
        context = {}
        context_obj = {}  # type: Dict[Any, Any]
        contents = []

        response = discover_request()

        contents.append({
            'Authentication Types': response.get('authenticate'),
            'Email Address': response.get('emailAddress'),
            'Email Token': response.get('emailToken')
        })

        context_obj = {
            'AuthenticationTypes': response.get('authenticate'),
            'EmailAddress': response.get('emailAddress'),
            'EmailToken': response.get('emailToken')
        }

        context['Mimecast.Authentication(val.EmailAddress && val.EmailAddress === obj.EmailAddress)'] = context_obj

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast Authentication Information', contents, headers),
            'EntryContext': context
        }

        return results


    def discover_request():
        if not EMAIL_ADDRESS:
            raise Exception('In order to discover account\'s auth types, account\'s email is required.')
        email = EMAIL_ADDRESS
        # Setup required variables
        api_endpoint = '/api/login/discover-authentication'
        payload = {
            'data': [{
                'emailAddress': email
            }]
        }
        response = http_request('POST', api_endpoint, payload, {}, user_auth=False)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def refresh_token():
        contents = refresh_token_request()

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': 'Token has been refreshed succesfully and is valid for the next 3 days'
        }

        return results


    def refresh_token_request():
        if not EMAIL_ADDRESS:
            raise Exception('In order to refresh a token validty duration, account\'s email is required.')
        if not ACCESS_KEY:
            raise Exception('In order to refresh a token validty duration, account\'s access key is required.')
        email = EMAIL_ADDRESS
        access_key = ACCESS_KEY
        # Setup required variables
        api_endpoint = '/api/login/login'
        payload = {
            'data': [{
                'userName': email,
                'accessKey': access_key
            }]
        }
        response = http_request('POST', api_endpoint, payload, {}, user_auth=False)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def login():
        headers = ['Access Key', 'Secret Key']
        contents = []

        response = login_request()

        contents.append({
            'Access Key': response.get('accessKey'),
            'Secret Key': response.get('secretKey')
        })

        results = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Mimecast authentication details \n Tokens are valid for 3 days', contents,
                                             headers)
        }

        return results


    def login_request():
        if not EMAIL_ADDRESS:
            raise Exception('In order to refresh a token validty duration, account\'s email is required.')
        email = EMAIL_ADDRESS
        # Setup required variables
        api_endpoint = '/api/login/login'
        payload = {
            'data': [{
                'userName': email
            }]
        }
        response = http_request('POST', api_endpoint, payload, {}, user_auth=False)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def get_message():
        context = {}
        contents = {}  # type: Dict[Any, Any]
        metadata_context = {}  # type: Dict[Any, Any]
        results = []
        message_id = demisto.args().get('messageID')
        message_context = demisto.args().get('context')
        message_type = demisto.args().get('type')
        message_part = demisto.args().get('part')

        if message_part == 'all' or message_part == 'metadata':
            contents, metadata_context = get_message_metadata(message_id)

            context['Mimecast.Message(val.ID && val.ID === obj.ID)'] = metadata_context

            results.append({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': contents,
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': tableToMarkdown('Mimecast message details', contents, removeNull=True),
                'EntryContext': context
            })

        if message_part == 'all' or message_part == 'message':
            email_file = get_message_body_content_request(message_id, message_context, message_type)
            results.append(fileResult(message_id, email_file))

        return results


    def get_message_body_content_request(message_id, message_context, message_type):
        # Setup required variables
        api_endpoint = '/api/archive/get-message-part'

        data = [{
            'id': message_id,
            'type': message_type,
            'context': message_context
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload, is_file=True)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response.content


    def get_message_metadata(message_id):
        contents = {}  # type: Dict[Any, Any]
        context = {}  # type: Dict[Any, Any]
        message = get_message_metadata_request(message_id)

        receivers = message.get('to', [])
        to_context = []
        to_contents = []
        for receiver in receivers:
            to_context.append({
                'EmailAddress': receiver.get('emailAddress')
            })
            to_contents.append(
                receiver.get('emailAddress')
            )

        copies = message.get('cc', [])
        cc_context = []
        cc_contents = []
        for copy in copies:
            cc_context.append({
                'EmailAddress': copy.get('emailAddress')
            })
            cc_contents.append(
                copy.get('emailAddress')
            )

        response_headers = message.get('headers', [])
        headers_contents = []
        headers_context = []
        for header in response_headers:
            values = header.get('values')
            values = list(values)
            headers_context.append({
                'Name': header.get('name'),
                'Values': values
            })
            headers_contents.append(
                'Name: {}, Values: {}'.format(str(header.get('name')), str(values))
            )

        attachments = message.get('attachments', [])
        attachments_context = []
        attachments_contents = []
        for attachment in attachments:
            attachments_context.append({
                'FileName': attachment.get('filename'),
                'SHA256': attachment.get('sha256'),
                'ID': attachment.get('id'),
                'Size': attachment.get('size'),
                'Extension': attachment.get('extension')
            })
            attachments_contents.append(
                'FileName: {}, SHA256: {}, ID: {}, Size: {}'.format(str(attachment.get('filename')),
                                                                    str(attachment.get('sha256')),
                                                                    str(attachment.get('id')),
                                                                    str(attachment.get('size')))
            )

        contents = {
            'Subject': message.get('subject'),
            'Header Date': message.get('headerDate'),
            'Size': message.get('size'),
            'From': message.get('from', {}).get('emailAddress'),
            'To': to_contents,
            'Reply To': message.get('replyTo', {}).get('emailAddress'),
            'CC': cc_contents,
            'Envelope From': message.get('envelopeFrom', {}).get('emailAddress'),
            'Headers': headers_contents,
            'Attachments': attachments_contents,
            'Processed': message.get('processed'),
            'Has Html Body': message.get('hasHtmlBody'),
            'ID': message.get('id')
        }

        context = {
            'Subject': message.get('subject'),
            'HeaderDate': message.get('headerDate'),
            'Size': message.get('size'),
            'From': message.get('from', {}).get('emailAddress'),
            'To': to_context,
            'ReplyTo': message.get('replyTo', {}).get('emailAddress'),
            'CC': cc_context,
            'EnvelopeFrom': message.get('envelopeFrom', {}).get('emailAddress'),
            'Headers': headers_context,
            'Attachments': attachments_context,
            'Processed': message.get('processed'),
            'HasHtmlBody': message.get('hasHtmlBody'),
            'ID': message.get('id')
        }

        return contents, context


    def get_message_metadata_request(message_id):
        # Setup required variables
        api_endpoint = '/api/archive/get-message-detail'
        data = [{
            'id': message_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        return response.get('data')[0]


    def download_attachment():
        attachment_id = demisto.args().get('attachmentID')
        attachment_name = demisto.args().get('attachmentName')
        attachment_file = download_attachment_request(attachment_id)
        return fileResult(attachment_name if attachment_name else attachment_id, attachment_file)


    def download_attachment_request(attachment_id):
        # Setup required variables
        api_endpoint = '/api/archive/get-file'

        data = [{
            'id': attachment_id
        }]
        payload = {
            'data': data
        }

        response = http_request('POST', api_endpoint, payload, is_file=True)
        try:
            json_response = response.json()
            if json_response.get('fail'):
                raise Exception(json_response.get('fail', [{}])[0].get('errors'))
        except ValueError:
            pass
        return response.content


    def find_groups():
        api_response = create_find_groups_request()

        markdown_output = find_groups_api_response_to_markdown(api_response)
        entry_context = find_groups_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_find_groups_request():
        api_endpoint = '/api/directory/find-groups'
        query_string = demisto.args().get('query_string', '')
        query_source = demisto.args().get('query_source', '')
        limit = demisto.args().get('limit')

        meta = {}
        data = {}

        if limit:
            meta['pagination'] = {
                'pageSize': int(limit)
            }

        if query_string:
            data['query'] = query_string
        if query_source:
            data['source'] = query_source

        payload = {
            'meta': meta,
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def find_groups_api_response_to_markdown(api_response):
        num_groups_found = api_response.get('meta', {}).get('pagination', {}).get('pageSize', 0)
        query_string = demisto.args().get('query_string', '')
        query_source = demisto.args().get('query_source', '')

        if not num_groups_found:
            md = '### Found 0 groups'

            if query_string:
                md += '\n#### query: ' + query_string

            if query_source:
                md += '\n#### source: ' + query_source

            return md

        md = 'Found ' + str(num_groups_found) + ' groups:'
        md_metadata = ''

        if query_string:
            md_metadata += '#### query: ' + query_string

        if query_source:
            if md_metadata:
                md_metadata += '\n'
            md_metadata += '#### source: ' + query_source

        groups_list = []
        for group in api_response.get('data', [])[0]['folders']:
            group_entry = {
                'Name': group['description'],
                'Source': group['source'],
                'Group ID': group['id'],
                'Number of users': group['userCount'],
                'Parent ID': group['parentId'],
                'Number of child groups': group['folderCount']
            }

            groups_list.append(group_entry)

        md = tableToMarkdown(md, groups_list,
                             ['Name', 'Source', 'Group ID', 'Number of users', 'Parent ID', 'Number of child groups'],
                             metadata=md_metadata)

        return md


    def find_groups_api_response_to_context(api_response):
        groups_list = []
        for group in api_response['data'][0]['folders']:
            group_entry = {
                'Name': group['description'],
                'Source': group['source'],
                'ID': group['id'],
                'NumberOfUsers': group['userCount'],
                'ParentID': group['parentId'],
                'NumberOfChildGroups': group['folderCount']
            }

            groups_list.append(group_entry)

        return {'Mimecast.Group(val.ID && val.ID == obj.ID)': groups_list}


    def get_group_members():
        api_response = create_get_group_members_request()

        markdown_output = group_members_api_response_to_markdown(api_response)
        entry_context = group_members_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_get_group_members_request(group_id=-1, limit=100):
        api_endpoint = '/api/directory/get-group-members'
        group_id = demisto.args().get('group_id', group_id)
        limit = demisto.args().get('limit', limit)

        meta = {}
        data = {}

        if limit:
            meta['pagination'] = {
                'pageSize': int(limit)
            }

        data['id'] = group_id

        payload = {
            'meta': meta,
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def group_members_api_response_to_markdown(api_response):
        num_users_found = api_response.get('meta', {}).get('pagination', {}).get('pageSize', 0)
        group_id = demisto.args().get('group_id', '')

        if not num_users_found:
            md = 'Found 0 users for group ID: ' + group_id + ''
            return md

        md = 'Found ' + str(num_users_found) + ' users for group ID: ' + group_id

        users_list = []
        for user in api_response['data'][0]['groupMembers']:
            user_entry = {
                'Name': user.get('name'),
                'Email address': user.get('emailAddress'),
                'Domain': user.get('domain'),
                'Type': user.get('type'),
                'Internal user': user.get('internal')
            }

            users_list.append(user_entry)

        md = tableToMarkdown(md, users_list,
                             ['Name', 'Email address', 'Domain', 'Type', 'Internal user'])

        return md


    def add_users_under_group_in_context_dict(users_list, group_id):
        demisto_context = demisto.context()

        if demisto_context and 'Mimecast' in demisto_context and 'Group' in demisto_context['Mimecast']:
            groups_entry_in_context = demisto_context['Mimecast']['Group']
            groups_entry_in_context = [groups_entry_in_context] if isinstance(groups_entry_in_context,
                                                                              dict) else groups_entry_in_context
            for group in groups_entry_in_context:
                if group['ID'] == group_id:
                    group['Users'] = users_list
                    return groups_entry_in_context

        return [
            {
                'ID': group_id,
                'Users': users_list
            }
        ]


    def group_members_api_response_to_context(api_response, group_id=-1):
        group_id = demisto.args().get('group_id', group_id)

        users_list = []
        for user in api_response['data'][0]['groupMembers']:
            user_entry = {
                'Name': user.get('name'),
                'EmailAddress': user.get('emailAddress'),
                'Domain': user.get('domain'),
                'Type': user.get('type'),
                'InternalUser': user.get('internal'),
                'IsRemoved': False
            }

            users_list.append(user_entry)

        groups_after_update = add_users_under_group_in_context_dict(users_list, group_id)

        return {'Mimecast.Group(val.ID && val.ID == obj.ID)': groups_after_update}


    def add_remove_member_to_group(action_type):
        """Adds or remove a member from a group

        Args:
            action_type: the action type

        Returns:
            Demisto Outputs
        """
        if action_type == 'add':
            api_endpoint = '/api/directory/add-group-member'
        else:
            api_endpoint = '/api/directory/remove-group-member'

        api_response = create_add_remove_group_member_request(api_endpoint)

        markdown_output = add_remove_api_response_to_markdown(api_response, action_type)
        entry_context = add_remove_api_response_to_context(api_response, action_type)
        return CommandResults(readable_output=markdown_output,
                              outputs=entry_context,
                              raw_response=api_response)


    def create_add_remove_group_member_request(api_endpoint):
        """Adds or remove a member from a group

        Args:
            api_endpoint: the add or the remove endpoint

        Returns:
            response from API
        """
        group_id = demisto.args().get('group_id', '')
        email = demisto.args().get('email_address', '')
        domain = demisto.args().get('domain_address', '')

        data = {
            'id': group_id,
        }

        if email:
            data['emailAddress'] = email

        if domain:
            data['domain'] = domain

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def add_remove_api_response_to_markdown(api_response, action_type):
        """Create a markdown response for the add or remove member operation

        Args:
            api_response: response from api
            action_type: the action type

        Returns:
            response from API
        """
        address_modified = api_response['data'][0].get('emailAddress')
        if not address_modified:
            address_modified = api_response['data'][0].get('domain', 'Address')
        group_id = api_response['data'][0].get('folderId', '')

        if action_type == 'add':
            return address_modified + ' had been added to group ID ' + group_id
        return address_modified + ' has been removed from group ID ' + group_id


    def change_user_status_removed_in_context(user_info, group_id):
        demisto_context = demisto.context()

        if demisto_context and 'Mimecast' in demisto_context and 'Group' in demisto_context['Mimecast']:
            groups_entry_in_context = demisto_context['Mimecast']['Group']
            groups_entry_in_context = [groups_entry_in_context] if isinstance(groups_entry_in_context,
                                                                              dict) else groups_entry_in_context
            for group in groups_entry_in_context:
                if group['ID'] == group_id:
                    for user in group['Users']:
                        if user['EmailAddress'] == user_info.get('EmailAddress', ''):
                            user['IsRemoved'] = True
                    return groups_entry_in_context

        return [
            {
                'ID': group_id,
                'Users': [user_info]
            }
        ]


    def add_remove_api_response_to_context(api_response, action_type):
        group_id = api_response['data'][0]['folderId']

        if action_type == 'add':
            # Run get group members again, to get all relevant data, the response from add user
            # does not match the get group members.
            api_response = create_get_group_members_request(group_id=group_id)
            return group_members_api_response_to_context(api_response, group_id=group_id)
        else:
            address_removed = api_response['data'][0].get('emailAddress', '')

            removed_user = {
                'EmailAddress': address_removed,
                'IsRemoved': True
            }

            groups_after_update = change_user_status_removed_in_context(removed_user, group_id)

            return {'Mimecast.Group(val.ID && val.ID == obj.ID)': groups_after_update}


    def create_group():
        api_response = create_group_request()

        markdown_output = create_group_api_response_to_markdown(api_response)
        entry_context = create_group_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_group_request():
        api_endpoint = '/api/directory/create-group'
        group_name = demisto.args().get('group_name', '')
        parent_id = demisto.args().get('parent_id', '-1')

        data = {
            'description': group_name,
        }

        if parent_id != '-1':
            data['parentId'] = parent_id

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def create_group_api_response_to_markdown(api_response):
        group_name = api_response['data'][0]['description']
        group_source = api_response['data'][0]['source']
        group_id = api_response['data'][0]['id']

        md = group_name + ' has been created'

        group_info = {
            'Group Source': group_source,
            'Group ID': group_id
        }

        return tableToMarkdown(md, group_info, ['Group Source', 'Group ID'])


    def create_group_api_response_to_context(api_response):
        group_created = {
            'Name': api_response['data'][0]['description'],
            'Source': api_response['data'][0]['source'],
            'ID': api_response['data'][0]['id'],
            'NumberOfUsers': 0,
            'ParentID': api_response['data'][0]['parentId'],
            'NumberOfChildGroups': 0
        }

        return {'Mimecast.Group(val.Name && val.Name == obj.Name)': group_created}


    def update_group():
        api_response = create_update_group_request()

        markdown_output = update_group_api_response_to_markdown(api_response)
        entry_context = update_group_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_update_group_request():
        api_endpoint = '/api/directory/update-group'
        group_name = demisto.args().get('group_name', '')
        group_id = demisto.args().get('group_id', '')
        parent_id = demisto.args().get('parent_id', '')

        data = {
            'id': group_id
        }

        if group_name:
            data['description'] = group_name

        if parent_id:
            data['parentId'] = parent_id

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def update_group_api_response_to_markdown(api_response):
        group_name = api_response['data'][0]['description']

        return group_name + ' has been updated'


    def update_group_api_response_to_context(api_response):
        group_updated = {
            'ID': api_response['data'][0]['id'],
            'Name': api_response['data'][0]['description'],
            'ParentID': api_response['data'][0]['parentId']
        }

        return {'Mimecast.Group(val.ID && val.ID == obj.ID)': group_updated}


    def create_mimecast_incident():
        api_response = create_mimecast_incident_request()

        markdown_output = mimecast_incident_api_response_to_markdown(api_response, 'create')
        entry_context = mimecast_incident_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_mimecast_incident_request():
        api_endpoint = '/api/ttp/remediation/create'
        reason = demisto.args().get('reason', '')
        start_date = demisto.args().get('start_date', '')
        end_date = demisto.args().get('end_date', '')
        search_by = demisto.args().get('search_by', 'hash')
        hash_or_message_id = demisto.args().get('hash_message_id', '')

        if search_by == 'hash':
            get_hash_type(hash_or_message_id)
        else:
            if not hash_or_message_id.startswith('<'):
                hash_or_message_id = f'<{hash_or_message_id}'
            if not hash_or_message_id.endswith('>'):
                hash_or_message_id = f'{hash_or_message_id}>'

        data = {
            'reason': reason,
            'hashOrMessageId': hash_or_message_id,
            'searchBy': search_by
        }

        if start_date:
            data['start'] = start_date

        if end_date:
            data['end'] = end_date

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def get_mimecast_incident():
        api_response = get_mimecast_incident_request()

        markdown_output = mimecast_incident_api_response_to_markdown(api_response, 'get')
        entry_context = mimecast_incident_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def get_mimecast_incident_request():
        api_endpoint = '/api/ttp/remediation/get-incident'
        incident_id = demisto.args().get('incident_id', '')

        data = {
            'id': incident_id
        }

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def mimecast_incident_api_response_to_markdown(api_response, action_type):
        response_data = api_response.get('data', [{}])[0]
        incident_code = response_data.get('code', '')
        incident_type = response_data.get('type', '')
        incident_reason = response_data.get('reason', '')
        incident_identified_messages_amount = response_data.get('identified', 0)
        incident_successful_messages_amount = response_data.get('successful', 0)
        incident_failed_messages_amount = response_data.get('failed', 0)
        incident_restored_messages_amount = response_data.get('restored', 0)
        incident_id = response_data.get('id', '')

        if action_type == 'create':
            md = 'Incident ' + incident_id + ' has been created'
        else:
            md = 'Incident ' + incident_id + ' has been found'
        md_metadata = """
    #### Code: {incident_code}
    #### Type: {incident_type}
    #### Reason: {incident_reason}
    #### The number of messages identified based on the search criteria: {incident_identified_messages_amount}
    #### The number successfully remediated messages: {incident_successful_messages_amount}
    #### The number of messages that failed to remediate: {incident_failed_messages_amount}
    #### The number of messages that were restored from the incident: {incident_restored_messages_amount}
    """.format(incident_code=incident_code,
               incident_type=incident_type,
               incident_reason=incident_reason,
               incident_identified_messages_amount=incident_identified_messages_amount,
               incident_successful_messages_amount=incident_successful_messages_amount,
               incident_failed_messages_amount=incident_failed_messages_amount,
               incident_restored_messages_amount=incident_restored_messages_amount)

        message = response_data['searchCriteria']
        message_entry = {
            'From': message.get('from'),
            'To': message.get('to'),
            'Start date': message.get('start'),
            'End date': message.get('end'),
            'Message ID': message.get('messageId'),
            'File hash': message.get('fileHash')
        }

        md = tableToMarkdown(md,
                             message_entry,
                             ['From', 'To', 'Start', 'End date', 'Message ID', 'File hash'],
                             metadata=md_metadata,
                             removeNull=True)

        return md


    def mimecast_incident_api_response_to_context(api_response):
        response_data = api_response['data'][0]
        message = response_data['searchCriteria']
        message_entry = {
            'From': message.get('from'),
            'To': message.get('to'),
            'StartDate': message.get('start'),
            'EndDate': message.get('end'),
            'MessageID': message.get('messageId'),
            'FileHash': message.get('fileHash')
        }

        incident_created = {
            'ID': response_data.get('id'),
            'Code': response_data.get('code'),
            'Type': response_data.get('type'),
            'Reason': response_data.get('reason'),
            'IdentifiedMessages': response_data.get('identified'),
            'SuccessfullyRemediatedMessages': response_data.get('successful'),
            'FailedRemediatedMessages': response_data.get('failed'),
            'MessagesRestored': response_data.get('restored'),
            'LastModified': response_data.get('modified'),
            'SearchCriteria': message_entry
        }

        return {'Mimecast.Incident(val.ID && val.ID == obj.ID)': incident_created}


    def search_file_hash():
        api_response = create_search_file_hash_request()

        markdown_output = search_file_hash_api_response_to_markdown(api_response)
        entry_context = search_file_hash_api_response_to_context(api_response)

        return_outputs(markdown_output, entry_context, api_response)


    def create_search_file_hash_request():
        api_endpoint = '/api/ttp/remediation/search-hash'
        hashes_to_search = argToList(demisto.args().get('hashes_to_search'))

        data = {
            'hashes': hashes_to_search
        }

        payload = {
            'data': [data]
        }

        response = http_request('POST', api_endpoint, payload)
        if isinstance(response, dict) and response.get('fail'):
            raise Exception(json.dumps(response.get('fail', [{}])[0].get('errors')))
        return response


    def search_file_hash_api_response_to_markdown(api_response):
        md = 'Hashes detected:\n'
        detected_hashes_list = []
        for detected_hash in api_response['data'][0]['hashStatus']:
            detected_hash_entry = {
                'Hash': detected_hash['hash'],
                'Found within the account': detected_hash['detected']
            }

            detected_hashes_list.append(detected_hash_entry)

        md = tableToMarkdown(md, detected_hashes_list, ['Hash', 'Found within the account'])

        md += '### Hashes that failed verification:\n'

        failed_hash_list = [str(failed_hash) for failed_hash in api_response['data'][0]['failedHashes']]
        md += str(failed_hash_list)[1:-1] + '\n'

        return md


    def search_file_hash_api_response_to_context(api_response):
        detected_hashes_list = []
        for detected_hash in api_response['data'][0]['hashStatus']:
            detected_hash_entry = {
                'HashValue': detected_hash['hash'],
                'Detected': detected_hash['detected']
            }

            detected_hashes_list.append(detected_hash_entry)

        if detected_hashes_list:
            return {'Mimecast.Hash(val.HashValue && val.HashValue == obj.HashValue)': detected_hashes_list}
        return None


    def search_message_command(args):
        """
        Getting message info for specific messages id.
        Args:
            args: input arguments for the command.

        """
        response = search_message_request(args)
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))

        tracked_emails = response.get('data')[0].get('trackedEmails')

        to_transformer = JsonTransformer(func=lambda to_data: ', '.join([to.get('emailAddress', '') for to in to_data]))
        from_env_transformer = JsonTransformer(func=lambda env: env.get('emailAddress', ''))
        from_hdr_transformer = JsonTransformer(func=lambda hdr: hdr.get('displayableName', ''))
        table_json_transformer = {'to': to_transformer,
                                  'fromEnv': from_env_transformer,
                                  'fromHdr': from_hdr_transformer
                                  }
        headers = {'fromEnv': 'From (Envelope)',
                   'fromHdr': 'From (Header)',
                   'received': 'Date/Time',
                   'senderIP': 'IP Address',
                   'spamScore': 'Spam Score',
                   'detectionLevel': 'Spam Detection'}
        readable_output = tableToMarkdown('Tracked Emails', t=tracked_emails,
                                          headerTransform=lambda header: headers.get(
                                              header) if header in headers else header.capitalize(),
                                          removeNull=True, json_transform_mapping=table_json_transformer)

        return CommandResults(
            outputs_prefix='Mimecast.SearchMessage',
            outputs_key_field='id',
            readable_output=readable_output,
            outputs=tracked_emails,
            raw_response=response
        )


    def held_message_summary_command():
        """
        Getting counts of currently held messages for each hold reason.
        Args:
            args: input arguments for the command.

        """
        response = http_request('POST', api_endpoint='/api/gateway/get-hold-summary-list', payload={'data': []})
        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))

        summary_list = response.get('data')

        headers = {'policyInfo': 'Held Reason',
                   'numberOfItems': 'Number Of Items'
                   }
        readable_output = tableToMarkdown('Message Summary', t=summary_list,
                                          headerTransform=lambda header: headers.get(header),
                                          removeNull=True)

        return CommandResults(
            outputs_prefix='Mimecast.HeldMessageSummary',
            outputs_key_field='policyInfo',
            readable_output=readable_output,
            outputs=summary_list,
            raw_response=response
        )


    def get_message_info_command(args):
        """
        Getting message info for specific messages ids.
        Args:
            args: input arguments for the command.

        """
        show_recipient_info = argToBoolean(args.get('show_recipient_info', True))
        show_delivered_message = argToBoolean(args.get('show_delivered_message', False))
        show_retention_info = argToBoolean(args.get('show_retention_info', True))
        show_spam_info = argToBoolean(args.get('show_spam_info', True))
        ids = argToList(args.get('ids', ''))
        results = []

        for id in ids:
            results.append(
                build_get_message_info_for_specific_id(id, show_recipient_info, show_delivered_message, show_retention_info,
                                                       show_spam_info))

        return results


    def list_held_messages_command(args):
        """
            Getting hold messages list.
            Args:
                args: input arguments for the command.

        """
        response, _ = list_held_messages_request(args)
        from_transformer = JsonTransformer(func=transformer_get_value('emailAddress'))
        table_json_transformer = {'to': from_transformer,
                                  'from': from_transformer,
                                  'fromHeader': from_transformer
                                  }
        headers = {'from': 'From (Envelope)',
                   'fromHeader': 'From (Header)',
                   'policyInfo': 'Held Reason',
                   'dateReceived': 'Held Since',
                   'hasAttachments': 'Has Attachments',
                   'reasonCode': 'Reason Code',
                   'reasonId': 'reason Id'
                   }
        readable_output = tableToMarkdown('Held Messages', t=response,
                                          headerTransform=lambda header: headers.get(
                                              header) if header in headers else header.capitalize(),
                                          removeNull=True, json_transform_mapping=table_json_transformer,
                                          headers=['id', 'dateReceived', 'from', 'fromHeader', 'hasAttachments',
                                                   'policyInfo', 'reason', 'reasonCode', 'reasonId',
                                                   'route', 'size', 'subject', 'to'],
                                          metadata=f'Showing page number {args.get("page", "1")}')

        return CommandResults(
            outputs_prefix='Mimecast.HeldMessage',
            outputs_key_field='id',
            readable_output=readable_output,
            outputs=response,
            raw_response=response
        )


    def reject_held_message_command(args):
        """

        Rejecting hold messages.
        Args:
            args: input arguments for the command.

        """
        response = reject_held_message_request(args)
        readable_output = ''

        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        for message in response.get('data', []):
            if not message.get('reject', False):
                raise Exception(f'Held message with id {message.get("id")} rejection failed.')
            else:
                readable_output += f'Held message with id {message.get("id")} was rejected successfully.\n'

        return CommandResults(
            readable_output=readable_output,
            raw_response=response,
        )


    def release_held_message_command(args):
        """

            Rejecting hold messages.
            Args:
                args: input arguments for the command.

            """
        id = args.get('id')
        response = release_held_message_request(id)

        if response.get('fail'):
            raise Exception(json.dumps(response.get('fail')[0].get('errors')))
        if not response.get('data', [])[0].get('release', False):
            raise Exception('Message release has failed.')
        else:
            readable_output = f'Held message with id {id} was released successfully'

        return CommandResults(
            readable_output=readable_output,
            raw_response=response,
        )


    def search_processing_message_command(args):
        """

        Searching for message being processed.
        Args:
            args: input arguments for the command.

        """
        response, _ = search_processing_message_request(args)
        from_transformer = JsonTransformer(func=transformer_get_value('emailAddress'))

        table_json_transformer = {'to': from_transformer,
                                  'fromHeader': from_transformer,
                                  'fromEnv': from_transformer
                                  }
        headers = {'fromEnv': 'From (Envelope)',
                   'fromHeader': 'From (Header)',
                   'routing': 'Route',
                   'created': 'Date/Time',
                   'remoteIp': 'IP Address',
                   'nextAttempt': 'Next Attempt'
                   }
        readable_output = tableToMarkdown('Processing Messages', t=response,
                                          headerTransform=lambda header: headers.get(
                                              header) if header in headers else header.capitalize(),
                                          removeNull=True, json_transform_mapping=table_json_transformer)

        return CommandResults(
            outputs_prefix='Mimecast.ProcessingMessage',
            readable_output=readable_output,
            outputs_key_field='id',
            outputs=response,
            raw_response=response
        )


    def list_email_queues_command(args):
        """

        Listing email queue (Inbound and Outbound).
        Args:
            args: input arguments for the command.

        """
        response = list_email_queues_request(args)
        response_data = response.get('data')[0]
        inbound_data = response_data.get('inboundEmailQueue')
        outbound_data = response_data.get('outboundEmailQueue')

        headers = {
            'date': 'Email Queue Date',
            'count': 'Email Queue Count'
        }

        total_markdown = tableToMarkdown('Inbound Email Queue', t=inbound_data,
                                         headerTransform=lambda header: f'Inbound {headers.get(header)}'
                                         if header in headers else header.capitalize(),
                                         removeNull=True)
        total_markdown += tableToMarkdown('Outbound Email Queue', t=outbound_data,
                                          headerTransform=lambda header: f'Outbound {headers.get(header)}'
                                          if header in headers else header.capitalize(),
                                          removeNull=True)
        return CommandResults(
            outputs_prefix='Mimecast.EmailQueue',
            readable_output=total_markdown,
            outputs=response.get('data'),
            raw_response=response
        )


    def main():
        """ COMMANDS MANAGER / SWITCH PANEL """
        # Check if token needs to be refresh, if it does and relevant params are set, refresh.
        command = demisto.command()
        args = demisto.args()

        try:
            handle_proxy()
            determine_ssl_usage()
            if ACCESS_KEY:
                auto_refresh_token()
            if command == 'test-module':
                # This is the call made when pressing the integration test button.
                test_module()
                demisto.results('ok')
            elif command == 'fetch-incidents':
                fetch_incidents()
            elif command == 'mimecast-query':
                demisto.results(query(args))
            elif command == 'mimecast-list-blocked-sender-policies':
                demisto.results(get_policy())
            elif command == 'mimecast-get-policy':
                demisto.results(get_policy())
            elif command == 'mimecast-create-policy':
                demisto.results(create_policy())
            elif command == 'mimecast-update-policy':
                demisto.results(update_policy())
            elif command == 'mimecast-delete-policy':
                demisto.results(delete_policy())
            elif command == 'mimecast-manage-sender':
                demisto.results(manage_sender())
            elif command == 'mimecast-list-managed-url':
                demisto.results(list_managed_url())
            elif command == 'mimecast-create-managed-url':
                demisto.results(create_managed_url())
            elif command == 'mimecast-list-messages':
                demisto.results(list_messages())
            elif command == 'mimecast-get-attachment-logs':
                demisto.results(get_attachment_logs())
            elif command == 'mimecast-get-url-logs':
                demisto.results(get_url_logs())
            elif command == 'mimecast-get-impersonation-logs':
                demisto.results(get_impersonation_logs())
            elif command == 'mimecast-url-decode':
                demisto.results(url_decode())
            elif command == 'mimecast-discover':
                demisto.results(discover())
            elif command == 'mimecast-login':
                demisto.results(login())
            elif command == 'mimecast-refresh-token':
                demisto.results(refresh_token())
            elif command == 'mimecast-get-message':
                demisto.results(get_message())
            elif command == 'mimecast-download-attachments':
                demisto.results(download_attachment())
            elif command == 'mimecast-find-groups':
                find_groups()
            elif command == 'mimecast-get-group-members':
                get_group_members()
            elif command == 'mimecast-add-group-member':
                return_results(add_remove_member_to_group('add'))
            elif command == 'mimecast-remove-group-member':
                return_results(add_remove_member_to_group('remove'))
            elif command == 'mimecast-create-group':
                create_group()
            elif command == 'mimecast-update-group':
                update_group()
            elif command == 'mimecast-create-remediation-incident':
                create_mimecast_incident()
            elif command == 'mimecast-get-remediation-incident':
                get_mimecast_incident()
            elif command == 'mimecast-search-file-hash':
                search_file_hash()
            elif command == 'mimecast-search-message':
                return_results(search_message_command(args))
            elif command == 'mimecast-held-message-summary':
                return_results(held_message_summary_command())
            elif command == 'mimecast-get-message-info':
                return_results(get_message_info_command(args))
            elif command == 'mimecast-list-held-message':
                return_results(list_held_messages_command(args))
            elif command == 'mimecast-reject-held-message':
                return_results(reject_held_message_command(args))
            elif command == 'mimecast-release-held-message':
                return_results(release_held_message_command(args))
            elif command == 'mimecast-search-processing-message':
                return_results(search_processing_message_command(args))
            elif command == 'mimecast-list-email-queues':
                return_results(list_email_queues_command(args))

        except Exception as e:
            return_error(e)


    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()

    register_module_line('MimecastV2', 'end', __line__())
  subtype: python3
  type: python
system: true
