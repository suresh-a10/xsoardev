category: Endpoint
commonfields:
  id: Crowdstrike Falcon v2.0
  version: -1
configuration:
- defaultvalue: https://api.crowdstrike.com
  display: Server URL (e.g., https://api.crowdstrike.com)
  name: url
  required: true
  type: 0
- display: Client ID
  name: client_id
  required: true
  type: 0
- display: Secret
  name: secret
  required: true
  type: 4
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: "15"
  display: Max incidents per fetch
  name: incidents_per_fetch
  required: false
  type: 0
- display: Detections fetch query
  name: fetch_query
  required: false
  type: 0
- display: Incidents fetch query
  name: incidents_fetch_query
  required: false
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: Choose what to fetch - incidents or detections or both
  defaultvalue: Detections
  display: Fetch types
  name: fetch_incidents_or_detections
  options:
  - Detections
  - Incidents
  required: false
  type: 16
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: The CrowdStrike Falcon OAuth 2 API (formerly the Falcon Firehose API),
  enables fetching and resolving detections, searching devices, getting behaviors
  by ID, containing hosts, and lifting host containment. getting behaviors by ID,
  containing hosts, and lifting host containment.
detaileddescription: |-
  To get an The API client ID and secret please contact the crowdstrike support: support@crowdstrike.com

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/crowdstrike-falcon)
display: Crowdstrike Falcon v2.0
image: data:image/png;base64,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
name: Crowdstrike Falcon v2.0
script:
  commands:
  - arguments:
    - description: The string representation of the indicator
      name: value
      required: true
    description: Searches for the IDs of indicators
    name: csfalcon-search-iocs
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type to retrieve. Possible values are: "sha256", "sha1",
        "md5", "domain", "ipv4", and "ipv6".'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The IOC value to retrieve.
      name: value
      required: true
    description: Gets the full definition of one or more indicators that you are watching.
    name: cs-falcon-get-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The date and time when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The date and time the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of the indicator. Possible values are: "sha256", "md5",
        "domain", "ipv4", and "ipv6".'
      name: ioc_type
      predefined:
      - sha256
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - auto: PREDEFINED
      defaultValue: detect
      description: Action to take when a host observes the custom IOC. The options
        allow, prevent_no_ui, prevent applies to hashes only
      name: action
      predefined:
      - detect
      - no_action
      - allow
      - prevent_no_ui
      - prevent
      required: true
    - auto: PREDEFINED
      description: 'The severity level to apply to this indicator. Required for the
        prevent and detect actions. Optional for no_action. '
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
      - critical
      required: true
    - auto: PREDEFINED
      description: The number of days for which the indicator should be valid. This
        only applies to domain, ipv4, and ipv6 types. Default is 30.
      isArray: true
      name: platforms
      predefined:
      - mac
      - windows
      - linux
      required: true
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 256 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    - description: Applies to hashes only. A common filename, or a filename in your
        environment. Filenames can be helpful for identifying hashes or filtering
        IOCs.
      name: filename
    - description: List of tags to apply to the indicator
      isArray: true
      name: tags
    - description: List of host group IDs that the indicator applies to
      isArray: true
      name: host_groups
    - description: The date on which the indicator will become inactive. When an indicator
        expires, its action is set to no_action but it remains in your list of custom
        IOCs.
      name: expiration
    - description: Add a comment
      name: comment
    - auto: PREDEFINED
      defaultValue: "True"
      description: Apply globally
      name: applied_globally
      predefined:
      - "True"
      - "False"
    description: Uploads an indicator for CrowdStrike to block and monitor.
    name: csfalcon-upload-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Action
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Severity
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The date and time the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of the indicator. Possible values are: "sha256", "md5",
        "sha1", "domain", "ipv4", and "ipv6".'
      name: ioc_type
      predefined:
      - sha256
      - md5
      - sha1
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - auto: PREDEFINED
      defaultValue: detect
      description: 'The policy to enact when the value is detected on a host. Possible
        values are: "detect" and "none". A value of "none" is equivalent to turning
        the indicator off. Default is "detect".'
      name: policy
      predefined:
      - detect
      - none
    - auto: PREDEFINED
      description: The level at which the indicator will be shared. Only "red" share
        level (not shared) is supported, which indicates that the IOC is not shared
        with other Falcon Host customers.
      name: share_level
      predefined:
      - red
    - description: The number of days for which the indicator should be valid. This
        only applies to domain, ipv4, and ipv6 types. Default is 30.
      name: expiration_days
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 200 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    description: Updates an indicator for CrowdStrike to monitor.
    name: cs-falcon-update-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The date and time the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - description: The ID of the Response policy to search for members of
      name: id
    - description: The filter expression that should be used to limit the results
      name: filters
    - description: The offset to start retrieving records from
      name: offset
    - description: The maximum records to return. [1-5000]
      name: limit
    - description: The property to sort by
      name: sort
    - description: The host id
      name: device_id
      required: true
    description: Get policy details of host
    name: cs-get-policy-details
  - arguments:
    - description: The host agent ID (AID) of the host to contain. Get an agent ID
        from a detection.
      isArray: true
      name: ids
      required: true
    description: This action will delete a host. After the host is deleted, no new
      detections for that host will be reported via UI or APIs
    name: csfalcon-delete-host
  dockerimage: demisto/python3:3.9.6.22912
  isfetch: true
  runonce: false
  script: |2




    ''' IMPORTS '''
    import json
    import requests
    import base64
    import email
    import hashlib
    from typing import List
    from dateutil.parser import parse
    from typing import Dict, Tuple, Any, Optional, Union
    from threading import Timer

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''
    INTEGRATION_NAME = 'CrowdStrike Falcon'
    CLIENT_ID = demisto.params().get('client_id')
    SECRET = demisto.params().get('secret')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else \
        demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('insecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    BYTE_CREDS = '{name}:{password}'.format(name=CLIENT_ID, password=SECRET).encode('utf-8')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic {}'.format(base64.b64encode(BYTE_CREDS).decode())
    }
    # Note: True life time of token is actually 30 mins
    TOKEN_LIFE_TIME = 28
    INCIDENTS_PER_FETCH = int(demisto.params().get('incidents_per_fetch', 15))
    # Remove proxy if not set to true in params
    handle_proxy()

    ''' KEY DICTIONARY '''

    IOC_SEARCH_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'action': 'Action',
        'severity': 'Severity',
        'created_timestamp': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_timestamp': 'ModifiedTime'
    }

    IOC_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'action': 'Action',
        'source': 'Source',
        'severity': 'Severity',
        'expired': 'Expired',
        'description': 'Description',
        'created_on': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_on': 'ModifiedTime',
        'modified_by': 'ModifiedBy'
    }

    ''' SPLIT KEY DICTIONARY '''

    """
        Pattern:
        {
            'Path': 'Path to item',
            'NewKey': 'Value of output key',
            'Delim': 'Delimiter char',
            'Index': Split Array Index
        }
    """





    """CLIENT CLASS"""

    class Client(BaseClient):
        def whoami(self) -> Dict[str, Any]:
            """Entity lookup."""
            return self._http_request(
                method="get",
                url_suffix="info/whoami",
                timeout=60,
            )



    ''' HELPER FUNCTIONS '''
    def http_request(method, url_suffix, params=None, data=None, files=None, headers=HEADERS, safe=False,
                     get_token_flag=True, no_json=False, json=None, status_code=None):
        """
            A wrapper for requests lib to send our requests and handle requests and responses better.

            :param json: JSON body
            :type json ``dict`` or ``list``

            :type method: ``str``
            :param method: HTTP method for the request.

            :type url_suffix: ``str``
            :param url_suffix: The suffix of the URL (endpoint)

            :type params: ``dict``
            :param params: The URL params to be passed.

            :type data: ``str``
            :param data: The body data of the request.

            :type headers: ``dict``
            :param headers: Request headers

            :type safe: ``bool``
            :param safe: If set to true will return None in case of http error

            :type get_token_flag: ``bool``
            :param get_token_flag: If set to True will call get_token()

            :type no_json: ``bool``
            :param no_json: If set to true will not parse the content and will return the raw response object for successful
            response

            :type status_code: ``int``
            :param: status_code: The request codes to accept as OK.

            :return: Returns the http request response json
            :rtype: ``dict``
        """
        if get_token_flag:
            token = get_token()
            headers['Authorization'] = 'Bearer {}'.format(token)
        url = SERVER + url_suffix
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                data=data,
                headers=headers,
                files=files,
                json=json
            )
        except requests.exceptions.RequestException:
            return_error('Error in connection to the server. Please make sure you entered the URL correctly.')
        try:
            valid_status_codes = {200, 201, 202, 204}
            # Handling a case when we want to return an entry for 404 status code.
            if status_code:
                valid_status_codes.add(status_code)
            if res.status_code not in valid_status_codes:
                res_json = res.json()
                reason = res.reason
                resources = res_json.get('resources', {})
                if resources:
                    error_msg = resources[0].get('message')
                    reason += f'\n{error_msg}'
                elif res_json.get('errors'):
                    errors = res_json.get('errors', [])
                    for error in errors:
                        reason += f"\n{error.get('message')}"
                err_msg = 'Error in API call to CrowdStrike Falcon: code: {code} - reason: {reason}'.format(
                    code=res.status_code,
                    reason=reason
                )
                # try to create a new token
                if res.status_code == 403 and get_token_flag:
                    LOG(err_msg)
                    token = get_token(new_token=True)
                    headers['Authorization'] = 'Bearer {}'.format(token)
                    return http_request(
                        method=method,
                        url_suffix=url_suffix,
                        params=params,
                        data=data,
                        headers=headers,
                        files=files,
                        json=json,
                        safe=safe,
                        get_token_flag=False,
                        status_code=status_code,
                        no_json=no_json,
                    )
                elif safe:
                    return None
                return_error(err_msg)
            return res if no_json else res.json()
        except ValueError as exception:
            raise ValueError(
                f'Failed to parse json object from response: {exception} - {res.content}')  # type: ignore[str-bytes-safe]


    def create_entry_object(contents: Union[List[Any], Dict[str, Any]] = {}, ec: Union[List[Any], Dict[str, Any]] = None,
                            hr: str = ''):
        """
            Creates an entry object

            :type contents: ``dict``
            :param contents: Raw response to output

            :type ec: ``dict``
            :param ec: Entry context of the entry object

            :type hr: ``str``
            :param hr: Human readable

            :return: Entry object
            :rtype: ``dict``
        """
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }

    def severity_string_to_int(severity):
        """
            Converts a severity string to DBot score representation

            :type severity: ``str``
            :param severity: String representation of a severity

            :return: DBot score representation of the severity
            :rtype ``int``
        """
        if severity in ('Critical', 'High'):
            return 3
        elif severity in ('Medium', 'Low'):
            return 2
        return 0


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
            Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict

            :type old_dict: ``dict``
            :param old_dict: Old dictionary to pull values from

            :type transformation_dict: ``dict``
            :param transformation_dict: Transformation dictionary that contains oldkeys:newkeys

            :return Transformed dictionart (according to transformation_dict values)
            :rtype ``dict``
        """
        new_dict = {}
        for k in list(old_dict.keys()):
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict

    def get_passed_mins(start_time, end_time_str):
        """
            Returns the time passed in mins
            :param start_time: Start time in datetime
            :param end_time_str: End time in str
            :return: The passed mins in int
        """
        time_delta = start_time - datetime.fromtimestamp(end_time_str)
        return time_delta.seconds / 60


    def handle_response_errors(raw_res: dict, err_msg: str = None):
        """
        Raise exception if raw_res is empty or contains errors
        """
        if not err_msg:
            err_msg = "The server was unable to return a result, please run the command again."
        if not raw_res:
            raise DemistoException(err_msg)
        if raw_res.get('errors'):
            raise DemistoException(raw_res.get('errors'))
        return


    ''' COMMAND SPECIFIC FUNCTIONS '''

    def get_token(new_token=False):
        """
            Retrieves the token from the server if it's expired and updates the global HEADERS to include it

            :param new_token: If set to True will generate a new token regardless of time passed

            :rtype: ``str``
            :return: Token
        """
        now = datetime.now()
        ctx = demisto.getIntegrationContext()
        if ctx and not new_token:
            passed_mins = get_passed_mins(now, ctx.get('time'))
            if passed_mins >= TOKEN_LIFE_TIME:
                # token expired
                auth_token = get_token_request()
                demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
            else:
                # token hasn't expired
                auth_token = ctx.get('auth_token')
        else:
            # there is no token
            auth_token = get_token_request()
            demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
        return auth_token


    def get_token_request():
        """
            Sends token request

            :rtype ``str``
            :return: Access token
        """
        body = {
            'client_id': CLIENT_ID,
            'client_secret': SECRET
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        token_res = http_request('POST', '/oauth2/token', data=body, headers=headers, safe=True,
                                 get_token_flag=False)
        if not token_res:
            err_msg = 'Authorization Error: User has no authorization to create a token. Please make sure you entered the' \
                      ' credentials correctly.'
            raise Exception(err_msg)
        return token_res.get('access_token')


    def upload_ioc(ioc_type, value, action, severity, platforms, source=None, description=None, filename=None, tags=None, host_groups=None, expiration=None, comment=None, applied_globally=True):
        """
        Create a new IOC (or replace an existing one)
        """
        applied_globally=True if applied_globally == "True" else False


        indicator = assign_params(
            type= ioc_type,
            value= value,
            action= action,
            severity= severity,
            source= source,
            description= description,
            expiration= expiration,
            applied_globally= applied_globally,
            platforms= argToList(platforms),
            tags= argToList(tags),
            host_groups= argToList(host_groups),
            metadata={'filename': filename if filename is not None else None}
            )

        indicators=[]
        indicators.append(indicator)

        payload=assign_params(
            comment=comment,
            indicators=indicators
            )

        return http_request('POST', '/iocs/entities/indicators/v1', data=json.dumps(payload))



    def searchioc(value):
        value=argToList(value)
        params={'filter':f"value:{value}"}
        results=http_request('GET', '/iocs/combined/indicator/v1', params=params)
        iocs=results.get('resources')
        if iocs:
            ec = [get_trasnformed_dict(ioc, IOC_SEARCH_KEY_MAP) for ioc in iocs]
            return create_entry_object(contents=results, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicators of Compromise', ec))





    def enrich_ioc_dict_with_ids(ioc_dict):
        """
            Enriches the provided ioc_dict with IOC ID
            :param ioc_dict: IOC dict transformed using the SEARCH_IOC_KEY_MAP
            :return: ioc_dict with its ID key:value updated
        """
        for ioc in ioc_dict:
            ioc['ID'] = '{type}:{val}'.format(type=ioc.get('Type'), val=ioc.get('Value'))
        return ioc_dict



    def delete_host(ids):
        """
            Contains host(s) with matching ids
            :param ids: IDs of host to contain
            :return: Contain host response json
        """
        payload = {
            'ids': ids
        }
        data = json.dumps(payload)
        params = {
            'action_name': 'hide_host'
        }
        return http_request('POST', '/devices/entities/devices-actions/v2', data=data, params=params)


    def delete_host_command():
        """
            Contains hosts with user arg ids
            :return: EntryObject of contain host command
        """
        ids = argToList(demisto.args().get('ids'))
        raw_res = delete_host(ids)
        hr = "Host {} Deleted".format(str(ids)[1:-1])
        return create_entry_object(contents=raw_res, hr=hr)


    ''' COMMANDS FUNCTIONS '''

    def upload_ioc_command(ioc_type, value, action, severity=None, platforms=None,
                           source=None, description=None, filename=None, tags=None, host_groups=None, expiration=None, comment=None, applied_globally=True):
        """
        :param ioc_type: The type of the indicator:
        :param policy :The policy to enact when the value is detected on a host.
        :param share_level: The level at which the indicator will be shared.
        :param expiration_days: This represents the days the indicator should be valid for.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param value: The string representation of the indicator.
        """
        raw_res = upload_ioc(ioc_type, value, action, severity, platforms, source, description, filename, tags, host_groups, expiration, comment, applied_globally)
        handle_response_errors(raw_res)
        # iocs=search_iocs(raw_res.get('resources')[0].get("id"))
        # iocs = search_iocs(ids=f"{ioc_type}:{value}").get('resources')
        # demisto.results("IOCS")
        # demisto.results(iocs)
        iocs=raw_res.get('resources')
        # res=raw_res.get("resources")[0].get('message')
        # if res:
        #     print(res)
        if not iocs:
            raise DemistoException("Failed to create IOC. Please try again.")
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        # ec['ID']=iocs[0].get('id')
        # enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                  hr=tableToMarkdown('Custom IOC was created successfully', ec))


    def update_ioc_command(ioc_type=None, value=None, policy=None, expiration_days=None,
                           share_level=None, description=None, source=None):
        """
        :param ioc_type: The type of the indicator:
        :param policy :The policy to enact when the value is detected on a host.
        :param share_level: The level at which the indicator will be shared.
        :param expiration_days: This represents the days the indicator should be valid for.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param value: The string representation of the indicator.
        """
        raw_res = update_ioc(ioc_type, value, policy, expiration_days, share_level, description, source)
        handle_response_errors(raw_res)
        iocs = search_iocs(ids=f"{ioc_type}:{value}").get('resources')
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Custom IOC was created successfully', ec))


    def search_iocs_command(types=None, values=None, policies=None, sources=None, from_expiration_date=None,
                            to_expiration_date=None, share_levels=None, limit=None, sort=None, offset=None):
        """
        :param types: A list of indicator types. Separate multiple types by comma.
        :param values: Comma-separated list of indicator values
        :param policies: Comma-separated list of indicator policies
        :param sources: Comma-separated list of IOC sources
        :param from_expiration_date: Start of date range to search (YYYY-MM-DD format).
        :param to_expiration_date: End of date range to search (YYYY-MM-DD format).
        :param share_levels: A list of share levels. Only red is supported.
        :param limit: The maximum number of records to return. The minimum is 1 and the maximum is 500. Default is 100.
        :param sort: The order of the results. Format
        :param offset: The offset to begin the list from
        """
        raw_res = search_iocs(types=types, values=values, policies=policies, sources=sources, sort=sort, offset=offset,
                              expiration_from=from_expiration_date, expiration_to=to_expiration_date,
                              share_levels=share_levels, limit=limit)
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        handle_response_errors(raw_res)
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicators of Compromise', ec))


    def get_ioc_command(ioc_type: str, value: str):
        """
        :param ioc_type: The type of the indicator
        :param value: The IOC value to retrieve
        """
        raw_res = search_iocs(ids=f"{ioc_type}:{value}")
        handle_response_errors(raw_res, 'Could not find any Indicators of Compromise.')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicator of Compromise', ec))

    def generate_status_fields(endpoint_status):
        status = ''
        is_isolated = ''

        if endpoint_status == 'normal':
            status = 'Online'
        elif endpoint_status == 'containment_pending':
            is_isolated = 'Pending isolation'
        elif endpoint_status == 'contained':
            is_isolated = 'Yes'
        elif endpoint_status == 'lift_containment_pending':
            is_isolated = 'Pending unisolation'

        return status, is_isolated

    def test_module():
        try:
            get_token(new_token=True)
        except ValueError:
            return 'Connection Error: The URL or The API key you entered is probably incorrect, please try again.'
        return 'ok'


    def get_policy_details(device_id):
        params={}
        params['filter']=(f"device_id:'{device_id}'")
        res= http_request('GET', '/policy/combined/response-members/v1', params=params)
        results = CommandResults(
        outputs_prefix='PolicyDetails',
        outputs=res['resources']
        )
        return results


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is {}'.format(demisto.command()))


    def main():
        command = demisto.command()
        # should raise error in case of issue

        args = demisto.args()
        try:
            if command == 'test-module':
                result = test_module()
                return_results(result)
            elif command == 'csfalcon-search-iocs':
                return_results(searchioc(**args))
            elif command == 'cs-falcon-get-ioc':
                return_results(get_ioc_command(ioc_type=args.get('type'), value=args.get('value')))
            elif command == 'csfalcon-upload-ioc':
                return_results(upload_ioc_command(**args))
            elif command == 'cs-falcon-update-ioc':
                return_results(update_ioc_command(**args))
            elif command== 'cs-get-policy-details':
                return_results(get_policy_details(**args))
            elif command== 'csfalcon-delete-host':
                return_results(delete_host_command())
        except Exception as e:
            return_error(str(e))


    if __name__ in ('__main__', 'builtin', 'builtins'):
        main()
  subtype: python3
  type: python
sourcemoduleid: CrowdstrikeFalcon
