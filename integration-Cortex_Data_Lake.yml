category: Analytics & SIEM
commonfields:
  id: Cortex Data Lake
  version: -1
configuration:
- display: Token
  hidden: true
  name: refresh_token
  required: false
  type: 4
- display: ID
  hidden: true
  name: reg_id
  required: false
  type: 4
- display: Key
  hidden: true
  name: auth_key
  required: false
  type: 4
- display: ""
  displaypassword: Key
  hiddenusername: true
  name: credentials_auth_key
  required: false
  type: 9
- additionalinfo: The API Key to use for connection
  display: ""
  displaypassword: Token
  hiddenusername: true
  name: credentials_refresh_token
  required: false
  type: 9
- display: ""
  displaypassword: ID
  hiddenusername: true
  name: credentials_reg_id
  required: false
  section: Connect
  type: 9
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: 24 hours
  display: First fetch time (<number> <time unit>, e.g., 12 hours, 7 days, 3 months,
    1 year)
  name: first_fetch_timestamp
  required: false
  type: 0
- additionalinfo: Choose which table incidents will be fetched from.
  defaultvalue: firewall.threat
  display: Fetch Table
  name: fetch_table
  options:
  - firewall.threat
  - firewall.file_data
  - firewall.auth
  - firewall.decryption
  - firewall.extpcap
  - firewall.globalprotect
  - firewall.hipmatch
  - firewall.iptag
  - firewall.traffic
  - firewall.url
  - firewall.userid
  - log.system
  - log.config
  required: false
  type: 15
- display: Severity of events to fetch (Firewall)
  name: firewall_severity
  options:
  - all
  - Critical
  - High
  - Medium
  - Low
  - Informational
  - Unused
  required: false
  type: 16
- display: Subtype of events to fetch (Firewall)
  name: firewall_subtype
  options:
  - all
  - attack
  - url
  - virus
  - spyware
  - vulnerability
  - file
  - scan
  - flood
  - packet
  - resource
  - data
  - url-content
  - wildfire
  - extpcap
  - wildfire-virus
  - http-hdr-insert
  - http-hdr
  - email-hdr
  - spyware-dns
  - spyware-wildfire-dns
  - spyware-wpc-dns
  - spyware-custom-dns
  - spyware-cloud-dns
  - spyware-raven
  - spyware-wildfire-raven
  - spyware-wpc-raven
  - wpc-virus
  - sctp
  required: false
  type: 16
- additionalinfo: Comma-separated fields that will be fetched with every incident,
    e.g., "pcap,session_id". Enter "*" for all possible fields.
  defaultvalue: '*'
  display: Fetch Fields
  name: fetch_fields
  required: false
  type: 12
- additionalinfo: 'Filter the fetched incidents according to the given query. Query
    example: "source_ip.value LIKE `192.168.1.*` AND dst = `192.168.1.12`" Note: Can
    not be used in combination with `Severity` and `Subtype` parameters.'
  display: Fetch Filter
  name: filter_query
  required: false
  type: 12
- display: Incident type
  name: incidentType
  required: false
  type: 13
- additionalinfo: "The maximum number of incidents to fetch per query.\t\nCaution:
    A large number could create overload. Default is 10."
  defaultvalue: "10"
  display: Max. number of incidents fetched per query
  name: limit
  required: false
  type: 0
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.4.10
    packID: CortexDataLake
    packName: Strata Logging Service by Palo Alto Networks
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Palo Alto Networks Strata Logging Service XSOAR Connector provides cloud-based,
  centralized log storage and aggregation for your organization on premise, virtual
  (private cloud and public cloud) firewalls, for Prisma Access, and for cloud-delivered
  services such as Cortex XDR.
detaileddescription: "## Overview\n---\n\nPalo Alto Networks Strata Logging Service
  XSOAR Connector provides cloud-based, centralized log storage and aggregation for
  your on premise, virtual (private cloud and public cloud) firewalls, for Prisma
  Access, and for cloud-delivered services such as Cortex XDR.\nThis integration was
  integrated and tested with version 2 of Strata Logging Service XSOAR Connector.\n\n\n\n---\n\n##
  Configure Strata Logging Service XSOAR Connector on Cortex XSOAR \n\n---\n\n1. In
  the War Room, run the command `!GetLicenseID` to get the `license ID`.\n2. Go to
  __Settings__ > __ABOUT__ > __License__ to get the `Customer Name`.\n3. Go to the
  [HUB](https://apps.paloaltonetworks.com/apps) and login using your **Palo Alto Networks**
  credentials. \n4. Under the `Cortex™ XSOAR` app select the relevant instance. If
  you don't have an active `Cortex™ XSOAR` app check out the Hub [Docs site](https://docs.paloaltonetworks.com/hub/hub-getting-started)
  to learn about app activation.\n5. Insert the `license ID` and the `Customer Name`
  in the required fields and complete the authentication process in order  \nto get
  the __Authentication Token__  __Registration ID__ __Encryption Key__\n6. Navigate
  to __Settings__ > __Integrations__ > __Servers & Services__.\n7. Search for Palo
  Alto Networks Cortex v2.\n8. Click __Add instance__ to create and configure a new
  integration instance.\n    * __Name__: a textual name for the integration instance.\n
  \   * __Authentication Token__: From the authentication process\n    * __Registration
  ID__: From the authentication process\n    * __Encryption Key__: From the authentication
  process\n    * __proxy__: Use system proxy settings\n    * __insecure__: Trust any
  certificate (not secure)\n    * __Fetch incidents__: Whether to fetch incidents
  or not\n    * __first_fetch_timestamp__: First fetch time (<number> <time unit>,
  e.g., 12 hours, 7 days, 3 months, 1 year)\n    * __Severity of events to fetch (Firewall)__:
  Select from all,Critical,High,Medium,Low,Informational,Unused\n    * __Subtype of
  events to fetch (Firewall)__: Select from all,attack,url,virus,spyware,vulnerability,file,scan,flood,packet,resource,data,url-content,wildfire,extpcap,wildfire-virus,http-hdr-insert,http-hdr,email-hdr,spyware-dns,spyware-wildfire-dns,spyware-wpc-dns,spyware-custom-dns,spyware-cloud-dns,spyware-raven,spyware-wildfire-raven,spyware-wpc-raven,wpc-virus,sctp\n9.
  Click __Test__ to validate the URLs, token, and connection.\n\n## CDL Server - API
  Calls Caching Mechanism\nThe integration implements a caching mechanism for repetitive
  error when requesting access token from CDL server.\nWhen the intgeration reaches
  the limit of allowed calls, the following error will be shown:\n\n```We have found
  out that your recent attempts to authenticate against the CDL server have failed.
  Therefore we have limited the number of calls that the CDL integration performs.```\n\nThe
  integration will re-attempt authentication if the command was called under the following
  cases:\n\n1. First hour - once every minute.\n2. First 48 hours - once in 10 minutes.\n3.
  After that every 60 minutes.\n\nIf you wish to try authenticating again, run the
  'cdl-reset-authentication-timeout' command and retry.\n\n---\n[View Integration
  Documentation](https://xsoar.pan.dev/docs/reference/integrations/cortex-data-lake)"
display: Strata Logging Service XSOAR Connector
image: data:image/png;base64,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
name: Cortex Data Lake
script:
  commands:
  - arguments:
    - defaultValue: SELECT * FROM `firewall.traffic`
      description: |-
        A free-text SQL query. For example, query="SELECT * FROM `firewall.traffic`".
        There are multiple tables in Loggings, for example: threat, traffic, and so on.
        Refer to the Cortex Logging service schema reference for the full list.
      name: query
    - defaultValue: "10"
      description: The maximum number of logs to return. Default is 10.
      name: limit
    - auto: PREDEFINED
      defaultValue: "true"
      description: If set to false, query results are not mapped into the standard
        command context. Default is "true".
      name: transform_results
      predefined:
      - "true"
      - "false"
    description: Runs a query on  any table or field.
    execution: true
    name: cdl-query-logs
    outputs:
    - contextPath: CDL.Logging.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: Number
    - contextPath: CDL.Logging.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.IsNat
      description: Indicates if the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: Boolean
    - contextPath: CDL.Logging.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.NatDestination
      description: If destination NAT was performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.FileSHA256
      description: The binary hash (SHA256) of the file sent for virus analysis.
      type: String
    - contextPath: CDL.Logging.FileName
      description: The name of the infected file.
      type: String
    - contextPath: CDL.Logging.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - defaultValue: "10"
      description: The maximum number of logs to return. Default is 10.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 minutes, 7 days,
        3 weeks).
      name: time_range
    - auto: PREDEFINED
      defaultValue: "true"
      description: If set to false, query results are not mapped into the standard
        command context. Default is "true".
      name: transform_results
      predefined:
      - "true"
      - "false"
    description: Runs a query on the threat table according to preset queries.
    name: cdl-get-critical-threat-logs
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: Boolean
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap), or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT is performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier.
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatName
      description: Threat name of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: Query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: Query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - defaultValue: "10"
      description: The maximum number of logs to return. Default is 10.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 minutes, 7 days,
        3 weeks).
      name: time_range
    description: Runs a query on traffic table where app_sub_category = "social networking".
    name: cdl-get-social-applications
    outputs:
    - contextPath: CDL.Logging.Traffic.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Traffic.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Traffic.Packets
      description: Number of total packets (transmit and receive) seen for the session.
      type: String
    - contextPath: CDL.Logging.Traffic.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.Vsys
      description: Virtual system associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1, otherwise it is 0.
      type: Boolean
    - contextPath: CDL.Logging.Traffic.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: date
    - contextPath: CDL.Logging.Traffic.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category.
      type: String
    - contextPath: CDL.Logging.Traffic.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestinationPort
      description: Post-NAT destination port.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalTimeElapsed
      description: Total time for the network session to complete.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceName
      description: Device name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Traffic.Subtype
      description: The log sub type.
      type: String
    - contextPath: CDL.Logging.Traffic.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Traffic.TunneledApp
      description: Whether the app is tunneled.
      type: String
    - contextPath: CDL.Logging.Traffic.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionEndReason
      description: The reason a session terminated.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionStartIP
      description: Time when the session was established.
      type: date
    - contextPath: CDL.Logging.Traffic.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: date
    - contextPath: CDL.Logging.Traffic.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalBytes
      description: Number of total bytes (transmit and receive).
      type: String
    - contextPath: CDL.Logging.Traffic.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: String
    - contextPath: CDL.Logging.Traffic.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Traffic.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Traffic.SourcePort
      description: Source port utilized by the session.
      type: String
    - contextPath: CDL.Logging.Traffic.Tunnel
      description: Type of tunnel.
      type: String
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - defaultValue: "10"
      description: The maximum number of logs to return. Default is 10.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 minutes, 7 days,
        3 weeks).
      name: time_range
    - description: The SHA256 hash of the file for the query. For example, SHA256="503ca1a4fc0d48b18c0336f544ba0f0abf305ae3a3f49b3c2b86b8645d6572dc"
        would return all logs associated with this file.
      name: SHA256
      required: true
    description: Runs a query on the threat table with the query 'SELECT * FROM `firewall.threat`
      WHERE file_sha_256 = <file_hash>'.
    name: cdl-search-by-file-hash
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1, otherwise it is 0.
      type: Boolean
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap) , or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier.
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
  - arguments:
    - description: A source IP address or an array of source IPs addresses for which
        to search, for example 1.1.1.1,2.2.2.2.
      name: source_ip
    - description: A rule name or an array of rule names to search.
      name: rule
    - description: A source zone name or an array of source zone names to search.
      name: from_zone
    - description: A destination zone name or an array of zone names to search.
      name: to_zone
    - description: Source port utilized by the session. Can be a port number or an
        array of destination port numbers to search. For example '443' or '443,445'.
      name: source_port
    - description: An action name or an array of action names to search.
      name: action
    - description: A free-text query for which to search. This forms the WHERE part
        of the query, for example, !cdl-query-traffic-logs query="source_ip.value
        LIKE '192.168.1.*' AND dest_ip.value='8.8.8.8' And dest_port=1234".
      name: query
    - auto: PREDEFINED
      defaultValue: all
      description: The fields selected in the query. Selection can be "all" (same
        as *) or a comma-separated list of specific fields. The list of fields can
        be found after viewing all the outputted fields with "all".
      name: fields
      predefined:
      - all
      - vendor_name
      - log_source
      - log_source_id
      - log_source_name
      - customer_id
      - log_time
      - log_source_tz_offset
      - log_type
      - sub_type
      - source_ip
      - source_port
      - dest_ip
      - dest_port
      - protocol
      - action_source
      - bytes_total
      - bytes_received
      - bytes_sent
      - ep_assoc_id
      - chunks_total
      - chunks_received
      - chunks_sent
      - packets_total
      - packets_received
      - packets_sent
      - session_start_time
      - total_time_elapsed
      - session_end_reason
      - traffic_flags
      - url_category
      - action
      - action_flags
      - app
      - app_category
      - characteristics_of_app
      - container_of_app
      - dg_hier_level_1
      - dg_hier_level_2
      - dg_hier_level_3
      - dg_hier_level_4
      - dest_uuid
      - dest_location
      - dest_user
      - dest_user_info
      - is_exported
      - is_forwarded
      - from_zone
      - http2_connection
      - inbound_if
      - inbound_if_details
      - is_saas_app
      - is_dup_log
      - is_prisma_branch
      - is_prisma_mobile
      - log_set
      - monitor_tag_imei
      - nat_dest_port
      - nat_dest
      - nat_source_port
      - nat_source
      - non_standard_dest_port
      - outbound_if
      - outbound_if_details
      - parent_session_id
      - parent_start_time
      - count_of_repeats
      - risk_of_app
      - rule_matched
      - rule_matched_uuid
      - sanctioned_state_of_app
      - sequence_no
      - session_id
      - source_uuid
      - source_location
      - source_user
      - source_user_info
      - app_sub_category
      - technology_of_app
      - time_generated
      - to_zone
      - tunnel
      - tunneled_app
      - tunnelid_imsi
      - users
      - vsys_id
      - vsys
      - vsys_name
      - flags
      - is_decrypt_mirror
      - is_sym_return
      - is_container
      - is_server_to_client
      - is_client_to_server
      - is_transaction
      - is_non_std_dest_port
      - is_captive_portal
      - is_nat
      - is_proxy
      - is_packet_capture
      - is_phishing
      - is_mptcp_on
      - is_recon_excluded
      - is_url_denied
      - is_tunnel_inspected
      - is_source_x_fwded
      - is_ipv6
      - is_decrypted_payload_fwded
      - is_decryption_log
      - is_l7_inspection_b4_session
      - sess_owner_rt_midx
      - session_tracker
      - container_id
      - pod_namespace
      - pod_name
      - source_device_class
      - source_device_vendor
      - source_device_model
      - source_device_os
      - source_device_mac
      - dest_device_class
      - dest_device_vendor
      - dest_device_model
      - dest_device_os
      - dest_device_mac
      - link_change_count
      - policy_id
      - link_switches
      - sdwan_cluster
      - sdwan_device_type
      - sdwan_cluster_type
      - sdwan_site
      - dynusergroup_name
      - ingestion_time
      - record_size
      - source_device_host
      - dest_device_host
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 minutes, 7 days,
        3 weeks).
      name: time_range
    - defaultValue: "5"
      description: The maximum number of logs to return. Default is 5.
      name: limit
    - description: A destination IP address or an array of destination IPs addresses
        for which to search, for example 1.1.1.1,2.2.2.2.
      name: dest_ip
    - description: Destination port utilized by the session. Can be port number or
        an array of destination port numbers to search. For example '443' or '443,445'.
      name: dest_port
    - description: An IP address or an array of IP addresses for which to search,
        for example 1.1.1.1,2.2.2.2. Used instead of the source/destination IP address.
      name: ip
    - description: A port or array of ports to search. Used instead of the source/destination
        port.
      name: port
    description: Searches the Cortex firewall.traffic table. Traffic logs contain
      entries for the end of each network session.
    name: cdl-query-traffic-logs
    outputs:
    - contextPath: CDL.Logging.Traffic.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Traffic.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Traffic.Packets
      description: Number of total packets (transmit and receive) seen for the session.
      type: String
    - contextPath: CDL.Logging.Traffic.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.Vsys
      description: Virtual system associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1, otherwise it is 0.
      type: Boolean
    - contextPath: CDL.Logging.Traffic.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: date
    - contextPath: CDL.Logging.Traffic.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category.
      type: String
    - contextPath: CDL.Logging.Traffic.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestinationPort
      description: Post-NAT destination port.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalTimeElapsed
      description: Total time for the network session to complete.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceName
      description: Device name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Traffic.Subtype
      description: The log sub type.
      type: String
    - contextPath: CDL.Logging.Traffic.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Traffic.TunneledApp
      description: Whether the app is tunneled.
      type: String
    - contextPath: CDL.Logging.Traffic.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionEndReason
      description: The reason a session terminated.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionStartIP
      description: Time when the session was established.
      type: date
    - contextPath: CDL.Logging.Traffic.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: date
    - contextPath: CDL.Logging.Traffic.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalBytes
      description: Number of total bytes (transmit and receive).
      type: String
    - contextPath: CDL.Logging.Traffic.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: String
    - contextPath: CDL.Logging.Traffic.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Traffic.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Traffic.SourcePort
      description: Source port utilized by the session.
      type: String
    - contextPath: CDL.Logging.Traffic.Tunnel
      description: Type of tunnel.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceDeviceHost
      description: Hostname of the device from which the session originated.
      type: String
    - contextPath: CDL.Logging.Traffic.DestDeviceHost
      description: Hostname of the device session destination.
      type: String
  - arguments:
    - description: Original source IP address. Enter an IP address or an array of
        IP addresses for which to search, for example 1.1.1.1,2.2.2.2.
      name: source_ip
    - description: Original destination IP address. Enter an IP address or an array
        of IP addresses for which to search, for example 1.1.1.1,2.2.2.2.
      name: dest_ip
    - description: Name of the security policy rule that the network traffic matched.
        Enter a rule name or array of rule names to search.
      name: rule_matched
    - description: The networking zone from which the traffic originated. Enter the
        zone or array of zones to search.
      name: from_zone
    - description: The networking zone to which the traffic was sent. Enter the zone
        or array of zones to search.
      name: to_zone
    - description: Source port utilized by the session. Enter a port or array of ports
        to search.
      name: source_port
    - description: Network traffic's destination port. Enter a port or array of ports
        to search.
      name: dest_port
    - auto: PREDEFINED
      description: The action that the firewall took for the network traffic. Enter
        an action or array of actions to search.
      name: action
      predefined:
      - unknown
      - n-a
      - aged-out
      - decoder
      - tcp-reuse
      - resources-unavailable
      - tcp-fin
      - tcp-rst-from-server
      - tcp-rst-from-client
      - policy-deny
      - threat
      - decrypt-error
      - decrypt-unsupport-param
      - decrypt-cert-validation
      - request-timeout
      - shutdown-from-endpoint
      - abort-from-endpoint
      - split-tunnel
    - description: The binary hash (SHA256) of the file. Enter a SHA256 hash or array
        of SHA256 hashes to search.
      name: file_sha_256
    - description: The name of the file that is blocked. Enter a file name or array
        of file names to search.
      name: file_name
    - description: Free input query to search. This is the WHERE part of the query.
        so an example will be !cdl-query-traffic-logs query="source_ip.value LIKE
        '192.168.1.*' AND dest_ip.value = '192.168.1.12'".
      name: query
    - auto: PREDEFINED
      defaultValue: all
      description: The fields that are selected in the query. Selection can be "all"
        (same as *) or or a comma-separated list of specific fields. The list of fields
        can be found after viewing all the outputted fields with "all".
      isArray: true
      name: fields
      predefined:
      - vendor_name
      - log_source
      - log_source_id
      - log_source_name
      - customer_id
      - log_time
      - log_source_tz_offset
      - log_type
      - sub_type
      - source_ip
      - source_port
      - dest_ip
      - dest_port
      - protocol
      - threat_id
      - threat_name
      - threat_category
      - cloud_hostname
      - direction_of_attack
      - url_domain
      - url_idx
      - file_name
      - cloud
      - file_sha_256
      - file_type
      - sender_of_virus
      - recipient_of_virus
      - subject_of_email
      - report_id
      - verdict
      - vendor_severity
      - severity
      - pcap
      - pcap_id
      - sig_flags
      - url_category
      - action
      - action_flags
      - app
      - app_category
      - characteristics_of_app
      - container_of_app
      - dg_hier_level_1
      - dg_hier_level_2
      - dg_hier_level_3
      - dg_hier_level_4
      - dest_uuid
      - dest_location
      - dest_user
      - dest_user_info
      - is_exported
      - is_forwarded
      - from_zone
      - http2_connection
      - inbound_if
      - inbound_if_details
      - is_saas_app
      - is_dup_log
      - is_prisma_branch
      - is_prisma_mobile
      - log_set
      - monitor_tag_imei
      - nat_dest_port
      - nat_dest
      - nat_source_port
      - nat_source
      - non_standard_dest_port
      - outbound_if
      - outbound_if_details
      - parent_session_id
      - parent_start_time
      - count_of_repeats
      - risk_of_app
      - rule_matched
      - rule_matched_uuid
      - sanctioned_state_of_app
      - sequence_no
      - session_id
      - source_uuid
      - source_location
      - source_user
      - source_user_info
      - app_sub_category
      - technology_of_app
      - time_generated
      - to_zone
      - tunnel
      - tunneled_app
      - tunnelid_imsi
      - users
      - vsys_id
      - vsys
      - vsys_name
      - flags
      - is_decrypt_mirror
      - is_sym_return
      - is_container
      - is_server_to_client
      - is_client_to_server
      - is_transaction
      - is_non_std_dest_port
      - is_captive_portal
      - is_nat
      - is_proxy
      - is_packet_capture
      - is_phishing
      - is_mptcp_on
      - is_recon_excluded
      - is_url_denied
      - is_tunnel_inspected
      - is_source_x_fwded
      - is_ipv6
      - container_id
      - pod_namespace
      - pod_name
      - source_device_class
      - source_device_vendor
      - source_device_model
      - source_device_os
      - source_device_mac
      - dest_device_class
      - dest_device_vendor
      - dest_device_model
      - dest_device_os
      - dest_device_mac
      - content_version
      - dynusergroup_name
      - ingestion_time
      - record_size
      - source_device_host
      - dest_device_host
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 minutes, 7 days,
        3 weeks).
      name: time_range
    - defaultValue: "5"
      description: The maximum number of logs to return. Default is 5.
      name: limit
    - description: The IP address or an array of IP addresses for which to search.
        For example 1.1.1.1,2.2.2.2. Used instead of the source/destination IP address.
      name: ip
    - description: The port or array of ports to search. Used instead of the source/destination
        port.
      name: port
    description: Searches the Cortex panw.threat table, which is the threat logs table
      for PAN-OS/Panorama.
    name: cdl-query-threat-logs
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1, otherwise it is 0.
      type: Boolean
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap) , or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier.
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatName
      description: Threat name of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
    - contextPath: CDL.Logging.Threat.SourceDeviceHost
      description: Hostname of the device from which the session originated.
      type: String
    - contextPath: CDL.Logging.Threat.DestDeviceHost
      description: Hostname of the device session destination.
      type: String
  - arguments:
    - description: A source IP address or an array of IP addresses for which to search.
        For example, 1.1.1.1,2.2.2.2.
      name: source_ip
    - description: A destination IP address or an array of IP addresses for which
        to search. For example, 1.1.1.1,2.2.2.2.
      name: dest_ip
    - description: The name of the security policy rule or an array of rule names
        to search.
      name: rule_matched
    - description: The networking zone or array of zones to search.
      name: from_zone
    - description: The networking zone or array of zones to search.
      name: to_zone
    - description: The source port or array of ports to search.
      name: source_port
    - description: The network traffic's destination port or array of ports to search.
      name: dest_port
    - auto: PREDEFINED
      description: The action or array of actions that the firewall undertook to search.
      name: action
      predefined:
      - unknown
      - n-a
      - aged-out
      - decoder
      - tcp-reuse
      - resources-unavailable
      - tcp-fin
      - tcp-rst-from-server
      - tcp-rst-from-client
      - policy-deny
      - threat
      - decrypt-error
      - decrypt-unsupport-param
      - decrypt-cert-validation
      - request-timeout
      - shutdown-from-endpoint
      - abort-from-endpoint
      - split-tunnel
    - description: Free input query to search. This is the WHERE part of the query.
        For example, !cdl-query-url-logs query="source_ip.value LIKE '192.168.1.*'
        AND dest_ip.value = '192.168.1.12'".
      name: query
    - auto: PREDEFINED
      defaultValue: all
      description: The fields that are selected in the query. Selection can be "all"
        (same as *) or a comma-separated list of specific fields. List of fields can
        be found after viewing all the outputted fields with "all".
      isArray: true
      name: fields
      predefined:
      - vendor_name
      - log_source
      - log_source_id
      - log_source_name
      - customer_id
      - log_time
      - log_source_tz_offset
      - log_type
      - sub_type
      - source_ip
      - source_port
      - dest_ip
      - dest_port
      - protocol
      - threat_id
      - threat_name
      - threat_category
      - cloud_hostname
      - direction_of_attack
      - url_domain
      - url_idx
      - file_name
      - cloud
      - file_sha_256
      - file_type
      - sender_of_virus
      - recipient_of_virus
      - subject_of_email
      - report_id
      - verdict
      - vendor_severity
      - severity
      - pcap
      - pcap_id
      - sig_flags
      - url_category
      - action
      - action_flags
      - app
      - app_category
      - characteristics_of_app
      - container_of_app
      - dg_hier_level_1
      - dg_hier_level_2
      - dg_hier_level_3
      - dg_hier_level_4
      - dest_uuid
      - dest_location
      - dest_user
      - dest_user_info
      - is_exported
      - is_forwarded
      - from_zone
      - http2_connection
      - inbound_if
      - inbound_if_details
      - is_saas_app
      - is_dup_log
      - is_prisma_branch
      - is_prisma_mobile
      - log_set
      - monitor_tag_imei
      - nat_dest_port
      - nat_dest
      - nat_source_port
      - nat_source
      - non_standard_dest_port
      - outbound_if
      - outbound_if_details
      - parent_session_id
      - parent_start_time
      - count_of_repeats
      - risk_of_app
      - rule_matched
      - rule_matched_uuid
      - sanctioned_state_of_app
      - sequence_no
      - session_id
      - source_uuid
      - source_location
      - source_user
      - source_user_info
      - app_sub_category
      - technology_of_app
      - time_generated
      - to_zone
      - tunnel
      - tunneled_app
      - tunnelid_imsi
      - users
      - vsys_id
      - vsys
      - vsys_name
      - flags
      - is_decrypt_mirror
      - is_sym_return
      - is_container
      - is_server_to_client
      - is_client_to_server
      - is_transaction
      - is_non_std_dest_port
      - is_captive_portal
      - is_nat
      - is_proxy
      - is_packet_capture
      - is_phishing
      - is_mptcp_on
      - is_recon_excluded
      - is_url_denied
      - is_tunnel_inspected
      - is_source_x_fwded
      - is_ipv6
      - container_id
      - pod_namespace
      - pod_name
      - source_device_class
      - source_device_vendor
      - source_device_model
      - source_device_os
      - source_device_mac
      - dest_device_class
      - dest_device_vendor
      - dest_device_model
      - dest_device_os
      - dest_device_mac
      - content_version
      - dynusergroup_name
      - ingestion_time
      - record_size
      - source_device_host
      - dest_device_host
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - auto: PREDEFINED
      description: First log time (<number> <time unit>. For example, 12 minutes,
        7 days, 3 weeks).
      name: time_range
    - description: The maximum number of logs to return. Default is 5.
      name: limit
    - description: The IP address or an array of IP addresses for which to search.
        For example 1.1.1.1,2.2.2.2. Used instead of the source/destination IP address.
      name: ip
    - description: The port or array of ports to search. Used instead of the source/destination
        port.
      name: port
    - description: "This argument allows to perform a LIKE search of the specified
        values on the URL and URI fields. \nAn example value will be paloaltonetworks.com,
        demisto\twhich will provide results like https://apps.paloaltonetworks.com
        and https://demisto.com."
      name: url
    description: Searches the URL log table.
    name: cdl-query-url-logs
    outputs:
    - contextPath: CDL.Logging.URL.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.URL.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.URL.App
      description: The application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.URL.PcapID
      description: Packet capture (pcap) ID. Used to correlate threat pcap files with
        extended pcaps taken as a part of the session flow. All threat logs contain
        either a pcap_id of 0 (no associated pcap), or an ID referencing the extended
        pcap file.
      type: String
    - contextPath: CDL.Logging.URL.DestinationPort
      description: The network traffic's destination port. If this value is 0, then
        the app is using its standard port.
      type: String
    - contextPath: CDL.Logging.URL.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.URL.AppSubCategory
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.URL.SourceLocation
      description: The source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.URL.DestinationLocation
      description: The destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.URL.ToZone
      description: The networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.URL.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.URL.Protocol
      description: The IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.URL.DestinationIP
      description: The original destination IP address.
      type: String
    - contextPath: CDL.Logging.URL.SourceIP
      description: The original source IP address.
      type: String
    - contextPath: CDL.Logging.URL.RuleMatched
      description: The unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.URL.ThreatCategory
      description: The category of the detected threat.
      type: String
    - contextPath: CDL.Logging.URL.ThreatName
      description: The name of the detected threat.
      type: String
    - contextPath: CDL.Logging.URL.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.URL.LogTime
      description: The time the log was received in Strata Logging Service XSOAR Connector.
      type: String
    - contextPath: CDL.Logging.URL.LogSourceName
      description: The name of the source of the log.
      type: String
    - contextPath: CDL.Logging.URL.Denied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.URL.Category
      description: The category of the URL.
      type: String
    - contextPath: CDL.Logging.URL.SourcePort
      description: The source port utilized by the session.
      type: Number
    - contextPath: CDL.Logging.URL.Url
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.URL.Uri
      description: The address of the URI.
      type: String
    - contextPath: CDL.Logging.URL.ContentType
      description: The content type of the HTTP response data.
      type: String
    - contextPath: CDL.Logging.URL.HTTPMethod
      description: |-
        The HTTP Method used
        in the web request.
      type: String
    - contextPath: CDL.Logging.URL.Severity
      description: The severity associated with the event.
      type: String
    - contextPath: CDL.Logging.URL.UserAgent
      description: |-
        The web browser that the user
        used to access the URL.
      type: String
    - contextPath: CDL.Logging.URL.RefererProtocol
      description: The protocol used in the HTTP Referer header field.
      type: Number
    - contextPath: CDL.Logging.URL.RefererPort
      description: The port used in the HTTP Referer header field.
      type: Number
    - contextPath: CDL.Logging.URL.RefererFQDN
      description: |-
        The full domain name used in the HTTP Referer
        header field.
      type: String
    - contextPath: CDL.Logging.URL.RefererURL
      description: The URL used in the HTTP Referer header field.
      type: String
    - contextPath: CDL.Logging.URL.SrcUser
      description: The username that initiated the network traffic.
      type: String
    - contextPath: CDL.Logging.URL.SrcUserInfo
      description: The information for the initiated user.
      type: String
    - contextPath: CDL.Logging.URL.DstUser
      description: The username to which the network traffic was destined.
      type: String
    - contextPath: CDL.Logging.URL.DstUserInfo
      description: The destination user information.
      type: String
    - contextPath: CDL.Logging.URL.TechnologyOfApp
      description: The networking technology used by the identified application.
      type: String
    - contextPath: CDL.Logging.URL.SourceDeviceHost
      description: Hostname of the device from which the session originated.
      type: String
    - contextPath: CDL.Logging.URL.DestDeviceHost
      description: Hostname of the device session destination.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: Identifies the action that the firewall took for the network traffic.
      name: action
      predefined:
      - unknown
      - n-a
      - aged-out
      - decoder
      - tcp-reuse
      - resources-unavailable
      - tcp-fin
      - tcp-rst-from-server
      - tcp-rst-from-client
      - policy-deny
      - threat
      - decrypt-error
      - decrypt-unsupport-param
      - decrypt-cert-validation
      - request-timeout
      - shutdown-from-endpoint
      - abort-from-endpoint
      - split-tunnel
    - description: Application associated with the network traffic.
      name: app
    - description: Identifies the high-level family of the application.
      name: app_category
    - description: Hostname of the device to which the session was directed.
      name: dest_device_host
    - description: Original destination IP address.
      name: dest_ip
    - description: The name of the external dynamic list that contains the destination
        IP address of the traffic.
      name: dest_edl
    - description: The dynamic address group that Device-ID identifies as the destination
        for the traffic.
      name: dest_dynamic_address_group
    - description: Destination country or internal region for private addresses.
      name: dest_location
    - description: |-
        Network traffic's destination port. If this value is 0, then the app is using
        its standard port.
      name: dest_port
    - description: The username to which the network traffic was destined.
      name: dest_user
    - description: The name of the file that is blocked.
      name: file_name
    - description: The binary hash (SHA256) of the file. Enter a SHA256 hash or array
        of SHA256 hashes to search.
      name: file_sha_256
    - description: Palo Alto Networks textual identifier for the threat.
      name: file_type
    - description: The networking zone from which the traffic originated.
      name: from_zone
    - description: Indicates if the direction of traffic is from server to client.
      name: is_server_to_client
    - description: Indicates whether the session was denied due to a URL filtering
        rule.
      name: is_url_denied
    - auto: PREDEFINED
      description: Identifies the log type.
      name: log_type
      predefined:
      - traffic
      - config
      - system
      - threat
      - appstat
      - trsum
      - thsum
      - event
      - alarm
      - hipmatch
      - userid
      - iptag
      - mdm
      - extpcap
      - urlsum
      - gtp
      - gtpsum
      - auth
      - panflex
      - extflex
      - sctp
      - sctpsum
      - analytics
      - action
      - scan
      - sam
    - description: If destination NAT performed, the post-NAT destination IP address.
      name: nat_dest
    - description: Post-NAT destination port.
      name: nat_dest_port
    - description: If source NAT was performed, the post-NAT source IP address.
      name: nat_source
    - description: Post-NAT source port.
      name: nat_source_port
    - description: Name of the security policy rule that the network traffic matched.
      name: rule_matched
    - description: Unique identifier for the security policy rule that the network
        traffic matched.
      name: rule_matched_uuid
    - description: Severity as defined by the platform.
      name: severity
    - description: Hostname of the device from which the session originated.
      name: source_device_host
    - description: Original source IP address.
      name: source_ip
    - description: The name of the external dynamic list that contains the source
        IP address of the traffic.
      name: source_edl
    - description: The dynamic address group that Device-ID identifies as the source
        of the traffic.
      name: source_dynamic_address_group
    - description: Source country or internal region for private addresses.
      name: source_location
    - description: Source port utilized by the session.
      name: source_port
    - description: The username that initiated the network traffic.
      name: source_user
    - auto: PREDEFINED
      description: Identifies the log subtype.
      name: sub_type
      predefined:
      - attack
      - url
      - virus
      - spyware
      - vulnerability
      - file
      - scan
      - flood
      - packet
      - resource
      - data
      - url-content
      - wildfire
      - extpcap
      - wildfire-virus
      - http-hdr-insert
      - http-hdr
      - email-hdr
      - spyware-dns
      - spyware-wildfire-dns
      - spyware-wpc-dns
      - spyware-custom-dns
      - spyware-cloud-dns
      - spyware-raven
      - spyware-wildfire-raven
      - spyware-wpc-raven
      - wpc-virus
      - sctp
    - description: The URL category.
      name: url_category
    - description: The name of the internet domain that was visited in this session.
      name: url_domain
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00".
        Default is 1970-01-01 00:00:00.
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - description: First log time (<number> <time unit>. For example, 12 minutes,
        7 days, 3 weeks).
      name: time_range
    - defaultValue: "5"
      description: The maximum number of logs to return. Default is 5.
      name: limit
    description: Searches the Cortex firewall.file_data table.
    name: cdl-query-file-data
    outputs:
    - contextPath: CDL.Logging.File.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.File.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.File.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.File.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.File.FileSHA256
      description: The binary hash (SHA256) of the file.
      type: String
    - contextPath: CDL.Logging.File.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.File.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.File.LogSourceName
      description: Name of the source of the log. The hostname of the firewall that
        logged the network traffic.
      type: String
    - contextPath: CDL.Logging.File.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.File.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.File.CharacteristicOfApp
      description: Identifies the behavioral characteristic of the application associated
        with the network traffic.
      type: String
    - contextPath: CDL.Logging.File.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.File.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.File.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.File.IsNat
      description: Indicates if the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1, otherwise it is 0.
      type: Boolean
    - contextPath: CDL.Logging.File.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.File.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.File.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.File.IsUrlDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.File.IsTunnelInspected
      description: Indicates whether the payload for the outer tunnel was inspected.
      type: Boolean
    - contextPath: CDL.Logging.File.SequenceNo
      description: The log entry identifier, which is incremented sequentially.
      type: Number
    - contextPath: CDL.Logging.File.IsDecryptMirror
      description: Indicates whether decrypted traffic was sent out in clear text
        through a mirror port.
      type: Boolean
    - contextPath: CDL.Logging.File.IsNonStdDestPort
      description: Indicates if the destination port is non-standard.
      type: Boolean
    - contextPath: CDL.Logging.File.RuleMatchedUuid
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.File.IsProxy
      description: Indicates whether the SSL session is decrypted (SSL Proxy).
      type: Boolean
    - contextPath: CDL.Logging.File.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.File.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.File.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.File.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6.
      type: Number
    - contextPath: CDL.Logging.File.Tunnel
      description: Type of tunnel.
      type: String
    - contextPath: CDL.Logging.File.CloudHostname
      description: The hostname in which the VM-series firewall is running.
      type: String
    - contextPath: CDL.Logging.File.Http2Connection
      description: Parent session ID for an HTTP/2 connection. If the traffic is not
        using HTTP/2, this field is set to 0.
      type: Number
    - contextPath: CDL.Logging.File.IsPrismaBranch
      description: Internal-use field. If set to 1, the log was generated on a cloud-based
        firewall. If 0, the firewall was running on-premise.
      type: Boolean
    - contextPath: CDL.Logging.File.OutboundIf
      description: Interface to which the network traffic was destined.
      type: String
    - contextPath: CDL.Logging.File.IsSymReturn
      description: Indicates whether symmetric return was used to forward traffic
        for this session.
      type: Boolean
    - contextPath: CDL.Logging.File.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.File.IsReconExcluded
      description: Indicates whether the source for the flow is on the firewall allow
        list and not subject to recon protection.
      type: Boolean
    - contextPath: CDL.Logging.File.SanctionedStateOfApp
      description: Indicates whether the application has been flagged as sanctioned
        by the firewall administrator.
      type: Boolean
    - contextPath: CDL.Logging.File.ReportID
      description: Identifies the analysis requested from the sandbox (cloud or appliance).
      type: Number
    - contextPath: CDL.Logging.File.DestinationPort
      description: |-
        Network traffic's destination port. If this value is 0, then the app is using
        its standard port.
      type: Number
    - contextPath: CDL.Logging.File.IsDupLog
      description: Indicates whether this log data is available in multiple locations,
        such as from Strata Logging Service XSOAR Connector as well as from an on-premise
        log collector.
      type: Boolean
    - contextPath: CDL.Logging.File.LogTime
      description: Time the log was received in Strata Logging Service XSOAR Connector.
      type: Date
    - contextPath: CDL.Logging.File.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: Number
    - contextPath: CDL.Logging.File.RecordSize
      description: The size of the record.
      type: Number
    - contextPath: CDL.Logging.File.IngestionTime
      description: Ingestion time of the log.
      type: Date
    - contextPath: CDL.Logging.File.CountOfRepeats
      description: Number of sessions with the same source IP, destination IP, application,
        and content/threat type seen for the summary interval.
      type: Number
    - contextPath: CDL.Logging.File.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.File.VendorName
      description: Identifies the vendor that produced the data.
      type: String
    - contextPath: CDL.Logging.File.IsMptcpOn
      description: Indicates whether the option is enabled on the next-generation
        firewall that allows a client to use multiple paths to connect to a destination
        host.
      type: Boolean
    - contextPath: CDL.Logging.File.IsClientToServer
      description: Indicates if the direction of traffic is from client to server.
      type: Boolean
    - contextPath: CDL.Logging.File.IsServerToClient
      description: Indicates if the direction of traffic is from server to client.
      type: Boolean
    - contextPath: CDL.Logging.File.IsPacketCapture
      description: Indicates whether the session has a packet capture (PCAP).
      type: Boolean
    - contextPath: CDL.Logging.File.IsTransaction
      description: Indicates whether the log corresponds to a transaction within an
        HTTP proxy session (Proxy Transaction).
      type: Boolean
    - contextPath: CDL.Logging.File.InboundIf
      description: Interface from which the network traffic was sourced.
      type: String
    - contextPath: CDL.Logging.File.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.File.FileType
      description: Palo Alto Networks textual identifier for the threat.
      type: String
    - contextPath: CDL.Logging.File.IsPrismaMobile
      description: If set to 1, the log record was generated using a cloud-based GlobalProtect
        instance. If 0, GlobalProtect was hosted on-premise. (For internal use only.)
      type: Boolean
    - contextPath: CDL.Logging.File.IsContainer
      description: Indicates if the session is a container page access (Container
        Page).
      type: Boolean
    - contextPath: CDL.Logging.File.IsSaasApp
      description: Indicates whether the application associated with this network
        traffic is a SAAS application. (For internal use only.)
      type: Boolean
    - contextPath: CDL.Logging.File.Vsys
      description: Unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: String
    - contextPath: CDL.Logging.File.FileID
      description: Numerical identifier for the threat type.
      type: Number
    - contextPath: CDL.Logging.File.IsCaptivePortal
      description: Indicates if user information for the session was captured through
        Captive Portal.
      type: Boolean
    - contextPath: CDL.Logging.File.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.File.CustomerID
      description: The ID that uniquely identifies the Strata Logging Service XSOAR
        Connector instance which received this log record.
      type: Number
    - contextPath: CDL.Logging.File.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.File.TunneledApp
      description: Tunneled app (For internal use only).
      type: String
    - contextPath: CDL.Logging.File.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, then it is its serial number.
      type: String
    - contextPath: CDL.Logging.File.IsForwarded
      description: Indicates if the log is being forwarded. (For internal use only.)
      type: Boolean
    - contextPath: CDL.Logging.File.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.File.PcapID
      description: Packet capture ID.
      type: Number
    - contextPath: CDL.Logging.File.AppSubcategory
      description: Identifies the application's subcategory.
      type: String
    - contextPath: CDL.Logging.File.IsExported
      description: Indicates if this log was exported from the firewall using the
        firewall's log export function.
      type: Boolean
    - contextPath: CDL.Logging.File.Severity
      description: Severity as defined by the platform.
      type: String
    - contextPath: CDL.Logging.File.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.File.LogType
      description: Identifies the log type.
      type: String
    - contextPath: CDL.Logging.File.LogSet
      description: Log forwarding profile name that was applied to the session. This
        name was defined by the firewall's administrator.
      type: String
    - contextPath: CDL.Logging.File.TechnologyOfApp
      description: The networking technology used by the identified application.
      type: String
    - contextPath: CDL.Logging.File.DirectionOfAttack
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.File.LogSource
      description: Identifies the origin of the data (the system that produced the
        data.
      type: String
  - arguments: []
    description: Use this command in case your authentication calls fail due to internal
      call-limit, the command will reset the limit cache.
    name: cdl-reset-authentication-timeout
  dockerimage: demisto/python_pancloud_v2:1.0.0.91454
  isfetch: true
  runonce: false
  script: |
    register_module_line('Cortex Data Lake', 'start', __line__())
    ### pack version: 1.4.10


    """ IMPORTS """
    import os
    import re
    import json
    from pancloud import QueryService, Credentials, exceptions
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Any
    from collections.abc import Callable
    from tempfile import gettempdir
    from dateutil import parser
    from datetime import timedelta

    # disable insecure warnings
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    ''' GLOBAL CONSTS '''
    ACCESS_TOKEN_CONST = 'access_token'  # guardrails-disable-line
    EXPIRES_IN = 'expires_in'
    INSTANCE_ID_CONST = 'instance_id'
    API_URL_CONST = 'api_url'
    FIRST_FAILURE_TIME_CONST = 'first_failure_time'
    LAST_FAILURE_TIME_CONST = 'last_failure_time'
    DEFAULT_API_URL = 'https://api.us.cdl.paloaltonetworks.com'
    MINUTES_60 = 60 * 60
    SECONDS_30 = 30
    FETCH_TABLE_HR_NAME = {
        "firewall.threat": "Cortex Firewall Threat",
        "firewall.file_data": "Cortex Firewall File Data",
        "firewall.auth": "Cortex Firewall Authentication",
        "firewall.decryption": "Cortex Firewall Decryption",
        "firewall.extpcap": "Cortex Firewall Extpcap",
        "firewall.globalprotect": "Cortex Firewall GlobalProtect",
        "firewall.hipmatch": "Cortex Firewall HIP Match",
        "firewall.iptag": "Cortex Firewall IPtag",
        "firewall.traffic": "Cortex Firewall Traffic",
        "firewall.url": "Cortex Firewall URL",
        "firewall.userid": "Cortex Firewall UserID",
        "log.system": "Cortex Common System",
        "log.config": "Cortex Common Config"
    }
    BAD_REQUEST_REGEX = r'^Error in API call \[400\].*'


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, token_retrieval_url, registration_id, use_ssl, proxy, refresh_token, enc_key):
            headers = get_x_content_info_headers()
            headers['Authorization'] = registration_id
            headers['Accept'] = 'application/json'
            super().__init__(base_url=token_retrieval_url, headers=headers, verify=use_ssl, proxy=proxy)
            self.refresh_token = refresh_token
            self.enc_key = enc_key
            self.use_ssl = use_ssl
            # Trust environment settings for proxy configuration
            self.trust_env = proxy
            self._set_access_token()

        def _set_access_token(self):
            """
            Checks if access token exists in the integration context and set it to the object properties, if not, a new token
            is generated and saved in the integration context along with the query api_url and the instance_id
            Returns:
                None
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get(ACCESS_TOKEN_CONST)
            valid_until = integration_context.get(EXPIRES_IN)
            if access_token and valid_until and int(time.time()) < valid_until:
                self.access_token = access_token
                self.api_url = integration_context.get(API_URL_CONST, DEFAULT_API_URL)
                self.instance_id = integration_context.get(INSTANCE_ID_CONST)
                return
            demisto.debug(f'access token time: {valid_until} expired/none. Will call oproxy')
            access_token, api_url, instance_id, refresh_token, expires_in = self._oproxy_authorize()
            updated_integration_context = {
                ACCESS_TOKEN_CONST: access_token,
                EXPIRES_IN: int(time.time()) + expires_in - SECONDS_30,
                API_URL_CONST: api_url,
                INSTANCE_ID_CONST: instance_id
            }
            if refresh_token:
                updated_integration_context.update({'refresh_token': refresh_token})
            demisto.setIntegrationContext(updated_integration_context)
            self.access_token = access_token
            self.api_url = api_url
            self.instance_id = instance_id

        def _oproxy_authorize(self) -> tuple[Any, Any, Any, Any, int]:
            oproxy_response = self._get_access_token_with_backoff_strategy()
            access_token = oproxy_response.get(ACCESS_TOKEN_CONST)
            api_url = oproxy_response.get('url')
            refresh_token = oproxy_response.get('refresh_token')
            instance_id = oproxy_response.get(INSTANCE_ID_CONST)
            # In case the response has EXPIRES_IN key with empty string as value, we need to make sure we don't try to cast
            # an empty string to an int.
            expires_in = int(oproxy_response.get(EXPIRES_IN, MINUTES_60) or 0)
            if not access_token or not api_url or not instance_id:
                raise DemistoException(f'Missing attribute in response: access_token, instance_id or api are missing.\n'
                                       f'Oproxy response: {oproxy_response}')
            return access_token, api_url, instance_id, refresh_token, expires_in

        def _get_access_token_with_backoff_strategy(self) -> dict:
            """ Implements a backoff strategy for retrieving an access token.
            Raises an exception if the call is within one of the time windows, otherwise fetches the access token

            Returns: The oproxy response or raising a DemistoException

            """
            self._backoff_strategy(demisto.getIntegrationContext())
            return self._get_access_token()

        @staticmethod
        def _backoff_strategy(integration_context: dict):
            """ Implements a backoff strategy for retrieving an access token. Logic as follows:
            - First 60 minutes check for access token once every 1 minute max.
            - Next 47 hours check for access token once every 10 minute max.
            - After 48 hours check for access token once every 60 minutes max.

            Args:
                integration_context: The integration context

            """
            err_msg = 'We have found out that your recent attempts to authenticate against the CDL server have failed. ' \
                      'Therefore we have limited the number of calls that the CDL integration performs. ' \
                      'If you wish to try authenticating again, please run the `cdl-reset-authentication-timeout` ' \
                      'command and retry. If you choose not to reset the authentication timeout, the next attempt can be ' \
                      'done in {} {}.'
            first_failure_time = integration_context.get(FIRST_FAILURE_TIME_CONST)
            last_failure_time = integration_context.get(LAST_FAILURE_TIME_CONST)
            now_datetime = datetime.utcnow()
            demisto.debug(f'CDL - First failure time: {first_failure_time}')
            demisto.debug(f'CDL - Last failure time: {last_failure_time}')
            demisto.debug(f'CDL - Current time: {last_failure_time}')

            if first_failure_time and last_failure_time:
                first_failure_datetime = datetime.fromisoformat(first_failure_time)
                last_failure_datetime = datetime.fromisoformat(last_failure_time)
                time_from_first_failure = now_datetime - first_failure_datetime
                time_from_last_failure = now_datetime - last_failure_datetime

                if time_from_first_failure < timedelta(hours=1):
                    window = timedelta(minutes=1)
                    if time_from_last_failure < window:
                        raise DemistoException(err_msg.format(window - time_from_last_failure, 'seconds'))
                elif time_from_first_failure < timedelta(hours=48):
                    window = timedelta(minutes=10)
                    if time_from_last_failure < window:
                        raise DemistoException(err_msg.format(window - time_from_last_failure, 'minutes'))
                else:
                    window = timedelta(minutes=60)
                    if time_from_last_failure < window:
                        raise DemistoException(err_msg.format(window - time_from_last_failure, 'minutes'))

        def _get_access_token(self) -> dict:
            """ Performs an http request to oproxy-cdl access token endpoint
            In case of failure, handles the error, otherwise reset the failure counters and return the response

            Returns: The oproxy response or raising a DemistoException

            """
            demisto.debug('CDL - Fetching access token')
            try:
                oproxy_response = self._http_request('POST',
                                                     '/cdl-token',
                                                     json_data={'token': get_encrypted(self.refresh_token, self.enc_key)},
                                                     timeout=(60 * 3, 60 * 3),
                                                     retries=3,
                                                     backoff_factor=10,
                                                     status_list_to_retry=[400])
            except DemistoException as e:
                if re.match(BAD_REQUEST_REGEX, str(e)):
                    demisto.error('The request to retrieve the access token has failed with 400 status code.')
                    demisto.setIntegrationContext(self._cache_failure_times(demisto.getIntegrationContext()))
                raise e

            self.reset_failure_times()
            return oproxy_response

        @staticmethod
        def _cache_failure_times(integration_context: dict) -> dict:
            """ Updates the failure times in case of an error with 400 status code.

            Args:
                integration_context: The integration context

            Returns:
                The updated integration context

            """
            current_time = datetime.utcnow().isoformat()
            times_dict = {LAST_FAILURE_TIME_CONST: current_time}
            if not integration_context.get(FIRST_FAILURE_TIME_CONST):
                # first failure
                times_dict[FIRST_FAILURE_TIME_CONST] = current_time
            integration_context.update(times_dict)
            return integration_context

        @staticmethod
        def reset_failure_times():
            """ Resets the time failure counters: FIRST_FAILURE_TIME_CONST & LAST_FAILURE_TIME_CONST

            """
            integration_context = demisto.getIntegrationContext()

            for failure_time_key in (FIRST_FAILURE_TIME_CONST, LAST_FAILURE_TIME_CONST):
                if failure_time_key in integration_context:
                    del integration_context[failure_time_key]

            demisto.setIntegrationContext(integration_context)

        def query_loggings(self, query: str) -> tuple[list[dict], list]:
            """
            This function handles all the querying of Cortex Logging service

            Args:
                query: The sql string query.

            Returns:
                A list of records according to the query
            """
            query_data = {'query': self.add_instance_id_to_query(query),
                          'language': 'csql'}
            demisto.debug(f'Query being executed in CDL: {str(query_data)}')
            query_service = self.initial_query_service()
            response = query_service.create_query(query_params=query_data, enforce_json=True)
            query_result = response.json()

            if not response.ok:
                status_code = response.status_code
                try:
                    # For some error responses the messages are in 'query_result['errors'] and for some they are simply
                    # in 'query_result
                    errors = query_result.get('errors', query_result)
                    error_message = ''.join([message.get('message') for message in errors])
                except AttributeError:
                    error_message = query_result

                raise DemistoException(f'Error in query to Cortex Data Lake XSOAR Connector [{status_code}] - {error_message}')

            try:
                raw_results = [r.json() for r in query_service.iter_job_results(job_id=query_result.get('jobId'),
                                                                                result_format='valuesDictionary',
                                                                                max_wait=2000)]
            except exceptions.HTTPError as e:
                raise DemistoException(f'Received error {str(e)} when querying logs.')

            extended_results: list[dict] = []
            for result in raw_results:
                page = result.get('page', {})
                data = page.get('result', {}).get('data', [])
                if data:
                    extended_results.extend(data)

            return extended_results, raw_results

        def initial_query_service(self) -> QueryService:
            credentials = Credentials(
                access_token=self.access_token,
                verify=self.use_ssl
            )
            query_service = QueryService(
                url=self.api_url,
                credentials=credentials,
                trust_env=self.trust_env
            )
            return query_service

        def add_instance_id_to_query(self, query: str) -> str:
            """
            On apollo v2 all table names must have the instance_id at the top of their hierarchy.
            This function adds the instance_id to the query.
            For example:
            For the query "SELECT * FROM `test`" with instance_id=1234 this function will return "SELECT * FROM `1234.test`"
            Args:
                query: A query for CDL
            Returns:
                A query with instance_id
            """
            FIND_FROM_STATEMENT_REGEX_PATTERN = r'(?i)FROM `'
            query = re.sub(FIND_FROM_STATEMENT_REGEX_PATTERN, f'FROM `{self.instance_id}.', query)
            return query


    ''' HELPER FUNCTIONS '''


    def human_readable_time_from_epoch_time(epoch_time: int, utc_time: bool = False):
        """
        Divides the epoch time by 1e6 since the epoch format has 6 trailing zeroes
        Since incidents need the time in utc format (ends in 'Z') but the SQL syntax cannot parse a UTC formatted date well
        it is parameterized
        Args:
            utc_time: A boolean that states weather to add the 'Z' at the end of the date string
            epoch_time: Epoch time as it is in the raw_content
        Returns:
            human readable time in the format of '1970-01-01T02:00:00'
        """
        result = datetime.fromtimestamp(epoch_time / 1e6).isoformat() if epoch_time else None
        if result:
            result += 'Z' if utc_time else ''
        return result


    def add_milliseconds_to_epoch_time(epoch_time):
        """
        Add 1 millisecond so we would not get duplicate incidents.
        Args:
            epoch_time: Epoch time as it is in the raw_content
        Returns:
            epoch_time with 1 more millisecond.
        """
        epoch_time = int(epoch_time / 1000 + 1) / 1000
        return epoch_time


    def epoch_to_timestamp_and_add_milli(epoch_time: int):
        """
        Create human readable time in the format of '1970-01-01T02:00:00.000Z'
        Args:
            epoch_time: Epoch time as it is in the raw_content
        Returns:
            human readable time in the format of '1970-01-01T02:00:00.000Z'
        """
        epoch_time = add_milliseconds_to_epoch_time(epoch_time)
        epoch_time_str = datetime.fromtimestamp(epoch_time).isoformat(timespec='milliseconds') + "Z"
        return epoch_time_str


    def common_context_transformer(row_content):
        """
            This function retrieves data from a row of raw data into context path locations

            Args:
                row_content: a dict representing raw data of a row

            Returns:
                a dict with context paths and their corresponding value
            """
        return {
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'LogSourceName': row_content.get('log_source_name'),
            'IsNat': row_content.get('is_nat'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'FileSHA256': row_content.get('file_sha_256'),
            'FileName': row_content.get('file_name'),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0))
        }


    def traffic_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """

        return {
            'Action': row_content.get('action', {}).get('value'),
            'RiskOfApp': row_content.get('risk_of_app'),
            'NatSourcePort': row_content.get('nat_source_port'),
            'SessionID': row_content.get('session_id'),
            'Packets': row_content.get('packets_total'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'App': row_content.get('app'),
            'Vsys': row_content.get('vsys'),
            'IsNat': row_content.get('is_nat'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'SubcategoryOfApp': row_content.get('app_sub_category'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'DestinationPort': row_content.get('dest_port'),
            'TotalTimeElapsed': row_content.get('total_time_elapsed'),
            'LogSourceName': row_content.get('log_source_name'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'Users': row_content.get('users'),
            'TunneledApp': row_content.get('tunneled_app'),
            'IsPhishing': row_content.get('is_phishing'),
            'SessionEndReason': row_content.get('session_end_reason', {}).get('value'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'SessionStartIP': human_readable_time_from_epoch_time(row_content.get('session_start_time', 0)),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0)),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'LogSourceID': row_content.get('log_source_id'),
            'TotalBytes': row_content.get('bytes_total'),
            'VsysID': row_content.get('vsys_id'),
            'ToZone': row_content.get('to_zone'),
            'URLCategory': row_content.get('url_category', {}).get('value'),
            'SourcePort': row_content.get('source_port'),
            'Tunnel': row_content.get('tunnel', {}).get('value'),
            'SourceDeviceHost': row_content.get('source_device_host'),
            'DestDeviceHost': row_content.get('dest_device_host')
        }


    def threat_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """
        return {
            'SessionID': row_content.get('session_id'),
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'IsNat': row_content.get('is_nat'),
            'SubcategoryOfApp': row_content.get('app_sub_category'),
            'PcapID': row_content.get('pcap_id'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'Flags': row_content.get('flags'),
            'DestinationPort': row_content.get('dest_port'),
            'ThreatID': row_content.get('threat_id'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'IsURLDenied': row_content.get('is_url_denied'),
            'Users': row_content.get('users'),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0)),
            'IsPhishing': row_content.get('is_phishing'),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'ToZone': row_content.get('to_zone'),
            'RiskOfApp': row_content.get('risk_of_app'),
            'NatSourcePort': row_content.get('nat_source_port'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'FromZone': row_content.get('from_zone'),
            'Vsys': row_content.get('vsys'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'ThreatCategory': row_content.get('threat_category', {}).get('value'),
            'ThreatName': row_content.get('threat_name'),
            'LogSourceName': row_content.get('log_source_name'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'Direction': row_content.get('direction_of_attack', {}).get('value'),
            'FileName': row_content.get('file_name'),
            'VendorSeverity': row_content.get('vendor_severity', {}).get('value'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'LogSourceID': row_content.get('log_source_id'),
            'VsysID': row_content.get('vsys_id'),
            'URLDomain': row_content.get('url_domain'),
            'URLCategory': row_content.get('url_category', {}).get('value'),
            'SourcePort': row_content.get('source_port'),
            'FileSHA256': row_content.get('file_sha_256'),
            'SourceDeviceHost': row_content.get('source_device_host'),
            'DestDeviceHost': row_content.get('dest_device_host')
        }


    def url_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """

        return {
            'SessionID': row_content.get('session_id'),
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'PcapID': row_content.get('pcap_id'),
            'DestinationPort': row_content.get('dest_port'),
            'AppCategory': row_content.get('app_category'),
            'AppSubcategory': row_content.get('app_sub_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'ToZone': row_content.get('to_zone'),
            'FromZone': row_content.get('from_zone'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'ThreatCategory': row_content.get('threat_category', {}).get('value'),
            'ThreatName': row_content.get('threat_name'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'LogSourceName': row_content.get('log_source_name'),
            'Denied': row_content.get('is_url_denied'),
            'Category': row_content.get('url_category', {}).get('value'),
            'SourcePort': row_content.get('source_port'),
            'URL': row_content.get('url_domain'),
            'URI': row_content.get('uri'),
            'ContentType': row_content.get('content_type'),
            'HTTPMethod': row_content.get('http_method', {}).get('value'),
            'Severity': row_content.get('severity'),
            'UserAgent': row_content.get('user_agent'),
            'RefererProtocol': row_content.get('referer_protocol', {}).get('value'),
            'RefererPort': row_content.get('referer_port'),
            'RefererFQDN': row_content.get('referer_fqdn'),
            'RefererURL': row_content.get('referer_url_path'),
            'SrcUser': row_content.get('source_user'),
            'SrcUserInfo': row_content.get('source_user_info'),
            'DstUser': row_content.get('dest_user'),
            'DstUserInfo': row_content.get('dest_user_info'),
            'TechnologyOfApp': row_content.get('technology_of_app'),
            'SourceDeviceHost': row_content.get('source_device_host'),
            'DestDeviceHost': row_content.get('dest_device_host')
        }


    def files_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """

        return {
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'AppCategory': row_content.get('app_category'),
            'AppSubcategory': row_content.get('app_sub_category'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'CloudHostname': row_content.get('cloud_hostname'),
            'CountOfRepeats': row_content.get('count_of_repeats'),
            'CustomerID': row_content.get('customer_id'),
            'DestinationLocation': row_content.get('dest_location'),
            'DestinationPort': row_content.get('dest_port'),
            'DirectionOfAttack': row_content.get('direction_of_attack', {}).get('value'),
            'FileID': row_content.get('file_id'),
            'FileName': row_content.get('file_name'),
            'FileType': row_content.get('file_type'),
            'Flags': row_content.get('flags'),
            'FromZone': row_content.get('from_zone'),
            'Http2Connection': row_content.get('http2_connection'),
            'InboundIf': row_content.get('inbound_if', {}).get('value'),
            'IngestionTime': human_readable_time_from_epoch_time(row_content.get('ingestion_time', 0)),
            'IsCaptivePortal': row_content.get('is_captive_portal'),
            'IsClientToServer': row_content.get('is_client_to_server'),
            'IsContainer': row_content.get('is_container'),
            'IsDecryptMirror': row_content.get('is_decrypt_mirror'),
            'IsDupLog': row_content.get('is_dup_log'),
            'IsExported': row_content.get('is_exported'),
            'IsForwarded': row_content.get('is_forwarded'),
            'IsMptcpOn': row_content.get('is_mptcp_on'),
            'IsNat': row_content.get('is_nat'),
            'IsNonStdDestPort': row_content.get('is_non_std_dest_port'),
            'IsPacketCapture': row_content.get('is_packet_capture'),
            'IsPhishing': row_content.get('is_phishing'),
            'IsPrismaBranch': row_content.get('is_prisma_branch'),
            'IsPrismaMobile': row_content.get('is_prisma_mobile'),
            'IsProxy': row_content.get('is_proxy'),
            'IsReconExcluded': row_content.get('is_recon_excluded'),
            'IsSaasApp': row_content.get('is_saas_app'),
            'IsServerToClient': row_content.get('is_server_to_client'),
            'IsSymReturn': row_content.get('is_sym_return'),
            'IsTransaction': row_content.get('is_transaction'),
            'IsTunnelInspected': row_content.get('is_tunnel_inspected'),
            'IsUrlDenied': row_content.get('is_url_denied'),
            'LogSet': row_content.get('log_set'),
            'LogSource': row_content.get('log_source'),
            'LogSourceID': row_content.get('log_source_id'),
            'LogSourceName': row_content.get('log_source_name'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'LogType': row_content.get('log_type', {}).get('value'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'NatSourcePort': row_content.get('nat_source_port'),
            'OutboundIf': row_content.get('outbound_if', {}).get('value'),
            'PcapID': row_content.get('pcap_id'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'RecordSize': row_content.get('record_size'),
            'ReportID': row_content.get('report_id'),
            'RiskOfApp': row_content.get('risk_of_app'),
            'RuleMatched': row_content.get('rule_matched'),
            'RuleMatchedUuid': row_content.get('rule_matched_uuid'),
            'SanctionedStateOfApp': row_content.get('sanctioned_state_of_app'),
            'SequenceNo': row_content.get('sequence_no'),
            'SessionID': row_content.get('session_id'),
            'Severity': row_content.get('severity'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'TechnologyOfApp': row_content.get('technology_of_app'),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0)),
            'ToZone': row_content.get('to_zone'),
            'Tunnel': row_content.get('tunnel', {}).get('value'),
            'TunneledApp': row_content.get('tunneled_app'),
            'URLCategory': row_content.get('url_category', {}).get('value'),
            'FileSHA256': row_content.get('file_sha_256'),
            'Vsys': row_content.get('vsys'),
            'VsysID': row_content.get('vsys_id'),
            'VendorName': row_content.get('vendor_name'),
            'VendorSeverity': row_content.get('vendor_severity', {}).get('value')
        }


    def records_to_human_readable_output(fields: str, table_name: str, results: list) -> str:
        """
        This function gets all relevant data for the human readable output of a specific table.
        By design if the user queries all fields of the table (i.e. enters '*' in the query) than the outputs
        shown in the war room will be the same for each query - the outputs will be the headers list in the code.
        If the user selects different fields in the query than those fields will be shown to the user.

        Args:
            fields: The field of the table named table_name
            table_name: The name of the table
            results: The results needs to be shown

        Returns:
            A markdown table of the outputs
        """
        filtered_results: list = []

        if fields == '*':
            for result in results:
                filtered_result = {
                    'Source Address': result.get('source_ip', {}).get('value'),
                    'Destination Address': result.get('dest_ip', {}).get('value'),
                    'Application': result.get('app'),
                    'Action': result.get('action', {}).get('value'),
                    'RuleMatched': result.get('rule_matched'),
                    'TimeGenerated': human_readable_time_from_epoch_time(result.get('time_generated')),
                    'FileID': result.get('file_id'),
                    'FileName': result.get('file_name'),
                    'FileType': result.get('file_type')
                }
                filtered_results.append(filtered_result)
        else:
            for result in results:
                filtered_result = {}
                for root in result:
                    parsed_tree: dict = parse_tree_by_root_to_leaf_paths(root, result[root])
                    filtered_result.update(parsed_tree)
                filtered_results.append(filtered_result)

        return tableToMarkdown(f'Logs {table_name} table', filtered_results, removeNull=True)


    def parse_tree_by_root_to_leaf_paths(root: str, body) -> dict:
        """
        This function receives a dict (root and a body) and parses it according to the upcoming example:
        Input: root = 'a', body = {'b': 2, 'c': 3, 'd': {'e': 5, 'f': 6, 'g': {'h': 8, 'i': 9}}}.
        So the dict is {'a': {'b': 2, 'c': 3, 'd': {'e': 5, 'f': 6, 'g': {'h': 8, 'i': 9}}}}
        The expected output is {'a.b': 2, 'a.c': 3, 'a.d.e': 5, 'a.d.f': 6, 'a.d.g.h': 8, 'a.d.g.i': 9}
        Basically what this function does is when it gets a tree it creates a dict from it which it's keys are all
        root to leaf paths and the corresponding values are the values in the leafs
        Please note that the implementation is similar to DFS on trees (which means we don't have to check for visited
        nodes since there are no cycles)

        Args:
            root: The root string
            body: The body of the root

        Returns:
            The parsed tree
        """
        parsed_tree: dict = {}
        help_stack: list = [(root, body)]

        while help_stack:
            node: tuple = help_stack.pop()
            root_to_node_path: str = node[0]
            body = node[1]
            if isinstance(body, dict):
                for key, value in body.items():
                    # for each node we append a tuple of it's body and the path from the root to it
                    help_stack.append((root_to_node_path + '.' + key, value))
            elif isinstance(body, list):
                for element in body:
                    help_stack.append((root_to_node_path, element))
            else:
                parsed_tree[root_to_node_path] = body
        return parsed_tree


    def build_where_clause(args: dict) -> str:
        """
        This function transforms the relevant entries of dict into the where part of a SQL query

        Args:
            args: The arguments dict

        Returns:
            A string represents the where part of a SQL query
        """
        args_dict = {
            'source_ip': 'source_ip.value',
            'dest_ip': 'dest_ip.value',
            'rule_matched': 'rule_matched',
            'from_zone': 'from_zone',
            'to_zone': 'to_zone',
            'source_port': 'source_port',
            'dest_port': 'dest_port',
            'action': 'action.value',
            'file_sha_256': 'file_sha_256',
            'file_name': 'file_name',
            'app': 'app',
            'app_category': 'app_category',
            'dest_device_port': 'dest_device_port',
            'dest_edl': 'dest_edl',
            'dest_dynamic_address_group': 'dest_dynamic_address_group',
            'dest_location': 'dest_location',
            'dest_user': 'dest_user',
            'file_type': 'file_type',
            'is_server_to_client': 'is_server_to_client',
            'is_url_denied': 'is_url_denied',
            'log_type': 'log_type',
            'nat_dest': 'nat_dest',
            'nat_dest_port': 'nat_dest_port',
            'nat_source': 'nat_source',
            'nat_source_port': 'nat_source_port',
            'rule_matched_uuid': 'rule_matched_uuid',
            'severity': 'severity',
            'source_device_host': 'source_device_host',
            'source_edl': 'source_edl',
            'source_dynamic_address_group': 'source_dynamic_address_group',
            'source_location': 'source_location',
            'source_user': 'source_user',
            'sub_type': 'sub_type.value',
            'time_generated': 'time_generated',
            'url_category': 'url_category',
            'url_domain': 'url_domain'
        }
        if args.get('ip') and (args.get('source_ip') or args.get('dest_ip')):
            raise DemistoException('Error: "ip" argument cannot appear with either "source_ip" nor "dest_ip"')

        if args.get('port') and (args.get('source_port') or args.get('dest_port')):
            raise DemistoException('Error: "port" argument cannot appear with either "source_port" nor "dest_port"')

        non_string_keys = {'dest_port', 'source_port'}
        if 'query' in args:
            # if query arg is supplied than we just need to parse it and only it
            return args['query'].strip()

        where_clause = ''
        if args.get('ip'):
            ips = argToList(args.pop('ip'))
            # Creating a query for ip argument using source ip and dest ip
            where_clause += '(' + ' OR '.join(f'source_ip.value = "{ip}" OR dest_ip.value = "{ip}"' for ip in ips) + ')'
            if any(args.get(key) for key in args_dict) or args.get('port') or args.get('url'):
                where_clause += ' AND '

        if args.get('port'):
            ports = argToList(args.pop('port'))
            # Creating a query for port argument using source port and dest port
            where_clause += '(' + ' OR '.join(f'source_port = {port} OR dest_port = {port}' for port in ports) + ')'
            if any(args.get(key) for key in args_dict):
                where_clause += ' AND '

        if args.get('url'):
            urls = argToList(args.pop('url'))
            # Creating a query for url argument using uri and referer
            where_clause += '(' + ' OR '.join(f'uri LIKE "%{url}%" OR referer LIKE "%{url}%"' for url in urls) + ')'
            if any(args.get(key) for key in args_dict):
                where_clause += ' AND '

        if args.get('rule'):
            rules_list = argToList(args.pop('rule'))
            where_clause += '(' + ' OR '.join(f'rule_matched = "{rule}"' for rule in rules_list) + ')'
            if any(args.get(key) for key in args_dict):
                where_clause += ' AND '

        # We want to add only keys that are part of the query
        string_query_fields = {key: value for key, value in args.items() if key in args_dict and key not in non_string_keys}
        or_statements = []
        for key, values in string_query_fields.items():
            string_values_list: list = argToList(values)
            field = args_dict[key]
            or_statements.append(' OR '.join([f'{field} = "{value}"' for value in string_values_list]))
        # ports are digested as ints and cannot be sent as strings
        non_string_query_fields = {key: value for key, value in args.items() if key in non_string_keys}
        for key, values in non_string_query_fields.items():
            non_string_values_list: list = argToList(values)
            field = args_dict[key]
            or_statements.append(' OR '.join([f'{field} = {value}' for value in non_string_values_list]))
        where_clause += ' AND '.join([f'({or_statement})' for or_statement in or_statements if or_statement])
        return where_clause


    def get_encrypted(auth_id: str, key: str) -> str:
        """

        Args:
            auth_id (str): auth_id from oproxy
            key (str): key from oproxy

        Returns:
            The encrypted auth_id with the time it was encrypted using AESGCM algorithm
        """

        def create_nonce() -> bytes:
            return os.urandom(12)

        def encrypt(string: str, enc_key: str) -> bytes:
            """

            Args:
                enc_key (str):
                string (str):

            Returns:
                bytes:
            """
            # String to bytes
            decoded_key = base64.b64decode(enc_key)
            # Create key
            aes_gcm = AESGCM(decoded_key)
            # Create nonce
            nonce = create_nonce()
            # Create ciphered data
            data = string.encode()
            ct = aes_gcm.encrypt(nonce, data, None)
            return base64.b64encode(nonce + ct)

        now = int(time.time())
        return encrypt(f'{now}:{auth_id}', key).decode('utf-8')


    def prepare_fetch_incidents_query(fetch_timestamp: str,
                                      fetch_severity: list,
                                      fetch_table: str,
                                      fetch_subtype: list,
                                      fetch_fields: str,
                                      fetch_limit: str,
                                      fetch_filter: str = '') -> str:
        """
        Prepares the SQL query for fetch incidents command
        Args:
            fetch_limit: Indicates how many incidents should be queried
            fetch_timestamp: The date from which threat logs should be queried
            fetch_severity: Severity associated with the incident.
            fetch_subtype: Identifies the log subtype.
            fetch_table: Identifies the fetch type.
            fetch_fields: Fields to fetch from the table.
            fetch_filter: Filter that should be used for the query.

        Returns:
            SQL query that matches the arguments
        """
        if fetch_filter and (fetch_subtype or fetch_severity):
            raise DemistoException('Fetch Filter parameter cannot be used with Subtype/Severity parameters.')
        query = f'SELECT {fetch_fields} FROM `{fetch_table}` '  # guardrails-disable-line # noqa: S608
        time_filter = 'event_time' if 'log' in fetch_table else 'time_generated'
        query += f'WHERE {time_filter} Between TIMESTAMP("{fetch_timestamp}") ' \
                 f'AND CURRENT_TIMESTAMP'
        if fetch_filter:
            query += f' AND {fetch_filter}'
        if fetch_subtype and 'all' not in fetch_subtype:
            sub_types = [f'sub_type.value = "{sub_type}"' for sub_type in fetch_subtype]
            query += f' AND ({" OR ".join(sub_types)})'
        if fetch_severity and 'all' not in fetch_severity:
            severities = [f'vendor_severity.value = "{severity}"' for severity in fetch_severity]
            query += f' AND ({" OR ".join(severities)})'
        query += f' ORDER BY {time_filter} ASC LIMIT {fetch_limit}'
        return query


    def convert_log_to_incident(log: dict, fetch_table: str) -> dict:
        time_filter = 'event_time' if 'log' in fetch_table else 'time_generated'
        time_generated = log.get(time_filter, 0)
        occurred = human_readable_time_from_epoch_time(time_generated, utc_time=True)
        incident = {
            'name': FETCH_TABLE_HR_NAME[fetch_table],
            'rawJSON': json.dumps(log, ensure_ascii=False),
            'occurred': occurred
        }
        return incident


    ''' COMMANDS FUNCTIONS '''


    def test_module(client: Client, fetch_table, fetch_fields, is_fetch, fetch_query, fetch_subtype, fetch_severity, first_fetch):
        if is_fetch:
            fetch_time, _ = parse_date_range(first_fetch)
            fetch_time = fetch_time.replace(microsecond=0)
            query = prepare_fetch_incidents_query(fetch_time, fetch_severity, fetch_table,
                                                  fetch_subtype, fetch_fields, "1", fetch_query)
        else:
            # fetch params not to be tested (won't be used)
            fetch_fields = '*'
            fetch_table = 'firewall.traffic'
            query = f'SELECT {fetch_fields} FROM `{fetch_table}` limit 1'  # noqa: S608
        client.query_loggings(query)
        return_outputs('ok')


    def query_logs_command(args: dict, client: Client) -> tuple[str, dict[str, list[dict]], list[dict[str, Any]]]:
        """
        Return the result of querying the Logging service
        """
        query = args.get('query', '')
        limit = args.get('limit', '')
        transform_results = argToBoolean(args.get('transform_results', 'true'))

        if 'limit' not in query.lower():
            query += f' LIMIT {limit}'

        records, raw_results = client.query_loggings(query)

        table_name = get_table_name(query)
        output_results = records if not transform_results else [common_context_transformer(record) for record in records]
        human_readable = tableToMarkdown('Logs ' + table_name + ' table', output_results, removeNull=True)
        ec = {
            'CDL.Logging': output_results
        }
        return human_readable, ec, raw_results


    def get_table_name(query: str) -> str:
        """
        Table name is stored in log_type attribute of the records
        Args:
            query: Query string, i.e SELECT * FROM firewall.threat LIMIT 1

        Returns:
            The query's table name
        """
        find_table_name_from_query = r'(FROM `)(\w+.\w+)(`)'
        search_result = re.search(find_table_name_from_query, query)
        if search_result:
            return search_result.group(2)
        return "Unrecognized table name"


    def get_critical_logs_command(args: dict, client: Client) -> tuple[str, dict[str, list[dict]], list[dict[str, Any]]]:
        """
        Queries Cortex Logging according to a pre-set query
        """
        logs_amount = args.get('limit')
        query_start_time, query_end_time = query_timestamp(args)
        query = 'SELECT * FROM `firewall.threat` WHERE severity = "Critical" '  # guardrails-disable-line
        query += f'AND time_generated BETWEEN TIMESTAMP("{query_start_time}") AND ' \
                 f'TIMESTAMP("{query_end_time}") LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [threat_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs threat table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Threat': transformed_results
        }
        return human_readable, ec, raw_results


    def query_timestamp(args: dict) -> tuple[datetime, datetime]:
        start_time = args.get('start_time', '')
        end_time = args.get('end_time', '')
        time_range = args.get('time_range', '')
        if time_range:
            query_start_time, query_end_time = parse_date_range(time_range)
        else:
            # parses user input to datetime object
            query_start_time = parser.parse(start_time)
            # if end_time is not given- will be replaced with current time
            query_end_time = parser.parse(end_time) if end_time else datetime.fromtimestamp(time.time())
        return query_start_time.replace(microsecond=0), query_end_time.replace(microsecond=0)


    def get_social_applications_command(args: dict,
                                        client: Client) -> tuple[str, dict[str, list[dict]], list[dict[str, Any]]]:
        """ Queries Cortex Logging according to a pre-set query """
        logs_amount = args.get('limit')
        query_start_time, query_end_time = query_timestamp(args)
        query = 'SELECT * FROM `firewall.traffic` WHERE app_sub_category = "social-networking" '  # guardrails-disable-line
        query += f' AND time_generated BETWEEN TIMESTAMP("{query_start_time}") AND ' \
                 f'TIMESTAMP("{query_end_time}") LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [traffic_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs traffic table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Traffic': transformed_results
        }
        return human_readable, ec, raw_results


    def search_by_file_hash_command(args: dict, client: Client) -> tuple[str, dict[str, list[dict]], list[dict[str, Any]]]:
        """
        Queries Cortex Logging according to a pre-set query
        """
        logs_amount = args.get('limit')
        file_hash = args.get('SHA256')

        query_start_time, query_end_time = query_timestamp(args)
        query = f'SELECT * FROM `firewall.threat` WHERE file_sha_256 = "{file_hash}" '  # guardrails-disable-line  # noqa: S608
        query += f'AND time_generated BETWEEN TIMESTAMP("{query_start_time}") AND ' \
                 f'TIMESTAMP("{query_end_time}") LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [threat_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs threat table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Threat': transformed_results
        }
        return human_readable, ec, raw_results


    def query_traffic_logs_command(args: dict, client: Client) -> tuple[str, dict, list[dict[str, Any]]]:
        """
        The function of the command that queries firewall.traffic table

            Returns: a Demisto's entry with all the parsed data
        """
        table_name: str = 'traffic'
        context_transformer_function = traffic_context_transformer
        table_context_path: str = 'CDL.Logging.Traffic'
        return query_table_logs(args, client, table_name, context_transformer_function, table_context_path)


    def query_threat_logs_command(args: dict, client: Client) -> tuple[str, dict, list[dict[str, Any]]]:
        """
        The function of the command that queries firewall.threat table

            Returns: a Demisto's entry with all the parsed data
        """
        query_table_name: str = 'threat'
        context_transformer_function = threat_context_transformer
        table_context_path: str = 'CDL.Logging.Threat'
        return query_table_logs(args, client, query_table_name, context_transformer_function, table_context_path)


    def query_url_logs_command(args: dict, client: Client) -> tuple[str, dict, list[dict[str, Any]]]:
        """
        The function of the command that queries firewall.url table

            Returns: a Demisto's entry with all the parsed data
        """
        query_table_name: str = 'url'
        context_transformer_function = url_context_transformer
        table_context_path: str = 'CDL.Logging.URL'
        return query_table_logs(args, client, query_table_name, context_transformer_function, table_context_path)


    def query_file_data_command(args: dict, client: Client) -> tuple[str, dict, list[dict[str, Any]]]:
        query_table_name: str = 'file_data'
        context_transformer_function = files_context_transformer
        table_context_path: str = 'CDL.Logging.File'
        return query_table_logs(args, client, query_table_name, context_transformer_function, table_context_path)


    def query_table_logs(args: dict,
                         client: Client,
                         table_name: str,
                         context_transformer_function: Callable[[dict], dict],
                         table_context_path: str) -> tuple[str, dict, list[dict[str, Any]]]:
        """
        This function is a generic function that get's all the data needed for a specific table of Cortex and acts as a
        regular command function

        Args:
            args: demisto args
            client: The client
            table_name: the name of the table in Cortex
            context_transformer_function:  the context transformer function to parse the data
            table_context_path: the context path where the parsed data should be located
        """
        fields, query = build_query(args, table_name)
        results, raw_results = client.query_loggings(query)
        outputs = [context_transformer_function(record) for record in results]
        human_readable = records_to_human_readable_output(fields, table_name, results)

        context_outputs: dict = {table_context_path: outputs}
        return human_readable, context_outputs, raw_results


    def build_query(args, table_name):
        fields = args.get('fields', 'all')
        fields = '*' if 'all' in fields else fields
        where = build_where_clause(args)
        query_start_time, query_end_time = query_timestamp(args)
        timestamp_limitation = f'time_generated BETWEEN TIMESTAMP("{query_start_time}") AND ' \
                               f'TIMESTAMP("{query_end_time}") '
        limit = args.get('limit') or '5'
        where += f' AND {timestamp_limitation}' if where else timestamp_limitation
        query = f'SELECT {fields} FROM `firewall.{table_name}` WHERE {where} LIMIT {limit}'  # noqa: S608
        return fields, query


    def fetch_incidents(client: Client,
                        first_fetch_timestamp: str,
                        fetch_severity: list,
                        fetch_table: str,
                        fetch_subtype: list,
                        fetch_fields: str,
                        fetch_limit: str,
                        last_run: dict,
                        fetch_filter: str = '') -> tuple[dict[str, str], list]:
        last_fetched_event_timestamp = last_run.get('lastRun')
        demisto.debug("CortexDataLake - Start fetching")
        demisto.debug(f"CortexDataLake - Last run: {json.dumps(last_run)}")

        if last_fetched_event_timestamp:
            last_fetched_event_timestamp = parser.parse(last_fetched_event_timestamp)
        else:
            last_fetched_event_timestamp, _ = parse_date_range(first_fetch_timestamp)
            last_fetched_event_timestamp = last_fetched_event_timestamp.replace(microsecond=0)
        query = prepare_fetch_incidents_query(last_fetched_event_timestamp, fetch_severity, fetch_table,
                                              fetch_subtype, fetch_fields, fetch_limit, fetch_filter)
        demisto.debug(f"CortexDataLake - Query sent to the server: {query}")
        records, _ = client.query_loggings(query)
        if not records:
            return {'lastRun': str(last_fetched_event_timestamp)}, []

        incidents = [convert_log_to_incident(record, fetch_table) for record in records]
        time_filter = 'event_time' if 'log' in fetch_table else 'time_generated'
        max_fetched_event_timestamp = max(records, key=lambda record: record.get(time_filter, 0)).get(time_filter, 0)

        next_run = {'lastRun': epoch_to_timestamp_and_add_milli(max_fetched_event_timestamp)}
        demisto.debug(f'CortexDataLake - Next run after incidents fetching: {json.dumps(next_run)}')
        demisto.debug(f"CortexDataLake- Number of incidents before filtering: {len(records)}")
        demisto.debug(f"CortexDataLake - Number of incidents after filtering: {len(incidents)}")
        return next_run, incidents


    ''' EXECUTION CODE '''


    def main():
        os.environ['PAN_CREDENTIALS_DBFILE'] = os.path.join(gettempdir(), 'pancloud_credentials.json')
        params = demisto.params()
        registration_id_and_url = params.get('credentials_reg_id', {}).get('password') or params.get('reg_id')
        # If there's a stored token in integration context, it's newer than current
        refresh_token = params.get('credentials_refresh_token', {}).get('password') or params.get('refresh_token')
        enc_key = params.get('credentials_auth_key', {}).get('password') or params.get('auth_key')
        if not enc_key or not refresh_token or not registration_id_and_url:
            raise DemistoException('Key, Token and ID must be provided.')
        registration_id_and_url = registration_id_and_url.split('@')
        if len(registration_id_and_url) != 2:
            token_retrieval_url = "https://oproxy.demisto.ninja"  # guardrails-disable-line
        else:
            token_retrieval_url = registration_id_and_url[1]
        registration_id = registration_id_and_url[0]
        use_ssl = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        args = demisto.args()
        fetch_table = params.get('fetch_table')
        fetch_fields = params.get('fetch_fields') or '*'
        command = demisto.command()
        LOG(f'command is {command}')
        # needs to be executed before creating a Client
        if command == 'cdl-reset-authentication-timeout':
            Client.reset_failure_times()
            return_outputs(readable_output="Caching mechanism failure time counters have been successfully reset.")
            return

        client = Client(token_retrieval_url, registration_id, use_ssl, proxy, refresh_token, enc_key)

        try:
            if command == 'test-module':
                test_module(client, fetch_table, fetch_fields, params.get('isFetch'), params.get('filter_query', ''),
                            params.get('firewall_subtype'), params.get('firewall_severity'),
                            params.get('first_fetch_timestamp', '24 hours').strip())
            elif command == 'cdl-query-logs':
                return_outputs(*query_logs_command(args, client))
            elif command == 'cdl-get-critical-threat-logs':
                return_outputs(*get_critical_logs_command(args, client))
            elif command == 'cdl-get-social-applications':
                return_outputs(*get_social_applications_command(args, client))
            elif command == 'cdl-search-by-file-hash':
                return_outputs(*search_by_file_hash_command(args, client))
            elif command == 'cdl-query-traffic-logs':
                return_outputs(*query_traffic_logs_command(args, client))
            elif command == 'cdl-query-threat-logs':
                return_outputs(*query_threat_logs_command(args, client))
            elif command == 'cdl-query-url-logs':
                return_outputs(*query_url_logs_command(args, client))
            elif command == 'cdl-query-file-data':
                return_outputs(*query_file_data_command(args, client))
            elif command == 'fetch-incidents':
                first_fetch_timestamp = params.get('first_fetch_timestamp', '24 hours').strip()
                fetch_severity = params.get('firewall_severity')
                fetch_table = params.get('fetch_table')
                fetch_fields = params.get('fetch_fields') or '*'
                fetch_subtype = params.get('firewall_subtype')
                fetch_limit = params.get('limit')
                last_run = demisto.getLastRun()
                fetch_filter = params.get('filter_query', '')
                next_run, incidents = fetch_incidents(client,
                                                      first_fetch_timestamp,
                                                      fetch_severity,
                                                      fetch_table,
                                                      fetch_subtype,
                                                      fetch_fields,
                                                      fetch_limit,
                                                      last_run,
                                                      fetch_filter)
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
        except Exception as e:
            error_message = str(e)
            return_error(error_message)


    if __name__ in ('__main__', 'builtins'):
        main()

    register_module_line('Cortex Data Lake', 'end', __line__())
  subtype: python3
  type: python
system: true
