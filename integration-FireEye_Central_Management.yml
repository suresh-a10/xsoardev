category: Analytics & SIEM
commonfields:
  id: FireEye Central Management
  version: -1
configuration:
- defaultvalue: https://example.com/
  display: Your server URL
  name: url
  required: true
  section: Connect
  type: 0
- display: Username
  name: credentials
  required: true
  section: Connect
  type: 9
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- defaultvalue: "50"
  display: Max incidents to fetch
  name: max_fetch
  required: false
  section: Collect
  type: 0
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: first_fetch
  required: false
  section: Collect
  type: 0
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- defaultvalue: concise
  display: Info level for fetched alerts
  name: info_level
  options:
  - concise
  - normal
  - extended
  required: false
  section: Collect
  type: 15
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 1.1.23
    packID: FireEyeCM
    packName: FireEye Central Management
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: FireEye Central Management (CM Series) is the FireEye threat intelligence
  hub. It services the FireEye ecosystem, ensuring that FireEye products share the
  latest intelligence and correlate across attack vectors to detect and prevent cyber
  attacks.
detaileddescription: |-
  To configure the integration, enter your credentials in the following fields:
  - Username
  - Password

  ## Known Limitations
  Clicking the **Test** button of the **Integration instance settings** window verifies that the instance configuration is correct.
  Due to a known limitation, clicking the **Test** button several times in quick succession may result in an "Unauthorized" error, even after a successful result was initially returned. It is enough to receive one success message to verify that the configuration is correct. "Unauthorized" error messages received from repeated clicking of the instance configuration **Test** button do not affect the validity of the instance if the initial response was successful.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/fire-eye-central-management)
display: FireEye Central Management
image: data:image/png;base64,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
name: FireEye Central Management
script:
  commands:
  - arguments:
    - description: The ID number of the alert to retrieve.
      name: alert_id
    - auto: PREDEFINED
      description: The time interval to search. This filter is used with either the
        start_time or end_time filter. If duration, start time, and end time are not
        specified, the system defaults to duration=12_hours, end_time=current_time.
        If only the duration is specified, the end_time defaults to the current_time.
      name: duration
      predefined:
      - 1_hour
      - 2_hours
      - 6_hours
      - 12_hours
      - 24_hours
      - 48_hours
    - description: 'The start time of the search. This filter is optional. Syntax:
        start_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om or ''1 day/month/year''. Default
        is 1 day.'
      name: start_time
    - description: 'The end time of the search. This filter is used with the duration
        filter. If the end_time is specified but not the duration, the system defaults
        to duration=12_hours, ending at the specified end_time. Syntax: end_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om.'
      name: end_time
    - description: Searches for alerts that include callbacks to the specified domain.
      name: callback_domain
    - description: The destination IPv4 address related to the malware alert.
      name: dst_ip
    - description: The source IPv4 address related to the malware alert.
      name: src_ip
    - description: The name of the malware file.
      name: file_name
    - description: The malware file type.
      name: file_type
    - auto: PREDEFINED
      defaultValue: concise
      description: 'The level of information to be returned. Possible values: "concise",
        "normal", and "extended".'
      name: info_level
      predefined:
      - concise
      - normal
      - extended
    - description: The name of the malware object.
      name: malware_name
    - description: 'The type of the malware object. Possible values: "domain_match",
        "malware_callback", "malware_object", "web_infection", "infection_match",
        "riskware-infection", "riskware-callback", "riskware-object".'
      name: malware_type
      predefined:
      - domain_match
      - malware_callback
      - malware_object
      - web_infection
      - infection_match
      - riskware-infection
      - riskware-callback
      - riskware-object
    - description: Searches for alerts that include a specific MD5 hash.
      name: md5
    - description: The email address of the malware object receiver.
      name: recipient_email
    - description: The email address of the malware object sender.
      name: sender_email
    - description: Searches for a specific alert URL.
      name: url
    - defaultValue: "20"
      description: Maximum number of alerts to return.
      name: limit
    - defaultValue: "120"
      description: Timeout (in seconds) to retrieve the alerts.
      name: timeout
    description: Searches and retrieves FireEye CM alerts based on several filters.
    name: fireeye-cm-get-alerts
    outputs:
    - contextPath: FireEyeCM.Alerts.id
      description: The ID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.uuid
      description: The UUID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.occurred
      description: The time when the alert occurred.
      type: String
    - contextPath: FireEyeCM.Alerts.product
      description: The product name of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.rootInfection
      description: The ID of the infection associated with the malware alert.
      type: String
    - contextPath: FireEyeCM.Alerts.name
      description: The link to the infection associated with the malware alert.
      type: String
    - contextPath: FireEyeCM.Alerts.vlan
      description: The virtual LAN (VLAN) of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.malicious
      description: A flag indicating whether the alert is malicious.
      type: String
    - contextPath: FireEyeCM.Alerts.severity
      description: The severity of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.sensor
      description: The sensor name that the alert is associated with.
      type: String
    - contextPath: FireEyeCM.Alerts.applianceId
      description: The appliance ID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.sensorIp
      description: The sensor IP that the alert is associated with.
      type: String
    - contextPath: FireEyeCM.Alerts.ack
      description: A flag indicating whether an acknowledgment is received.
      type: String
    - contextPath: FireEyeCM.Alerts.src
      description: The source of the alert.
      type: Unknown
    - contextPath: FireEyeCM.Alerts.dst
      description: The destination of the alert.
      type: Unknown
    - contextPath: FireEyeCM.Alerts.explanation
      description: The explanation data of the alert.
      type: Unknown
  - arguments:
    - description: The ID of the alert for which to retrieve its details.
      isArray: true
      name: alert_id
      required: true
    - defaultValue: "30"
      description: Timeout (in seconds) to retrieve the alert details.
      name: timeout
    description: Searches and retrieves the details of a single alert.
    name: fireeye-cm-get-alert-details
    outputs:
    - contextPath: FireEyeCM.Alerts.id
      description: The ID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.uuid
      description: The UUID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.occurred
      description: The time when the alert occurred.
      type: String
    - contextPath: FireEyeCM.Alerts.product
      description: The product name of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.rootInfection
      description: The ID of the infection associated with the malware alert.
      type: String
    - contextPath: FireEyeCM.Alerts.name
      description: The link to the infection associated with the malware alert.
      type: String
    - contextPath: FireEyeCM.Alerts.vlan
      description: The virtual LAN (VLAN) of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.malicious
      description: A flag indicating whether the alert is malicious.
      type: String
    - contextPath: FireEyeCM.Alerts.severity
      description: The severity of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.sensor
      description: The sensor name that the alert is associated with.
      type: String
    - contextPath: FireEyeCM.Alerts.applianceId
      description: The appliance ID of the alert.
      type: String
    - contextPath: FireEyeCM.Alerts.sensorIp
      description: The sensor IP that the alert is associated with.
      type: String
    - contextPath: FireEyeCM.Alerts.ack
      description: A flag indicating whether an acknowledgment is received.
      type: String
    - contextPath: FireEyeCM.Alerts.src
      description: The source of the alert.
      type: Unknown
    - contextPath: FireEyeCM.Alerts.dst
      description: The destination of the alert.
      type: Unknown
    - contextPath: FireEyeCM.Alerts.explanation
      description: The explanation data of the alert.
      type: Unknown
  - arguments:
    - description: The universally unique identifier (UUID) for the alert.
      isArray: true
      name: uuid
      required: true
    description: Confirms that the alert has been reviewed.
    name: fireeye-cm-alert-acknowledge
  - arguments:
    - description: The universally unique identifier (UUID) for the alert.
      isArray: true
      name: uuid
      required: true
    - defaultValue: "120"
      description: Timeout (in seconds) to retrieve the artifacts.
      name: timeout
    description: Downloads malware artifacts data for the specified UUID as a zip
      file.
    name: fireeye-cm-get-artifacts-by-uuid
    outputs:
    - contextPath: InfoFile.EntryID
      description: The EntryID of the artifact file.
      type: string
    - contextPath: InfoFile.Extension
      description: The extension of the artifact file.
      type: string
    - contextPath: InfoFile.Name
      description: The name of the artifact file.
      type: string
    - contextPath: InfoFile.Info
      description: The info of the artifact file.
      type: string
    - contextPath: InfoFile.Size
      description: The size of the artifact file.
      type: number
    - contextPath: InfoFile.Type
      description: The type of the artifact file.
      type: string
  - arguments:
    - description: The universally unique identifier (UUID) for the alert.
      isArray: true
      name: uuid
      required: true
    description: Gets artifacts metadata for the specified UUID.
    name: fireeye-cm-get-artifacts-metadata-by-uuid
    outputs:
    - contextPath: FireEyeCM.Alerts.uuid
      description: Universally unique ID (UUID) of the alert.
      type: string
    - contextPath: FireEyeCM.Alerts.artifactsInfoList.artifactType
      description: The artifact type.
      type: string
    - contextPath: FireEyeCM.Alerts.artifactsInfoList.artifactName
      description: The artifact name.
      type: string
    - contextPath: FireEyeCM.Alerts.artifactsInfoList.artifactSize
      description: The zipped artifact size in bytes.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: The time interval in which to search. This filter is used with
        the end_time filter. If the duration is not specified, the system defaults
        to duration=12_hours, end_time=current_time.
      name: duration
      predefined:
      - 1_hour
      - 2_hours
      - 6_hours
      - 12_hours
      - 24_hours
      - 48_hours
    - description: 'The end time of the search. This filter is used with the duration
        filter. If the end_time is specified but not the duration, the system defaults
        to duration=12_hours, ending at the specified end_time. Syntax: end_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om'
      name: end_time
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Specifies whether to include all IPS events or MVX-correlated
        events only. Possible values: "true" and "false".'
      name: mvx_correlated_only
      predefined:
      - "false"
      - "true"
    - defaultValue: "20"
      description: Maximum number of events to return.
      name: limit
    description: Retrieves information about existing IPS NX events. An IPS enabled
      appliance is a prerequisite to be able to retrieve IPS event data.
    name: fireeye-cm-get-events
    outputs:
    - contextPath: FireEyeCM.Events.eventId
      description: The ID of the event.
      type: Number
    - contextPath: FireEyeCM.Events.occurred
      description: The date and time when the event occurred.
      type: string
    - contextPath: FireEyeCM.Events.srcIp
      description: The IP address of the victim.
      type: string
    - contextPath: FireEyeCM.Events.srcPort
      description: The port address of the victim.
      type: Number
    - contextPath: FireEyeCM.Events.dstIp
      description: The IP address of the attacker.
      type: string
    - contextPath: FireEyeCM.Events.dstPort
      description: The port address of the attacker.
      type: Number
    - contextPath: FireEyeCM.Events.vlan
      description: The virtual LAN (VLAN) of the event.
      type: Number
    - contextPath: FireEyeCM.Events.signatureMatchCnt
      description: The date and time when the event occurred.
      type: String
    - contextPath: FireEyeCM.Events.signatureId
      description: The ID of the event.
      type: String
    - contextPath: FireEyeCM.Events.signatureRev
      description: The date and time when the event occurred.
      type: String
    - contextPath: FireEyeCM.Events.severity
      description: The ID of the event.
      type: String
    - contextPath: FireEyeCM.Events.vmVerified
      description: The date and time when the event occurred.
      type: String
    - contextPath: FireEyeCM.Events.srcMac
      description: The MAC address of the source machine.
      type: String
    - contextPath: FireEyeCM.Events.dstMac
      description: The MAC address of the destination machine.
      type: String
    - contextPath: FireEyeCM.Events.ruleName
      description: The rule name for the event.
      type: String
    - contextPath: FireEyeCM.Events.sensorId
      description: The sensor ID of the FireEye machine.
      type: String
    - contextPath: FireEyeCM.Events.cveId
      description: The CVE ID found in the event.
      type: String
    - contextPath: FireEyeCM.Events.actionTaken
      description: The IPS blocking action taken on the event.
      type: String
    - contextPath: FireEyeCM.Events.attackMode
      description: The attack mode mentioned in the event.
      type: String
    - contextPath: FireEyeCM.Events.interfaceId
      description: The interface ID of the event.
      type: Number
    - contextPath: FireEyeCM.Events.protocol
      description: The protocol used in the event.
      type: Number
    - contextPath: FireEyeCM.Events.incidentId
      description: The incident ID of the event on FireEye.
      type: Number
  - arguments:
    - defaultValue: 1 day
      description: 'Specifies the start time of the search. This filter is optional.
        Default is last day. Syntax: start_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om or ''1
        day/month/year''.'
      name: start_time
    - description: 'Specifies the end time of the search. Default is now. Syntax:
        end_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om or ''1 day/month/year''.'
      name: end_time
    - description: The sender email.
      name: from
    - description: The email subject. Must be URL encoded.
      name: subject
    - description: The appliance ID.
      name: appliance_id
    - defaultValue: "20"
      description: Number of emails to return.
      name: limit
    description: Searches and retrieves quarantined emails.
    name: fireeye-cm-get-quarantined-emails
    outputs:
    - contextPath: FireEyeCM.QuarantinedEmail.appliance_id
      description: The appliance ID associated with the quarantined email.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.completed_at
      description: The time the email has been quarantined.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.email_uuid
      description: The quarantined email UUID.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.from
      description: The quarantined email sender.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.message_id
      description: The quarantined email message ID.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.quarantine_path
      description: The quarantined email path.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.The quarantined email queue id.
      description: The quarantined email queue ID.
      type: string
    - contextPath: FireEyeCM.QuarantinedEmail.subject
      description: The quarantined email subject.
      type: string
  - arguments:
    - description: A comma-separated list of quarantined email queue IDs. Supports
        up to 100 IDs.
      isArray: true
      name: queue_ids
      required: true
    - description: The sensor display name.
      name: sensor_name
      required: true
    description: Releases and deletes quarantined emails. This is not available when
      Email Security is in Drop mode.
    name: fireeye-cm-release-quarantined-emails
  - arguments:
    - description: A comma-separated list of quarantined email queue IDs. Supports
        up to 100 IDs.
      isArray: true
      name: queue_ids
      required: true
    - description: The sensor display name.
      name: sensor_name
      required: true
    description: Deletes quarantined emails. This is not available when Email Security
      is in Drop mode.
    name: fireeye-cm-delete-quarantined-emails
  - arguments:
    - description: The quarantined emails queue ID.
      name: queue_id
      required: true
    - description: The sensor display name.
      name: sensor_name
      required: true
    - defaultValue: "120"
      description: Timeout (in seconds) to retrieve the reports.
      name: timeout
    description: Download quarantined emails.
    name: fireeye-cm-download-quarantined-emails
    outputs:
    - contextPath: File.Name
      description: The name of the email.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the email.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the email.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the email.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.Size
      description: The size of the email in bytes.
      type: Number
    - contextPath: File.SSDeep
      description: The SSDeep hash of the email.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The report type. Requests for ipsTopNAttack, ipsTopNAttacker, ipsTopNVictim,
        or ipsTopNMvxVerified reports must be used with the limit parameter set to
        either 25, 50, 75, or 100. You must have an Intrusion Prevention System (IPS)-enabled
        appliance to be able to generate the IPS reports.
      name: report_type
      predefined:
      - empsEmailAVReport
      - empsEmailActivity
      - empsEmailExecutiveSummary
      - empsEmailHourlyStat
      - mpsCallBackServer
      - mpsExecutiveSummary
      - mpsInfectedHostsTrend
      - mpsMalwareActivity
      - mpsWebAVReport
      - ipsExecutiveSummary
      - ipsTopNAttack
      - ipsTopNAttacker
      - ipsTopNVictim
      - ipsTopNMvxVerified
      - alertDetailsReport
      required: true
    - defaultValue: 1 week
      description: 'The start time of the search. This filter is optional. Syntax:
        start_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om or ''1 day/month/year''.'
      name: start_time
    - description: 'Specifies the end time of the search. Default is now. Syntax:
        end_time=YYYY-MM-DDTHH:mm:ss.sss-OH:om or ''1 day/month/year''.'
      name: end_time
    - defaultValue: "100"
      description: The maximum number of items covered by each report. This option
        is required only for IPS TopN reports.
      name: limit
    - auto: PREDEFINED
      description: The internet interface to one of the values. This option is required
        only for IPS reports.
      name: interface
      predefined:
      - A
      - B
      - AB
    - description: Alert ID. This argument is only relevant when retrieving a report
        of type alertDetailsReport.
      name: alert_id
    - description: Infection ID. This argument is only relevant when retrieving a
        report of type alertDetailsReport with conjunction to the infection_type argument.
      name: infection_id
    - auto: PREDEFINED
      description: 'Infection type. Possible values: "malware-object", "malware-callback",
        "infection-match", "domain-match", "web-infection". This argument is only
        relevant when retrieving a report of type alertDetailsReport with conjunction
        to the infection_id argument.'
      name: infection_type
      predefined:
      - malware-object
      - malware-callback
      - infection-match
      - domain-match
      - web-infection
    - defaultValue: "120"
      description: Timeout (in seconds) to retrieve the reports.
      name: timeout
    description: Returns reports on selected alerts.
    name: fireeye-cm-get-reports
    outputs:
    - contextPath: InfoFile.EntryID
      description: The EntryID of the artifact file.
      type: string
    - contextPath: InfoFile.Extension
      description: The extension of the artifact file.
      type: string
    - contextPath: InfoFile.Name
      description: The name of the artifact file.
      type: string
    - contextPath: InfoFile.Info
      description: The info of the artifact file.
      type: string
    - contextPath: InfoFile.Size
      description: The size of the artifact file.
      type: number
    - contextPath: InfoFile.Type
      description: The type of the artifact file.
      type: string
  dockerimage: demisto/python3:3.10.13.80014
  isfetch: true
  runonce: false
  script: |
    register_module_line('FireEye Central Management', 'start', __line__())
    ### pack version: 1.1.23



    import urllib3
    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' CONSTANTS '''
    INTEGRATION_NAME = 'FireEye Central Management'
    INTEGRATION_COMMAND_NAME = 'fireeye-cm'
    INTEGRATION_CONTEXT_NAME = 'FireEyeCM'
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'  # ISO8601 format with UTC, default in XSOAR


    class Client:
        """
        The integration's client
        """

        def __init__(self, base_url: str, username: str, password: str, verify: bool, proxy: bool):
            self.fe_client: FireEyeClient = FireEyeClient(base_url=base_url, username=username, password=password,
                                                          verify=verify, proxy=proxy)


    @logger
    def run_test_module(client: Client) -> str:
        client.fe_client.get_alerts_request({'info_level': 'concise'})
        return 'ok'


    @logger
    def get_alerts(client: Client, args: Dict[str, Any]) -> CommandResults:
        def parse_request_params(args: Dict[str, Any]) -> Dict:
            alert_id = args.get('alert_id', '')
            start_time = args.get('start_time', '')
            if start_time:
                start_time = to_fe_datetime_converter(start_time)
            end_time = args.get('end_time')
            if end_time:
                end_time = to_fe_datetime_converter(end_time)
            duration = args.get('duration')
            callback_domain = args.get('callback_domain', '')
            dst_ip = args.get('dst_ip', '')
            src_ip = args.get('src_ip', '')
            file_name = args.get('file_name', '')
            file_type = args.get('file_type', '')
            malware_name = args.get('malware_name', '')
            malware_type = args.get('malware_type', '')
            recipient_email = args.get('recipient_email', '')
            sender_email = args.get('sender_email', '')
            url_ = args.get('url', '')

            request_params = {
                'info_level': args.get('info_level', 'concise')
            }
            if start_time:
                request_params['start_time'] = start_time
            if end_time:
                request_params['end_time'] = end_time
            if duration:
                request_params['duration'] = duration
            if alert_id:
                request_params['alert_id'] = alert_id
            if callback_domain:
                request_params['callback_domain'] = callback_domain
            if dst_ip:
                request_params['dst_ip'] = dst_ip
            if src_ip:
                request_params['src_ip'] = src_ip
            if file_name:
                request_params['file_name'] = file_name
            if file_type:
                request_params['file_type'] = file_type
            if malware_name:
                request_params['malware_name'] = malware_name
            if malware_type:
                request_params['malware_type'] = malware_type
            if recipient_email:
                request_params['recipient_email'] = recipient_email
            if sender_email:
                request_params['sender_email'] = sender_email
            if url_:
                request_params['url'] = url_
            return request_params

        request_params = parse_request_params(args)
        limit = int(args.get('limit', '20'))
        timeout = int(args.get('timeout', '120'))

        raw_response = client.fe_client.get_alerts_request(request_params, timeout=timeout)

        alerts = raw_response.get('alert')
        if not alerts:
            md_ = f'No alerts with the given arguments were found.\n Arguments {str(request_params)}'
        else:
            alerts = alerts[:limit]
            headers = ['id', 'occurred', 'product', 'name', 'malicious', 'severity', 'alertUrl']
            md_ = tableToMarkdown(name=f'{INTEGRATION_NAME} Alerts:', t=alerts, headers=headers, removeNull=True)

        return CommandResults(
            readable_output=md_,
            outputs_prefix=f'{INTEGRATION_CONTEXT_NAME}.Alerts',
            outputs_key_field='uuid',
            outputs=alerts,
            raw_response=raw_response
        )


    @logger
    def get_alert_details(client: Client, args: Dict[str, Any]) -> List[CommandResults]:
        alert_ids = argToList(args.get('alert_id'))
        timeout = int(args.get('timeout', '120'))

        command_results: List[CommandResults] = []

        headers = ['id', 'occurred', 'product', 'name', 'malicious', 'action', 'src', 'dst', 'severity', 'alertUrl']

        for alert_id in alert_ids:
            raw_response = client.fe_client.get_alert_details_request(alert_id, timeout)

            alert_details = raw_response.get('alert')
            if not alert_details:
                md_ = f'Alert {alert_id} was not found.'
            else:
                md_ = tableToMarkdown(name=f'{INTEGRATION_NAME} Alerts:', t=alert_details, headers=headers, removeNull=True)

            command_results.append(CommandResults(
                readable_output=md_,
                outputs_prefix=f'{INTEGRATION_CONTEXT_NAME}.Alerts',
                outputs_key_field='uuid',
                outputs=alert_details,
                raw_response=raw_response
            ))

        return command_results


    @logger
    def alert_acknowledge(client: Client, args: Dict[str, Any]) -> List[CommandResults]:
        uuids = argToList(args.get('uuid'))
        command_results: List[CommandResults] = []

        for uuid in uuids:
            try:
                client.fe_client.alert_acknowledge_request(uuid)
                md_ = f'Alert {uuid} was acknowledged successfully.'
            except Exception as err:
                if 'Error in API call [404]' in str(err):
                    md_ = f'Alert {uuid} was not found or cannot update. It may have been acknowledged in the past.'
                else:
                    raise

            command_results.append(CommandResults(
                readable_output=md_
            ))

        return command_results


    @logger
    def get_artifacts_by_uuid(client: Client, args: Dict[str, Any]):
        uuids = argToList(args.get('uuid'))
        timeout = int(args.get('timeout', '120'))

        for uuid in uuids:
            artifact = client.fe_client.get_artifacts_by_uuid_request(uuid, timeout)
            demisto.results(fileResult(f'artifacts_{uuid}.zip', data=artifact, file_type=EntryType.ENTRY_INFO_FILE))


    @logger
    def get_artifacts_metadata_by_uuid(client: Client, args: Dict[str, Any]) -> List[CommandResults]:
        uuids: List[str] = argToList(str(args.get('uuid')))
        command_results: List[CommandResults] = []

        for uuid in uuids:
            raw_response = client.fe_client.get_artifacts_metadata_by_uuid_request(uuid)

            outputs = raw_response
            outputs['uuid'] = uuid  # type: ignore
            md_ = tableToMarkdown(name=f'{INTEGRATION_NAME} {uuid} Artifact metadata:',
                                  t=raw_response.get('artifactsInfoList'), removeNull=True)

            command_results.append(CommandResults(
                readable_output=md_,
                outputs_prefix=f'{INTEGRATION_CONTEXT_NAME}.Alerts',
                outputs_key_field='uuid',
                outputs=outputs,
                raw_response=raw_response
            ))

        return command_results


    @logger
    def get_events(client: Client, args: Dict[str, Any]) -> CommandResults:
        duration = args.get('duration', '12_hours')
        end_time = to_fe_datetime_converter(args.get('end_time', 'now'))
        mvx_correlated_only = argToBoolean(args.get('mvx_correlated_only', 'false'))
        limit = int(args.get('limit', '20'))

        raw_response = client.fe_client.get_events_request(duration, end_time, mvx_correlated_only)

        events = raw_response.get('events')
        if not events:
            md_ = 'No events in the given timeframe were found.'
        else:
            events = events[:limit]
            headers = ['occurred', 'ruleName', 'severity', 'malicious', 'cveId', 'eventId', 'srcIp', 'dstIp']
            md_ = tableToMarkdown(name=f'{INTEGRATION_NAME} Events:', t=events, headers=headers, removeNull=True)

        return CommandResults(
            readable_output=md_,
            outputs_prefix=f'{INTEGRATION_CONTEXT_NAME}.Events',
            outputs_key_field='eventId',
            outputs=events,
            raw_response=raw_response
        )


    @logger
    def get_quarantined_emails(client: Client, args: Dict[str, Any]) -> CommandResults:
        start_time = to_fe_datetime_converter(args.get('start_time', '1 day'))
        end_time = to_fe_datetime_converter(args.get('end_time', 'now'))
        from_ = args.get('from', '')
        subject = args.get('subject', '')
        appliance_id = args.get('appliance_id', '')
        limit = (args.get('limit', '10000'))

        raw_response = client.fe_client.get_quarantined_emails_request(start_time, end_time, from_, subject, appliance_id, limit)
        if not raw_response:
            md_ = 'No emails with the given query arguments were found.'
        else:
            headers = ['email_uuid', 'from', 'subject', 'message_id', 'completed_at']
            md_ = tableToMarkdown(name=f'{INTEGRATION_NAME} Quarantined emails:', t=raw_response,
                                  headers=headers, removeNull=True)

        return CommandResults(
            readable_output=md_,
            outputs_prefix=f'{INTEGRATION_CONTEXT_NAME}.QuarantinedEmail',
            outputs_key_field='email_uuid',
            outputs=raw_response,
            raw_response=raw_response
        )


    @logger
    def release_quarantined_emails(client: Client, args: Dict[str, Any]) -> CommandResults:
        sensor_name = args.get('sensor_name', '')
        queue_ids = argToList(args.get('queue_ids', ''))

        raw_response = client.fe_client.release_quarantined_emails_request(queue_ids, sensor_name)

        if raw_response.text:  # returns 200 either way. if operation is successful than resp is empty
            raise DemistoException(raw_response.json())
        else:
            md_ = f'{INTEGRATION_NAME} released emails successfully.'
        return CommandResults(
            readable_output=md_,
            raw_response=raw_response
        )


    @logger
    def delete_quarantined_emails(client: Client, args: Dict[str, Any]) -> CommandResults:
        sensor_name = args.get('sensor_name', '')
        queue_ids = argToList(args.get('queue_ids', ''))

        raw_response = client.fe_client.delete_quarantined_emails_request(queue_ids, sensor_name)
        if raw_response.text:  # returns 200 either way. if operation is successful than resp is empty
            raise DemistoException(raw_response.json())
        else:
            md_ = f'{INTEGRATION_NAME} deleted emails successfully.'

        return CommandResults(
            readable_output=md_,
            raw_response=raw_response
        )


    @logger
    def download_quarantined_emails(client: Client, args: Dict[str, Any]):
        sensor_name = args.get('sensor_name', '')
        queue_id = args.get('queue_id', '')
        timeout = int(args.get('timeout', '120'))

        raw_response = client.fe_client.download_quarantined_emails_request(queue_id, timeout, sensor_name)

        demisto.results(fileResult(f'quarantined_email_{queue_id}.eml', data=raw_response, file_type=EntryType.FILE))


    @logger
    def get_reports(client: Client, args: Dict[str, Any]):
        report_type = args.get('report_type', '')
        start_time = to_fe_datetime_converter(args.get('start_time', '1 week'))
        end_time = to_fe_datetime_converter(args.get('end_time', 'now'))
        limit = args.get('limit', '100')
        interface = args.get('interface', '')
        alert_id = args.get('alert_id', '')
        infection_id = args.get('infection_id', '')
        infection_type = args.get('infection_type', '')
        timeout = int(args.get('timeout', '120'))

        if report_type == 'alertDetailsReport':  # validate arguments
            # can use either alert_id, or infection_type and infection_id
            err_str = 'The alertDetailsReport can be retrieved using alert_id argument alone, ' \
                      'or by infection_type and infection_id'
            if alert_id:
                if infection_id or infection_type:
                    raise DemistoException(err_str)
            else:
                if not infection_id and not infection_type:
                    raise DemistoException(err_str)

        try:
            raw_response = client.fe_client.get_reports_request(report_type, start_time, end_time, limit, interface,
                                                                alert_id, infection_type, infection_id, timeout)
            csv_reports = {'empsEmailAVReport', 'empsEmailHourlyStat', 'mpsCallBackServer', 'mpsInfectedHostsTrend',
                           'mpsWebAVReport'}
            prefix = 'csv' if report_type in csv_reports else 'pdf'
            demisto.results(fileResult(f'report_{report_type}_{datetime.now().timestamp()}.{prefix}', data=raw_response,
                                       file_type=EntryType.ENTRY_INFO_FILE))
        except Exception as err:
            if 'WSAPI_REPORT_ALERT_NOT_FOUND' in str(err):
                return CommandResults(readable_output=f'Report {report_type} was not found with the given arguments.')
            else:
                raise


    @logger
    def fetch_incidents(client: Client, last_run: dict, first_fetch: str, max_fetch: int = 50,
                        info_level: str = 'concise') -> tuple[dict, list]:
        if not last_run:  # if first time fetching
            next_run = {
                'time': to_fe_datetime_converter(first_fetch),
                'last_alert_ids': []
            }
        else:
            next_run = last_run

        demisto.info(f'{INTEGRATION_NAME} executing fetch with: {str(next_run.get("time"))}')
        raw_response = client.fe_client.get_alerts_request(request_params={
            'start_time': to_fe_datetime_converter(next_run['time']),  # type: ignore
            'info_level': info_level,
            'duration': '48_hours'
        })
        all_alerts = raw_response.get('alert')

        ten_minutes = dateparser.parse('10 minutes')
        assert ten_minutes is not None
        if not all_alerts:
            demisto.info(f'{INTEGRATION_NAME} no alerts were fetched from FireEye server at: {str(next_run)}')
            # as no alerts occurred in the window of 48 hours from the given start time, update last_run window to the next
            # 48 hours. If it is later than now -10 minutes take the latter (to avoid missing events).
            next_run_time_date = dateparser.parse(str(next_run['time']))
            assert next_run_time_date is not None
            two_days_from_last_search = (next_run_time_date + timedelta(hours=48))
            now_minus_ten_minutes = ten_minutes.astimezone(two_days_from_last_search.tzinfo)
            next_search = min(two_days_from_last_search, now_minus_ten_minutes)
            next_run = {
                'time': next_search.isoformat(),
                'last_alert_ids': []
            }
            demisto.info(f'{INTEGRATION_NAME} setting next run to: {str(next_run)}')
            return next_run, []

        alerts = all_alerts[:max_fetch]
        last_alert_ids = last_run.get('last_alert_ids', [])
        incidents = []

        for alert in alerts:
            alert_id = str(alert.get('id'))
            if alert_id not in last_alert_ids:  # check that event was not fetched in the last fetch
                occurred_date = dateparser.parse(alert.get('occurred'))
                assert occurred_date is not None, f"could not parse {alert.get('occurred')}"
                incident = {
                    'name': f'{INTEGRATION_NAME} Alert: {alert_id}',
                    'occurred': occurred_date.strftime(DATE_FORMAT),
                    'severity': alert_severity_to_dbot_score(alert.get('severity')),
                    'rawJSON': json.dumps(alert)
                }
                incidents.append(incident)
                last_alert_ids.append(alert_id)

        if not incidents:
            demisto.info(f'{INTEGRATION_NAME} no new alerts were collected at: {str(next_run)}.')
            # As no incidents were collected, we know that all the fetched alerts for 48 hours starting in the 'start_time'
            # already exists in our system, thus update last_run time to look for the next 48 hours. If it is later than
            # now -10 minutes take the latter (to avoid missing events)
            parsed_date = dateparser.parse(alerts[-1].get('occurred'))
            assert parsed_date is not None, f"could not parse {alerts[-1].get('occurred')}"
            two_days_from_last_incident = parsed_date + timedelta(hours=48)
            now_minus_ten_minutes = ten_minutes.astimezone(two_days_from_last_incident.tzinfo)
            next_search = min(two_days_from_last_incident, now_minus_ten_minutes)
            next_run['time'] = next_search.isoformat()
            demisto.info(f'{INTEGRATION_NAME} Setting next_run to: {next_run["time"]}')
            return next_run, []

        # as alerts occurred till now, update last_run time accordingly to the that of latest fetched alert
        next_run = {
            'time': alerts[-1].get('occurred'),
            'last_alert_ids': last_alert_ids  # save the alert IDs from the last fetch
        }
        demisto.info(f'{INTEGRATION_NAME} Fetched {len(incidents)}. last fetch at: {str(next_run)}')
        return next_run, incidents


    def main() -> None:
        params = demisto.params()
        username = params.get('credentials').get('identifier')
        password = params.get('credentials').get('password')
        # there is also a v1.2.0 which holds different paths and params, we support only the newest API version
        base_url = urljoin(params.get('url'), '/wsapis/v2.0.0/')
        verify = not argToBoolean(params.get('insecure', 'false'))
        proxy = argToBoolean(params.get('proxy'))

        # fetch params
        max_fetch = int(params.get('max_fetch', '50'))
        first_fetch = params.get('first_fetch', '3 days').strip()
        info_level = params.get('info_level', 'concise')

        command = demisto.command()
        args = demisto.args()
        LOG(f'Command being called is {command}')
        try:
            client = Client(base_url=base_url, username=username, password=password, verify=verify, proxy=proxy)
            commands = {
                f'{INTEGRATION_COMMAND_NAME}-get-alerts': get_alerts,
                f'{INTEGRATION_COMMAND_NAME}-get-alert-details': get_alert_details,
                f'{INTEGRATION_COMMAND_NAME}-alert-acknowledge': alert_acknowledge,
                f'{INTEGRATION_COMMAND_NAME}-get-artifacts-by-uuid': get_artifacts_by_uuid,
                f'{INTEGRATION_COMMAND_NAME}-get-artifacts-metadata-by-uuid': get_artifacts_metadata_by_uuid,
                f'{INTEGRATION_COMMAND_NAME}-get-events': get_events,
                f'{INTEGRATION_COMMAND_NAME}-get-quarantined-emails': get_quarantined_emails,
                f'{INTEGRATION_COMMAND_NAME}-release-quarantined-emails': release_quarantined_emails,
                f'{INTEGRATION_COMMAND_NAME}-delete-quarantined-emails': delete_quarantined_emails,
                f'{INTEGRATION_COMMAND_NAME}-download-quarantined-emails': download_quarantined_emails,
                f'{INTEGRATION_COMMAND_NAME}-get-reports': get_reports,
            }
            if command == 'test-module':
                return_results(run_test_module(client))
            elif command == 'fetch-incidents':
                next_run, incidents = fetch_incidents(
                    client=client,
                    last_run=demisto.getLastRun(),
                    first_fetch=first_fetch,
                    max_fetch=max_fetch,
                    info_level=info_level
                )
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
            elif command == f'{INTEGRATION_COMMAND_NAME}-get-artifacts-by-uuid':
                get_artifacts_by_uuid(client, args)
            elif command == f'{INTEGRATION_COMMAND_NAME}-get-reports':
                get_reports(client, args)
            elif command == f'{INTEGRATION_COMMAND_NAME}-download-quarantined-emails':
                download_quarantined_emails(client, args)
            elif command in commands:
                return_results(commands[command](client, args))
            else:
                raise NotImplementedError(f'Command "{command}" is not implemented.')

        except Exception as err:
            return_error(str(err), err)



    ### GENERATED CODE ###: from FireEyeApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('FireEyeApiModule', 'start', __line__(), wrapper=-3)



    ''' CONSTANTS '''
    FE_DATE_FORMAT = '%Y-%m-%dT%H:%M:%S'
    OK_CODES = (200, 206)


    class FireEyeClient(BaseClient):
        def __init__(self, base_url: str,
                     username: str, password: str,
                     verify: bool, proxy: bool,
                     ok_codes: tuple = OK_CODES):

            super().__init__(base_url=base_url, auth=(username, password), verify=verify, proxy=proxy, ok_codes=ok_codes)
            self._headers = {
                'X-FeApi-Token': self._get_token(),
                'Accept': 'application/json',
            }

        @logger
        def http_request(self, method: str, url_suffix: str = '', json_data: dict = None, params: dict = None,
                         timeout: int = 10, resp_type: str = 'json', retries: int = 1):
            try:
                address = urljoin(self._base_url, url_suffix)
                res = self._session.request(
                    method,
                    address,
                    headers=self._headers,
                    verify=self._verify,
                    params=params,
                    json=json_data,
                    timeout=timeout
                )
                # Handle error responses gracefully
                if not self._is_status_code_valid(res):
                    err_msg = f'Error in API call {res.status_code} - {res.reason}'
                    try:
                        # Try to parse json error response
                        error_entry = res.json()
                        err_msg += f'\n{json.dumps(error_entry)}'
                        if 'Server Error. code:AUTH004' in err_msg and retries:
                            # implement 1 retry to re create a token
                            self._headers['X-FeApi-Token'] = self._generate_token()
                            self.http_request(method, url_suffix, json_data, params, timeout, resp_type, retries - 1)
                        else:
                            raise DemistoException(err_msg, res=res)
                    except ValueError:
                        err_msg += f'\n{res.text}'
                        raise DemistoException(err_msg, res=res)

                resp_type = resp_type.lower()
                try:
                    if resp_type == 'json':
                        return res.json()
                    if resp_type == 'text':
                        return res.text
                    if resp_type == 'content':
                        return res.content
                    return res
                except ValueError:
                    raise DemistoException('Failed to parse json object from response.')
            except requests.exceptions.ConnectTimeout as exception:
                err_msg = 'Connection Timeout Error - potential reasons might be that the Server URL parameter' \
                          ' is incorrect or that the Server is not accessible from your host.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.SSLError as exception:
                # in case the "Trust any certificate" is already checked
                if not self._verify:
                    raise
                err_msg = 'SSL Certificate Verification Failed - try selecting \'Trust any certificate\' checkbox in' \
                          ' the integration configuration.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.ProxyError as exception:
                err_msg = 'Proxy Error - if the \'Use system proxy\' checkbox in the integration configuration is' \
                          ' selected, try clearing the checkbox.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.ConnectionError as exception:
                # Get originating Exception in Exception chain
                error_class = str(exception.__class__)
                err_type = '<' + error_class[error_class.find('\'') + 1: error_class.rfind('\'')] + '>'
                err_msg = f'Verify that the server URL parameter' \
                          f' is correct and that you have access to the server from your host.' \
                          f'\nError Type: {err_type}\nError Number: [{exception.errno}]\nMessage: {exception.strerror}\n'
                raise DemistoException(err_msg, exception)

        @logger
        def _get_token(self) -> str:
            """
            Obtains token from integration context if available and still valid
            (15 minutes according to the API, we gave 10 minutes).
            After expiration, new token are generated and stored in the integration context.
            Returns:
                str: token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            token = integration_context.get('token', '')
            valid_until = integration_context.get('valid_until')

            now = datetime.now()
            now_timestamp = datetime.timestamp(now)
            # if there is a key and valid_until, and the current time is smaller than the valid until
            # return the current token
            if token and valid_until and now_timestamp < valid_until:
                return token

            # else generate a token and update the integration context accordingly
            token = self._generate_token()

            return token

        @logger
        def _generate_token(self) -> str:
            try:
                resp = self._http_request(method='POST', url_suffix='auth/login', resp_type='response')
            except DemistoException as er:
                raise DemistoException(
                    f'Token request failed. message: {str(er)}')
            if 'X-FeApi-Token' not in resp.headers:
                raise DemistoException(
                    f'Token request failed. API token is missing. message: {str(resp)}')
            token = resp.headers['X-FeApi-Token']

            integration_context = get_integration_context()
            integration_context.update({'token': token})
            time_buffer = 600  # 600 seconds (10 minutes) by which to lengthen the validity period
            integration_context.update({'valid_until': datetime.timestamp(datetime.now() + timedelta(seconds=time_buffer))})
            set_integration_context(integration_context)

            return token

        @logger
        def get_alerts_request(self, request_params: Dict[str, Any], timeout: int = 120) -> Dict[str, str]:
            return self.http_request(method='GET', url_suffix='alerts', params=request_params, resp_type='json',
                                     timeout=timeout)

        @logger
        def get_alert_details_request(self, alert_id: str, timeout: int) -> Dict[str, str]:
            return self.http_request(method='GET', url_suffix=f'alerts/alert/{alert_id}', resp_type='json',
                                     timeout=timeout)

        @logger
        def alert_acknowledge_request(self, uuid: str) -> Dict[str, str]:
            # json_data here is redundant as we are not sending any meaningful data,
            # but without it the API call to FireEye fails and we are getting an error. hence sending it with a dummy value.
            # the error we get when not sending json_data is: "Bad Request" with Invalid input. code:ALRTCONF001
            return self.http_request(method='POST', url_suffix=f'alerts/alert/{uuid}',
                                     params={'schema_compatibility': True}, json_data={"annotation": "<test>"},
                                     resp_type='resp')

        @logger
        def get_artifacts_by_uuid_request(self, uuid: str, timeout: int) -> Dict[str, str]:
            self._headers.pop('Accept')  # returns a file, hence this header is disruptive
            return self.http_request(method='GET', url_suffix=f'artifacts/{uuid}', resp_type='content',
                                     timeout=timeout)

        @logger
        def get_artifacts_metadata_by_uuid_request(self, uuid: str) -> Dict[str, str]:
            return self.http_request(method='GET', url_suffix=f'artifacts/{uuid}/meta', resp_type='json')

        @logger
        def get_events_request(self, duration: str, end_time: str, mvx_correlated_only: bool) -> Dict[str, str]:
            return self.http_request(method='GET',
                                     url_suffix='events',
                                     params={
                                         'event_type': 'Ips Event',
                                         'duration': duration,
                                         'end_time': end_time,
                                         'mvx_correlated_only': mvx_correlated_only
                                     },
                                     resp_type='json')

        @logger
        def get_quarantined_emails_request(self, start_time: str, end_time: str, from_: str, subject: str,
                                           appliance_id: str, limit: int) -> Dict[str, str]:
            params = {
                'start_time': start_time,
                'end_time': end_time,
                'limit': limit
            }
            if from_:
                params['from'] = from_
            if subject:
                params['subject'] = subject
            if appliance_id:
                params['appliance_id'] = appliance_id

            return self.http_request(method='GET', url_suffix='emailmgmt/quarantine', params=params, resp_type='json')

        @logger
        def release_quarantined_emails_request(self, queue_ids: list, sensor_name: str):
            return self.http_request(method='POST',
                                     url_suffix='emailmgmt/quarantine/release',
                                     params={'sensorName': sensor_name},
                                     json_data={"queue_ids": queue_ids},
                                     resp_type='resp')

        @logger
        def delete_quarantined_emails_request(self, queue_ids: list, sensor_name: str = ''):
            return self.http_request(method='POST',
                                     url_suffix='emailmgmt/quarantine/delete',
                                     params={'sensorName': sensor_name},
                                     json_data={"queue_ids": queue_ids},
                                     resp_type='resp')

        @logger
        def download_quarantined_emails_request(self, queue_id: str, timeout: str, sensor_name: str = ''):
            self._headers.pop('Accept')  # returns a file, hence this header is disruptive
            return self.http_request(method='GET',
                                     url_suffix=f'emailmgmt/quarantine/{queue_id}',
                                     params={'sensorName': sensor_name},
                                     resp_type='content',
                                     timeout=timeout)

        @logger
        def get_reports_request(self, report_type: str, start_time: str, end_time: str, limit: str, interface: str,
                                alert_id: str, infection_type: str, infection_id: str, timeout: int):
            params = {
                'report_type': report_type,
                'start_time': start_time,
                'end_time': end_time
            }
            if limit:
                params['limit'] = limit
            if interface:
                params['interface'] = interface
            if alert_id:
                params['id'] = alert_id
            if infection_type:
                params['infection_type'] = infection_type
            if infection_id:
                params['infection_id'] = infection_id

            return self.http_request(method='GET',
                                     url_suffix='reports/report',
                                     params=params,
                                     resp_type='content',
                                     timeout=timeout)

        @logger
        def list_allowedlist_request(self, type_: str) -> Dict[str, str]:
            return self.http_request(method='GET', url_suffix=f'devicemgmt/emlconfig/policy/allowed_lists/{type_}',
                                     resp_type='json')

        @logger
        def create_allowedlist_request(self, type_: str, entry_value: str, matches: int) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/allowed_lists/{type_}',
                                     params={'operation': 'create'},
                                     json_data={"name": entry_value, "matches": matches},
                                     resp_type='resp')

        @logger
        def update_allowedlist_request(self, type_: str, entry_value: str, matches: int) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/allowed_lists/{type_}/{entry_value}',
                                     json_data={"matches": matches},
                                     resp_type='resp')

        @logger
        def delete_allowedlist_request(self, type_: str, entry_value: str) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/allowed_lists/{type_}/{entry_value}',
                                     params={'operation': 'delete'},
                                     resp_type='resp')

        @logger
        def list_blockedlist_request(self, type_: str) -> Dict[str, str]:
            return self.http_request(method='GET', url_suffix=f'devicemgmt/emlconfig/policy/blocked_lists/{type_}',
                                     resp_type='json')

        @logger
        def create_blockedlist_request(self, type_: str, entry_value: str, matches: int) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/blocked_lists/{type_}',
                                     params={'operation': 'create'},
                                     json_data={'name': entry_value, 'matches': matches},
                                     resp_type='resp')

        @logger
        def update_blockedlist_request(self, type_: str, entry_value: str, matches: int) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/blocked_lists/{type_}/{entry_value}',
                                     json_data={"matches": matches},
                                     resp_type='resp')

        @logger
        def delete_blockedlist_request(self, type_: str, entry_value: str) -> Dict[str, str]:
            return self.http_request(method='POST',
                                     url_suffix=f'devicemgmt/emlconfig/policy/blocked_lists/{type_}/{entry_value}',
                                     params={'operation': 'delete'},
                                     resp_type='resp')


    def to_fe_datetime_converter(time_given: str = 'now') -> str:
        """Generates a string in the FireEye format, e.g: 2015-01-24T16:30:00.000-07:00

        Examples:
            >>> to_fe_datetime_converter('2021-05-14T01:08:04.000-02:00')
            2021-05-14T01:08:04.000-02:00
            >>> to_fe_datetime_converter('now')
            2021-05-23T06:45:16.688+00:00

        Args:
            time_given: the time given, if none given, the default is now.

        Returns:
            The time given in FireEye format.
        """
        date_obj = dateparser.parse(time_given)
        assert date_obj is not None, f'failed parsing {time_given}'
        fe_time = date_obj.strftime(FE_DATE_FORMAT)
        fe_time += f'.{date_obj.strftime("%f")[:3]}'
        if not date_obj.tzinfo:
            given_timezone = '+00:00'
        else:
            given_timezone = f'{date_obj.strftime("%z")[:3]}:{date_obj.strftime("%z")[3:]}'  # converting the timezone
        fe_time += given_timezone
        return fe_time


    def alert_severity_to_dbot_score(severity_str: str):
        severity = severity_str.lower()
        if severity == 'minr':
            return 1
        if severity == 'majr':
            return 2
        if severity == 'crit':
            return 3
        demisto.info(f'FireEye Incident severity: {severity} is not known. Setting as unknown(DBotScore of 0).')
        return 0

    register_module_line('FireEyeApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('FireEye Central Management', 'end', __line__())
  subtype: python3
  type: python
system: true
