category: IT Services
commonfields:
  id: ServiceNow CMDB
  version: -1
configuration:
- display: ServiceNow URL, in the format https://company.service-now.com/
  name: url
  required: true
  type: 0
- display: Username/Client ID
  name: credentials
  required: true
  type: 9
- additionalinfo: Check this box to use OAuth 2.0 authentication. See (?) for more
    information.
  display: Use OAuth Login
  name: use_oauth
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.7.0
    packID: ServiceNow
    packName: ServiceNow
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: ServiceNow CMDB is a service‑centric foundation that proactively analyzes
  service‑impacting changes, identifies issues, and eliminates outages.
detaileddescription: "### Instance Configuration\nThe integration supports two types
  of authorization:\n1. Basic authorization using username and password.\n2. OAuth
  2.0 authorization.\n\n#### OAuth 2.0 Authorization\nTo use OAuth 2.0 authorization
  perform the following steps:\n1. Login to your ServiceNow instance and create an
  endpoint for XSOAR to access your instance. (See [Snow OAuth](https://docs.servicenow.com/bundle/xanadu-platform-security/page/administer/security/concept/c_OAuthApplications.html)
  for more information). \n2. Copy the **Client Id** and **Client Secret** (press
  the lock next to the client secret to reveal it) that were automatically generated
  when creating the endpoint into the **Username** and **Password** fields of the
  instance configuration.\n3. Select the **Use OAuth Login** checkbox and click **Done**.\n4.
  Run the command ***!servicenow-cmdb-oauth-login*** from the XSOAR CLI and fill in
  the username and password of the ServiceNow instance. This step generates and saves
  in the integration context a refresh token to the ServiceNow instance and is required
  only the first time you configure a new instance in the XSOAR platform.\n5. (Optional)
  Test the created instance by running the ***!servicenow-cmdb-oauth-test*** command.\n\n**Notes:**\n1.
  When running the ***!servicenow-cmdb-oauth-login*** command, a refresh token is
  generated and will be used to produce new access tokens after the current access
  token has expired.\n2. Every time the refresh token expires you will have to run
  the ***servicenow-cmdb-oauth-login*** command again. Therefore, we recommend to
  set the **Refresh Token Lifespan** field in the endpoint created in step 1 to a
  long period (can be set to several years). \n3. The grant type used to get an access
  token is `Client credentials`. See the [Snow documentation](https://docs.servicenow.com/bundle/xanadu-platform-security/page/administer/security/concept/c_OAuthApplications.html#d25788e201)
  for more information.\n\n\n### Using Multi Factor Authentication (MFA)\nMFA can
  be used both when using basic authorization and when using OAuth 2.0 authorization,
  however we strongly recommend using OAuth 2.0 when using MFA.\nIf MFA is enabled
  for your user, perform the following steps:\n1. Open the Google Authenticator application
  on your mobile device and make note of the number. The number refreshes every 30
  seconds.\n2. Enter your username and password, and append the One Time Password
  (OTP) that you currently see on your mobile device to your password without any
  extra spaces. For example, if your password is **12345** and the current OTP code
  is **424 058**, enter `12345424058`.\n\n**Notes:**\n1. When using basic authorization,
  you will have to update your password with the current OTP every time the current
  code expires (30 seconds), therefore we recommend using OAuth 2.0 authorization.\n2.
  For using OAuth 2.0 see the instructions above. The OTP code should be appended
  to the password parameter in the ***!servicenow-cmdb-oauth-login*** command.\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/service-now-cmdb)"
display: ServiceNow CMDB
image: data:image/png;base64,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
name: ServiceNow CMDB
script:
  commands:
  - arguments:
    - description: The name of the class to query.
      name: class
      required: true
    - description: An encoded query string used to filter the results. For more information
        about querying in ServiceNow, see https://docs.servicenow.com/bundle/paris-servicenow-platform/page/use/common-ui-elements/reference/r_OpAvailableFiltersQueries.html.
      name: query
    - defaultValue: "50"
      description: 'The maximum number of results returned per page (default: 50).'
      name: limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the query (default: 0).'
      name: offset
    description: Query records for a CMDB class.
    name: servicenow-cmdb-records-list
    outputs:
    - contextPath: ServiceNowCMDB.Class
      description: The name of CMDB table that was queried.
      type: String
    - contextPath: ServiceNowCMDB.Records
      description: A list of all the records that were found in the CMDB table.
      type: Unknown
  - arguments:
    - description: The name of the class to query.
      name: class
      required: true
    - description: The ID of the record that should be queried.
      name: sys_id
      required: true
    - description: A comma-separated list of the fields to return for the queried
        record.
      name: fields
    - defaultValue: "50"
      description: 'The maximum number of relations returned (default: 50).'
      name: relation_limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the relations query (default:
        0).'
      name: relation_offset
    description: Query attributes and relationship information for a specific record.
    name: servicenow-cmdb-record-get-by-id
    outputs:
    - contextPath: ServiceNowCMDB.Record.SysID
      description: The sys_id of the record that was queried.
      type: String
    - contextPath: ServiceNowCMDB.Record.Class
      description: The name of the class from which the record was queried.
      type: String
    - contextPath: ServiceNowCMDB.Record.Attributes
      description: The attributes that were returned in the response for the queried
        record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.OutboundRelations
      description: A list of all the outbound relations of the queried record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.InboundRelations
      description: A list of all the inbound relations of the queried record.
      type: Unknown
  - arguments:
    - description: The name of the class to add the record to.
      name: class
      required: true
    - defaultValue: ServiceNow
      description: 'The discovery source value. You can see all available values from
        the sys_choice table with query GOTOelementLIKEdiscovery_source^name=cmdb_ci.
        (default: "ServiceNow").'
      name: source
    - description: 'A comma-separated list of attributes that should be added to the
        created record. Input format: attribute=value pairs, e.g., "name=test, ram=1024".'
      name: attributes
      required: true
    - description: A comma-separated list of dictionaries. Each dictionary represents
        an inbound relation that should be added to the created record.
      isArray: true
      name: inbound_relations
    - description: A comma-separated list of dictionaries. Each dictionary represents
        an outbound relation that should be added to the created record.
      isArray: true
      name: outbound_relations
    - description: A comma-separated list of fields to return for the created record.
      name: fields
    - defaultValue: "50"
      description: 'The maximum number of relations returned (default: 50).'
      name: relation_limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the relations query (default:
        0).'
      name: relation_offset
    description: Create a record with associated relations and attributes.
    name: servicenow-cmdb-record-create
    outputs:
    - contextPath: ServiceNowCMDB.Record.SysID
      description: The sys_id of the record that was created.
      type: String
    - contextPath: ServiceNowCMDB.Record.Class
      description: The name of the class from which the record was created.
      type: String
    - contextPath: ServiceNowCMDB.Record.Attributes
      description: The attributes that were returned in the response for the created
        record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.OutboundRelations
      description: A list of all the outbound relations of the created record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.InboundRelations
      description: A list of all the inbound relations of the created record.
      type: Unknown
  - arguments:
    - description: The class name of the record that should be updated.
      name: class
      required: true
    - description: The ID of the record that should be updated.
      name: sys_id
      required: true
    - defaultValue: ServiceNow
      description: 'The discovery source value. You can see all available values from
        sys_choice table with query GOTOelementLIKEdiscovery_source^name=cmdb_ci.
        (default: "ServiceNow").'
      name: source
    - description: 'A comma-separated list of the attributes that should be updated
        in the record. Input format: attribute=value pairs, e.g., "name=test,ram=1024".'
      name: attributes
      required: true
    - description: A comma-separated list of the fields to return for the updated
        record.
      name: fields
    - defaultValue: "50"
      description: 'The maximum number of relations returned (default: 50).'
      name: relation_limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the relations query (default:
        0).'
      name: relation_offset
    description: Update a record with the given attributes.
    name: servicenow-cmdb-record-update
    outputs:
    - contextPath: ServiceNowCMDB.Record.SysID
      description: The sys_id of the record that was updated.
      type: String
    - contextPath: ServiceNowCMDB.Record.Class
      description: The class name of the updated record.
      type: String
    - contextPath: ServiceNowCMDB.Record.Attributes
      description: The attributes that were returned in the response for the updated
        record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.OutboundRelations
      description: A list of all the outbound relations of the updated record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.InboundRelations
      description: A list of all the inbound relations of the updated record.
      type: Unknown
  - arguments:
    - description: The class name of the record.
      name: class
      required: true
    - description: The ID of the record to which the relations should be added.
      name: sys_id
      required: true
    - defaultValue: ServiceNow
      description: 'The discovery source value. You can see all available values from
        sys_choice table with query GOTOelementLIKEdiscovery_source^name=cmdb_ci.
        (default: "ServiceNow").'
      name: source
    - description: A comma-separated list of dictionaries. Each dictionary represents
        an inbound relation that should be added to the created record.
      isArray: true
      name: inbound_relations
    - description: A comma-separated list of dictionaries. Each dictionary represents
        an outbound relation that should be added to the created record.
      isArray: true
      name: outbound_relations
    - description: A comma-separated list of the fields to return for the record.
      name: fields
    - defaultValue: "50"
      description: 'The maximum number of relations returned (default: 50).'
      name: relation_limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the relations query (default:
        0).'
      name: relation_offset
    description: Add a new relation to an existing record.
    name: servicenow-cmdb-record-add-relations
    outputs:
    - contextPath: ServiceNowCMDB.Record.SysID
      description: The sys_id of the record that was updated.
      type: String
    - contextPath: ServiceNowCMDB.Record.Class
      description: The class name of the record.
      type: String
    - contextPath: ServiceNowCMDB.Record.Attributes
      description: The attributes that were returned in the response for the updated
        record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.OutboundRelations
      description: A list of all the outbound relations of the record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.InboundRelations
      description: A list of all the inbound relations of the record.
      type: Unknown
  - arguments:
    - description: The class name of the record.
      name: class
      required: true
    - description: The ID of the record from which a relation should be deleted.
      name: sys_id
      required: true
    - description: The ID of the relation that should be deleted.
      name: relation_sys_id
      required: true
    - description: A comma-separated list of the fields to return for the record.
      name: fields
    - defaultValue: "50"
      description: 'The maximum number of relations returned (default: 50).'
      name: relation_limit
    - defaultValue: "0"
      description: 'The number of records to exclude from the relations query (default:
        0).'
      name: relation_offset
    description: Delete a relation of an existing record.
    name: servicenow-cmdb-record-delete-relations
    outputs:
    - contextPath: ServiceNowCMDB.Record.SysID
      description: The sys_id of the record that was updated.
      type: String
    - contextPath: ServiceNowCMDB.Record.Class
      description: The class name of the record.
      type: String
    - contextPath: ServiceNowCMDB.Record.Attributes
      description: The attributes that were returned in the response for the updated
        record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.OutboundRelations
      description: A list of all the outbound relations of the record.
      type: Unknown
    - contextPath: ServiceNowCMDB.Record.InboundRelations
      description: A list of all the inbound relations of the record.
      type: Unknown
  - arguments:
    - description: The username that should be used for login.
      name: username
      required: true
      secret: true
    - description: The password that should be used for login.
      name: password
      required: true
      secret: true
    description: This function should be used once before running any command when
      using OAuth authorization.
    name: servicenow-cmdb-oauth-login
  - arguments: []
    description: Test the instance configuration when using OAuth authorization.
    name: servicenow-cmdb-oauth-test
  dockerimage: demisto/python3:3.11.10.113941
  runonce: false
  script: |
    register_module_line('ServiceNow CMDB', 'start', __line__())
    demisto.debug('pack name = ServiceNow, pack version = 2.7.0')




    '''IMPORTS'''
    import urllib3
    from typing import Any
    from _collections import defaultdict
    import ast
    from operator import itemgetter

    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' CONSTANTS '''
    API_VERSION = '/api/now/cmdb/instance/'
    CREAT_RECORD_DATA_FIELDS = ['attributes', 'inbound_relations', 'outbound_relations', 'source']
    UPDATE_RECORD_DATA_FIELDS = ['attributes', 'source']
    ADD_RELATION_DATA_FIELDS = ['inbound_relations', 'outbound_relations', 'source']
    FIELD_TO_OUTPUT = {
        'inbound_relations': 'Inbound Relations',
        'outbound_relations': 'Outbound Relations'
    }


    class Client:
        """Client class to interact with the service API

        This Client implements API calls, and does not contain any Demisto logic.
        Should only do requests and return data.
        It inherits from BaseClient defined in CommonServer Python.
        Most calls use _http_request() that handles proxy, SSL verification, etc.
        """

        def __init__(self, credentials: dict, use_oauth: bool = False, client_id: str = '', client_secret: str = '',
                     url: str = '', verify: bool = False, proxy: bool = False):
            """
            Args:
                - credentials: the username and password given by the user.
                - client_id: the client id of the application of the user.
                - client_secret - the client secret of the application of the user.
                - url: the instance url of the user, i.e: https://<instance>.service-now.com.
                       NOTE - url should be given without an API specific suffix as it is also used for the OAuth process.
                - insecure: Whether the request should verify the SSL certificate.
                - proxy: Whether to run the integration using the system proxy.
                - headers: The request headers, for example: {'Accept`: `application/json`}. Can be None.
                - use_oauth: a flag indicating whether the user wants to use OAuth 2.0 or basic authorization.
            """
            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            self.use_oauth = use_oauth
            self.snow_client: ServiceNowClient = ServiceNowClient(credentials=credentials, use_oauth=use_oauth,
                                                                  client_id=client_id, client_secret=client_secret,
                                                                  url=url, verify=verify, proxy=proxy, headers=headers)

        def records_list(self, class_name, params=None):
            return self.snow_client.http_request(method='GET', url_suffix=f'{API_VERSION}{class_name}', params=params)

        def get_record(self, class_name, sys_id, params=None):
            url_suffix = f'{API_VERSION}{class_name}/{sys_id}'
            return self.snow_client.http_request(method='GET', url_suffix=url_suffix, params=params)

        def create_record(self, class_name, data, params=None):
            return self.snow_client.http_request(method='POST', url_suffix=f'{API_VERSION}{class_name}', params=params, data=data)

        def update_record(self, class_name, sys_id, data, params=None):
            url_suffix = f'{API_VERSION}{class_name}/{sys_id}'
            return self.snow_client.http_request(method='PATCH', url_suffix=url_suffix, params=params, data=data)

        def add_relation(self, class_name, sys_id, data, params=None):
            url_suffix = f'{API_VERSION}{class_name}/{sys_id}/relation'
            return self.snow_client.http_request(method='POST', url_suffix=url_suffix, params=params, data=data)

        def delete_relation(self, class_name, sys_id, rel_sys_id, params=None):
            url_suffix = f'{API_VERSION}{class_name}/{sys_id}/relation/{rel_sys_id}'
            return self.snow_client.http_request(method='DELETE', url_suffix=url_suffix, params=params)


    ''' HELPER FUNCTIONS '''


    def create_request_data(data_fields: list, args: dict) -> dict:
        """
        This function converts the input given by the user when creating a new record to a data dict that should be passed
        in the http request.

        Args:
            data_fields: A list with the fields that should be added to the data.
            args: The arguments that were filled by the user.

        Returns:
            A dictionary representing the data parameter that should be sent in the http request.
        """
        data = {}
        for field in data_fields:
            if field == 'source':
                data[field] = args.get(field)
            elif field == 'attributes':  # 'attributes' input should be of the form key1=value1,key2=value2...
                val = args.get(field)
                if val:
                    try:
                        attributes_dict = {}
                        attributes_input = val.split(',')
                        for attribute in attributes_input:
                            pair = attribute.split('=')
                            attributes_dict[pair[0]] = pair[1]
                        data[field] = attributes_dict
                    except Exception:
                        raise Exception('Illegal input. Input format should be "key=value". Multiple values can be filled, '
                                        'separated by a comma.')
            else:  # other fields should be converted to dict/list
                val = args.get(field)
                if val:
                    try:
                        data[field] = ast.literal_eval(val)
                    except Exception:
                        raise Exception('Illegal input. Please see the argument description for the correct input format.')
        return data


    def create_record_context(class_name: str, sys_id: str, result: dict) -> dict:
        """
        Create the context output for commands that operate on a single record.

        Args:
            class_name: The class name of the record used.
            sys_id: The id of the record.
            result: The raw response from the http request.

        Return:
            A dictionary representing the context output for the record.
        """
        context = {
            'ServiceNowCMDB.Record(val.ID===obj.ID)': {
                'Class': class_name,
                'SysID': sys_id,
                'Attributes': result.get('attributes', {}),
                'InboundRelations': result.get('inbound_relations', []),
                'OutboundRelations': result.get('outbound_relations', []),
            }
        }
        return context


    def create_human_readable(title: str, result: dict, fields: str) -> str:
        """
        Create the human readable output for commands.

        Args:
            title: The title of the human readable output.
            result: The raw response from the http request consisting of the attributes, inbound_relations and
                    outbound_relations fields.
            fields: A string representing all the fields of the record the client specified that should be returned. If no
            fields were specified, only the record name and sys_id will be displayed in the war room.

        Return:
            A string representing the markdown output that should be displayed in the war room.
        """
        md = f'{title}\n'
        attributes_outputs = {}
        if fields:
            for field in fields.split(','):
                if result.get('attributes', {}).get(field):
                    attributes_outputs[string_to_context_key(field)] = result.get('attributes', {}).get(field)
        else:
            attributes_outputs = {
                'SysID': result.get('attributes', {}).get('sys_id'),
                'Name': result.get('attributes', {}).get('name')
            }

        md += tableToMarkdown('Attributes', t=attributes_outputs, removeNull=True)

        for relation_type in ['inbound_relations', 'outbound_relations']:
            relations = result.get(relation_type)
            if relations:
                relation_output = {
                    'SysID': list(map(itemgetter('sys_id'), relations)),
                    'Target Display Value': list(
                        map(itemgetter('display_value'), list(map(itemgetter('target'), result.get(relation_type))))),  # type: ignore
                    'Type Display Value': list(
                        map(itemgetter('display_value'), list(map(itemgetter('type'), result.get(relation_type))))),  # type: ignore
                }
                md += f' {tableToMarkdown(FIELD_TO_OUTPUT.get(relation_type), t=relation_output)}'
        return md


    ''' COMMAND FUNCTIONS '''


    def records_list_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Query a CMDB table using the class name to receive all records in the class.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class')
        params = {}
        if args.get('query'):
            params['sysparm_query'] = args.get('query')
        if args.get('limit'):
            params['sysparm_limit'] = args.get('limit')
        if args.get('offset'):
            params['sysparm_offset'] = args.get('offset')

        outputs = {
            'Class': class_name
        }

        response = client.records_list(class_name=class_name, params=params)
        result = response.get('result', {})
        if result:
            outputs['Records'] = result
            human_readable = tableToMarkdown(f'Found {len(result)} records for class {class_name}:', t=result)
        else:
            human_readable = f'Found no records for class {class_name}.'
        context['ServiceNowCMDB(val.ID===obj.ID)'] = outputs

        return human_readable, context, response


    def get_record_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Query attributes and relationship information for a specific record.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class')
        sys_id = args.get('sys_id')
        params: dict = {}
        if args.get('fields'):
            params['sysparm_fields'] = args.get('fields')
            # Verify that sys_id and name were added so they can be used in the output of the command:
            if 'sys_id' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',sys_id'
            if 'name' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',name'
        if args.get('relation_limit'):
            params['sysparm_relation_limit'] = args.get('relation_limit')
        if args.get('relation_offset'):
            params['sysparm_relation_offset'] = args.get('relation_offset')

        response = client.get_record(class_name=class_name, sys_id=sys_id, params=params)
        result = response.get('result')
        if result:
            context['ServiceNowCMDB.Record(val.ID===obj.ID)'] = {
                'Class': class_name,
                'SysID': sys_id,
                'Attributes': result.get('attributes', {}),
                'InboundRelations': result.get('inbound_relations', []),
                'OutboundRelations': result.get('outbound_relations', []),
            }
            hr_title = f'### Found the following attributes and relations for record {sys_id}:'
            human_readable = create_human_readable(hr_title, result, params.get('sysparm_fields', ''))
        else:
            context['ServiceNowCMDB.Record(val.ID===obj.ID)'] = {
                'Class': class_name,
                'SysID': sys_id
            }
            human_readable = f'Found no attributes and relations for record {sys_id}.'

        return human_readable, context, response


    def create_record_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Create a record with associated relations.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class', '')
        params: dict = {}
        if args.get('fields'):
            params['sysparm_fields'] = args.get('fields')
            # Verify that sys_id and name were added so they can be used in the output of the command:
            if 'sys_id' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',sys_id'
            if 'name' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',name'
        if args.get('relation_limit'):
            params['sysparm_relation_limit'] = args.get('relation_limit')
        if args.get('relation_offset'):
            params['sysparm_relation_offset'] = args.get('relation_offset')

        data = create_request_data(CREAT_RECORD_DATA_FIELDS, args)

        response = client.create_record(class_name=class_name, params=params, data=str(data))
        result = response.get('result')
        if result:
            sys_id = result.get('attributes', {}).get('sys_id')
            context = create_record_context(class_name, sys_id, result)
            hr_title = f'### Record {sys_id} was created successfully.'
            human_readable = create_human_readable(hr_title, result, params.get('sysparm_fields', ''))
        else:
            human_readable = 'Failed to create a new record.'

        return human_readable, context, response


    def update_record_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Update a record with attributes given by the user.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class', '')
        sys_id = args.get('sys_id', '')
        params: dict = {}
        if args.get('fields'):
            params['sysparm_fields'] = args.get('fields')
            # Verify that sys_id and name were added so they can be used in the output of the command:
            if 'sys_id' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',sys_id'
            if 'name' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',name'
        if args.get('relation_limit'):
            params['sysparm_relation_limit'] = args.get('relation_limit')
        if args.get('relation_offset'):
            params['sysparm_relation_offset'] = args.get('relation_offset')

        data = create_request_data(UPDATE_RECORD_DATA_FIELDS, args)

        response = client.update_record(class_name=class_name, sys_id=sys_id, data=str(data), params=params)
        result = response.get('result')
        if result:
            context = create_record_context(class_name, sys_id, result)
            hr_title = f'### Updated record {sys_id} successfully.'
            human_readable = create_human_readable(hr_title, result, params.get('sysparm_fields', ''))
        else:
            human_readable = f'Failed to update record {sys_id}.'

        return human_readable, context, response


    def add_relation_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Add new relations to an existing record.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class', '')
        sys_id = args.get('sys_id', '')
        params: dict = {}
        if args.get('fields'):
            params['sysparm_fields'] = args.get('fields')
            # Verify that sys_id and name were added so they can be used in the output of the command:
            if 'sys_id' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',sys_id'
            if 'name' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',name'
        if args.get('relation_limit'):
            params['sysparm_relation_limit'] = args.get('relation_limit')
        if args.get('relation_offset'):
            params['sysparm_relation_offset'] = args.get('relation_offset')

        data = create_request_data(ADD_RELATION_DATA_FIELDS, args)

        response = client.add_relation(class_name=class_name, sys_id=sys_id, data=str(data), params=params)
        result = response.get('result')
        if result:
            context = create_record_context(class_name, sys_id, result)
            hr_title = f'### New relations were added to {sys_id} record successfully.'
            human_readable = create_human_readable(hr_title, result, params.get('sysparm_fields', ''))
        else:
            human_readable = f'Failed to add new relations to record {sys_id}.'

        return human_readable, context, response


    def delete_relation_command(client: Client, args: dict) -> tuple[str, dict, Any]:
        """
        Delete relations for an existing record.

        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        context: dict = defaultdict(list)
        class_name = args.get('class', '')
        sys_id = args.get('sys_id', '')
        rel_sys_id = args.get('relation_sys_id', '')
        params: dict = {}
        if args.get('fields'):
            params['sysparm_fields'] = args.get('fields')
            # Verify that sys_id and name were added so they can be used in the output of the command:
            if 'sys_id' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',sys_id'
            if 'name' not in params.get('sysparm_fields', ''):
                params['sysparm_fields'] += ',name'
        if args.get('relation_limit'):
            params['sysparm_relation_limit'] = args.get('relation_limit')
        if args.get('relation_offset'):
            params['sysparm_relation_offset'] = args.get('relation_offset')

        response = client.delete_relation(class_name=class_name, sys_id=sys_id, rel_sys_id=rel_sys_id, params=params)
        result = response.get('result')
        if result:
            context = create_record_context(class_name, sys_id, result)
            hr_title = f'### Deleted relation {rel_sys_id} successfully from {sys_id} record.'
            human_readable = create_human_readable(hr_title, result, params.get('sysparm_fields', ''))
        else:
            human_readable = f'Failed to delete relation {rel_sys_id} from record {sys_id}.'

        return human_readable, context, response


    def test_module(client: Client) -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type client: ``Client``
        :param Client: ServiceNow CMDB client to use

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """
        # Notify the user that test button can't be used when using OAuth 2.0:
        if client.use_oauth:
            return_error('Test button cannot be used when using OAuth 2.0. Please use the !servicenow-cmdb-oauth-login '
                         'command followed by the !servicenow-cmdb-oauth-test command to test the instance.')

        try:
            client.records_list(class_name='cmdb_ci_linux_server')
        except Exception as e:
            raise e
        return 'ok'


    def oauth_test_module(client: Client, *_) -> tuple[str, dict[Any, Any], dict[Any, Any]]:
        """
        Test the instance configurations when using OAuth authorization.
        """
        if not client.use_oauth:
            return_error('!servicenow-cmdb-oauth-test command should be used only when using OAuth 2.0 authorization.\n '
                         'Please select the `Use OAuth Login` checkbox in the instance configuration before running this '
                         'command.')
        try:
            client.records_list(class_name='cmdb_ci_linux_server')
        except Exception as e:
            raise e
        hr = '### Instance Configured Successfully.\n'
        return hr, {}, {}


    def login_command(client: Client, args: dict[str, Any]) -> tuple[str, dict[Any, Any], dict[Any, Any]]:
        """
        Login the user using OAuth authorization
        Args:
            client: Client object with request.
            args: Usually demisto.args()

        Returns:
            Demisto Outputs.
        """
        # Verify that the user selected the `Use OAuth Login` checkbox:
        if not client.use_oauth:
            return_error('!servicenow-cmdb-oauth-login command can be used only when using OAuth 2.0 authorization.\n '
                         'Please select the `Use OAuth Login` checkbox in the instance configuration before running this '
                         'command.')

        username = args.get('username', '')
        password = args.get('password', '')
        try:
            client.snow_client.login(username, password)
            hr = '### Logged in successfully.\n A refresh token was saved to the integration context and will be ' \
                 'used to generate a new access token once the current one expires.'
        except Exception as e:
            return_error(f'Failed to login. Please verify that the provided username and password are correct, and that you'
                         f' entered the correct client id and client secret in the instance configuration (see ? for'
                         f'correct usage when using OAuth).\n\n{e}')
        return hr, {}, {}


    ''' MAIN FUNCTION '''


    def main() -> None:
        """main function, parses params and runs command functions
        """
        params = demisto.params()

        url = params.get('url', '')
        verify = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        client_id = client_secret = ''
        credentials = params.get('credentials', {})
        use_oauth = params.get('use_oauth', False)

        if use_oauth:
            client_id = credentials.get('identifier')
            client_secret = credentials.get('password')

        client = Client(credentials=credentials, use_oauth=use_oauth, client_id=client_id,
                        client_secret=client_secret, url=url, verify=verify, proxy=proxy)

        commands = {
            'servicenow-cmdb-oauth-login': login_command,
            'servicenow-cmdb-oauth-test': oauth_test_module,
            'servicenow-cmdb-records-list': records_list_command,
            'servicenow-cmdb-record-get-by-id': get_record_command,
            'servicenow-cmdb-record-create': create_record_command,
            'servicenow-cmdb-record-update': update_record_command,
            'servicenow-cmdb-record-add-relations': add_relation_command,
            'servicenow-cmdb-record-delete-relations': delete_relation_command
        }

        command = demisto.command()

        demisto.debug(f'Command being called is {command}')
        try:
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                result = test_module(client)
                return_results(result)
            elif command in commands:
                return_outputs(*commands[command](client, demisto.args()))  # type: ignore
            else:
                return_error('Command not found.')

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')



    ### GENERATED CODE ###: from ServiceNowApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('ServiceNowApiModule', 'start', __line__(), wrapper=-3)




    OAUTH_URL = '/oauth_token.do'


    class ServiceNowClient(BaseClient):

        def __init__(self, credentials: dict, use_oauth: bool = False, client_id: str = '', client_secret: str = '',
                     url: str = '', verify: bool = False, proxy: bool = False, headers: dict = None):
            """
            ServiceNow Client class. The class can use either basic authorization with username and password, or OAuth2.
            Args:
                - credentials: the username and password given by the user.
                - client_id: the client id of the application of the user.
                - client_secret - the client secret of the application of the user.
                - url: the instance url of the user, i.e: https://<instance>.service-now.com.
                       NOTE - url should be given without an API specific suffix as it is also used for the OAuth process.
                - verify: Whether the request should verify the SSL certificate.
                - proxy: Whether to run the integration using the system proxy.
                - headers: The request headers, for example: {'Accept`: `application/json`}. Can be None.
                - use_oauth: a flag indicating whether the user wants to use OAuth 2.0 or basic authorization.
            """
            self.auth = None
            self.use_oauth = use_oauth
            if self.use_oauth:  # if user selected the `Use OAuth` box use OAuth authorization, else use basic authorization
                self.client_id = client_id
                self.client_secret = client_secret
            else:
                self.username = credentials.get('identifier')
                self.password = credentials.get('password')
                self.auth = (self.username, self.password)

            if '@' in client_id:  # for use in OAuth test-playbook
                self.client_id, refresh_token = client_id.split('@')
                set_integration_context({'refresh_token': refresh_token})

            self.base_url = url
            super().__init__(base_url=self.base_url, verify=verify, proxy=proxy, headers=headers, auth=self.auth)  # type
            # : ignore[misc]

        def http_request(self, method, url_suffix, full_url=None, headers=None, json_data=None, params=None, data=None,
                         files=None, return_empty_response=False, auth=None, timeout=None):
            ok_codes = (200, 201, 401)  # includes responses that are ok (200) and error responses that should be
            # handled by the client and not in the BaseClient
            try:
                if self.use_oauth:  # add a valid access token to the headers when using OAuth
                    access_token = self.get_access_token()
                    self._headers.update({
                        'Authorization': 'Bearer ' + access_token
                    })
                res = super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, resp_type='response',
                                            headers=headers, json_data=json_data, params=params, data=data, files=files,
                                            ok_codes=ok_codes, return_empty_response=return_empty_response, auth=auth,
                                            timeout=timeout)
                if res.status_code in [200, 201]:
                    try:
                        return res.json()
                    except ValueError as exception:
                        raise DemistoException('Failed to parse json object from response: {}'
                                               .format(res.content), exception)

                if res.status_code in [401]:
                    if self.use_oauth:
                        if demisto.getIntegrationContext().get('expiry_time', 0) <= date_to_timestamp(datetime.now()):
                            access_token = self.get_access_token()
                            self._headers.update({
                                'Authorization': 'Bearer ' + access_token
                            })
                            return self.http_request(method, url_suffix, full_url=full_url, params=params)
                        try:
                            err_msg = f'Unauthorized request: \n{str(res.json())}'
                        except ValueError:
                            err_msg = f'Unauthorized request: \n{str(res)}'
                        raise DemistoException(err_msg)
                    else:
                        raise Exception(f'Authorization failed. Please verify that the username and password are correct.'
                                        f'\n{res}')

            except Exception as e:
                if self._verify and 'SSL Certificate Verification Failed' in e.args[0]:
                    return_error('SSL Certificate Verification Failed - try selecting \'Trust any certificate\' '
                                 'checkbox in the integration configuration.')
                raise DemistoException(e.args[0])

        def login(self, username: str, password: str):
            """
            Generate a refresh token using the given client credentials and save it in the integration context.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'username': username,
                'password': password,
                'grant_type': 'password'
            }
            try:
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
                res = super()._http_request(method='POST', url_suffix=OAUTH_URL, resp_type='response', headers=headers,
                                            data=data)
                try:
                    res = res.json()
                except ValueError as exception:
                    raise DemistoException('Failed to parse json object from response: {}'.format(res.content), exception)
                if 'error' in res:
                    return_error(
                        f'Error occurred while creating an access token. Please check the Client ID, Client Secret '
                        f'and that the given username and password are correct.\n{res}')
                if res.get('refresh_token'):
                    refresh_token = {
                        'refresh_token': res.get('refresh_token')
                    }
                    set_integration_context(refresh_token)
            except Exception as e:
                return_error(f'Login failed. Please check the instance configuration and the given username and password.\n'
                             f'{e.args[0]}')

        def get_access_token(self):
            """
            Get an access token that was previously created if it is still valid, else, generate a new access token from
            the client id, client secret and refresh token.
            """
            ok_codes = (200, 201, 401)
            previous_token = get_integration_context()

            # Check if there is an existing valid access token
            if previous_token.get('access_token') and previous_token.get('expiry_time') > date_to_timestamp(datetime.now()):
                return previous_token.get('access_token')
            else:
                data = {'client_id': self.client_id,
                        'client_secret': self.client_secret}

                # Check if a refresh token exists. If not, raise an exception indicating to call the login function first.
                if previous_token.get('refresh_token'):
                    data['refresh_token'] = previous_token.get('refresh_token')
                    data['grant_type'] = 'refresh_token'
                else:
                    raise Exception('Could not create an access token. User might be not logged in. Try running the'
                                    ' oauth-login command first.')

                try:
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                    res = super()._http_request(method='POST', url_suffix=OAUTH_URL, resp_type='response', headers=headers,
                                                data=data, ok_codes=ok_codes)
                    try:
                        res = res.json()
                    except ValueError as exception:
                        raise DemistoException('Failed to parse json object from response: {}'.format(res.content),
                                               exception)
                    if 'error' in res:
                        return_error(
                            f'Error occurred while creating an access token. Please check the Client ID, Client Secret '
                            f'and try to run again the login command to generate a new refresh token as it '
                            f'might have expired.\n{res}')
                    if res.get('access_token'):
                        expiry_time = date_to_timestamp(datetime.now(), date_format='%Y-%m-%dT%H:%M:%S')
                        expiry_time += res.get('expires_in', 0) * 1000 - 10
                        new_token = {
                            'access_token': res.get('access_token'),
                            'refresh_token': res.get('refresh_token'),
                            'expiry_time': expiry_time
                        }
                        set_integration_context(new_token)
                        return res.get('access_token')
                except Exception as e:
                    return_error(f'Error occurred while creating an access token. Please check the instance configuration.'
                                 f'\n\n{e.args[0]}')

    register_module_line('ServiceNowApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###


    ''' ENTRY POINT '''
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('ServiceNow CMDB', 'end', __line__())
  subtype: python3
  type: python
system: true
