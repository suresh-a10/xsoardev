args:
- description: CSV list of entry ids for the files to zip.
  isArray: true
  name: entryID
  required: true
- description: 'Name of the output file, for example: zipName="test" would result
    in output file "test.gz"'
  name: GzipName
- description: 'Used to create a password protected gzip file. Example: password="abcd"'
  name: password
comment: GZip a file and upload to war room
commonfields:
  id: f54a5b78-e071-459e-885e-f2b713f44053
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/py3-tools:0.0.1.30715
enabled: true
engineinfo: {}
mainengineinfo: {}
name: GZipFile_Custom
outputs:
- contextPath: ZipFile.ZippedFile
  description: The zipped file
  type: string
- contextPath: File.Name
  description: The full file name (including file extension).
  type: String
- contextPath: File.EntryID
  description: The ID for locating the file in the War Room.
  type: String
- contextPath: File.Size
  description: The size of the file in bytes.
  type: Number
- contextPath: File.MD5
  description: The MD5 hash of the file.
  type: String
- contextPath: File.SHA1
  description: The SHA1 hash of the file.
  type: String
- contextPath: File.SHA256
  description: The SHA1 hash of the file.
  type: String
- contextPath: File.SHA512
  description: The SHA512 hash of the file.
  type: String
- contextPath: File.SSDeep
  description: The ssdeep hash of the file (same as displayed in file entries).
  type: String
- contextPath: File.Extension
  description: 'The file extension, for example: ''xls''.'
  type: String
- contextPath: File.Type
  description: The file type, as determined by libmagic (same as displayed in file
    entries).
  type: String
pswd: ""
runas: DBotWeakRole
runonce: false
script: |2+




  import re
  import shutil
  #import zipfile
  import gzip
  import io
  #import pyminizip
  from os.path import isfile

  ESCAPE_CHARACTERS = r'[/\<>"|?*]'

  """
  def escape_illegal_characters_in_file_name(file_name: str) -> str:
      if file_name:
          file_name = re.sub(ESCAPE_CHARACTERS, '-', file_name)
          file_name = re.sub(r'-+', '-', file_name)  # prevent more than one consecutive dash in the file name

      return file_name
  """

  def main():
      #try:  # in order to support compression of the file
          #compression = zipfile.ZIP_DEFLATED
      #except Exception:
          #compression = zipfile.ZIP_STORED
      #try:
      args = demisto.args()
      GzipName = None
      password = None
      fileEntryID = args.get('entryID')

      if 'GzipName' in args:
          #GzipName = escape_illegal_characters_in_file_name(demisto.args().get('GzipName')) + '.gz'
          GzipName = demisto.args().get('GzipName') + '.gz'

      if not fileEntryID:
          raise DemistoException('You must set an entryID when using the gzip script')

      entry_ids = argToList(fileEntryID)
      file_names = list()
      for entry_id in entry_ids:
          res = demisto.executeCommand('getFilePath', {'id': entry_id})

          if is_error(res):
              raise DemistoException(
                  'Failed to get the file path for entry: ' + entry_id + ' the error message was ' + get_error(res))

          filePath = res[0]['Contents']['path']
          fileCurrentName = res[0]['Contents']['name']
          #fileCurrentName = escape_illegal_characters_in_file_name(res[0]['Contents']['name'])

          if not isfile(filePath):  # in case that the user will send a directory
              raise DemistoException(entry_id + ' is not a file. Please recheck your input.')

          # Handling duplicate names.
          if fileCurrentName in file_names:
              name, ext = os.path.splitext(fileCurrentName)
              print(name)
              i = 0
              while fileCurrentName in file_names:
                  i += 1
                  fileCurrentName = f'{name} {i}{ext}'
          # copying the file to current location
          shutil.copy(filePath, fileCurrentName)
          file_names.append(fileCurrentName)

      print(file_names)


      if not GzipName:
          # Preserving old behaviour. If only one file provided - will use its name .zip
          # Else will use a uuid.
          if len(file_names) == 1:
              fileCurrentName = file_names[0]
          else:
              fileCurrentName = demisto.uniqueFile()
          GzipName = fileCurrentName + '.gz'

      gzf = gzip.open(GzipName,mode='wb')
      with io.TextIOWrapper(gzf, encoding='utf-8') as encode:
          try:
              for file_name in file_names:
                  f_in = open(file_name,'r')
                  data = f_in.read()
                  encode.write(data)

          finally:
              gzf.close()


      with gzip.open(GzipName,'rb') as f:
          with io.TextIOWrapper(f, encoding='utf-8') as decode:
              file_content = decode.read()

      demisto.results(fileResult(GzipName, file_content))

      human_readable = tableToMarkdown('GZipped Files',[{'original name': file_names, 'Gzipped file': GzipName}])
      context: Dict[str, Any] = {
          'GZippedFiles': GzipName,
          'GZipFile.GZippedFile': GzipName
      }
      for entry_id in entry_ids:
          context[f'File(val.EntryID == {entry_id}).gzipped'] = True
      raw_response = {'GZippedFiles': GzipName}

      return_outputs(human_readable, context, raw_response)

      #except Exception as exc:
          #return_error(exc)

  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()


scripttarget: 0
subtype: python3
tags:
- Utility
- file
type: python
