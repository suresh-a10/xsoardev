category: Email
commonfields:
  id: Proofpoint Threat Protection
  version: -1
configuration:
- defaultvalue: https://threatprotection-api.proofpoint.com/api/v1
  display: Server URL
  name: url
  required: true
  section: Connect
  type: 0
- display: Client ID
  displaypassword: Client Secret
  name: credentials
  required: true
  section: Connect
  type: 9
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Cluster ID
  name: cluster_id
  required: true
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.10.0
    itemVersion: 1.0.0
    packID: ProofpointThreatProtection
    packName: Proofpoint Threat Protection
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Threat Protection APIs are REST APIs that allow Proofpoint On Demand
  customers to retrieve, add, update or delete certain PoD configurations.
detaileddescription: "## Proofpoint Threat Protection\n\n### Proofpoint Threat Protection
  Integration Setup\n\nTo set up the Proofpoint Threat Protection API Cortex XSOAR
  integration, a Threat Protection API Key and its associated secret must be configured,
  along with the associated Proofpoint clusterID. ([See API Key Management](https://help.proofpoint.com/Admin_Portal/Settings/API_Key_Management))
  for more information regarding Proofpoint Threat Protection API key generation and
  management.\n\n#### To Create a New Threat Protection API Key\n\n1. From within
  the Proofpoint Admin Portal, navigate to the API Key Management section.\n2. Click
  **+Create New**. The Create New Threat Protection API Key dialog box for the cluster
  appears.\n3. Add a descriptive name for the key. \n4. Click **Generate Key** to
  create the key and secret.\n5. The Create New Threat Protection API Key dialog box
  displays the key and secret for the currently-selected cluster. Click the page icon
  next to each cluster to copy the API key and Secret to the clipboard and store them
  in a safe place. The Secret will not be visible once you close this dialog box.
  **You will need the key and secret to obtain the authentication token for the API
  service**.\n\n#### To Manage Previously Generated Threat Protection API Keys\n\n1.
  In the Proofpoint Admin Portal, navigate to the API Key Management section.\n2.
  For each API key previously generated there is an ellipsis providing two choices
  of action: **Renew** and **Revoke**. Select the action as needed.\n  - **Renew**
  will extend the key expiration for one more year.\n  - **Revoke** will permanently
  remove the key and it cannot be restored.\n\n#### Additional Notes regarding Threat
  Protection API Keys\n\n- Your deployment must be running release 8.20.X or greater,
  and have cloud-based configuration management enabled.\n- Threat Protection API
  will honor the key and secret for a 7-day grace period when it expires to give you
  a chance to **Renew** it before permanently expiring it.\n- Creating keys and revoking
  keys are logged as events in the **Audit Logs**.\n\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/proofpoint-threat-protection)"
display: Proofpoint Threat Protection
image: data:image/png;base64,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
name: Proofpoint Threat Protection
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: A boolean argument to designate whether to send back all the list
        results. This argument takes precedence over the limit argument when set to
        true. Default is False.
      name: all_results
      predefined:
      - "True"
      - "False"
    - description: An integar argument to designate the amount of entries to return
        from the list results. Defualt is 25. Maximum is 100.
      name: limit
    description: Get entries from the Organizational Block List.
    name: proofpoint-tp-blocklist-list
    outputs:
    - contextPath: ProofpointThreatProtection.Blocklist
      description: A list of entries in the blocklist.
  - arguments:
    - auto: PREDEFINED
      description: Supported attributes for the Organizational Block List.
      name: attribute
      predefined:
      - $from
      - $hfrom
      - $ip
      - $host
      - $helo
      - $rcpt
      required: true
    - auto: PREDEFINED
      description: Supported operators for the Organizational Block List.
      name: operator
      predefined:
      - equal
      - not_equal
      - contain
      - not_contain
      required: true
    - description: The entry that is to be added to the Organizational Block List.
      name: value
      required: true
    - description: An optional short comment about the added entry (max 150 chars).
      name: comment
    description: Add an entry to the Organizational Block List.
    name: proofpoint-tp-blocklist-add-entry
    outputs:
    - contextPath: ProofpointThreatProtection.Blocklist
      description: Standard HTTP response with status code 200.
  - arguments:
    - auto: PREDEFINED
      description: Supported attributes for the Organizational Block List.
      name: attribute
      predefined:
      - $from
      - $hfrom
      - $ip
      - $host
      - $helo
      - $rcpt
      required: true
    - auto: PREDEFINED
      description: Supported operators for the Organizational Block List.
      name: operator
      predefined:
      - equal
      - not_equal
      - contain
      - not_contain
      required: true
    - description: The entry that is to be deleted from the Organizational Block List.
      name: value
      required: true
    - description: The short comment associated with the blockilst entry.
      name: comment
    description: Delete an entry from the Organizational Block List.
    name: proofpoint-tp-blocklist-delete-entry
    outputs:
    - contextPath: ProofpointThreatProtection.Blocklist
      description: Standard HTTP response with status code 200.
  - arguments:
    - auto: PREDEFINED
      description: A boolean argument to designate whether to send back all the list
        results. This argument takes precedence over the limit argument when set to
        true. Default is False.
      name: all_results
      predefined:
      - "True"
      - "False"
    - description: An integar argument to designate the amount of entries to return
        from the list results. Defualt is 25. Maximum is 100.
      name: limit
    description: Get entries from the Organizational Safe List.
    name: proofpoint-tp-safelist-list
    outputs:
    - contextPath: ProofpointThreatProtection.Safelist
      description: A list of entries in the Organizational Safe List.
  - arguments:
    - auto: PREDEFINED
      description: Supported attributes for the Organizational Safe List.
      name: attribute
      predefined:
      - $from
      - $hfrom
      - $ip
      - $host
      - $helo
      - $rcpt
      required: true
    - auto: PREDEFINED
      description: Supported operators for the Organizational Safe List.
      name: operator
      predefined:
      - equal
      - not_equal
      - contain
      - not_contain
      required: true
    - description: The entry to be added to the Organizational Safe List.
      name: value
      required: true
    - description: An optional short comment about the added entry (max 150 chars).
      name: comment
    description: Add an entry to the Organizational Safe List.
    name: proofpoint-tp-safelist-add-entry
    outputs:
    - contextPath: ProofpointThreatProtection.Safelist
      description: Standard HTTP response with status code 200.
  - arguments:
    - auto: PREDEFINED
      description: Supported attributes for the Organizational Safe List.
      name: attribute
      predefined:
      - $from
      - $hfrom
      - $ip
      - $host
      - $helo
      - $rcpt
      required: true
    - auto: PREDEFINED
      description: Supported operators for the Organizational Safe List.
      name: operator
      predefined:
      - equal
      - not_equal
      - contain
      - not_contain
      required: true
    - description: The entry to be deleted from the Organizational Safe List.
      name: value
      required: true
    description: Delete an entry from the Organizational Safe List.
    name: proofpoint-tp-safelist-delete-entry
    outputs:
    - contextPath: ProofpointThreatProtection.Safelist
      description: Standard HTTP response with status code 200.
  dockerimage: demisto/python3:3.11.9.107902
  runonce: false
  script: |
    register_module_line('Proofpoint Threat Protection', 'start', __line__())
    demisto.debug('pack name = Proofpoint Threat Protection, pack version = 1.0.0')




    ''' CONSTANTS '''


    CTX_PREFIX = 'ProofpointThreatProtection'
    OSL_HEADER = 'Organizational Safe List'
    OBL_HEADER = 'Organizational Block List'
    URL_SUFFIX_SAFELIST = '/emailProtection/modules/spam/orgSafeList'
    URL_SUFFIX_BLOCKLIST = '/emailProtection/modules/spam/orgBlockList'
    AUTH_HOST_BASE_URL = 'https://auth.proofpoint.com/v1'
    LIMIT_DEFAULT = 25
    LIMIT_MAXIMUM = 100

    ''' INTEGRATION API CLIENT '''


    class Client(BaseClient):
        """Client class to interact with the service API"""

        def get_args(self):
            return demisto.args()

        def get_auth_host(self):
            return AUTH_HOST_BASE_URL

        def get_shared_integration_context(self):
            return get_integration_context()

        def set_shared_integration_context(self, context):
            return set_integration_context(context)

        def get_access_token(self, client_id, client_secret):
            """
            Get an access token that was previously created if it is still valid, else, generate a new access token from
            the API key and secret.
            """
            # Check if there is an existing valid access token
            integration_context = self.get_shared_integration_context()
            if integration_context.get('access_token') and integration_context.get('expiry_time') > date_to_timestamp(datetime.now()):
                self._headers = {'Authorization': f'Bearer {integration_context.get("access_token")}', 'Accept': 'application/json'}
                return integration_context.get('access_token')
            else:
                try:
                    res = self._http_request(
                        method='POST',
                        full_url=f'{self.get_auth_host()}/token',
                        headers={'Content-Type': 'application/x-www-form-urlencoded'},
                        data={
                            'grant_type': 'client_credentials',
                            'client_id': client_id,
                            'client_secret': client_secret
                        }
                    )
                    access_token = res.get('access_token', None)
                    if access_token is not None:
                        expiry_time = date_to_timestamp(datetime.now(), date_format='%Y-%m-%dT%H:%M:%S')
                        expiry_time += res.get('expires_in', 0) * 1000 - 10
                        context = {
                            'access_token': access_token,
                            'expiry_time': expiry_time
                        }
                        self.set_shared_integration_context(context)
                        self._headers = {'Authorization': f'Bearer {access_token}', 'Accept': 'application/json'}
                        return res.get('access_token')

                except Exception as e:
                    raise (Exception(f'Error occurred while creating an access token. '
                                     f'Please check the instance configuration.'
                                     f'\n\n{e.args[0]}'))

        def get_safelist(self, cluster_id):
            return self._http_request(
                'GET',
                url_suffix=URL_SUFFIX_SAFELIST,
                headers=self._headers,
                params={'clusterId': cluster_id}
            )

        def safelist_add_delete(self, cluster_id, args, action):
            import json
            self._headers.update({'Content-Type': 'application/json'})
            return self._http_request(
                'POST',
                resp_type='response',
                url_suffix=URL_SUFFIX_SAFELIST,
                headers=self._headers,
                params={'clusterId': cluster_id},
                data=json.dumps({
                    'action': action,
                    'attribute': args.get('attribute'),
                    'operator': args.get('operator'),
                    'value': args.get('value'),
                    'comment': args.get('comment')
                })
            )

        def get_blocklist(self, cluster_id):
            return self._http_request(
                'GET',
                url_suffix=URL_SUFFIX_BLOCKLIST,
                headers=self._headers,
                params={'clusterId': cluster_id}
            )

        def blocklist_add_delete(self, cluster_id, args, action):
            import json
            self._headers.update({'Content-Type': 'application/json'})
            return self._http_request(
                'POST',
                resp_type='response',
                url_suffix=URL_SUFFIX_BLOCKLIST,
                headers=self._headers,
                params={'clusterId': cluster_id},
                data=json.dumps({
                    'action': action,
                    'attribute': args.get('attribute'),
                    'operator': args.get('operator'),
                    'value': args.get('value'),
                    'comment': args.get('comment')
                })
            )


    ''' HELPER FUNCTIONS '''


    def make_return_command_results(header_str: str, listname: str, op: str | dict) -> CommandResults:
        readable_op = tableToMarkdown(header_str, op, headers={} if not isinstance(op, str) else ['Outcome'], removeNull=True)
        return_cr = CommandResults(readable_output=readable_op, outputs_prefix=CTX_PREFIX, outputs={listname: op})

        return return_cr


    def get_limit_args(client: Client):
        args = client.get_args()
        limit = args.get('limit', str(LIMIT_DEFAULT))
        limit = int(limit) if limit.isnumeric() else LIMIT_DEFAULT
        limit = limit if limit < LIMIT_MAXIMUM else LIMIT_MAXIMUM
        all_results = args.get('all_results', 'false')
        all_results = all_results.lower() == 'true'

        return limit, all_results


    ''' COMMAND FUNCTIONS '''


    def module_test_command(client: Client, cluster_id: str) -> str:
        client.get_blocklist(cluster_id)
        return 'ok'


    def safelist_list_command(client: Client, cluster_id: str) -> CommandResults:
        limit, all_results = get_limit_args(client)
        res = client.get_safelist(cluster_id)
        res_rc = make_return_command_results(OSL_HEADER, 'Safelist', res.get(
            'entries') if all_results else res.get('entries')[-limit:])
        return res_rc


    def safelist_add_command(client: Client, cluster_id: str) -> CommandResults:
        client.safelist_add_delete(cluster_id, client.get_args(), 'add')
        res_rc = make_return_command_results(OSL_HEADER, 'Safelist Entry Added', 'Success')
        return res_rc


    def safelist_delete_command(client: Client, cluster_id: str) -> CommandResults:
        client.safelist_add_delete(cluster_id, client.get_args(), 'delete')
        res_rc = make_return_command_results(OSL_HEADER, 'Safelist Entry Deleted', 'Success')
        return res_rc


    def blocklist_list_command(client: Client, cluster_id: str) -> CommandResults:
        limit, all_results = get_limit_args(client)
        res = client.get_blocklist(cluster_id)
        res_rc = make_return_command_results(OBL_HEADER, 'Blocklist', res.get('entries')
                                             if all_results else res.get('entries')[-limit:])
        return res_rc


    def blocklist_add_command(client: Client, cluster_id: str) -> CommandResults:
        client.blocklist_add_delete(cluster_id, client.get_args(), 'add')
        res_rc = make_return_command_results(OBL_HEADER, 'Blocklist Entry Added', 'Success')
        return res_rc


    def blocklist_delete_command(client: Client, cluster_id: str) -> CommandResults:
        client.blocklist_add_delete(cluster_id, client.get_args(), 'delete')
        res_rc = make_return_command_results(OBL_HEADER, 'Blocklist Entry Deleted', 'Success')
        return res_rc


    '''         UPDATE COMMAND MAPPINGS
        (After command function declarations) '''

    COMMANDS = {
        'test-module': module_test_command,
        'proofpoint-tp-safelist-list': safelist_list_command,
        'proofpoint-tp-safelist-add-entry': safelist_add_command,
        'proofpoint-tp-safelist-delete-entry': safelist_delete_command,
        'proofpoint-tp-blocklist-list': blocklist_list_command,
        'proofpoint-tp-blocklist-add-entry': blocklist_add_command,
        'proofpoint-tp-blocklist-delete-entry': blocklist_delete_command
    }


    ''' MAIN FUNCTION '''


    def parse_params(params: dict):
        client_id = params.get('credentials', {}).get('username', params.get('credentials', {}).get('identifier'))
        client_secret = params.get('credentials', {}).get('password')
        base_url = params.get('url')
        cluster_id = params.get('cluster_id')
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('proxy', False)

        return client_id, client_secret, base_url, cluster_id, verify_certificate, proxy


    def main() -> None:

        client_id, client_secret, base_url, cluster_id, verify_certificate, proxy = parse_params(demisto.params())

        command = demisto.command()

        try:
            if command in COMMANDS:
                client = Client(
                    base_url=base_url,
                    verify=verify_certificate,
                    proxy=proxy)

                client.get_access_token(client_id, client_secret)
                return_results(COMMANDS[command](client, cluster_id))
            else:
                raise NotImplementedError(f'Command {command} is not implemented')

        except Exception as e:
            return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()

    register_module_line('Proofpoint Threat Protection', 'end', __line__())
  subtype: python3
  type: python
system: true
