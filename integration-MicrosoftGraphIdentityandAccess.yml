category: Authentication & Identity Management
commonfields:
  id: MicrosoftGraphIdentityandAccess
  version: -1
configuration:
- defaultvalue: 597c0375-766f-4e6d-ad2a-f48117044ac5
  display: Application ID (Client ID for Client credentials mode)
  name: app_id
  required: false
  section: Connect
  type: 0
- display: Tenant ID (required for Client Credentials mode)
  name: tenant_id
  required: false
  section: Connect
  type: 0
- additionalinfo: Client Secret. Required for Client Credentials mode)
  display: ""
  displaypassword: Client Secret (required for Client Credentials mode)
  hiddenusername: true
  name: credentials
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication. As appears in the "Certificates
    & secrets" page of the app.
  advanced: true
  display: Certificate Thumbprint
  displaypassword: Private Key
  name: creds_certificate
  required: false
  section: Connect
  type: 9
- additionalinfo: Relevant only if the integration is running on Azure VM. If selected,
    authenticates based on the value provided for the Azure Managed Identities Client
    ID field. If no value is provided for the Azure Managed Identities Client ID field,
    authenticates based on the System Assigned Managed Identity. For additional information,
    see the Help tab.
  display: Use Azure Managed Identities
  name: use_managed_identities
  required: false
  section: Connect
  type: 8
- additionalinfo: The Managed Identities client ID for authentication - relevant only
    if the integration is running on Azure VM.
  display: ""
  displaypassword: Azure Managed Identities Client ID
  hiddenusername: true
  name: managed_identities_client_id
  required: false
  section: Connect
  type: 9
- additionalinfo: The time range to consider for the initial data fetch in the format
    <number> <unit>. For example, 1 hour, 2 hours, 6 hours, 12 hours, 24 hours, 48
    hours, etc.
  defaultvalue: 1 days
  display: First Fetch Time Interval
  name: first_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: The maximum number of incidents per request from the Azure Active
    Directory. Default is 50.
  defaultvalue: "50"
  display: Max fetch interval
  name: max_fetch
  required: false
  section: Collect
  type: 0
- advanced: true
  display: Fetch query
  name: fetch_filter_expression
  required: false
  section: Collect
  type: 0
- additionalinfo: Azure AD endpoint associated with a national cloud.
  advanced: true
  defaultvalue: https://login.microsoftonline.com
  display: Azure AD endpoint
  name: azure_ad_endpoint
  options:
  - https://login.microsoftonline.com
  - https://login.microsoftonline.us
  - https://login.microsoftonline.de
  - https://login.chinacloudapi.cn
  required: false
  section: Connect
  type: 15
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: Use a self-deployed Azure application and authenticate using the
    Client Credentials flow.
  display: Use Client Credentials Authorization Flow
  name: client_credentials
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.2.48
    packID: MicrosoftGraphIdentityandAccess
    packName: Microsoft Graph Identity and Access
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: Microsoft Graph Identity and Access Classifier
defaultmapperin: Microsoft Graph Identity and Access Incoming Mapper
description: Use the Azure Active Directory Identity And Access integration to manage
  roles and members.
detaileddescription: "## Authorization\nTo use Microsoft Graph Services, you need
  to configure authentication. There are three authentication methods available:\n-
  Client Credentials Flow (Recommended)\n- Device Code Flow\n- Azure Managed Identities\n\n###
  Device Code Flow\n___\nIn both options below, the [device authorization grant flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code)
  is used.\n\nTo connect to Microsoft Graph Identity & Access using either Cortex
  XSOAR Graph app or the Self-Deployed Graph app:\n1. Fill in the required parameters.\n2.
  Run the ***!msgraph-identity-auth-start*** command.\n3. Follow the instructions
  that appear.\n4. Run the ***!msgraph-identity-auth-complete*** command.\n\nAt the
  end of the process you'll see a message that you've logged in successfully.\n\n####
  Cortex XSOAR Graph App\n\nTo use the Cortex XSOAR Azure application, use the default
  application ID (597c0375-766f-4e6d-ad2a-f48117044ac5).  \nA detailed explanation
  on how to register an app can be found [here](https://docs.microsoft.com/en-us/power-apps/developer/data-platform/walkthrough-register-app-azure-active-directory).\n\n####
  Self-Deployed Azure App\n\nTo use a self-configured Azure application, you need
  to add a new Azure App Registration in the Azure Portal, with mobile and desktop
  flows enabled.\n\n### Client Credentials Flow\n___\nFollow these steps for a self-deployed
  configuration:\n\n1. To use a self-configured Azure application, you need to add
  a new Azure App Registration in the Azure Portal. To add the registration.\n2. Enter
  your Client/Application ID in the ***Application ID*** parameter. \n3. Enter your
  Client Secret in the ***Client Secret*** parameter.\n4. Enter your Tenant ID in
  the ***Tenant ID*** parameter.\n\n\n### Azure Managed Identities Authentication\n___\n#####
  Note: This option is relevant only if the integration is running on Azure VM.\nFollow
  one of these steps for authentication based on Azure Managed Identities:\n\n- #####
  To use System Assigned Managed Identity\n   - Select the **Use Azure Managed Identities**
  checkbox and leave the **Azure Managed Identities Client ID** field empty.\n\n-
  ##### To use User Assigned Managed Identity\n   1. Go to [Azure Portal](https://portal.azure.com/)
  -> **Managed Identities**.\n   2. Select your User Assigned Managed Identity ->
  copy the Client ID -> paste it in the **Azure Managed Identities Client ID** field
  in the instance settings.\n   3. Select the **Use Azure Managed Identities** checkbox.\n\nFor
  more information, see [Managed identities for Azure resources](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview).\n\n\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/microsoft-graph-identityand-access)"
display: Azure Active Directory Identity And Access
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAAC+9JREFUeAHtWXtwVNUZP+c+du9udiGB8DBjImkFWrRTpB1ardToQAVEyggZx9ZSBOQ5FAgJFGw1UssrD94BeQz4oB3hj7ZDBdERqUPRGW1x6kyAgI0ELIRHXvu+ex/9fQub7i7ZZBXoxJlzmMve+53vO4/f9zwnjIkmEBAICAQEAgIBgYBAQCAgEBAICAQEAgIBgYBAQCAgEBAICAQEAgIBgYBA4CYQ4JnInnrcm+tUXOWyxBxWJwJOzrnpZ4e3L22MuCw2Ro8wOx07p5k5M7nGlj/3Y3YhHZ+g3xwCSibi3JJ6MJvPcckSt+z0NuGSOQvIhmXbzO90s+lSelZGCo5GGYuE2GasQSg4E0V8BZ6MFGy54YlRFgyZdhZpL32TmG1Zum1Cd2HG4MFpGynYspjOLPwT7bYhkJGCb9vsYuAOEVi6dGlvy7LyWluVpq1bf/9Fh0wZEruNgouLix35+YU/kmVb1XU9vH79+qPYQ4fevXjx4sG2bd9Fe7xy5crxXbt2XYa8q6CgAOFevlNR+PTVq1c3ZIhBd2KTysrKSg3DXKiqan+PJ/IBFvfAzSxQuhnhWyk7cODAHEmy/yTLyiGnU3uvpKRkeEfjz5gxQ4V1v64o6iF6cnJyfkB8hYWFOZzLT7nd2qhw2BjckWx3p8Fwx2FPq2G8qmkay7HPXVgz6Yhj33csWLBgGL1/mX10Gw+mRWNDZjQatR0Oh4QN/hKkD1M3k52d/SDKgO/Dy01FUWTIxIqCNWvW/GfhwoWj/f5or1AocCRV7uvwjZrkYU1TWSQS3lhZWfFifM3Y13AY/V8NI1oH2oNxeia/3UrBOGWRtV6MRKIK3ieVlpa+UFlZeSlxIwhfz0qShPLNPovfQYl9a9eu/Vvid8q7NG3atOzc3FwT4bs1pa/9E57i3rZtW7CdgBeieb1et8/nC6b2JfJNmTIlu3///nzVqlU0/g3pZcyYMc6hQ4d6WltbIzU1Nf5EWXq3LCOmD1mWk/aMcO0FrU80qp9IlenqOyN3P1ncs1CLap/KMkcVnX5IHKOY6Y9u2lJ6OeBV2BIdlXS6Fq+iDYvdVz6W1S5btqyfrkdPwYobZJl9oGmuGYGAf1Z1dfXL8THmzp17V1aWp9YwrMOcWyqs+tFgMDBu3bp1bwJcrXfv3Fdsm/dDCf/0xo0bz5Mc5eb8/Py5AOgpOPs3YDg4CPCPkKefRCi0TJP9kaCVZQkh0V6JiHB3OBwaBQWcgYHdi5xexpj5MKIGUgC/inW/i2FXVFRUfBZfF0LnJEVxzuPc/g5oEoY9iwgzacOGDaeJZ968eXe6XK4yy+JjMVc/zOtH8DkWDodXo9b4aM6cOfkul+cPkB8Eo+2L/TVAqZewj/VY6z1Op/qEaVqDIOfDGk6Zpl3v97f+HMaGg2bnLaMcLAUZtzlXVXCrONymexT028yW4YdIpYCmiwfZRJW05JyCTcoI07sjcGM49DN79+6V41sASD9D+HbbtrEDG00yNQrraA/ACB+CktwkU1RUrqHwet3t9lSQckF6C4o6CKAKgsGgF0rA2NYI0B8xDPtVjHkvHr/T6WSU72AUhx0OZTL46wH0XiiuBUY1Fd9vLVmypIDmQN6cANpejDME/a8Agc22LbVhPb2on/jQ/47D4fwV5HxQMsbhZwDQRE3TDi1a9OvvZWVlQVEmKeu614OLW9g/RxqSDKzdpLEgDzUwA2x4MmuxkNAVq8vdGlHCkX9y03LhwiMtu6TITDODDVhpKBRh/8KSk5SQKohoEMWWQsl02wHwP5Yk+QiseOTRo/+gIuoYeSL2NzUUCtWfP3/+7fz8gvnJcti2ZesEABQTm3fYsLZfuFxZT8AjTyK8jY97FIXSxsbGEIVLRI0wlNFX141/NzVdnQxZX3NzM4dhHFJVR59wOPK7qqqq52kuihJ9+khvuN1Z40Oh4AKQSgyDjfN6Ne7zta1GtKmMr6m4uNxB76Zp/gb830I02tPQ0DB13759OtFRLa9DlJofjYaWIxo8BtIjKCw3uN3ueT5foAphfhPxUYMRHUa9cRg5+DhqjaIYMcP/MlLwhJH7m/PYHS9ItqFw6Rp4HY0vWwoPMsfnb7TdY4a97LRppVcwuaUBd29uYpfKkwbjjEIPwuMOADzKNINT0H0sL69wlMvlvBshuRwghUpKytJGn7iC4QHFNDTC26q4cul79+7dLfQ7ZMgQL7yNQwmWYURe3LlzZxPRMXchPP1+hNCr8MoNRKMGufCiRYtqEGHGQ6SIaOj/BBEDN3PyXCjC39bWtn/r1q1f7NtXrmOcLBjlKBiliWhRFVcuycGIa1AQz0YgGk7n3pUrV14FOeY9shyrnIkt3mJ7xTzpvSvOmfKbkYJ7SwP7RRyOP0uSAi+6oXZoH1J2uFgooG6G6UadMltgtQfXdpb2F8rBMACjt4N9F8Ta9g680JkYABwAyGfBNxGgLkPImgqQIuGwvSeRt6N3hPcYGVEgD8qg4iVp/EQZAMwNw/DDi8/F6ZDJRVh1QvGfobBKKsigsIvgZ5LEe1DR1Nx8ZYck9RmAHD4ToX2L18tfgiduHDx48Ira2loPjDQHMkGs6WJ8fPpFeG6CwtrwmoWI4cUvKfiWt7RecMNMNtRhmYx38lC/hRoGYTd2AQkJUmLaB7ZixeJVymTISRJVmQDxNQDdC7l1GYx7JIA9WFOz9kwKe9pPeFkI3gzv4n3TMqED/UlWi28/lGvCuHoFAnmuRFnLknIQLmE0vNXj8Rjk1VVVFaUw/KGBQKjMtk0dIbn85MnTM+vq6hApbEpBGkJvduI4mMOLGsMDWgBneV9iX7p34NBpyutILnMFdyR9m2nBoPIaLD8AFcyDorIA1vZMpoQCYqFMktj7pGBZdsxHVCAwY23GjHI3jj4qvLZDwFpaWupRztSiMOrft69/clyOfqHbZ1AbwCisdxFyTVTIPYhOVXV1dUUlvPV5KAIebo84ePBgBN8fojiEiDqT+OIN3vu0y6VpMKK/IzzHUkO8L/UXESW2H8jEisfU/s6+MwrRnQ1wK/tQJKmw7PY1bd68sq6kZNE78OgJCNm1TU1Nh+PzAUDlGpD/+5sVPF4BoAo5H/EFg9Y61Hs/BZCjCgoKj6KweRP9DpxSHpLl7Al4J++i+VTijzfySlwu/NYwpH2qKm9ELr0f4NZhvh8iooxGTj0Bw8HYjMFIVqJSzoYS3sfaNRjjdPDCw633qB+KXY5CbQRC9XzUDd9EPPsY54tvozp/EinnMmTKwRY3NJn2BPEkx8NcF8GLCloahj28jLHPIvxXkQHRHJ21pIE6Y7zdffBUOgogV/LTqHDjG4b3SVsQmgEuryHgE9ZRD1BPY7OxCwMAgPOtVYeH8m1s4zU11eeQtscA4L04PhVgbAr1c+GdjX6/vw0KRmiWTiLXn8A4SUcPXJr8BVXrBHjYUchMxLGmHL/DcXp71efTx9LNGa0FCjkLJT0K8Lfgqca3ExVz6fHjx3dQP6rh47haH4Mq/gD2UETjIO8/hqn348ZqNDz/E+K73i5gr9iTlJSPcdlTi7Ffwjyg82ex3sdxtsfau24xS++K7SfbTxYyVf4UDpKFvwemZZdQZPnDjk1v5+TqPJuV0J8M0zUAR0Ppts7u806IFVkcRYsDec1OrDZJvqioSDty5EjSaFSIUa6G0imNxxZFNCiOw7KJ1m4kNAZCaR9N69lDVS3/ihUrGomGFpuTXjqSIToanzXruTyvV9cQQZrjlfa1rmv/z549O6dnz545Pl/UDASuNqYYYjsrXea0tIS8brfclnpDR0zYpzJgwAAlEAhEKfy3C15/oT1gHk99ff3VPXv2UIHWZetOCu5ysYLhyyPQbUL0l1+6kMgEAaHgTFD6GvO0V6yd7cGSdZSnboXjjNBpDsblM47BdA+D22iUp3jSNcrBURsVbMpddDp+Qf9qCGSk4IAn54K3NUB/CelEZTgAYA26qZ7Tcd/h0NmBcMotc+ISFRwo0KwAZ5/H3sR/AgGBgEBAICAQEAgIBAQCAgGBgEBAICAQEAgIBAQCAgGBgEBAICAQEAgIBAQCAgGBwP8Zgf8CqLeLzH1CkPwAAAAASUVORK5CYII=
name: MicrosoftGraphIdentityandAccess
script:
  commands:
  - arguments: []
    description: Run this command to start the authorization process and follow the
      instructions in the command results.
    name: msgraph-identity-auth-start
  - arguments: []
    description: |-
      Run this command to complete the authorization process.
      Should be used after running the msgraph-identity-auth-start command.
    name: msgraph-identity-auth-complete
  - arguments: []
    description: Run this command if for some reason you need to rerun the authentication
      process.
    name: msgraph-identity-auth-reset
  - arguments: []
    description: Tests connectivity to Microsoft.
    name: msgraph-identity-auth-test
  - arguments:
    - defaultValue: "10"
      description: Maximum number of results to fetch.
      name: limit
    description: Lists the roles in the directory.
    name: msgraph-identity-directory-roles-list
    outputs:
    - contextPath: MSGraphIdentity.Role.deletedDateTime
      description: The time when a role was deleted. Displays only if a role was deleted.
      type: Date
    - contextPath: MSGraphIdentity.Role.description
      description: The description of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.displayName
      description: The display name of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.id
      description: The unique identifier of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.roleTemplateId
      description: The ID of the directory role template on which the role is based.
      type: String
  - arguments:
    - description: ID of the role template to activate. Can be retrieved using the
        msgraph-identity-directory-roles-list command.
      name: role_template_id
      required: true
    description: Activates a role by its template ID.
    name: msgraph-identity-directory-role-activate
    outputs:
    - contextPath: MSGraphIdentity.Role.deletedDateTime
      description: The time when the role was deleted. Displays only if the role was
        deleted.
      type: Date
    - contextPath: MSGraphIdentity.Role.description
      description: The description of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.displayName
      description: The display name of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.id
      description: The unique identifier of the directory role.
      type: String
    - contextPath: MSGraphIdentity.Role.roleTemplateId
      description: The ID of the directory role template on which this role is based.
      type: String
  - arguments:
    - description: The ID of the application for which to get its role members list.
        Can be retrieved using the msgraph-identity-directory-roles-list command.
      name: role_id
      required: true
    - defaultValue: "10"
      description: The maximum number of members to fetch.
      name: limit
    description: Gets all members in a role ID.
    name: msgraph-identity-directory-role-members-list
    outputs:
    - contextPath: MSGraphIdentity.RoleMember.user_id
      description: The unique identifier of the user in the role.
      type: String
    - contextPath: MSGraphIdentity.RoleMember.role_id
      description: The unique identifier of the role specified in the input.
      type: String
  - arguments:
    - description: The ID of the role to add the user to. Can be retrieved using the
        msgraph-identity-directory-roles-list command.
      name: role_id
      required: true
    - description: The ID of the user to add to the role. Can be retrieved using the
        msgraph-identity-directory-role-members-list command.
      name: user_id
      required: true
    description: Adds a user to a role.
    name: msgraph-identity-directory-role-member-add
  - arguments:
    - description: ID of the role from which to remove the user. Can be retrieved
        using the msgraph-identity-directory-roles-list command.
      name: role_id
      required: true
    - description: ID of the user to remove from the role. Can be retrieved using
        the msgraph-identity-directory-role-members-list command.
      name: user_id
      required: true
    description: Removes a user from a role.
    name: msgraph-identity-directory-role-member-remove
  - arguments:
    - description: The id of the named ip location to get from the api.
      name: ip_id
      required: true
    description: Retrieve an ip named location by id.
    name: msgraph-identity-ip-named-locations-get
    outputs:
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.time_created
      description: The time when an ip named location was created.
      type: Date
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.time_modified
      description: The time when an ip named location was updated.
      type: Date
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.display_name
      description: The display name of the ip named location.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.id
      description: The unique identifier of the ip named location.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.is_trusted
      description: Abollean that taled if the ip named location is a trusted source.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.ip_ranges
      description: List of ip ranges for the ip named location.
      type: Array
  - arguments:
    - description: The limit for results we get from the api.
      name: limit
    - description: The page to get the data from.
      name: page
    - description: An odata query to send to the api.
      name: odata_query
    description: Retrieve all ip named locations.
    name: msgraph-identity-ip-named-locations-list
    outputs:
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.ip_named_locations
      description: List of ip named locations.
      type: Array
  - arguments:
    - description: The id of the named ip location to get from the api.
      name: ip_id
      required: true
    description: Delete an ip named location by id.
    name: msgraph-identity-ip-named-locations-delete
  - arguments:
    - description: A list of IP addresses to add to the named location, should be
        a string with the addresses separated by the delimiter ','.
      name: ips
    - description: Boolean that indicates if the ip can be trusted.
      name: is_trusted
    - description: The disply name for the named ip location.
      name: display_name
    description: Create an ip named location.
    name: msgraph-identity-ip-named-locations-create
    outputs:
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.time_created
      description: The time when an ip named location was created.
      type: Date
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.time_modified
      description: The time when an ip named location was updated.
      type: Date
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.display_name
      description: The display name of the ip named location.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.id
      description: The unique identifier of the ip named location.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.is_trusted
      description: Abollean that taled if the ip named location is a trusted source.
      type: String
    - contextPath: MSGraph.conditionalAccess.namedIpLocations.ip_ranges
      description: List of ip ranges for the ip named location.
      type: Array
  - arguments:
    - description: The id of the named ip location to get from the api.
      name: ip_id
      required: true
    - description: A list of ip addresses to ad to the named location, it should be
        a string with the addresses separated by the delimiter ','.
      name: ips
    - description: Boolean that indicates if the ip can be trusted.
      name: is_trusted
    - description: The disply name for the named ip location.
      name: display_name
    description: update an ip named location by id.
    name: msgraph-identity-ip-named-locations-update
  - arguments:
    - description: The limit for results we get from the api.
      name: limit
    - description: An odata query to send to the api.
      name: odata_query
    description: Retrieve all the detected risks.
    name: msgraph-identity-protection-risks-list
    outputs:
    - contextPath: MSGraph.identityProtection.risks.additionalInfo
      description: dentityProtection.risks.additionalInfo
      type: string
    - contextPath: MSGraph.identityProtection.risks.userPrincipalName
      description: Risky user principal name.
      type: string
    - contextPath: MSGraph.identityProtection.risks.userDisplayName
      description: Risky user display name.
      type: string
    - contextPath: MSGraph.identityProtection.risks.userId
      description: Unique ID of the user.
      type: string
    - contextPath: MSGraph.identityProtection.risks.lastUpdatedDateTime
      description: Date and time that the risk detection was last updated. The DateTimeOffset
        type represents date and time information using the ISO 8601 format and is
        always in UTC time.
      type: string
    - contextPath: MSGraph.identityProtection.risks.detectedDateTime
      description: Date and time that the risk was detected. The DateTimeOffset type
        represents date and time information using the ISO 8601 format and is always
        in UTC time.
      type: string
    - contextPath: MSGraph.identityProtection.risks.activityDateTime
      description: Date and time that the risky activity occurred. The DateTimeOffset
        type represents date and time information using the ISO 8601 format and is
        always in UTC time.
      type: string
    - contextPath: MSGraph.identityProtection.risks.location.state
      description: State of the sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.location.geoCoordinates.longitude
      description: Longitude of the sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.location.geoCoordinates.latitude
      description: Latitude of the sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.location.countryOrRegion
      description: Country or region of the sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.location.city
      description: City of the sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.ipAddress
      description: Provides the IP address of the client from where the risk occurred.
      type: string
    - contextPath: MSGraph.identityProtection.risks.tokenIssuerType
      description: Indicates the type of token issuer for the detected sign-in risk.
        The possible values are AzureAD, ADFederationServices, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.activity
      description: Indicates the activity type the detected risk is linked to. The
        possible values are signin, user, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.detectionTimingType
      description: Timing of the detected risk (real-time/offline). The possible values
        are notDefined, realtime, nearRealtime, offline, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.source
      description: Source of the risk detection. For example, activeDirectory.
      type: string
    - contextPath: MSGraph.identityProtection.risks.riskDetail
      description: Reason why the user is considered a risky user. The possible values
        are limited to none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange,
        userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe,
        userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised,
        hidden, adminConfirmedUserCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.riskstate
      description: State of the user's risk. The possible values are none, confirmedSafe,
        remediated, dismissed, atRisk, confirmedCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.riskLevel
      description: Risk level of the detected risky user. The possible values are
        low, medium, high, hidden, none, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.riskType
      description: Deprecated. Use riskEventType instead. List of risk event types.
      type: string
    - contextPath: MSGraph.identityProtection.risks.riskEventType
      description: The type of risk event detected. The possible values are unlikelyTravel,
        anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures, malwareInfectedIPAddress,
        suspiciousIPAddress, leakedCredentials, investigationsThreatIntelligence,
        generic,adminConfirmedUserCompromised, mcasImpossibleTravel, mcasSuspiciousInboxManipulationRules,
        investigationsThreatIntelligenceSigninLinked, maliciousIPAddressValidCredentialsBlockedIP,
        and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risks.correlationId
      description: Correlation ID of the sign-in associated with the risk detection.
        This property is null if the risk detection is not associated with a sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.requestId
      description: The ID of the sign-in associated with the risk detection. This
        property is null if the risk detection is not associated with a sign-in.
      type: string
    - contextPath: MSGraph.identityProtection.risks.id
      description: Unique ID of the risk detection.
      type: string
  - arguments:
    - description: The limit for results we get from the api.
      name: limit
    - description: An odata query to send to the api.
      name: odata_query
    description: Retrieve the risky users in active directory.
    name: msgraph-identity-protection-risky-user-list
    outputs:
    - contextPath: MSGraph.identityProtection.risky-users.userPrincipalName
      description: Risky user principal name.
      type: string
    - contextPath: MSGraph.identityProtection.risky-users.userDisplayName
      description: Risky user display name.
      type: string
    - contextPath: MSGraph.identityProtection.risky-users.riskDetail
      description: Reason why the user is considered a risky user. The possible values
        are limited to none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange,
        userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe,
        userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised,
        hidden, adminConfirmedUserCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risky-users.riskstate
      description: State of the user's risk. The possible values are none, confirmedSafe,
        remediated, dismissed, atRisk, confirmedCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risky-users.riskLevel
      description: Risk level of the detected risky user. The possible values are
        low, medium, high, hidden, none, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.risky-users.riskLastUpdatedDateTime
      description: The date and time that the risky user was last updated. The DateTimeOffset
        type represents date and time information using the ISO 8601 format and is
        always in UTC time.
      type: DateTime
    - contextPath: MSGraph.identityProtection.risky-users.isProcessing
      description: Indicates whether a user's risky state is being processed by the
        backend.
      type: Boolean
    - contextPath: MSGraph.identityProtection.risky-users.isDeleted
      description: Indicates whether a user is delted.
      type: Boolean
    - contextPath: MSGraph.identityProtection.risky-users.id
      description: Unique ID of the risky user.
      type: string
  - arguments:
    - description: The limit for results we get from the api.
      name: limit
    - description: An odata query to send to the api.
      name: odata_query
    - description: The id of the user to get the history for.
      name: user_id
      required: true
    description: Retrieve the risky users history in active directory.
    name: msgraph-identity-protection-risky-user-history-list
    outputs:
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.userPrincipalName
      description: Risky user principal name.
      type: string
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.userDisplayName
      description: Risky user display name.
      type: string
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.riskDetail
      description: Reason why the user is considered a risky user. The possible values
        are limited to none, adminGeneratedTemporaryPassword, userPerformedSecuredPasswordChange,
        userPerformedSecuredPasswordReset, adminConfirmedSigninSafe, aiConfirmedSigninSafe,
        userPassedMFADrivenByRiskBasedPolicy, adminDismissedAllRiskForUser, adminConfirmedSigninCompromised,
        hidden, adminConfirmedUserCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.riskstate
      description: State of the user's risk. The possible values are none, confirmedSafe,
        remediated, dismissed, atRisk, confirmedCompromised, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.riskLevel
      description: Risk level of the detected risky user. The possible values are
        low, medium, high, hidden, none, and unknownFutureValue.
      type: string
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.riskLastUpdatedDateTime
      description: The date and time that the risky user was last updated. The DateTimeOffset
        type represents date and time information using the ISO 8601 format and is
        always in UTC time.
      type: DateTime
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.isProcessing
      description: Indicates whether a user's risky state is being processed by the
        backend.
      type: Boolean
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.isDeleted
      description: Indicates whether the user is deleted.
      type: Boolean
    - contextPath: MSGraph.identityProtection.RiskyUserHistory.id
      description: Unique ID of the risky user.
      type: string
  - arguments:
    - description: The ids of the users to compromise seperated be commas.
      name: user_ids
      required: true
    description: Delete an ip named location by id.
    name: msgraph-identity-protection-risky-user-confirm-compromised
  - arguments:
    - description: The ids of the users to dismiss seperated be commas.
      name: user_ids
      required: true
    description: Delete an ip named location by id.
    name: msgraph-identity-protection-risky-user-dismiss
  dockerimage: demisto/crypto:1.0.0.87358
  isfetch: true
  runonce: false
  script: |
    register_module_line('MicrosoftGraphIdentityandAccess', 'start', __line__())
    ### pack version: 1.2.48
    """
    An integration to MS Graph Identity and Access endpoint.
    https://docs.microsoft.com/en-us/graph/api/resources/serviceprincipal?view=graph-rest-1.0
    """
    import urllib3



    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)


    # pylint: disable=E9010, E9011
    import traceback


    import requests
    import re
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM


    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'  # resource_manager


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        management_azure = 'https://management.azure.com/'  # resource_manager
        manage_office = 'https://manage.office.com/'


    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line
    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'
    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'
    REGEX_SEARCH_ERROR_DESC = r"^.*?:\s(?P<desc>.*?\.)"
    SESSION_STATE = 'session_state'

    # Deprecated, prefer using AZURE_CLOUDS
    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.us',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"
    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"


    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris
    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api
    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'geo-us': 'https://login.microsoftonline.com',
        'geo-eu': 'https://login.microsoftonline.com',
        'geo-uk': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
    }

    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'geo-us': 'https://graph.microsoft.com',
        'geo-eu': 'https://graph.microsoft.com',
        'geo-uk': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        'com': 'https://securitycenter.onmicrosoft.com',
        'geo-us': 'https://securitycenter.onmicrosoft.com',
        'geo-eu': 'https://securitycenter.onmicrosoft.com',
        'geo-uk': 'https://securitycenter.onmicrosoft.com',
        'gcc': 'https://securitycenter.onmicrosoft.us',
        'gcc-high': 'https://securitycenter.onmicrosoft.us',
        'dod': 'https://securitycenter.onmicrosoft.us',
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.us',
        'gcc-high': 'https://login.microsoftonline.us',
    }

    # Azure Managed Identities
    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'
    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'
    TOKEN_EXPIRED_ERROR_CODES = {50173, 700082, 70008, 54005, 7000222,
                                 }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism
    MAX_DELAY_REQUEST_COUNTER = 6


    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     management=None,
                     resource_manager=None,
                     sql_management=None,
                     batch_resource_id=None,
                     gallery=None,
                     active_directory=None,
                     active_directory_resource_id=None,
                     active_directory_graph_resource_id=None,
                     microsoft_graph_resource_id=None,
                     active_directory_data_lake_resource_id=None,
                     vm_image_alias_doc=None,
                     media_resource_id=None,
                     ossrdbms_resource_id=None,
                     log_analytics_resource_id=None,
                     app_insights_resource_id=None,
                     app_insights_telemetry_channel_resource_id=None,
                     synapse_analytics_resource_id=None,
                     attestation_resource_id=None,
                     portal=None,
                     keyvault=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     storage_endpoint=None,
                     storage_sync_endpoint=None,
                     keyvault_dns=None,
                     mhsm_dns=None,
                     sql_server_hostname=None,
                     azure_datalake_store_file_system_endpoint=None,
                     azure_datalake_analytics_catalog_and_job_endpoint=None,
                     acr_login_server_endpoint=None,
                     mysql_server_endpoint=None,
                     postgresql_server_endpoint=None,
                     mariadb_server_endpoint=None,
                     synapse_analytics_endpoint=None,
                     attestation_endpoint=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """ Represents an Azure Cloud instance """

        def __init__(self,
                     origin,
                     name,
                     abbreviation,
                     endpoints=None,
                     suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        'Embedded',
        'AzureCloud',
        'com',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.windows.net/',
            resource_manager='https://management.azure.com/',
            sql_management='https://management.core.windows.net:8443/',
            batch_resource_id='https://batch.core.windows.net/',
            gallery='https://gallery.azure.com/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.windows.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.com/',
            active_directory_data_lake_resource_id='https://datalake.azure.net/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.azure.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.windows.net',
            app_insights_resource_id='https://api.applicationinsights.io',
            log_analytics_resource_id='https://api.loganalytics.io',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.com/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.net',
            attestation_resource_id='https://attest.azure.net',
            portal='https://portal.azure.com',
            keyvault='https://vault.azure.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.windows.net',
            storage_sync_endpoint='afs.azure.net',
            keyvault_dns='.vault.azure.net',
            mhsm_dns='.managedhsm.azure.net',
            sql_server_hostname='.database.windows.net',
            mysql_server_endpoint='.mysql.database.azure.com',
            postgresql_server_endpoint='.postgres.database.azure.com',
            mariadb_server_endpoint='.mariadb.database.azure.com',
            azure_datalake_store_file_system_endpoint='azuredatalakestore.net',
            azure_datalake_analytics_catalog_and_job_endpoint='azuredatalakeanalytics.net',
            acr_login_server_endpoint='.azurecr.io',
            synapse_analytics_endpoint='.dev.azuresynapse.net',
            attestation_endpoint='.attest.azure.net'))

    AZURE_US_GCC_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc-high',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_DOD_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'dod',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://dod-graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))


    AZURE_GERMAN_CLOUD = AzureCloud(
        'Embedded',
        'AzureGermanCloud',
        'de',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.cloudapi.de/',
            resource_manager='https://management.microsoftazure.de',
            sql_management='https://management.core.cloudapi.de:8443/',
            batch_resource_id='https://batch.cloudapi.de/',
            gallery='https://gallery.cloudapi.de/',
            active_directory='https://login.microsoftonline.de',
            active_directory_resource_id='https://management.core.cloudapi.de/',
            active_directory_graph_resource_id='https://graph.cloudapi.de/',
            microsoft_graph_resource_id='https://graph.microsoft.de',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.cloudapi.de',
            ossrdbms_resource_id='https://ossrdbms-aad.database.cloudapi.de',
            portal='https://portal.microsoftazure.de',
            keyvault='https://vault.microsoftazure.de'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.cloudapi.de',
            keyvault_dns='.vault.microsoftazure.de',
            mhsm_dns='.managedhsm.microsoftazure.de',
            sql_server_hostname='.database.cloudapi.de',
            mysql_server_endpoint='.mysql.database.cloudapi.de',
            postgresql_server_endpoint='.postgres.database.cloudapi.de',
            mariadb_server_endpoint='.mariadb.database.cloudapi.de'))

    AZURE_CHINA_CLOUD = AzureCloud(
        'Embedded',
        'AzureChinaCloud',
        'cn',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.chinacloudapi.cn/',
            resource_manager='https://management.chinacloudapi.cn',
            sql_management='https://management.core.chinacloudapi.cn:8443/',
            batch_resource_id='https://batch.chinacloudapi.cn/',
            gallery='https://gallery.chinacloudapi.cn/',
            active_directory='https://login.chinacloudapi.cn',
            active_directory_resource_id='https://management.core.chinacloudapi.cn/',
            active_directory_graph_resource_id='https://graph.chinacloudapi.cn/',
            microsoft_graph_resource_id='https://microsoftgraph.chinacloudapi.cn',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.chinacloudapi.cn',
            ossrdbms_resource_id='https://ossrdbms-aad.database.chinacloudapi.cn',
            app_insights_resource_id='https://api.applicationinsights.azure.cn',
            log_analytics_resource_id='https://api.loganalytics.azure.cn',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.cn/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.azure.cn',
            portal='https://portal.azure.cn',
            keyvault='https://vault.azure.cn',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.chinacloudapi.cn',
            keyvault_dns='.vault.azure.cn',
            mhsm_dns='.managedhsm.azure.cn',
            sql_server_hostname='.database.chinacloudapi.cn',
            mysql_server_endpoint='.mysql.database.chinacloudapi.cn',
            postgresql_server_endpoint='.postgres.database.chinacloudapi.cn',
            mariadb_server_endpoint='.mariadb.database.chinacloudapi.cn',
            acr_login_server_endpoint='.azurecr.cn',
            synapse_analytics_endpoint='.dev.azuresynapse.azure.cn'))


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    AZURE_CLOUD_NAME_CUSTOM = "Custom"

    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }


    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(origin: str,
                                  name: str | None = None,
                                  abbreviation: str | None = None,
                                  defaults: AzureCloud | None = None,
                                  endpoints: dict | None = None,
                                  suffixes: dict | None = None):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get('management', defaults.endpoints.management),
                resource_manager=endpoints.get('resource_manager', defaults.endpoints.resource_manager),
                sql_management=endpoints.get('sql_management', defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get('batch_resource_id', defaults.endpoints.batch_resource_id),
                gallery=endpoints.get('gallery', defaults.endpoints.gallery),
                active_directory=endpoints.get('active_directory', defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get('active_directory_resource_id',
                                                           defaults.endpoints.active_directory_resource_id),
                active_directory_graph_resource_id=endpoints.get(
                    'active_directory_graph_resource_id', defaults.endpoints.active_directory_graph_resource_id),
                microsoft_graph_resource_id=endpoints.get('microsoft_graph_resource_id',
                                                          defaults.endpoints.microsoft_graph_resource_id),
                active_directory_data_lake_resource_id=endpoints.get(
                    'active_directory_data_lake_resource_id', defaults.endpoints.active_directory_data_lake_resource_id),
                vm_image_alias_doc=endpoints.get('vm_image_alias_doc', defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get('media_resource_id', defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get('ossrdbms_resource_id', defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get('app_insights_resource_id', defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get('log_analytics_resource_id', defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    'app_insights_telemetry_channel_resource_id', defaults.endpoints.app_insights_telemetry_channel_resource_id),
                synapse_analytics_resource_id=endpoints.get(
                    'synapse_analytics_resource_id', defaults.endpoints.synapse_analytics_resource_id),
                attestation_resource_id=endpoints.get('attestation_resource_id', defaults.endpoints.attestation_resource_id),
                portal=endpoints.get('portal', defaults.endpoints.portal),
                keyvault=endpoints.get('keyvault', defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get('storage_endpoint', defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get('storage_sync_endpoint', defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get('keyvault_dns', defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get('mhsm_dns', defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get('sql_server_hostname', defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get('mysql_server_endpoint', defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get('postgresql_server_endpoint', defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get('mariadb_server_endpoint', defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    'azure_datalake_store_file_system_endpoint', defaults.suffixes.azure_datalake_store_file_system_endpoint),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    'azure_datalake_analytics_catalog_and_job_endpoint',
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint),
                acr_login_server_endpoint=suffixes.get('acr_login_server_endpoint', defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get('synapse_analytics_endpoint', defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get('attestation_endpoint', defaults.suffixes.attestation_endpoint),
            ))


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, 'com')
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get('azure_cloud')
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if 'server_url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'resource_manager': params.get('server_url')
                                                            or 'https://management.azure.com'})
            if 'azure_ad_endpoint' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={
                                                     'active_directory': params.get('azure_ad_endpoint')
                                                     or 'https://login.microsoftonline.com'
                                                 })
            # in multiple Graph integrations, the url is called 'url' instead of 'server_url' and the default url is different.
            if 'url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'microsoft_graph_resource_id': params.get('url')
                                                            or 'https://graph.microsoft.com'})

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str | None = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str | None = '',
                     multi_resource: bool = False,
                     resources: list[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: int | None = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
                     endpoint: str = "__NA__",  # Deprecated
                     certificate_thumbprint: str | None = None,
                     retry_on_rate_limit: bool = False,
                     private_key: str | None = None,
                     managed_identities_client_id: str | None = None,
                     managed_identities_resource_uri: str | None = None,
                     base_url: str | None = None,
                     command_prefix: str | None = "command_prefix",
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=self.azure_cloud.endpoints.active_directory
                                                                      .rstrip("/"))
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(
                endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: str | None = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    try:
                        import defusedxml.ElementTree as defused_ET
                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug('defused_ET is not supported, using ET instead.')
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f'Failed to parse json object from response: {response.content}', exception)

        def get_access_token(self, resource: str = '', scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else \
                            min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug('Set integration context successfully.')

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in Microsoft authorization.'
            try:
                demisto.info(
                    f'Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} '
                    f'{oproxy_response.text}'
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r'{.*}', oproxy_response.text)
                microsoft_response = self.extract_microsoft_error(json.loads(search_microsoft_response.group())) \
                    if search_microsoft_response else ""
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f' body: {err_str}'
                err_response = oproxy_response.json()
                server_msg = err_response.get('message', '') or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f' Server message: {server_msg}'
            except Exception as ex:
                demisto.error(f'Failed parsing error response - Exception: {ex}')
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: dict[str, str], content: str,
                                            scope: str | None = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get('delay_request_counter', 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(next_request_time=next_request_time, delay_request_counter=delay_request_counter,
                                              context=context)
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: str | None = None,
                                     integration_context: dict | None = None
                                     ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                      resource)
                    self.resource_to_access_token[resource] = access_token

                return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: str | None = None,
                                                        resource: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope or self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')
            return None

        def _get_token_device_code(
            self, refresh_token: str = '', scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run, timeout_in_seconds=900))

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get('error', {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get('error_description', '')

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += f"\nYou can run the ***{self.command_prefix}-auth-reset*** command " \
                               f"to reset the authentication process."
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f'Failed getting integration info: {str(e)}')

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search['url'] if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
            Calculates the next request time based on the delay_request_counter.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2 ** delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
            Sets the next_request_time in the integration context.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context['next_request_time'] = next_request_time
        context['delay_request_counter'] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context['delay_request_counter'] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
            Checks if the request should be delayed based on context variables.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient,
                           login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException("Please make sure you entered the Authorization configuration correctly. "
                                   f"Missing:{','.join(missing)}")

        login_url = urljoin(login_url, f'{client.tenant_id}/oauth2/v2.0/authorize?'
                                       f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
                                       f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}&prompt=consent')

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.
    You will be automatically redirected to a link with the following structure:
    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```
    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)
    and paste it in your instance configuration under the **Authorization code** parameter.
        """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f'No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.')


    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(readable_output='Authorization was reset successfully. Please regenerate the credentials, '
                                              'and then click **Test** to validate the credentials and connection.')

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    # Disable insecure warnings
    urllib3.disable_warnings()  # pylint: disable=no-member
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%f'

    REQUIRED_PERMISSIONS = (
        'offline_access',  # allows device-flow login
        'IdentityRiskEvent.Read.All',
        'IdentityRiskyUser.ReadWrite.All',
        'RoleManagement.ReadWrite.Directory',
        'Policy.ReadWrite.ConditionalAccess',
        'Policy.Read.All'
    )


    class Client:  # pragma: no cover
        def __init__(self, app_id: str, verify: bool, proxy: bool,
                     azure_ad_endpoint: str = 'https://login.microsoftonline.com', client_credentials: bool = False,
                     tenant_id: str = None, enc_key: str = None,
                     managed_identities_client_id: Optional[str] = None, private_key: Optional[str] = None,
                     certificate_thumbprint: Optional[str] = None):
            if app_id and '@' in app_id:
                app_id, refresh_token = app_id.split('@')
                integration_context = get_integration_context()
                integration_context['current_refresh_token'] = refresh_token
                set_integration_context(integration_context)
            elif client_credentials and (not enc_key and not (certificate_thumbprint and private_key)):
                raise DemistoException('Either enc_key or (Certificate Thumbprint and Private Key) must be provided. For further '
                                       'information see '
                                       'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')
            args = {
                "azure_ad_endpoint": azure_ad_endpoint,
                "self_deployed": True,
                "auth_id": app_id,
                "grant_type": CLIENT_CREDENTIALS if client_credentials else DEVICE_CODE,
                "base_url": 'https://graph.microsoft.com',
                "verify": verify,
                "proxy": proxy,
                "tenant_id": tenant_id,
                "enc_key": enc_key,
                "managed_identities_client_id": managed_identities_client_id,
                "managed_identities_resource_uri": Resources.graph,
                "certificate_thumbprint": certificate_thumbprint,
                "private_key": private_key,
                "command_prefix": "msgraph-identity",
            }
            if not client_credentials:
                args["scope"] = ' '.join(REQUIRED_PERMISSIONS)
                args["token_retrieval_url"] = 'https://login.microsoftonline.com/organizations/oauth2/v2.0/token'
            self.ms_client = MicrosoftClient(**args)  # type: ignore

        def get_directory_roles(self, limit: int) -> list:
            """Get all service principals.

            Args:
                limit: Maximum of services to get.

            Returns:
                All given service principals

            Docs:
                https://docs.microsoft.com/en-us/graph/api/directoryrole-list?view=graph-rest-1.0&tabs=http
            """
            results = []
            res = self.ms_client.http_request(
                'GET', 'v1.0/directoryRoles')
            results.extend(res.get('value'))
            while (next_link := res.get('@odata.nextLink')) and len(results) < limit:
                res = self.ms_client.http_request('GET', '', next_link)
                results.extend(res.get('value'))
            return results[:limit]

        def get_role_members(self, role_id: str, limit: int) -> dict:
            """Get all members of a specific role

            Args:
                role_id: a role id to get its members.
                limit: Maximum roles to get.

            Returns:
                directoryObject

            Docs:
                https://docs.microsoft.com/en-us/graph/api/directoryrole-list-members?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'GET', f'v1.0/directoryRoles/{role_id}/members')['value'][:limit]

        def get_ip_named_location(self, ip_id: str) -> dict:
            """Get an IP named location by id

            Args:
                ip_id: the id of the requested IP named location.

            Returns:
                a dictionary with the object from the api

            Docs:
                https://docs.microsoft.com/en-us/graph/api/ipnamedlocation-get?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'GET', f'v1.0/identity/conditionalAccess/namedLocations/{ip_id}')

        def update_ip_named_location(self, ip_id: str, data: dict) -> dict:
            """Update an IP named location by id

            Args:
                data: the request necessary to create the IP named location, json body.
                ip_id: the id of the IP named location to update.

            Returns:
                None

            Docs:
                https://docs.microsoft.com/en-us/graph/api/ipnamedlocation-update?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'PUT', f'v1.0/identity/conditionalAccess/namedLocations/{ip_id}', return_empty_response=True,
                json_data=data)

        def delete_ip_named_location(self, ip_id: str) -> dict:
            """Delete an IP named location by id

            Args:
                ip_id: the id of the requested IP named location.

            Returns:
                None

            Docs:
                https://docs.microsoft.com/en-us/graph/api/ipnamedlocation-delete?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'DELETE', f'v1.0/identity/conditionalAccess/namedLocations/{ip_id}', return_empty_response=True)

        def create_ip_named_location(self, data: dict) -> dict:
            """Create an IP named location

            Args:
                data: the request necessary to create the IP named location, json body.

            Returns:
                THe created IP named location

            Docs:
                https://docs.microsoft.com/en-us/graph/api/conditionalaccessroot-post-namedlocations?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'POST', 'v1.0/identity/conditionalAccess/namedLocations', json_data=data)

        def compromise_users(self, data: dict) -> dict:
            """Compromise users in active directory

            Args:
                data: the request necessary to compromise the users, json body.

            Returns:


            Docs:
                https://docs.microsoft.com/en-us/graph/api/riskyuser-confirmcompromised?view=graph-rest-1.0&tabs=http # noqa
            """
            return self.ms_client.http_request(
                'POST', 'v1.0/identityProtection/riskyUsers/confirmCompromised', json_data=data, return_empty_response=True)

        def dismiss_users(self, data: dict) -> dict:
            """dismiss users in active directory

            Args:
                data: the request necessary to dismiss the users, json body.

            Returns:


            Docs:
                https://docs.microsoft.com/en-us/graph/api/riskyuser-dismiss?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'POST', 'v1.0/identityProtection/riskyUsers/dismiss', json_data=data, return_empty_response=True)

        def list_ip_named_location(self, limit: str, page: str, odata: str) -> list:
            """Get a list of all IP named locations

            Args:
                limit: Maximum IP named locations to get.
                page: The page to take the data from.
                odata: An odata query to use in the api call.

            Returns:
                a list of dictionaries with the object from the api

            Docs:
                https://docs.microsoft.com/en-us/graph/api/conditionalaccessroot-list-namedlocations?view=graph-rest-1.0&tabs=http
            """
            odata_query = '?'
            if limit:
                odata_query += f'$top={limit}&'
            if page:
                odata_query += f'$skip={page}&'
            if odata:
                odata_query += f'{odata}&'
            return self.ms_client.http_request(
                'GET', f'v1.0/identity/conditionalAccess/namedLocations{odata_query}')['value']

        def list_risk_detections(self, limit: str, odata: str, odata_filter: str) -> list:
            """Get a list of all risk detections

            Args:
                limit: Maximum IP named locations to get.
                page: The page to take the data from.
                odata: An odata query to use in the api call.
                odata_filter: An odata filter

            Returns:
                a list of dictionaries with the object from the api

            Docs:
                https://docs.microsoft.com/en-us/graph/api/riskdetection-list?view=graph-rest-1.0&tabs=http
            """
            odata_query = '?'
            if limit:
                odata_query += f'$top={limit}&'
            if odata:
                odata_query += odata
            if odata_filter:
                odata_query += f'$filter={odata_filter}'
            return self.ms_client.http_request(
                'GET', f'v1.0/identityProtection/riskDetections{odata_query}')['value']

        def list_risky_users(self, limit: str, odata: str) -> list:
            """Get a list of all risky users

            Args:
                limit: Maximum IP named locations to get.
                page: The page to take the data from.
                odata: An odata query to use in the api call.

            Returns:
                a list of dictionaries with the object from the api

            Docs:
                https://docs.microsoft.com/en-us/graph/api/riskyuser-list?view=graph-rest-1.0&tabs=http
            """
            odata_query = '?'
            if limit:
                odata_query += f'$top={limit}&'
            if odata:
                odata_query += odata
            return self.ms_client.http_request(
                'GET', f'v1.0/identityProtection/riskyUsers{odata_query}')['value']

        def list_risky_users_history(self, limit: str, odata: str, user_id: str) -> list:
            """Get a list of all risky user history

            Args:
                limit: Maximum IP named locations to get.
                page: The page to take the data from.
                odata: An odata query to use in the api call.
                user_id: The user id to get the history for.

            Returns:
                a list of dictionaries with the object from the api

            Docs:
                https://docs.microsoft.com/en-us/graph/api/riskyuser-list-history?view=graph-rest-1.0&tabs=http
            """
            odata_query = '?'
            if limit:
                odata_query += f'$top={limit}&'
            if odata:
                odata_query += odata
            return self.ms_client.http_request(
                'GET', f'v1.0/identityProtection/riskyUsers/{user_id}/history{odata_query}')['value']

        def activate_directory_role(self, template_id: str) -> dict:
            """Activating a role in the directory.
            Args:
                template_id: A template id to activate

            Returns:
                directoryRole object.

            Docs:
                https://docs.microsoft.com/en-us/graph/api/directoryrole-post-directoryroles?view=graph-rest-1.0&tabs=http
            """
            return self.ms_client.http_request(
                'POST',
                'v1.0/directoryRoles',
                json_data={'roleTemplateId': template_id}
            )

        def add_member_to_role(self, role_object_id: str, user_id: str):
            """Adds a member to a specific role.

            Args:
                role_object_id: A role to add the user to.
                user_id: The user to add to the role.

            Return:
                True if succeeded.

            Raises:
                Error on failed add (as long with requests errors).

            Docs:
                https://docs.microsoft.com/en-us/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http
            """
            body = {
                '@odata.id': f'https://graph.microsoft.com/v1.0/directoryObjects/{user_id}'
            }
            self.ms_client.http_request(
                'POST',
                f'v1.0/directoryRoles/{role_object_id}/members/$ref',
                json_data=body,
                return_empty_response=True
            )

        def remove_member_from_role(self, role_object_id: str, user_id: str):
            """Removing a member from a specific role.

            Args:
                role_object_id: A role to remove the user from.
                user_id: The user to remove from the role.

            Return:
                True if succeeded.

            Raises:
                Error on failed removal (as long with requests errors).

            Docs:
                https://docs.microsoft.com/en-us/graph/api/directoryrole-delete-member?view=graph-rest-1.0&tabs=http
            """
            self.ms_client.http_request(
                'DELETE',
                f'v1.0/directoryRoles/{role_object_id}/members/{user_id}/$ref',
                return_empty_response=True
            )


    ''' COMMAND FUNCTIONS '''


    def start_auth(client: Client) -> CommandResults:  # pragma: no cover
        result = client.ms_client.start_auth('!msgraph-identity-auth-complete')
        return CommandResults(readable_output=result)


    def complete_auth(client: Client) -> str:  # pragma: no cover
        client.ms_client.get_access_token()
        return ' Authorization completed successfully.'


    def test_connection(client: Client) -> str:  # pragma: no cover
        client.ms_client.get_access_token()
        return ' Success!'


    def list_directory_roles(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        """Lists all service principals

        Args:
            ms_client: The Client
            args: demisto.args()

        Returns:
            Results to post in demisto
        """
        limit_str = args.get('limit', '')
        try:
            limit = int(limit_str)
        except ValueError:
            raise DemistoException(f'Limit must be an integer, not "{limit_str}"')
        results = ms_client.get_directory_roles(limit)
        return CommandResults(
            "MSGraphIdentity.Role",
            "id",
            outputs=results,
            readable_output=tableToMarkdown(
                'Directory roles:',
                results,
                ['id', 'displayName', 'description', 'roleTemplateId', 'deletedDateTime'],
                removeNull=True
            )
        )


    def list_role_members_command(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        """Lists all service principals

        Args:
            ms_client: The Client
            args: demisto.args()

        Returns:
            Results to post in demisto
        """
        limit_str = args.get('limit', '')
        try:
            limit = int(limit_str)
        except ValueError:
            raise DemistoException(f'Limit must be an integer, not "{limit_str}"')
        role_id = args.get('role_id')
        if results := ms_client.get_role_members(role_id, limit):  # type: ignore
            ids = [member['id'] for member in results]
            context = {
                'role_id': role_id,
                'user_id': ids
            }
            return CommandResults(
                'MSGraphIdentity.RoleMember',
                'role_id',
                outputs=context,
                raw_response=results,
                readable_output=tableToMarkdown(
                    f'Role \'{role_id}\' members:',
                    context
                )
            )
        else:
            return CommandResults(readable_output=f"No members found in {role_id}")


    def activate_directory_role_command(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        template_id = args.get('role_template_id')
        results = ms_client.activate_directory_role(template_id)  # type: ignore
        return CommandResults(
            "MSGraphIdentity.Role",
            "id",
            outputs=results,
            readable_output=tableToMarkdown(
                'Role has been activated',
                results,
                ['id', 'roleTemplateId', 'displayName', 'description', 'deletedDateTime']
            )
        )


    def add_member_to_role_command(client: Client, args: dict) -> str:  # pragma: no cover
        user_id = args.get('user_id')
        role_object_id = args.get('role_id')
        client.add_member_to_role(role_object_id, user_id)  # type: ignore
        return f"User ID {user_id} has been added to role {role_object_id}"


    def remove_member_from_role(client: Client, args: dict) -> str:  # pragma: no cover
        role_object_id = args.get('role_id')
        user_id = args.get('user_id')
        client.remove_member_from_role(role_object_id, user_id)  # type: ignore
        return f"User ID {user_id} has been removed from role {role_object_id}"


    def ip_named_location_get(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        ip_id = args.get('ip_id')
        if results := ms_client.get_ip_named_location(ip_id):  # type: ignore
            context = {
                'id': ip_id,
                'display_name': results.get('displayName'),
                'time_created': results.get('createdDateTime'),
                'time_modified': results.get('modifiedDateTime'),
                'is_trusted': results.get('isTrusted'),
                'ip_ranges': results.get('ipRanges')
            }
            return CommandResults(
                'MSGraph.conditionalAccess.namedIpLocations',
                'namedIpLocations',
                outputs=context,
                raw_response=results,
                ignore_auto_extract=True,
                readable_output=tableToMarkdown(
                    f'IP named location \'{ip_id}\':',
                    context
                )
            )
        return CommandResults(readable_output=f"No IP location found for {ip_id}")


    def ip_named_location_update(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        ip_id = args.get('ip_id')
        if results := ms_client.get_ip_named_location(ip_id):  # type: ignore
            data = {
                '@odata.type': '#microsoft.graph.ipNamedLocation',
                'displayName': results.get('displayName'),
                'isTrusted': results.get('isTrusted'),
                'ipRanges': results.get('ipRanges')
            }
            ips = args.get('ips')
            is_trusted = args.get('is_trusted')
            display_name = args.get('display_name')
            if ips:
                ips = ms_ip_string_to_list(ips)
                data['ipRanges'] = ips
            if is_trusted:
                data['isTrusted'] = is_trusted
            if display_name:
                data['displayName'] = display_name
            ms_client.update_ip_named_location(ip_id, data)  # type: ignore
            return CommandResults(
                'MSGraph.conditionalAccess.namedIpLocations',
                'namedIpLocations',
                outputs={},
                raw_response={},
                ignore_auto_extract=True,
                readable_output=f'Successfully  updated IP named location \'{ip_id}\''
            )
        return CommandResults(readable_output=f'Could not update IP named location \'{ip_id}\'')


    def ip_named_location_create(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        ips = args.get('ips')
        is_trusted = args.get('is_trusted')
        display_name = args.get('display_name')
        if ips and display_name and is_trusted:
            is_trusted = str(is_trusted).lower() == 'true'
            ips_arr = ms_ip_string_to_list(ips)
            data = {
                '@odata.type': '#microsoft.graph.ipNamedLocation',
                'displayName': display_name,
                'isTrusted': is_trusted,
                'ipRanges': ips_arr
            }
            if results := ms_client.create_ip_named_location(data):
                id = results.get('id')
                context = {
                    'id': id,
                    'display_name': results.get('displayName'),
                    'time_created': results.get('createdDateTime'),
                    'time_modified': results.get('modifiedDateTime'),
                    'is_trusted': results.get('isTrusted'),
                    'ip_ranges': results.get('ipRanges')
                }
                return CommandResults(
                    'MSGraph.conditionalAccess.namedIpLocations',
                    'namedIpLocations',
                    outputs=context,
                    raw_response=results,
                    ignore_auto_extract=True,
                    readable_output=tableToMarkdown(
                        f'created IP named location \'{id}\':',
                        context
                    )
                )
        return CommandResults(readable_output="Could not create IP named location")


    def azure_ad_identity_protection_confirm_compromised_command(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover  # noqa
        user_ids = str(args.get('user_ids')).split(',')
        data = {
            'userIds': user_ids
        }
        try:
            ms_client.compromise_users(data)
            return CommandResults(
                raw_response={},
                ignore_auto_extract=True,
                readable_output=f'Successfully compromised {str(user_ids)}'
            )
        except Exception as e:
            return CommandResults(readable_output=f"Could not compromised {str(user_ids)}:\n{e}")


    def azure_ad_identity_protection_risky_users_dismiss_command(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover  # noqa
        user_ids = str(args.get('user_ids')).split(',')
        data = {
            'userIds': user_ids
        }
        try:
            ms_client.dismiss_users(data)
            return CommandResults(
                raw_response={},
                ignore_auto_extract=True,
                readable_output=f'Successfully dismissed {str(user_ids)}'
            )
        except Exception as e:
            return CommandResults(readable_output=f"Could not dismiss {str(user_ids)}:\n{e}")


    def ip_named_location_delete(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        ip_id = args.get('ip_id')
        if results := ms_client.delete_ip_named_location(ip_id):  # type: ignore  # noqa
            return CommandResults(
                'MSGraph.conditionalAccess.namedIpLocations',
                'namedIpLocations',
                outputs={},
                raw_response={},
                ignore_auto_extract=True,
                readable_output=f'Successfully deleted IP named location \'{ip_id}\''
            )
        return CommandResults(readable_output=f'Could not delete IP named location \'{ip_id}\'')


    def ip_named_location_list(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover
        limit = args.get('limit')
        page = args.get('page')
        odata = args.get('odata_query')
        if results := ms_client.list_ip_named_location(limit, page, odata):  # type: ignore
            ip_named_locations = []
            for result in results:
                ip_named_location = {
                    'id': result.get('id'),
                    'display_name': result.get('displayName'),
                    'time_created': result.get('createdDateTime'),
                    'time_modified': result.get('modifiedDateTime'),
                    'is_trusted': result.get('isTrusted'),
                    'ip_ranges': result.get('ipRanges')
                }
                ip_named_locations.append(ip_named_location)
            context = {
                'ip_named_locations': ip_named_locations
            }
            return CommandResults(
                'MSGraph.conditionalAccess.namedIpLocations',
                'namedIpLocations',
                outputs=context,
                raw_response=results,
                ignore_auto_extract=True,
                readable_output=tableToMarkdown(
                    'IP named locations:',
                    ip_named_locations,
                )
            )
        else:
            return CommandResults(readable_output="could not list IP named locations")


    def azure_ad_identity_protection_risky_users_list(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover  # noqa
        limit = args.get('limit')
        odata = args.get('odata_query')
        if results := ms_client.list_risky_users(limit, odata):  # type: ignore
            risky_users = []
            for result in results:
                risky_user = {
                    'id': result.get('id'),
                    'isDeleted': result.get('isDeleted'),
                    'isProcessing': result.get('isProcessing'),
                    'riskLevel': result.get('riskLevel'),
                    'riskState': result.get('riskState'),
                    'riskDetail': result.get('riskDetail'),
                    'riskLastUpdatedDateTime': result.get('riskLastUpdatedDateTime'),
                    'userDisplayName': result.get('userDisplayName'),
                    'userPrincipalName': result.get('userPrincipalName'),
                }
                risky_users.append(risky_user)
            context = {
                'riskyUsers': risky_users
            }
            return CommandResults(
                'MSGraph.identityProtection.riskyUsers',
                'riskyUsers',
                outputs=context,
                raw_response=results,
                ignore_auto_extract=True,
                readable_output=tableToMarkdown(
                    'Risky users:',
                    risky_users,
                )
            )
        else:
            return CommandResults(readable_output="could not list IP named locations")


    def azure_ad_identity_protection_risky_users_history_list(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover  # noqa
        limit = args.get('limit')
        odata = args.get('odata_query')
        user_id = args.get('user_id')
        if results := ms_client.list_risky_users_history(limit, odata, user_id):  # type: ignore
            risky_users = []
            for result in results:
                risky_user = {
                    'id': result.get('id'),
                    'isDeleted': result.get('isDeleted'),
                    'isProcessing': result.get('isProcessing'),
                    'riskLevel': result.get('riskLevel'),
                    'riskState': result.get('riskState'),
                    'riskDetail': result.get('riskDetail'),
                    'riskLastUpdatedDateTime': result.get('riskLastUpdatedDateTime'),
                    'userDisplayName': result.get('userDisplayName'),
                    'userPrincipalName': result.get('userPrincipalName'),
                    'userId': result.get('userId'),
                    'initiatedBy': result.get('initiatedBy'),
                    'activity': result.get('activity'),
                }
                risky_users.append(risky_user)
            context = {
                'riskyUsers': risky_users
            }
            return CommandResults(
                'MSGraph.identityProtection.riskyUsers',
                'riskyUsers',
                outputs=context,
                raw_response=results,
                ignore_auto_extract=True,
                readable_output=tableToMarkdown(
                    'Risky users history:',
                    risky_users,
                )
            )
        else:
            return CommandResults(readable_output="could not list IP named locations")


    def azure_ad_identity_protection_risk_detection_list(ms_client: Client, args: dict) -> CommandResults:  # pragma: no cover  # noqa
        limit = args.get('limit')
        odata = args.get('odata_query')
        odata_filter = args.get('filter')
        if results := ms_client.list_risk_detections(limit, odata, odata_filter):  # type: ignore
            risks = []
            for result in results:
                risk = {
                    'id': result.get('id'),
                    'requestId': result.get('requestId'),
                    'correlationId': result.get('correlationId'),
                    'riskEventType': result.get('riskEventType'),
                    'riskState': result.get('riskState'),
                    'riskLevel': result.get('riskLevel'),
                    'riskDetail': result.get('riskDetail'),
                    'source': result.get('source'),
                    'detectionTimingType': result.get('detectionTimingType'),
                    'activity': result.get('activity'),
                    'ipAddress': result.get('ipAddress'),
                    'activityDateTime': result.get('activityDateTime'),
                    'detectedDateTime': result.get('detectedDateTime'),
                    'lastUpdatedDateTime': result.get('lastUpdatedDateTime'),
                    'userId': result.get('userId'),
                    'userDisplayName': result.get('userDisplayName'),
                    'userPrincipalName': result.get('userPrincipalName'),
                    'additionalInfo': result.get('additionalInfo'),
                    'location': result.get('location')
                }
                risks.append(risk)
            context = {
                'riskDetections': risks
            }
            return CommandResults(
                'MSGraph.identityProtection.risks',
                'riskDetections',
                outputs=context,
                raw_response=results,
                ignore_auto_extract=True,
                readable_output=tableToMarkdown(
                    'Risks detected:',
                    risks,
                )
            )
        else:
            return CommandResults(readable_output="could not list IP named locations")


    def ms_ip_string_to_list(ips: str) -> list:
        ips_arr = []
        ips = ips.split(',')
        for ip in ips:
            temp = {'cidrAddress': ip}
            # ipv4 check
            if '.' in ip:
                temp['@odata.type'] = '#microsoft.graph.iPv4CidrRange'
            # ipv6 check
            elif ':' in ip:
                temp['@odata.type'] = '#microsoft.graph.iPv6CidrRange'
            else:
                continue
            ips_arr.append(temp)
        return ips_arr


    def get_last_fetch_time(last_run: dict, params: dict):
        last_fetch = last_run.get('latest_detection_found')
        if not last_fetch:
            demisto.debug('[AzureADIdentityProtection] First run')
            # handle first time fetch
            first_fetch = f"{params.get('first_fetch') or '1 days'} ago"
            default_fetch_datetime = dateparser.parse(date_string=first_fetch, date_formats=[DATE_FORMAT])
            assert default_fetch_datetime is not None, f'failed parsing {first_fetch}'
            last_fetch = str(default_fetch_datetime.isoformat(timespec='milliseconds')) + 'Z'

        demisto.debug(f'[AzureADIdentityProtection] last_fetch: {last_fetch}')
        return last_fetch


    def date_str_to_azure_format(date_str: str) -> str:
        """
        Given a string representing a date in some general format, modifies the date to Azure format.
        That means removing the Z at the end and adding nanoseconds if they don't exist.
        Moreover, sometimes the date has too many digits for
        """
        date_str = date_str[:-1] if date_str[-1].lower() == 'z' else date_str
        if '.' not in date_str:
            date_str = f'{date_str}.000'
        else:
            date_without_ns, ns = date_str.split('.')
            ns = ns[:6]
            date_str = f'{date_without_ns}.{ns}'

        return date_str


    def detection_to_incident(detection: dict, detection_date: str) -> dict:
        detection_id: str = detection.get('id', '')
        detection_type: str = detection.get('riskEventType', '')
        detection_detail: str = detection.get('riskDetail', '')
        incident = {
            'name': f'Azure AD:'
                    f' {detection_id} {detection_type} {detection_detail}',
            'occurred': f'{detection_date}Z',
            'rawJSON': json.dumps(detection)
        }
        return incident


    def detections_to_incidents(detections: List[Dict[str, str]], last_fetch_datetime: str) -> tuple[List[Dict[str, str]], str]:  # pragma: no cover  # noqa
        """
        Given the detections retrieved from Azure Identity Protection, transforms their data to incidents format.
        """
        incidents: List[Dict[str, str]] = []
        latest_incident_time = last_fetch_datetime

        for detection in detections:
            detection_datetime = detection.get('detectedDateTime', '')
            detection_datetime_in_azure_format = date_str_to_azure_format(detection_datetime)
            incident = detection_to_incident(detection, detection_datetime_in_azure_format)
            incidents.append(incident)

            if datetime.strptime(detection_datetime_in_azure_format, DATE_FORMAT) > \
                    datetime.strptime(date_str_to_azure_format(latest_incident_time), DATE_FORMAT):
                latest_incident_time = detection_datetime

        return incidents, latest_incident_time


    def build_filter(last_fetch: datetime, params: dict) -> str:
        start_time_enforcing_filter = f"detectedDateTime gt {last_fetch}"
        user_supplied_filter = params.get('fetch_filter_expression', '')
        query_filter = f'({user_supplied_filter}) and {start_time_enforcing_filter}' if user_supplied_filter \
            else start_time_enforcing_filter
        demisto.debug(f'[AzureADIdentityProtection] query_filter: {query_filter}')
        return query_filter


    def fetch_incidents(client: Client, params: Dict[str, str]):  # pragma: no cover
        last_run: Dict[str, str] = demisto.getLastRun()
        demisto.debug(f'[AzureIdentityProtection] last run: {last_run}')

        last_fetch = get_last_fetch_time(last_run, params)
        query_filter = build_filter(last_fetch, params)
        demisto.debug(f'last fetch is: {last_fetch}, filter is: {query_filter}')

        limit = params.get('max_fetch', '50')
        filter_expression = query_filter

        detections: list = client.list_risk_detections(limit, None, filter_expression)  # type: ignore

        incidents, latest_detection_time = detections_to_incidents(detections, last_fetch_datetime=last_fetch)  # type: ignore
        demisto.debug(f'Fetched {len(incidents)} incidents')

        demisto.debug(f'next run latest_detection_found: {latest_detection_time}')
        last_run = {
            'latest_detection_found': latest_detection_time,
        }

        return incidents, last_run


    def main():  # pragma: no cover
        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            command = demisto.command()
            params = demisto.params()
            args = demisto.args()
            handle_proxy()
            client = Client(
                app_id=params.get('app_id'),
                verify=not params.get('insecure', False),
                proxy=params.get('proxy', False),
                azure_ad_endpoint=params.get('azure_ad_endpoint',
                                             'https://login.microsoftonline.com') or 'https://login.microsoftonline.com',
                tenant_id=params.get("tenant_id"),
                client_credentials=params.get("client_credentials", False),
                enc_key=(params.get('credentials') or {}).get('password'),
                managed_identities_client_id=get_azure_managed_identities_client_id(params),
                certificate_thumbprint=params.get('creds_certificate', {}).get('identifier'),
                private_key=(replace_spaces_in_credential(params.get('creds_certificate', {}).get('password')))
            )
            if command == 'test-module':
                if client.ms_client.managed_identities_client_id or client.ms_client.grant_type == CLIENT_CREDENTIALS:
                    test_connection(client=client)
                    return_results('ok')
                else:
                    return_results('The test module is not functional, run the msgraph-identity-auth-start command instead.')
            elif command == 'msgraph-identity-auth-start':
                return_results(start_auth(client))
            elif command == 'msgraph-identity-auth-complete':
                return_results(complete_auth(client))
            elif command == 'msgraph-identity-auth-test':
                return_results(test_connection(client))
            elif command == 'msgraph-identity-auth-reset':
                return_results(reset_auth())
            elif command == 'msgraph-identity-directory-roles-list':
                return_results(list_directory_roles(client, args))
            elif command == 'msgraph-identity-directory-role-members-list':
                return_results(list_role_members_command(client, args))
            elif command == 'msgraph-identity-directory-role-activate':
                return_results(activate_directory_role_command(client, args))
            elif command == 'msgraph-identity-directory-role-member-add':
                return_results(add_member_to_role_command(client, args))
            elif command == 'msgraph-identity-directory-role-member-remove':
                return_results(remove_member_from_role(client, args))
            elif command == 'msgraph-identity-ip-named-locations-create':
                return_results(ip_named_location_create(client, args))
            elif command == 'msgraph-identity-ip-named-locations-get':
                return_results(ip_named_location_get(client, args))
            elif command == 'msgraph-identity-ip-named-locations-update':
                return_results(ip_named_location_update(client, args))
            elif command == 'msgraph-identity-ip-named-locations-delete':
                return_results(ip_named_location_delete(client, args))
            elif command == 'msgraph-identity-ip-named-locations-list':
                return_results(ip_named_location_list(client, args))
            elif command == 'msgraph-identity-protection-risks-list':
                return_results(azure_ad_identity_protection_risk_detection_list(client, args))
            elif command == 'msgraph-identity-protection-risky-user-list':
                return_results(azure_ad_identity_protection_risky_users_list(client, args))
            elif command == 'msgraph-identity-protection-risky-user-history-list':
                return_results(azure_ad_identity_protection_risky_users_history_list(client, args))
            elif command == 'msgraph-identity-protection-risky-user-confirm-compromised':
                return_results(azure_ad_identity_protection_confirm_compromised_command(client, args))
            elif command == 'msgraph-identity-protection-risky-user-dismiss':
                return_results(azure_ad_identity_protection_risky_users_dismiss_command(client, args))
            elif command == 'fetch-incidents':
                incidents, last_run = fetch_incidents(client, params)
                demisto.incidents(incidents)
                demisto.setLastRun(last_run)
            else:
                raise NotImplementedError(f"Command '{command}' not found.")

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):  # pragma: no cover
        main()

    register_module_line('MicrosoftGraphIdentityandAccess', 'end', __line__())
  subtype: python3
  type: python
system: true
