category: Utilities
commonfields:
  id: SMIME Messaging
  version: -1
configuration:
- additionalinfo: Sender public key required for signing emails.
  display: Public Key
  name: public_key
  required: true
  type: 12
- additionalinfo: Sender private key required for decrypting and signing emails.
  display: Private Key
  name: private_key
  required: true
  type: 14
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.0.0
    packID: SMIME_Messaging
    packName: SMIME Messaging
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Use the S/MIME (Secure Multipurpose Internet Mail Extensions) integration
  to send and receive secure MIME data.
detaileddescription: "\n## Configure an RSA Key and Certificate\n\n1. Run the following
  command: `openssl req -newkey rsa:1024 -nodes -x509 -days 365 -out CERTIFICATE -keyout
  PRIVATE`\n\n   - **CERTIFICATE** is the out public certificate file name. \n   -
  **PRIVATE** is the out private key file name.\n2. Copy the text from CERTIFICATE
  to the **Public Key** field when configuring the integration instance.\n3. copy
  the text from PRIVATE to **Private Key** field when configuring the integration
  instance.\n\n## Certificate usage\n\n- Signing emails uses the public/private keys
  from the instance parameters.\n- Email encryption requires the public certificate
  of the receiver.\n  - Provided on command call, use `instancePublicKey` to use the
  instance params.\n- Decrypting emails uses the private key from the instance parameters.\n-
  Verifying emails looks for the certificate in the signed message.\n  - A different
  certificate can be provided if needed.\n\nSee [here for more information](https://m2crypto.readthedocs.io/en/latest/howto.smime.html#howto-smime).\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/smime-messaging)"
display: SMIME Messaging
image: data:image/png;base64,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
name: SMIME Messaging
script:
  commands:
  - arguments:
    - description: The message body to send.
      name: message_body
      required: true
    - auto: PREDEFINED
      description: Set 'true' to use content transfer encoding.
      name: use_transport_encoding
      predefined:
      - "false"
      - "true"
    deprecated: true
    description: |-
      Deprecated. Use smime-sign-and-encrypt instead.
      Retrieves items from the service.
    name: smime-sign-email
    outputs:
    - contextPath: SMIME.Signed.Message
      description: The signed message body.
      type: String
    - contextPath: SMIME.Signed.Headers
      description: The S/MIME signing headers.
      type: String
  - arguments:
    - description: The message body to encrypt.
      name: message
      required: true
    deprecated: true
    description: |-
      Deprecated. Use smime-sign-and-encrypt instead.
      Encrypts an email message with S/MIME protocol by using a public RSA certificate.
    name: smime-encrypt-email-body
    outputs:
    - contextPath: SMIME.Encrypted.Message
      description: The encrypted message.
      type: String
    - contextPath: SMIME.Encrypted.Headers
      description: The encryption headers.
      type: String
  - arguments:
    - description: Entity ID of the file with a .p7 extension containing the signed
        message.
      name: signed_message
      required: true
    - defaultValue: instancePublicKey
      description: Sender's public key to verify.
      name: public_key
    - auto: PREDEFINED
      description: Whether to get the full raw output of the email.
      name: raw_output
      predefined:
      - "false"
      - "true"
    - description: A comma-separated list of tags to be included in the War Room output.
      name: tag
    description: |-
      Verifies the signature.

      Warning: This function does not check the CA chain. Ensure the certificate chain is validated separately to avoid security risks.
    name: smime-verify-sign
    outputs:
    - contextPath: SMIME.Verified.Message
      description: The decoded signed message.
      type: String
  - arguments:
    - description: Entity ID of the file with a .p7 extension containing the encrypted
        email.
      name: encrypt_message
      required: true
    - description: The encoding code to use when decode the message body, e.g 'ISO-8859-2''.
      name: encoding
    - auto: PREDEFINED
      description: Whether to get the full raw output of the email.
      name: raw_output
      predefined:
      - "false"
      - "true"
    - description: A comma-separated list of tags to be included in the War Room output.
      name: tag
    description: Decrypts the message body.
    name: smime-decrypt-email-body
    outputs:
    - contextPath: SMIME.Decrypted.Message
      description: The decrypted message.
      type: String
  - arguments:
    - description: The message body to encrypt and sign.
      name: message
      required: true
    - description: |-
        JSON dict of recipients and their public keys
        Format: {"recipient@email":"cert", "other@email":"cert"}
        Use "instancePublicKey" in the cert field to use the instance certificate.
      name: recipients
    - description: |-
        JSON dict of cc recipients and their public keys
        Format: {"cc@email":"cert", "othercc@email":"cert"}
        Use "instancePublicKey" in the cert field to use the instance certificate.
      name: cc
    - description: |-
        JSON dict of bcc recipients and their public keys
        Format: {"bcc@email":"cert", "otherbcc@email":"cert"}
        Use "instancePublicKey" in the cert field to use the instance certificate.
      name: bcc
    - description: List of War Room entry IDs of files to attach to the mail.
      isArray: true
      name: attachment_entry_id
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether the mail should be signed.
      name: signed
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether the mail should be encrypted.
      name: encrypted
      predefined:
      - "true"
      - "false"
    - description: Sender email address.
      name: sender
    - description: Email subject.
      name: subject
    - auto: PREDEFINED
      description: Whether to create a file with the encrypted/signed content.
      name: create_file_p7
      predefined:
      - "false"
      - "true"
    description: Encrypts and signs an email message with S/MIME protocol by using
      a public RSA certificate.
    name: smime-sign-and-encrypt
    outputs:
    - contextPath: SMIME.SignedAndEncrypted.Message
      description: The raw message to send.
      type: String
    - contextPath: SMIME.SignedAndEncrypted.RecipientIds
      description: Address of the recipient.
      type: String
    - contextPath: SMIME.SignedAndEncrypted.FileName
      description: Name of the file output if create_file_p7 is used.
      type: String
  dockerimage: demisto/m2crypto:1.0.0.108031
  runonce: false
  script: |
    register_module_line('SMIME Messaging', 'start', __line__())
    ### pack version: 2.0.0




    ''' IMPORTS '''

    from M2Crypto import BIO, SMIME, X509
    from tempfile import NamedTemporaryFile

    from charset_normalizer import from_bytes
    import quopri
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.mime.base import MIMEBase
    from email import encoders, message_from_string
    from email.message import Message
    import pytz
    import mimetypes
    import uuid


    ''' HELPER FUNCTIONS '''


    def makebuf(text):
        return BIO.MemoryBuffer(text)


    def create_pem_string(base64_cert: str) -> str:
        """Converts a base64 encoded certificate string to a PEM format.

        Args:
            base64_cert (str): certificate string with no BEGIN or END markers

        Returns:
            pemstring (str): PEM-formatted certificate string
        """
        pem_header = '-----BEGIN CERTIFICATE-----\n'
        pem_footer = '-----END CERTIFICATE-----\n'

        # Split the base64 certificate into lines of 64 characters each
        pem_body = '\n'.join(base64_cert[i:i + 64] for i in range(0, len(base64_cert), 64))

        return f"{pem_header}{pem_body}\n{pem_footer}"


    def handle_attachment(attachment_part: Message) -> None:
        """
        Extracts and saves the attachment file to the context.
        p7 files will be ignored.

        Args:
            attachment_part (Message): attachment message part

        """

        file_name = attachment_part.get_filename()
        if not file_name:
            demisto.debug('Got nameless attachment, generating file name')
            mime_type = attachment_part.get_content_type()
            extension = mimetypes.guess_extension(mime_type) or '.bin'
            file_name = f'attachment_{uuid.uuid4()}{extension}'

        # ignore p7 file types and subtypes (e.g. p7m)
        if (file_name.lower().endswith('.p7')
                or file_name.lower().endswith('.p7', 0, -1)):
            demisto.debug(f'Skipping p7 file: {file_name}')
            return
        # create the attachment
        file_result = fileResult(file_name, attachment_part.get_payload(decode=True))

        # check for error
        if file_result['Type'] == entryTypes['error']:
            raise Exception(file_result['Contents'])

        # return the attachment to war room
        return_results(file_result)


    def handle_image(image_part: Message, payload: Any) -> tuple[str, str, str] | None:
        """
        Handles the payload for an image, extracting the cid and image data

        Args:
            image_part (Message): Image message part
            payload (Any): Message part payload

        Returns:
            (cid, content_type, image_data): Complete image data to allow embedding into the message, None if no cid is found

        """
        content_type = image_part.get_content_type()
        image_data_base64 = base64.b64encode(payload).decode('utf-8')

        cid = image_part.get('Content-Id')
        if not cid:
            return None

        # Remove angle brackets if present around CID
        cid = re.sub(r'<(.*?)>', r'\1', cid)

        return cid, content_type, image_data_base64


    def extract_email_body(text_part: Message, payload: Any) -> tuple[str, str]:
        """
        Handles the payload for the email body part

        Args:
            text_part (Message): Text message part
            payload (Any): Message part payload

        Returns:
            (email_body, body_type): Strings containing the email body and the body type (text or html)

        """
        email_body = payload.decode(text_part.get_content_charset('utf-8'), errors='ignore')
        if text_part.get_content_type() == 'text/html':
            body_type = 'html'
            # Clean up whitespaces between </head> and <body> tags
            email_body = re.sub(r'</head>\s*<body>', '</head><body>', email_body)
        else:
            body_type = 'text'

        return email_body, body_type


    def patch_cid_with_urls(email_body: str, images: list[tuple[str, str, str]]) -> str:
        """
        Replaces HTML image references with their data URLs

        Args:
            email_body (str): The html email message to patch
            images (list): List of images found in the message, each containing (cid, type, data)

        Returns:
            patched_body (str): email body with patched URLs

        """
        patched_body = email_body
        for cid, content_type, image_data_base64 in images:
            cid_reference = f'cid:{cid}'
            data_url = f'data:{content_type};base64,{image_data_base64}'
            patched_body = patched_body.replace(cid_reference, data_url)

        return patched_body


    def parse_multipart_message(msg: str) -> tuple[str, str]:
        """
        Extracts the contents from a MIME message.
        Images (if any exist) will be added to the html email_body,
        attachments will be added to the context directly.

        Args:
            msg (str): Message to parse

        Returns:
            (email_body, body_type): Strings containing the parsed email, and the message type (text or html)

        """
        email_message = message_from_string(msg)
        if email_message.get_content_type() == 'multipart/signed':
            # The message is signed
            return ('', '')
        email_body = ''
        body_type = ''
        images: list[tuple[str, str, str]] = []

        for part in email_message.walk():
            if part.is_multipart():
                continue

            content_type = part.get_content_type()
            if content_type in {'application/pkcs7-signature', 'application/pkcs7-mime', 'application/x-pkcs7-mime'}:
                # The message is signed
                return ('', '')

            if part.get_content_disposition() == 'attachment':
                handle_attachment(part)
                continue

            payload = part.get_payload(decode=True)
            if not isinstance(payload, bytes):
                raise TypeError(f'Error in message.get_payload(decode=True), expected bytes, got: {type(payload)}')

            if part.get_content_maintype() == 'image':
                if image := handle_image(part, payload):
                    images.append(image)

            elif part.get_content_maintype() == 'text' and body_type != 'html':
                email_body, body_type = extract_email_body(part, payload)

        if body_type == 'html':
            email_body = patch_cid_with_urls(email_body, images)

        return (email_body, body_type)


    def create_message_with_attachments(message: str, attach_ids: list[str]) -> str:
        """
        Creates a MIMEMultipart formatted message with message body and attachments

        Args:
            message (str): Message body
            attach_ids (list): list of war room entries containing files to attach

        Returns:
            msg (str): Formatted mime message with attachments added

        """
        msg = MIMEMultipart()

        is_html = bool(re.search(r'<.*?>', message))
        if is_html:
            msg.attach(MIMEText(message, 'html'))
        else:
            msg.attach(MIMEText(message, 'plain'))

        # Add attachments to message
        for attach_id in attach_ids:
            try:
                fp = demisto.getFilePath(attach_id)
                file_path = fp['path']
                attach_name = fp['name']
            except Exception as ex:
                raise Exception(f'Error while opening attachment id {attach_id}: {str(ex)}')
            if isinstance(attach_name, list):
                attach_name = attach_name[0]
            part = MIMEBase('application', 'octet-stream')
            with open(file_path, 'rb') as f:
                part.set_payload(f.read())
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', f'attachment; filename={attach_name}')
                msg.attach(part)

        return msg.as_string()


    def create_email_header(sender: str, subject: str, recipients: list[str], cc: list[str], bcc: list[str]) -> BIO.MemoryBuffer:
        """
        Creates a memory buffer with email headers

        Args:
            sender (str): Sender email
            subject (str): Email subject
            recipients (list): List of recipient emails
            cc (list): List of cc emails
            bcc (list): List of bcc emails

        Returns:
            header (MemoryBuffer): memory buffer containing email headers

        """
        header = BIO.MemoryBuffer()

        current_time = datetime.now(pytz.timezone('UTC')).strftime('%a, %d %b %Y %H:%M:%S %z')
        header.write(f'Date: {current_time}\r\n')
        if sender:
            header.write(f'From: {sender}\r\n')
        if recipients:
            header.write(f'To: {", ".join(recipients)}\r\n')
        if cc:
            header.write(f'CC: {", ".join(cc)}\r\n')
        if bcc:
            header.write(f'BCC: {", ".join(bcc)}\r\n')
        if subject:
            header.write(f'Subject: {subject}\r\n')

        return header


    class Client:
        def __init__(self, private_key, public_key):
            self.smime = SMIME.SMIME()

            public_key_file = NamedTemporaryFile(delete=False)
            public_key_file.write(bytes(public_key, 'utf-8'))
            self.public_key_file = public_key_file.name
            public_key_file.close()

            private_key_file = NamedTemporaryFile(delete=False)
            private_key_file.write(bytes(private_key, 'utf-8'))
            self.private_key_file = private_key_file.name
            private_key_file.close()


    def set_encryption_params(client: Client, certs: list[str]) -> None:
        """
        Sets the smime cipher and X509 certificate stack

        Args:
            client: Client
            certs: List of recipient certificates to use for the encryption

        """
        client.smime.set_cipher(SMIME.Cipher('aes_256_cbc'))

        # Create and set certificate stack
        cert_stack = X509.X509_Stack()
        if not certs:
            demisto.debug('No certs given, using instance cert')
            cert_stack.push(X509.load_cert(client.public_key_file))
        for cert in certs:
            if cert == 'instancePublicKey':
                cert_stack.push(X509.load_cert(client.public_key_file))
                continue
            if ('-----BEGIN CERTIFICATE-----') not in cert:
                demisto.debug('No ---BEGIN CERTIFICATE--- tag, creating pem from cert')
                cert = create_pem_string(cert)

            with NamedTemporaryFile(delete=False) as public_key_file:
                public_key_file.write(bytes(cert, 'utf-8'))
                public_key_file.close()
                cert_stack.push(X509.load_cert(public_key_file.name))
                os.unlink(public_key_file.name)

        client.smime.set_x509_stack(cert_stack)


    ''' COMMANDS '''


    def sign_email(client: Client, args: dict):
        """
        send a S/MIME-signed message via SMTP.
        """
        use_transport_encoding: bool = argToBoolean(args.get('use_transport_encoding', 'false'))
        if use_transport_encoding:
            message_body = (
                b'Content-Type: text/plain;  charset="utf-8"\nContent-Transfer-Encoding: quoted-printable\n\n'
                + quopri.encodestring(args.get('message_body', '').encode("utf-8"))
            )
            buf = makebuf(message_body)

            client.smime.load_key(client.private_key_file, client.public_key_file)
            p7 = client.smime.sign(buf, SMIME.PKCS7_DETACHED)

            buf = makebuf(message_body)
            out = BIO.MemoryBuffer()

            client.smime.write(out, p7, buf)
        else:
            message_body = args.get('message_body', '')
            buf = makebuf(message_body.encode())  # type: ignore

            client.smime.load_key(client.private_key_file, client.public_key_file)
            p7 = client.smime.sign(buf, SMIME.PKCS7_DETACHED)

            buf = makebuf(message_body.encode())  # type: ignore
            out = BIO.MemoryBuffer()

            client.smime.write(out, p7, buf, SMIME.PKCS7_TEXT)
        signed = out.read().decode('utf-8')
        signed_message = signed.split('\n\n')
        headers = signed_message[0].replace(': ', '=').replace('\n', ',')

        return CommandResults(
            readable_output=signed,
            outputs_prefix='SMIME.Signed',
            outputs={'Message': signed,
                     'Headers': headers,
                     }
        )


    def encrypt_email_body(client: Client, args: dict):
        """ generate an S/MIME-encrypted message

        Args:
            client: Client
            args: Dict

        """
        message_body = args.get('message', '').encode('utf-8')
        buf = makebuf(message_body)

        x509 = X509.load_cert(client.public_key_file)
        sk = X509.X509_Stack()
        sk.push(x509)
        client.smime.set_x509_stack(sk)
        client.smime.set_cipher(SMIME.Cipher('des_ede3_cbc'))
        p7 = client.smime.encrypt(buf)
        out = BIO.MemoryBuffer()

        client.smime.write(out, p7)
        encrypted_message = out.read().decode('utf-8')
        message = encrypted_message.split('\n\n')
        headers = message[0]
        new_headers = headers.replace(': ', '=').replace('\n', ',')

        return CommandResults(
            readable_output=encrypted_message,
            outputs_prefix='SMIME.Encrypted',
            outputs={'Message': encrypted_message,
                     'Headers': new_headers,
                     }
        )


    def verify(client: Client, args: dict) -> List[CommandResults]:
        """ Verify the signature

        Args:
            client (Client): The client instance.
            args (dict): The arguments for verification.

        """
        signed_message = demisto.getFilePath(args.get('signed_message'))
        cert = args.get('public_key', 'instancePublicKey')
        raw_output = argToBoolean(args.get('raw_output', 'false'))
        tags = argToList(args.get('tag', ''))

        sk = X509.X509_Stack()
        st = X509.X509_Store()
        if cert == 'instancePublicKey':
            sk.push(X509.load_cert(client.public_key_file))
            st.load_info(client.public_key_file)
        elif cert:
            with NamedTemporaryFile(delete=False) as public_key_file:
                public_key_file.write(cert.encode('utf-8'))
                public_key_file_name = public_key_file.name

            sk.push(X509.load_cert(public_key_file_name))
            st.load_info(public_key_file_name)
            os.unlink(public_key_file_name)

        client.smime.set_x509_stack(sk)
        client.smime.set_x509_store(st)
        try:
            result = SMIME.smime_load_pkcs7(signed_message['path'])
            if not isinstance(result, tuple):
                raise DemistoException('SMIME error while loading message')
            p7, data = result
            verified_data = client.smime.verify(p7, data, flags=SMIME.PKCS7_NOVERIFY)
            human_readable = f'The signature verified\n\n{verified_data}'

        except SMIME.SMIME_Error as e:

            if str(e) == 'no content type':
                demisto.debug('No content type found in message, testing if it is in DER format (binary)')
                with open(signed_message['path'], 'rb') as message_file:
                    p7data = message_file.read()
                p7bio = BIO.MemoryBuffer(p7data)
                p7 = SMIME.load_pkcs7_bio_der(p7bio)
                verified_data = client.smime.verify(p7, flags=SMIME.PKCS7_NOVERIFY)
                return_results(fileResult(f'unwrapped-{signed_message["name"]}', verified_data))
                human_readable = 'The signature verified\n\n'
            else:
                raise e

        if not verified_data:
            raise ValueError('Unknown error: failed to verify message')
        msg = verified_data.decode('utf-8')
        msg_out = msg
        if not raw_output:  # Return message after parsing html/images/attachments
            demisto.debug(f'Parsing message:\n\n{msg}')
            msg_out, email_type = parse_multipart_message(msg)
            if email_type == 'html':
                human_readable = 'The signature verified'
            else:
                human_readable = f'### The signature verified, message is: \n ___ \n {msg_out}'

        results = [CommandResults(
            readable_output=human_readable,
            outputs_prefix='SMIME.Verified',
            outputs={'Message': msg_out},
            tags=tags,
        )]

        if email_type == 'html':
            results.append(CommandResults(
                raw_response=msg_out,
                content_format=EntryFormat.HTML,
                entry_type=EntryType.NOTE,
            ))

        return results


    def decode_str(decrypted_text: bytes, encoding: str) -> tuple[str, str]:
        """
        Detect encoding type using chardet, if the confidence of the detected encoding is lower than 0.9 we will add a
        message indicates it. If encoding is given, will use it.
        """
        msg = ''
        out = ''
        if not encoding:
            with warnings.catch_warnings(record=True) as e:
                charset_match = from_bytes(decrypted_text)
                if len(charset_match):
                    out = str(charset_match[0])
                    demisto.debug(f"Decode decrypted text using {charset_match[0].encoding} encoding")
                if e:
                    msg = f'Note: encoding detection ended with warning: {e[0].message} Characters may be missing.' \
                          ' You can try running this command again and pass the encoding code as argument.\n'
        else:
            out = decrypted_text.decode(encoding)

        return out, msg


    def decrypt_email_body(client: Client, args: dict) -> List[CommandResults]:
        """Decrypt the message

        Args:
            client (Client): The client instance.
            args (Dict): The arguments for decryption.
        """
        if 'test_file_path' in args:  # test module
            encrypt_message = {'path': args.get('test_file_path', '')}
        else:
            encrypt_message = demisto.getFilePath(args.get('encrypt_message', ''))
            demisto.debug(f'File Name:{encrypt_message["name"]}; Type:{type(encrypt_message["name"])}')

        encoding = args.get('encoding', '')
        raw_output = argToBoolean(args.get('raw_output', 'false'))
        tags = argToList(args.get('tag', ''))

        msg = ''
        client.smime.load_key(client.private_key_file, client.public_key_file)
        try:
            p7 = SMIME.smime_load_pkcs7(encrypt_message['path'])
            if isinstance(p7, tuple):
                p7 = p7[0]
            decrypted_text = client.smime.decrypt(p7)
            if not decrypted_text:
                raise ValueError('Unknown error: failed to decrypt message')
            out, msg = decode_str(decrypted_text, encoding)

        except SMIME.SMIME_Error as e:

            if str(e) == 'no content type':  # If no content type; see if we can process as DER format
                demisto.debug('No content type found in message, testing if it is in DER format (binary)')
                with open(encrypt_message['path'], 'rb') as message_file:
                    p7data = message_file.read()
                p7bio = BIO.MemoryBuffer(p7data)
                p7 = SMIME.load_pkcs7_bio_der(p7bio)
                decrypted_text = client.smime.decrypt(p7, flags=SMIME.PKCS7_NOVERIFY)
                if not decrypted_text:
                    raise ValueError('Unknown error: failed to decrypt message')
                out, msg = decode_str(decrypted_text, encoding)

            else:
                raise

        msg_out = out
        human_readable = f'{msg}The decrypted message is: \n{out}'
        if not raw_output:  # Return message after parsing html/images/attachments
            demisto.debug(f'parsing message:\n\n{out}')
            email_body, email_type = parse_multipart_message(out)
            if email_type == 'html':
                msg_out = email_body
                human_readable = f'{msg}Message decrypted successfully'
            elif email_type == 'text':
                msg_out = email_body
                human_readable = f'### {msg}The decrypted message is: \n ___ \n {msg_out}'
            else:
                human_readable = f'### {msg}The decrypted message is signed, verify to get the original message\n ___ \n{out}'

        results = [CommandResults(
            readable_output=human_readable,
            outputs_prefix='SMIME.Decrypted',
            outputs={'Message': msg_out},
            tags=tags,
        )]

        if email_type == 'html':
            results.append(CommandResults(
                raw_response=msg_out,
                content_format=EntryFormat.HTML,
                entry_type=EntryType.NOTE,
            ))

        return results


    def sign_and_encrypt(client: Client, args: dict) -> CommandResults:
        """Sign and encrypt the message

        Args:
            client (Client): The client instance.
            args (Dict): The arguments for signing and encrypting.
        """
        message = args.get('message', '')
        sign = argToBoolean(args.get('signed', 'true'))
        encrypt = argToBoolean(args.get('encrypted', 'true'))
        sender = args.get('sender', '')
        subject = args.get('subject', '')
        create_file = argToBoolean(args.get('create_file_p7', 'false'))
        attachment_ids = argToList(args.get('attachment_entry_id', ''))  # type: list[str]

        recipients = safe_load_json(args.get('recipients', {}) or '{}')
        if not isinstance(recipients, dict):
            raise DemistoException('Failed to parse recipients. (format `{"recipient@email":"cert", "other@email":"cert"}`)')

        cc = safe_load_json(args.get('cc', {}) or '{}')
        if not isinstance(cc, dict):
            raise DemistoException('Failed to parse cc. (format `{"recipient@email":"cert", "other@email":"cert"}`)')

        bcc = safe_load_json(args.get('bcc', {}) or '{}')
        if not isinstance(bcc, dict):
            raise DemistoException('Failed to parse bcc. (format `{"recipient@email":"cert", "other@email":"cert"}`)')

        msg_str = create_message_with_attachments(message, attachment_ids)
        demisto.debug(f'\n\nMessage:\n\n {msg_str} \n\nMessage end\n')

        if sign:
            msg_bio = BIO.MemoryBuffer(msg_str.encode('utf-8'))
            client.smime.load_key(client.private_key_file, client.public_key_file)
            p7 = client.smime.sign(msg_bio, algo='sha256')

        if encrypt:
            pub_certs = [cert for dest in [recipients, cc, bcc] for cert in dest.values()]  # Consolidate all recipient certificates
            set_encryption_params(client, pub_certs)

            msg_bio = BIO.MemoryBuffer()
            if sign:
                client.smime.write(msg_bio, p7)
            else:
                msg_bio.write(msg_str)
            p7 = client.smime.encrypt(msg_bio)

        # Prepare output
        out_bio = create_email_header(sender, subject, list(recipients.keys()), list(cc.keys()), list(bcc.keys()))
        if encrypt or sign:
            client.smime.write(out_bio, p7)
        else:
            out_bio.write(msg_str)

        msg_out = out_bio.read().decode('utf-8')

        file_results = {}
        if create_file:
            file_results = fileResult(filename=f'SMIME-{demisto.uniqueFile()[:8]}.p7', data=msg_out, file_type=EntryType.FILE)
            return_results(file_results)

        return CommandResults(
            readable_output=msg_out,
            outputs_prefix='SMIME.SignedAndEncrypted',
            outputs={
                'Message': msg_out,
                'RecipientIds': {
                    'to': list(recipients.keys()),
                    'cc': list(cc.keys()),
                    'bcc': list(bcc.keys()),
                },
                'FileName': file_results.get('File', ''),
            },
        )


    def test_module(client, *_):
        message_body = 'testing'
        try:
            # Encrypt the message
            encrypted_out = sign_and_encrypt(client, {'message': message_body, 'signed': 'false'}).to_context()
            encrypted_msg = encrypted_out['EntryContext']['SMIME.SignedAndEncrypted']['Message']

            # Write the encrypted message to a temporary file
            with NamedTemporaryFile(delete=False) as test_file:
                test_file.write(bytes(encrypted_msg, 'utf-8'))
                test_file_name = test_file.name

            # Decrypt the message
            decrypt_out = decrypt_email_body(client, {'test_file_path': test_file_name})[0].to_context()
            decrypted_msg = decrypt_out['HumanReadable']
            if message_body in decrypted_msg:
                demisto.results('ok')
            else:
                raise Exception

        except Exception:
            return_error('''Failed to encrypt->decrypt using the provided credentials.
                         Verify that the provided keys are valid and matching.''')
        finally:
            os.unlink(test_file.name)


    def main():  # pragma: no cover

        public_key: str = demisto.params().get('public_key', '')
        private_key: str = demisto.params().get('private_key', '')

        client = Client(private_key, public_key)
        LOG(f'Command being called is {demisto.command()}')
        commands = {
            'test-module': test_module,
            'smime-sign-email': sign_email,
            'smime-encrypt-email-body': encrypt_email_body,
            'smime-verify-sign': verify,
            'smime-decrypt-email-body': decrypt_email_body,
            'smime-sign-and-encrypt': sign_and_encrypt
        }
        try:
            command = demisto.command()
            if command in commands:
                return_results(commands[command](client, demisto.args()))  # type: ignore

        except Exception as e:
            return_error(str(e))

        finally:
            if client.private_key_file:
                os.unlink(client.private_key_file)
            if client.public_key_file:
                os.unlink(client.public_key_file)


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('SMIME Messaging', 'end', __line__())
  subtype: python3
  type: python
system: true
