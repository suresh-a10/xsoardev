category: Network Security
commonfields:
  id: Proofpoint Protection Server v2
  version: -1
configuration:
- display: Server URL (e.g., https://xxxxxxxx.pphosted.com:10000)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.1.7
    packID: ProofpointServerProtection
    packName: Proofpoint Protection Server
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Proofpoint email security appliance.
detaileddescription: "### Authentication\nAn administrator must have a role that includes
  access to a specific REST API. \n\nProofpoint on Demand (PoD) administrators must
  file a support ticket to Proofpoint support to obtain a role with access to an API.\n\nOn
  premise administrators: Edit the **filter.cfg** file and set the following key to
  true: com.proofpoint.admin.apigui.enable=t\n\nIn the management interface, create
  a role of type API. Select the APIs under **Managed Modules** for the role and assign
  an administrator that role.\n\nThe following are the required managed modules for
  this integration:\n - pss\n - Quarantine\n \nThe operations are accessed through
  port 10000.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/proofpoint-protection-server-v2)"
display: Proofpoint Protection Server v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAACHtJREFUeAHtmHls1UUQxx8KyI1AiiCHpoIkRA0QowSiIRKJyB+igChqMJEoGiNi8IBIsEgUEoxBSRS8SBQFBbWGwwO8QhBNOAppidJCoVQoFChHC6XS+vludx/Lj0d9fbYEyk74vpmdmZ3Znd3f7pZYLFCoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQEOsQKOGOKnInJrSHn5ZLNYf3qIyFlsPfy/iUx/N0eTsrcDkXAzLqY8kl3rMRhR57uWxWJUDO/qn81EU8ix3Ock3OsWc9zL+hQL9h6cSo3EqnS6iPh0Z6xiNtyoWOwl+Az+ej/GzwCXkKrW5TqSYsx9xzPjpnwu+rm2culhgNmqsGxAvBMlMphN+xyxghprx2xk0B0fB3+AUOBddgeFqIH/Fkv8/wCfZ5KcF3goGSa6BumOTv2K5xUnkrmNfuVtYP/lXgDhxLE+g8ZJVFMcNZwutULUGynckYi732r7sqetW7MKOWgFWE3YGGIC8hiPkKCgFW9A97qXshH2Z9Z+GvhfySvwOII+1fm3hr6DLBopTDkrw+wP9eBDdhCrIy/hs8fwP46+79Rmg4osy0K3FpwJUAsXUuDNAS+Qltj2Xdl/k7/E5DDSPv9C9AKK5taAv4puFzxGgsSr3RvTPAW1SR1PRfyegGGiV82mvBpm0+9L3bbAdHAD54H30aaA58mL88uAaeyVyrvpiuxHUG11PslO6W+CFoNjdMz4nu9u56ficlI3BrUfe7PzwGQfaoP/V6RJx+nyEXxMgaov/qkR+Tof/Z/g1xs/cgbRNgZwd/UrFQV8iHbwYFDq7z9G/qaSWWtN3hW+PytiX4qtTI4b8jbPTHGl1OdIRV2NKmBP75/hqfIc830ov1iDFqi/qSeIylwx5D4kmgYeQPwVmIHAdmT1AV+SjbqCWFzD5LGxDsc30YhWg0xc4DH2G6yc7usdADN3rnr+OxYlgGJiKzSyY9X8K3Q3gEfTHpSNnHu0h4CbQAf0+L1YJuqlgDPp5oEI2uI589/VN8/z3oX8eKPdk/A46G23VQwu8xNPdZ3WbnI4+Oo6nA+VcAPza9UQ/UHrP/0N0g8GVoN4ovsAk151zl5+JSWW6AaFXATriZxZYeuTZ6NoDmsZWZPW6X+4APk10sYi7BkN7+u+y/sqt4vo03vPXkSnqQp9j0hNjU7XK/KahNwsM57qMXxfGiG6+i4U8B2VTeJ7NfYr2CON4+udRxbH2bNQ6Qb5wMWiftcDodP04akb/7V78m61hihfDnYquT1KcuClTPj1/9nvzqel4MUTgPgiMr5qwFVPJmbQOAhWpB0XQK1efqO68XyR79BV6nQT6GtJh/UEntaEdYJWRTv9k4n9ITevfGdG/Q1Gf0ZarSO+BFUayP4xzkWsTszfydaCr1RXAv7WyY8sQim3jWrjeHppjQiKmbGs94wl0rr/UGqvIH78vV1uT+E15gRmQCnMikqPItbG3Rvbj60g67uxw/6jR5KIFkb9ZYLhetlows2GIrU2ir94n+aqPqBloBXD9TzqMR2nEq5iObjwtsbUH5h1gc/vzUFf1VxyRxqq515RbNreIiEb229LVCfkLUKuAjKYtHdzjx/Sl+u1cEOz6U0fHnyNNwJ+E7I7ULzoWFVYQnQS690w8gmhzNAU+taChwoq0+GXAzyd9ItJG0IbwSXNz49Hi6WTQfayAyh3118PK5dZYtdmSyY1b/ZKbRCpZ0unkHiCmP9syfjexElko3VeQKP42/A/IQCV6wW6JOA1Fb4qG305s64AWWaTcA4x0+mcI/vrSRPlAp4n54uE1ka6JO30HijKCWPwzP1theWCP2lA3cLuR7A9JBiMqjqgA7GXMyeQ2HZL8MRssSd+4W8oLzOz18FhApCfA3cjvwEcBnU06wjJB9CuT2dFehC/VIJYeGQsQHwS3gqdpvwY3RLxPEPaDJVLg3wT7B4gPA/mPpz0bbojN9TGCCmIWqVqb+BcH89+ZWJ8FetnPgj8pb/JWEWspok6ERdLh3xifdxHHAuUeh98cxUHWEbMQpkcgbv+b4h8Iu6Uf0W4DbWzULvAOVq4z5r+iDzID8zcuyeP/1ysZ/XSbUX8Hn7C6AnQ6Dn3qTFU2RPv7bewqsDsS02iv8+1RGfty/N3R3oP85fJBn4PePVT8V7T+w6I0Gkdt9PPoQ1dD7RBq/Jsd+w94mlMH2f+LYqQioMt2eWj2kc5SI2wbPZs7zUY6neP46+RKB6+CSUDXyTmJOaRG7NpsdusD8BxwClSB3Wy5yegzbNRydBtoZ8E3o0M8g/agHwreAgXAHENw9fuTWFPg+krdY24/7WHgDbAT6EvRl6b/Z96G/zT4/ah0b4ri+ZGzAeazqJBBjQLrMVYAzaMIzEQ3wetzCN09YBbYAfzcebRnAF1R5m3BguXSP0tApztcn7RqJt0GmmXSOcI/x9o2oXPjX0HMuUDxdezvxqbTEdFwppxwTqiribi1In3BWXRqzmB+J0t/eutr6QmagO3gAPCJzRcnDehcpIdWd6AHyxGQD84oAm2ftHOvAXpcqaj5wBUGMU6J8usLzmYeacwhj7n0wlt+4sq/ExSBc5GOSeXW3PWgkr9ZWLgjfTykMEQKsxD+WJzOupgjPervbJqjTjHVT/nErwK6OkpAnVH8iGYk6+os6vkP5B/RuaRXARskaZfVltwuc7y2/S8Ufzd+xy+UcdXpONyjI9mgnGixMn7E3b2YbN8Lyc/NQ/eZ0GCptrtX92w3oC9fC6xL/2Ik3YW678X1WNoFtOiBQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgUuoQr8C4/kmRLXPZUVAAAAAElFTkSuQmCC
name: Proofpoint Protection Server v2
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: 'Final disposition action message. Possible values are: "accept",
        "continue", "discard", "redirect", "reject", "retry".'
      name: action
      predefined:
      - accept
      - continue
      - discard
      - redirect
      - reject
      - retry
    - defaultValue: 24 hours
      description: Time from when the search should begin. Can be either free text
        (<number> <time unit>, e.g., 12 hours, 7 days) or ISO-8601 (YYYY-MM-DDThh:mm:ssZ,
        e.g., 2020-01-25T10:00:00Z).
      name: start_time
    - description: Time of when the search should end. Can be either free text (<number>
        <time unit>, e.g., 12 hours, 7 days) or ISO-8601 (YYYY-MM-DDThh:mm:ssZ, e.g.,
        2020-01-25T10:00:00Z).
      name: end_time
    - description: Comma-separated list of the detected virus names that infected
        the message.
      name: virus
    - description: Email address of the sender.
      name: sender
    - description: Email address of the recipient.
      name: recipient
    - description: Comma-separated list of the message attachments.
      name: attachment
    - description: ID of the message queue.
      name: queue_id
    - description: The host or IP address of the sent email message.
      name: host
    - description: The SID of the email message.
      name: sid
    - description: The subject of the email message.
      name: subject
    - description: The global unique ID of the email message.
      name: guid
    - description: The ID of the header message. This corresponds to the Message ID
        field in the UI.
      name: message_id
    - defaultValue: "100"
      description: The maximum number of email messages to return. The maximum value
        is set by the com.proofpoint.pss.query.default-count value in the filter.cfg
        file.
      name: limit
    description: Trace and analyze information about messages after they have been
      filtered by the Proofpoint Protection Server.
    name: proofpoint-pps-smart-search
    outputs:
    - contextPath: Proofpoint.SmartSearch.Rule_ID
      description: The ID of the message rule (e.g., system).
      type: String
    - contextPath: Proofpoint.SmartSearch.Disposition_Action
      description: Message disposition action.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sendmail_Action
      description: Message send mail action.
      type: String
    - contextPath: Proofpoint.SmartSearch.Attachment_Names
      description: Names of the email attachments.
      type: String
    - contextPath: Proofpoint.SmartSearch.Recipients
      description: Email addresses of the recipient of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.SendmailRaw_Log
      description: The raw log of the send mail email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.GUID
      description: GUID of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Date
      description: Date of the email message.
      type: Date
    - contextPath: Proofpoint.SmartSearch.Raw_Log
      description: Raw log of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sender_Host
      description: The sender host of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Module_ID
      description: The module ID of the email message (e.g., access).
      type: String
    - contextPath: Proofpoint.SmartSearch.Sender_IP_Address
      description: IP address of the email message sender.
      type: String
    - contextPath: Proofpoint.SmartSearch.Quarantine_Folder
      description: The email message quarantine folder.
      type: String
    - contextPath: Proofpoint.SmartSearch.QID
      description: The queue ID of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Quarantine_Rule
      description: The quarantine rule of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Spam_Score
      description: The spam score of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.country
      description: The country of the email message (e.g., **).
      type: String
    - contextPath: Proofpoint.SmartSearch.TLS
      description: The TLS of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Policy_Routes
      description: Comma-separated list of mail message policy routes (e.g., allow_relay,firewallsafe).
      type: String
    - contextPath: Proofpoint.SmartSearch.current_folder
      description: The current folder of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.FID
      description: The folder ID of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.module_rules
      description: The module rules of the email message (e.g., access.system).
      type: String
    - contextPath: Proofpoint.SmartSearch.PE_Recipients
      description: The PE recipients of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Virus_Names
      description: The virus names of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sendmail_Errorcode
      description: The error codes of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.FQIN
      description: The FQIN of the email message (e.g., example.com-10000_instance1).
      type: String
    - contextPath: Proofpoint.SmartSearch.SMIME_Recipients
      description: The SMIME recipients of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Agent
      description: The agent host of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Subject
      description: The subject of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Final_Rule
      description: The final rule of the email message (e.g., access.system).
      type: String
    - contextPath: Proofpoint.SmartSearch.Suborg
      description: The sub-organization of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.SMIME_Recipients_Signed
      description: The SMIME signed recipients  for the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Message_Encrypted
      description: The encrypted email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Message_Split
      description: The split of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Disposition_SmtpProfile
      description: The disposition SMTP profile of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sendmail_To
      description: The send to address in the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sendmail_Stat
      description: The send email status of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.SID
      description: The SID of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Message_ID
      description: The ID of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Final_Action
      description: The final action of the email message (e.g., accept).
      type: String
    - contextPath: Proofpoint.SmartSearch.Sender
      description: The sender of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Sendmail_To_Stat
      description: The send mail to status of the email message.
      type: String
    - contextPath: Proofpoint.SmartSearch.Message_Size
      description: The size of the email message.
      type: String
  - arguments:
    - description: 'Envelope message sender equals, starts with, ends with, or is
        in a domain such as "bar.com". At least one of the following arguments must
        be specified: sender, recipient, subject.'
      name: sender
    - description: 'Envelope message recipient equals, starts with, ends with, or
        is in a domain such as "bar.com". At least one of the following arguments
        must be specified: sender, recipient, subject.'
      name: recipient
    - description: 'Message subject starts with, ends with, or contains. At least
        one of the following arguments must be specified: sender, recipient, subject.'
      name: subject
    - defaultValue: 24 hours
      description: Time from when the search should begin. Can be either free text
        (<number> <time unit>, e.g., 12 hours, 7 days) or ISO-8601 (YYYY-MM-DDThh:mm:ssZ,
        e.g., 2020-01-25T10:00:00Z).
      name: start_time
    - description: Time of when the search should end. Can be either free text (<number>
        <time unit>, e.g., 12 hours, 7 days) or ISO-8601 (YYYY-MM-DDThh:mm:ssZ, e.g.,
        2020-01-25T10:00:00Z).
      name: end_time
    - defaultValue: Quarantine
      description: Quarantine folder name.
      name: folder_name
    - description: Message Global Unique Identifier (generated by PPS) to retrieve
        raw data for a message. If it is specified and a message is found, the messageâ€™s
        raw data is returned.
      name: guid
    description: Search for quarantined messages.
    name: proofpoint-pps-quarantine-messages-list
    outputs:
    - contextPath: Proofpoint.QuarantinedMessage.processingserver
      description: The processing server of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.date
      description: The date of the quarantined message.
      type: Date
    - contextPath: Proofpoint.QuarantinedMessage.subject
      description: The subject of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.messageid
      description: The ID of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.folder
      description: The folder of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.size
      description: The size of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.rcpts
      description: The recipients of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.from
      description: The sender of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.spamscore
      description: The spam score of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.guid
      description: The GUID of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.host_ip
      description: The host IP address of the quarantined message.
      type: String
    - contextPath: Proofpoint.QuarantinedMessage.localguid
      description: The local GUID of the quarantined message.
      type: String
  - arguments:
    - description: Name of the folder where the message is stored (e.g., HIPAA).
      name: folder_name
      required: true
    - description: Comma-separated list of message GUIDs. Format is folder_id:table_id:dbase_id
        (e.g., 4:2:6), or in Cloud Quarantine format is GUID (e.g., g4fsnj_sTLMk9hECaJ
        wmmxwP6lQkr5k7). Can be retrieved using the proofpoint-pps-quarantine-messages-list
        command.
      name: local_guid
      required: true
    - description: Name of the folder to move the message to. The folder must be for
        quarantined messages from the same type of module. For example, you cannot
        send deleted spam messages to a folder for deleted DLP incidents, and vice
        versa.
      name: deleted_folder
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether to rescan the message by the DLP and Attachment Defense
        filtering modules. Possible values are: "true" and "false".'
      name: scan
      predefined:
      - "true"
      - "false"
    - description: When encryption is licensed, the Branding Template to use when
        an encrypted message is released. The Branding Templates are listed on the
        System > End User Services > Branding Templates page in the management interface
        (admin GUI).
      name: brand_template
    - description: The Secure Reader response profile to use when a release is used
        for an encrypted message.The Response Profiles are listed on the Information
        Protection > Encryption > Response Profiles page in the management interface
        (admin UI).
      name: security_policy
    description: Releases the message to the email infrastructure without further
      scanning. The message remains in the folder and will be moved to the `deleted_folder`
      if specified.
    name: proofpoint-pps-quarantine-message-release
  - arguments:
    - description: Name of the folder where the message is stored (e.g., HIPAA).
      name: folder_name
      required: true
    - description: Comma-separated list of message GUIDs. Format is folder_id:table_id:dbase_id
        (e.g., 4:2:6), or in Cloud Quarantine format is GUID (e.g., g4fsnj_sTLMk9hECaJ
        wmmxwP6lQkr5k7).
      name: local_guid
      required: true
    description: Resubmits the message to the filtering modules. The message is removed
      from the folder and will not be moved to any folder.
    name: proofpoint-pps-quarantine-message-resubmit
  - arguments:
    - description: Name of the folder where the message is stored (e.g., HIPAA).
      name: folder_name
      required: true
    - description: Comma-separated list of message GUIDs. Format is folder_id:table_id:dbase_id
        (e.g., 4:2:6), or in Cloud Quarantine format is GUID (e.g., g4fsnj_sTLMk9hECaJ
        wmmxwP6lQkr5k7). Can be retrieved using the proofpoint-pps-quarantine-messages-list
        command.
      name: local_guid
      required: true
    - description: Name of the folder to move the message to. The folder must be for
        quarantined messages from the same type of module. For example, you cannot
        send deleted spam messages to a folder for deleted DLP Incidents, and vice
        versa.
      name: deleted_folder
    - description: The new subject with which to overwrite the original subject for
        the message.
      name: subject
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Whether to append the original subject to the string specified
        in the subject argument. Possible values are: "true" and "false".'
      name: append_old_subject
      predefined:
      - "true"
      - "false"
    - description: The envelope email address of the sender.
      name: sender
    - description: The header from email address.
      name: header_from
    - description: Comma-separate list of recipient email addresses.
      name: recipient
      required: true
    - description: |-
        New message body. (The original message is
        sent as an attachment.)
      name: comment
    description: Forwards the message to another recipient. The message remains in
      the folder and will be moved to the deleted_folder if specified.
    name: proofpoint-pps-quarantine-message-forward
  - arguments:
    - description: Name of the folder where the message is stored (e.g., HIPAA).
      name: folder_name
      required: true
    - description: |-
        Comma-separate list of message GUIDs. Format is folder_id:table_id:dbase_id (e.g., 4:2:6), or in Cloud Quarantine format is GUID (e.g., g4fsnj_sTLMk9hECaJ
        wmmxwP6lQkr5k7). Can be retrieved using the proofpoint-pps-quarantine-messages-list command.
      name: local_guid
      required: true
    - description: Name of the folder to move the email message to (e.g., PCI).The
        folder for moved messages must be for quarantined messages from the same type
        of module. For example, you cannot move spam messages to a folder for DLP
        incidents, and vice versa.
      name: target_folder
      required: true
    description: Moves the message to the specified target folder.
    name: proofpoint-pps-quarantine-message-move
  - arguments:
    - description: Name of the folder where the message is stored (e.g., HIPAA).
      name: folder_name
      required: true
    - description: |-
        Comma-separate list of message GUIDs. Format is folder_id:table_id:dbase_id (e.g., 4:2:6), or in Cloud Quarantine format is GUID (e.g., g4fsnj_sTLMk9hECaJ
        wmmxwP6lQkr5k7). Can be retrieved using the proofpoint-pps-quarantine-messages-list command.
      name: local_guid
      required: true
    - description: Name of the folder to move the message to. The folder must be for
        quarantined messages from the same type of module. For example, you cannot
        send deleted spam messages to a folder for deleted DLP Incidents, and vice
        versa.
      name: deleted_folder
    description: Deletes the message from the quarantine folder. The message is removed
      from its folder and moved to the deleted_folder if specified.
    name: proofpoint-pps-quarantine-message-delete
  - arguments:
    - description: Global unique ID of the email message (e.g., g4fsnj_sTLMk9hECaJwmmxwP6lQkr5k7).
        Can be retrieved using the proofpoint-pps-quarantine-messages-list command.
      name: guid
      required: true
    description: Downloads a quarantine email message's raw data.
    name: proofpoint-pps-quarantine-message-download
  - arguments:
    - description: Email address of the user.
      name: email
    - description: UID of the user.
      name: uid
    description: Gets the end user resource with the specified email address or UID.
    name: proofpoint-pps-get-user
    outputs:
    - contextPath: Proofpoint.User.alias
      description: List of aliases for the enduser.
    - contextPath: Proofpoint.User.attributes
      description: All attributes for this user profile. The value of these attributes
        is calculated based on the Organization, Sub-Org/Group membership and Profile
        settings. For a description of these attributes, see the table at the end
        of this document.
    - contextPath: Proofpoint.User.blocklist
      description: List of all block list entries for the enduser.
    - contextPath: Proofpoint.User.created
      description: Timestamp when profile was created (in UTC).
    - contextPath: Proofpoint.User.creationsource
      description: Source for the profile creation (see the table below).
    - contextPath: Proofpoint.User.email
      description: Primary email address of the enduser.
    - contextPath: Proofpoint.User.firstname
      description: First name of enduser.
    - contextPath: Proofpoint.User.groups
      description: List of all the groups to which the user belongs.
    - contextPath: Proofpoint.User.lastmodified
      description: Timestamp when profile changes were made (in UTC).
    - contextPath: Proofpoint.User.lastname
      description: Last name of enduser.
    - contextPath: Proofpoint.User.lastpasswordchange
      description: Timestamp for the last password change.
    - contextPath: Proofpoint.User.lastsignon
      description: Timestamp for the last login by the end user.
    - contextPath: Proofpoint.User.safelist
      description: List of all safe list entries for the enduser.
    - contextPath: Proofpoint.User.suborg
      description: Defines the sub-organization to which this user profile belongs.
    - contextPath: Proofpoint.User.type
      description: 0=User 1=Mailing List.
    - contextPath: Proofpoint.User.uid
      description: uid of the user.
  - arguments:
    - description: Email address of the user.
      name: email
      required: true
    - description: Request fields in JSON string format (e.g., firstname, lastname,
        addgroup).
      name: fields
    - description: Attributes in JSON string format.
      name: attributes
    description: Creates a new end user resource with the specified email address.
    name: proofpoint-pps-create-user
    outputs:
    - contextPath: Proofpoint.User.alias
      description: List of aliases for the enduser.
    - contextPath: Proofpoint.User.attributes
      description: All attributes for this user profile. The value of these attributes
        is calculated based on the Organization, Sub-Org/Group membership and Profile
        settings. For a description of these attributes, see the table at the end
        of this document.
    - contextPath: Proofpoint.User.blocklist
      description: List of all block list entries for the enduser.
    - contextPath: Proofpoint.User.created
      description: Timestamp when profile was created (in UTC).
    - contextPath: Proofpoint.User.creationsource
      description: Source for the profile creation (see the table below).
    - contextPath: Proofpoint.User.email
      description: Primary email address of the enduser.
    - contextPath: Proofpoint.User.firstname
      description: First name of enduser.
    - contextPath: Proofpoint.User.groups
      description: List of all the groups to which the user belongs.
    - contextPath: Proofpoint.User.lastmodified
      description: Timestamp when profile changes were made (in UTC).
    - contextPath: Proofpoint.User.lastname
      description: Last name of enduser.
    - contextPath: Proofpoint.User.lastpasswordchange
      description: Timestamp for the last password change.
    - contextPath: Proofpoint.User.lastsignon
      description: Timestamp for the last login by the end user.
    - contextPath: Proofpoint.User.safelist
      description: List of all safe list entries for the enduser.
    - contextPath: Proofpoint.User.suborg
      description: Defines the sub-organization to which this user profile belongs.
    - contextPath: Proofpoint.User.type
      description: 0=User 1=Mailing List.
    - contextPath: Proofpoint.User.uid
      description: uid of the user.
  - arguments:
    - description: Email address of the user.
      name: email
    - description: UID of the user.
      name: UID
    - description: Request fields in JSON string format (e.g., firstname, lastname,
        addgroup).
      name: fields
    - description: Attributes in JSON string format.
      name: attributes
    description: Modifies a user profile.
    name: proofpoint-pps-modify-user
    outputs:
    - contextPath: Proofpoint.User.alias
      description: List of aliases for the enduser.
    - contextPath: Proofpoint.User.attributes
      description: All attributes for this user profile. The value of these attributes
        is calculated based on the Organization, Sub-Org/Group membership and Profile
        settings. For a description of these attributes, see the table at the end
        of this document.
    - contextPath: Proofpoint.User.blocklist
      description: List of all block list entries for the enduser.
    - contextPath: Proofpoint.User.created
      description: Timestamp when profile was created (in UTC).
    - contextPath: Proofpoint.User.creationsource
      description: Source for the profile creation (see the table below).
    - contextPath: Proofpoint.User.email
      description: Primary email address of the enduser.
    - contextPath: Proofpoint.User.firstname
      description: First name of enduser.
    - contextPath: Proofpoint.User.groups
      description: List of all the groups to which the user belongs.
    - contextPath: Proofpoint.User.lastmodified
      description: Timestamp when profile changes were made (in UTC).
    - contextPath: Proofpoint.User.lastname
      description: Last name of enduser.
    - contextPath: Proofpoint.User.lastpasswordchange
      description: Timestamp for the last password change.
    - contextPath: Proofpoint.User.lastsignon
      description: Timestamp for the last login by the end user.
    - contextPath: Proofpoint.User.safelist
      description: List of all safe list entries for the enduser.
    - contextPath: Proofpoint.User.suborg
      description: Defines the sub-organization to which this user profile belongs.
    - contextPath: Proofpoint.User.type
      description: 0=User 1=Mailing List.
    - contextPath: Proofpoint.User.uid
      description: uid of the user.
  - arguments:
    - description: Email address of the user.
      name: email
    - description: UID of the user.
      name: uid
    description: Delete a user profile.
    name: proofpoint-pps-delete-user
  dockerimage: demisto/python3:3.10.13.89009
  runonce: false
  script: |
    register_module_line('Proofpoint Protection Server v2', 'start', __line__())
    ### pack version: 2.1.7


    from typing import Any

    import urllib3
    from dateparser import parse
    from requests import Response

    urllib3.disable_warnings()


    class Client(BaseClient):
        def health_check(self) -> dict[str, str]:
            return self._http_request(method='GET', url_suffix='/pss/health')

        @logger
        def smart_search_request(self,
                                 action: Optional[str] = None,
                                 from_: Optional[str] = None,
                                 to: Optional[str] = None,
                                 virus: Optional[str] = None,
                                 env_from: Optional[str] = None,
                                 env_rcpt: Optional[str] = None,
                                 attach: Optional[str] = None,
                                 qid: Optional[str] = None,
                                 host: Optional[str] = None,
                                 sid: Optional[str] = None,
                                 subject: Optional[str] = None,
                                 guid: Optional[str] = None,
                                 hdr_mid: Optional[str] = None,
                                 count: Optional[int] = 100,
                                 ) -> dict[str, str | List]:
            return self._http_request(
                method='GET',
                url_suffix='/pss/filter',
                params={
                    'action': action,
                    'from': from_,
                    'to': to,
                    'virus': virus,
                    'env_from': env_from,
                    'env_rcpt': env_rcpt,
                    'attach': attach,
                    'qid': qid,
                    'host': host,
                    'sid': sid,
                    'subject': subject,
                    'guid': guid,
                    'hdr_mid': hdr_mid,
                    'count': count,
                }
            )

        @logger
        def list_quarantined_messages_request(self,
                                              from_: Optional[str] = None,
                                              rcpt: Optional[str] = None,
                                              startdate: Optional[str] = None,
                                              enddate: Optional[str] = None,
                                              subject: Optional[str] = None,
                                              folder: Optional[str] = None,
                                              ) -> dict[str, str | List]:
            return self._http_request(
                method='GET',
                url_suffix='/quarantine',
                params={
                    'from': from_,
                    'rcpt': rcpt,
                    'startdate': startdate,
                    'enddate': enddate,
                    'subject': subject,
                    'folder': folder,
                    'dlpviolation': 'details',
                    'messagestatus': 't',
                }
            )

        @logger
        def quarantine_action_request(self,
                                      action: str,
                                      folder: str,
                                      localguid: str,
                                      scan: Optional[str] = None,
                                      brandtemplate: Optional[str] = None,
                                      securitypolicy: Optional[str] = None,
                                      deletedfolder: Optional[str] = None,
                                      targetfolder: Optional[str] = None,
                                      subject: Optional[str] = None,
                                      appendoldsubject: Optional[str] = None,
                                      from_: Optional[str] = None,
                                      headerfrom: Optional[str] = None,
                                      to: Optional[str] = None,
                                      comment: Optional[str] = None,
                                      resp_type: str = 'json',
                                      ) -> dict[str, str]:
            return self._http_request(
                method='POST',
                url_suffix='/quarantine',
                json_data={
                    'action': action,
                    'folder': folder,
                    'localguid': localguid,
                    'scan': scan,
                    'brandtemplate': brandtemplate,
                    'securitypolicy': securitypolicy,
                    'deletedfolder': deletedfolder,
                    'targetfolder': targetfolder,
                    'subject': subject,
                    'appendoldsubject': appendoldsubject,
                    'from': from_,
                    'headerfrom': headerfrom,
                    'to': to,
                    'comment': comment,
                },
                resp_type=resp_type,
            )

        @logger
        def download_message_request(self,
                                     guid: str,
                                     ) -> Response:
            return self._http_request(
                method='GET',
                url_suffix='/quarantine',
                params={
                    'guid': guid,
                },
                resp_type='response',
                ok_codes=(200, 404),
            )

        @logger
        def get_user(self, email_or_uid: str) -> Response:
            return self._http_request(
                method='GET',
                url_suffix=f'/enduser/{email_or_uid}'
            )

        @logger
        def create_user(self, email: str, fields: dict, attributes: dict) -> Response:
            json_data = {'attributes': attributes}
            json_data.update(fields)
            return self._http_request(
                method='POST',
                url_suffix=f'/enduser/{email}',
                json_data=json_data,
                ok_codes=(200, 400)
            )

        @logger
        def modify_user(self, email_or_uid: str, fields: dict, attributes: dict) -> Response:
            json_data = {'attributes': attributes}
            json_data.update(fields)
            return self._http_request(
                method='PUT',
                url_suffix=f'/enduser/{email_or_uid}',
                json_data=json_data
            )

        @logger
        def delete_user(self, email_or_uid: str) -> Response:
            return self._http_request(
                method='DELETE',
                url_suffix=f'/enduser/{email_or_uid}',
                ok_codes=(200, 404)
            )


    def test_module(client: Client) -> str:
        client.list_quarantined_messages_request(subject='Test')  # test Quarantine managed module
        return 'ok'


    def smart_search(client: Client, args: dict[str, Any]) -> CommandResults:
        assert (start_time := parse(args.get('start_time', '24 hours'), settings={'RETURN_AS_TIMEZONE_AWARE': True})), \
            f"Failed parsing start time: {args.get('start_time')}"
        if end_time := args.get('end_time'):
            assert (end_time := parse(end_time, settings={'RETURN_AS_TIMEZONE_AWARE': True})), \
                f"Failed parsing start time: {end_time}"
            end_time = end_time.strftime("%Y-%m-%dT%H:%M:%S%z")
        result = client.smart_search_request(
            action=args.get('action'),
            from_=start_time.strftime("%Y-%m-%dT%H:%M:%S%z"),
            to=end_time,
            virus=args.get('virus'),
            env_from=args.get('sender'),
            env_rcpt=args.get('recipient'),
            attach=args.get('attachment'),
            qid=args.get('queue_id'),
            host=args.get('host'),
            sid=args.get('sid'),
            subject=args.get('subject'),
            guid=args.get('guid'),
            hdr_mid=args.get('message_id'),
            count=int(args.get('limit', 100)),
        )
        if isinstance(result, dict) and result.get('result'):
            search_result = result.get('result')
            command_results_args = {
                'readable_output': tableToMarkdown(
                    'Proofpoint Protection Server Smart Search Results',
                    search_result,
                    ['GUID', 'Date', 'Sender', 'Recipients', 'Subject', 'Final_Action'],
                ),
                'outputs_prefix': 'Proofpoint.SmartSearch',
                'outputs_key_field': 'GUID',
                'outputs': search_result,
                'raw_response': result,
            }
        else:
            command_results_args = {'readable_output': 'No results found.'}
        return CommandResults(**command_results_args)


    def list_quarantined_messages(client: Client, args: dict[str, Any]) -> CommandResults:
        sender = args.get('sender')
        recipient = args.get('recipient')
        subject = args.get('subject')
        if not any([sender, recipient, subject]):
            raise ValueError('At least one of the following arguments must be specified: sender, recipient, subject.')
        assert (start_time := parse(args.get('start_time', '24 hours'))), \
            f"Failed parsing start time: {args.get('start_time')}"
        assert (end_time := parse(args.get('end_time', 'now'))), f"Failed parsing end time: {args.get('end_time')}"
        result = client.list_quarantined_messages_request(
            from_=sender,
            rcpt=recipient,
            startdate=start_time.strftime('%Y-%m-%d %H:%M:%S'),
            enddate=end_time.strftime('%Y-%m-%d %H:%M:%S'),
            subject=subject,
            folder=args.get('folder_name'),
        )
        if isinstance(result, dict) and result.get('records'):
            records = result.get('records')
            command_results_args = {
                'readable_output': tableToMarkdown(
                    'Proofpoint Protection Server Quarantined Messages',
                    records,
                    ['localguid', 'folder', 'spamscore', 'from', 'rcpts', 'date', 'subject', 'size', 'host_ip'],
                ),
                'outputs_prefix': 'Proofpoint.QuarantinedMessage',
                'outputs_key_field': 'guid',
                'outputs': records,
                'raw_response': result,
            }
        else:
            command_results_args = {'readable_output': 'No results found.'}
        return CommandResults(**command_results_args)


    def release_message(client: Client, args: dict[str, Any]) -> CommandResults:
        result = str(client.quarantine_action_request(
            action='release',
            folder=args.get('folder_name'),
            localguid=args.get('local_guid'),
            deletedfolder=args.get('deleted_folder'),
            scan='t' if args.get('scan') == 'true' else 'f',
            brandtemplate=args.get('brand_template'),
            securitypolicy=args.get('security_policy'),
            resp_type='text',
        ))
        return CommandResults(readable_output=result)


    def resubmit_message(client: Client, args: dict[str, Any]) -> CommandResults:
        result = str(client.quarantine_action_request(
            action='resubmit',
            folder=args.get('folder_name'),
            localguid=args.get('local_guid'),
            resp_type='text',
        ))
        return CommandResults(readable_output=result)


    def forward_message(client: Client, args: dict[str, Any]) -> CommandResults:
        result = str(client.quarantine_action_request(
            action='forward',
            folder=args.get('folder_name'),
            localguid=args.get('local_guid'),
            to=args.get('recipient'),
            deletedfolder=args.get('deleted_folder'),
            subject=args.get('subject'),
            appendoldsubject='t' if args.get('append_old_subject') == 'true' else 'f',
            from_=args.get('sender'),
            headerfrom=args.get('header_from'),
            comment=args.get('comment'),
            resp_type='text',
        ))
        return CommandResults(readable_output=result)


    def move_message(client: Client, args: dict[str, Any]) -> CommandResults:
        local_guid = args.get('local_guid')
        result = client.quarantine_action_request(
            action='move',
            folder=args.get('folder_name'),
            localguid=local_guid,
            targetfolder=args.get('target_folder'),
        )
        if isinstance(result, dict):
            return CommandResults(readable_output=result.get('status', f'Successfully moved message {local_guid}'))
        raise RuntimeError(f'Message move action failed.\n{result}')


    def delete_message(client: Client, args: dict[str, Any]) -> CommandResults:
        local_guid = args.get('local_guid')
        result = client.quarantine_action_request(
            action='delete',
            folder=args.get('folder_name'),
            localguid=local_guid,
            deletedfolder=args.get('deleted_folder'),
        )
        if isinstance(result, dict):
            return CommandResults(readable_output=result.get('status', f'Successfully deleted message {local_guid}'))
        raise RuntimeError(f'Message delete action failed.\n{result}')


    def download_message(client: Client, args: dict[str, Any]) -> CommandResults | dict:
        guid = args.get('guid', '')
        result = client.download_message_request(guid)
        if result.status_code == 404:
            return CommandResults(readable_output='No message found.')
        return fileResult(guid + '.eml', result.content)


    def get_user(client: Client, args: dict[str, Any]) -> CommandResults:
        email = args.get('email')
        uid = args.get('uid')
        if email or uid:
            result = client.get_user(email or uid)
            if isinstance(result, dict):
                command_results_args = {
                    'readable_output': tableToMarkdown(
                        'Proofpoint Protection Server Users',
                        result,
                        ['uid', 'email', 'firstname', 'lastname', 'created', 'lastmodified'],
                    ),
                    'outputs_prefix': 'Proofpoint.User',
                    'outputs_key_field': 'email',
                    'outputs': result,
                    'raw_response': result,
                }
            else:
                raise RuntimeError(f'Failed to get user.\n{result}')
        else:
            command_results_args = {
                'readable_output': 'Please specify an email or uid'
            }
        return CommandResults(**command_results_args)


    def create_user(client: Client, args: dict[str, Any]) -> CommandResults:
        email = args.get('email')
        fields = json.loads(args.get('fields', '{}'))
        attributes = json.loads(args.get('attributes', '{}'))
        result = client.create_user(email, fields, attributes)
        demisto.debug(f'result: {result}')
        if isinstance(result, dict):
            if result.get('status') == 400:
                if result.get('errors', {}).get('invalidarguments', [])[0].get('error') == 'User already exists':
                    command_results_args: dict[str, Any] = {
                        'readable_output': 'User already exists'
                    }
                else:
                    raise RuntimeError(f'Failed to create user.\n{result}')
            else:
                command_results_args = {
                    'readable_output': tableToMarkdown(
                        'User created',
                        result,
                        ['uid', 'email', 'firstname', 'lastname', 'created', 'lastmodified'],
                    ),
                    'outputs_prefix': 'Proofpoint.User',
                    'outputs_key_field': 'email',
                    'outputs': result,
                    'raw_response': result
                }
            return CommandResults(**command_results_args)
        else:
            raise RuntimeError(f'Failed to create user.\n{result}')


    def modify_user(client: Client, args: dict[str, Any]) -> CommandResults:
        email = args.get('email')
        uid = args.get('uid')
        fields = json.loads(args.get('fields', '{}'))
        attributes = json.loads(args.get('attributes', '{}'))
        if email or uid:
            result = client.modify_user(email or uid, fields, attributes)
            if isinstance(result, dict):
                command_results_args: dict[str, Any] = {
                    'readable_output': tableToMarkdown(
                        'Modified User',
                        result,
                        ['uid', 'email', 'firstname', 'lastname', 'created', 'lastmodified'],
                    ),
                    'outputs_prefix': 'Proofpoint.User',
                    'outputs_key_field': 'email',
                    'outputs': result,
                    'raw_response': result,
                }
            else:
                raise RuntimeError(f'Failed to modify user.\n{result}')
        else:
            command_results_args = {
                'readable_output': 'Please specify an email or uid'
            }
        return CommandResults(**command_results_args)


    def delete_user(client: Client, args: dict[str, Any]) -> CommandResults:
        email = args.get('email')
        uid = args.get('uid')
        if email or uid:
            result = client.delete_user(email or uid)
            if isinstance(result, dict):
                if result.get('status') == 404:
                    if result.get('errors', {}).get('invalidarguments', [])[0].get('error') == 'User not found':
                        command_results_args: dict[str, Any] = {
                            'readable_output': 'User not found'
                        }
                    else:
                        raise RuntimeError(f'Failed to delete user.\n{result}')
                else:
                    command_results_args = {
                        'readable_output': 'Deleted User',
                        'raw_response': result,
                    }
            else:
                raise RuntimeError(f'Failed to delete user.\n{result}')
        else:
            command_results_args = {
                'readable_output': 'Please specify an email or uid'
            }
        return CommandResults(**command_results_args)


    def main() -> None:
        try:
            command = demisto.command()
            params = demisto.params()
            handle_proxy()
            client = Client(
                base_url=urljoin(params['url'], '/rest/v1'),
                auth=(params['credentials']['identifier'], params['credentials']['password']),
                verify=not params.get('unsecure', False),
                proxy=params.get('proxy', False),
            )
            commands = {
                'proofpoint-pps-get-user': get_user,
                'proofpoint-pps-create-user': create_user,
                'proofpoint-pps-modify-user': modify_user,
                'proofpoint-pps-delete-user': delete_user,
            }
            if command == 'test-module':
                return_results(test_module(client))
            elif command == 'proofpoint-pps-smart-search':
                return_results(smart_search(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-messages-list':
                return_results(list_quarantined_messages(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-release':
                return_results(release_message(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-resubmit':
                return_results(resubmit_message(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-forward':
                return_results(forward_message(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-move':
                return_results(move_message(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-delete':
                return_results(delete_message(client, demisto.args()))
            elif command == 'proofpoint-pps-quarantine-message-download':
                return_results(download_message(client, demisto.args()))
            elif command in commands:
                return_results(commands[command](client, demisto.args()))

        except Exception as e:
            return_error(str(e), error=e)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Proofpoint Protection Server v2', 'end', __line__())
  subtype: python3
  type: python
system: true
