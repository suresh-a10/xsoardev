category: Network Security
commonfields:
  id: RedLock_v1.1
  version: -1
configuration:
- defaultvalue: https://api.redlock.io/
  display: Server URL
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: Customer name
  name: customer
  required: false
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Fetch only incidents matching this rule name
  name: ruleName
  required: false
  type: 0
- display: Fetch only incidents with this severity
  name: policySeverity
  required: false
  type: 0
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: fetch_time
  required: false
  type: 0
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Cloud threat defense
detaileddescription: |-
  ## Prisma Cloud
  Use the Prisma Cloud integration to manage alerts from Microsoft Azure, Google Cloud Platform, and AWS.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/red-lock)
display: RedLock_v1.1
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAABX5JREFUeAHtmG3I31MYx2fNzWw2JKO0O1mmbSxjzYSVoiiUCC/whluRV/cYGfIUM5uklIcU8cJTiiGGFx62olFGI0u38liYzT3MGJ+vzrWunZ3z//3++vff/eK66tu5fte5rnPO//v9nfM79z1uXFgwEAwEA8FAMBAMBAPBQDAQDAQDwUAwEAwEA8FAMBAMBAPBQDAQDAQDwUAw0GsGhhlwcq8HjfHGBgMS9x8QAo8NPXq6ChM3BO4prWNjMC9uCDw2NOnZKnJxRxh5ds9Gj4H2KAO5uNq9l4Ln9+iq+jP5QUwzExzQn+kaZ5lAhu4+wkBjdouExeRIUI/1PI8Ho+A00NaU/1cBPxBbA4bA3qBkpxAs1Sr2O/gCPAXmgJodRYeNcVctifgM8BDYDPzv1vrfA1eCqaBk2wjaHH/i1065Y+nb7nK34rex50iyNX2QFYiju8GSLF59LO1cDX52qviV9v1q9e4dEsIWV2uf2L3sv4gWX6vxca1pVmUMCWy5yyo5ekF+dHm/4W9yz1a/kljJJK7lqJUgJXuBoM/7o5SUxebyvCOrO8flaHPsB/Zxsapb2rla0LuuQmQqdr6LdXJN4NdJOiThMNqTwFpgP/ho/NxOJWD91+Pr6DQM4t/g+h/AL1kbgR+h0ObR6bRXGmgK7fHgDrARTAclM4G30KlxJMhxWeK81Kd+y2sjsL0UP1OnU0/1HwFbI247GybNfmTenuyGMIE/J6ZvQ5OZwKsKiRcRs7n8W2mpXuBrLOjaAfy/gcZ40cW920ZgnSC2jgfxTwfT/CANvgl8H3kmXv579aw5PgG6x8hvElgvia3rZvzr3PN5+K2tk7gvZaOYwJp4KOsrPZrAr9CpY0SYBPSdegPYDzgSPzd/RN9PpwQXFoFzwbPA6m/CL1kbgRdS6H+Xjakd8ypYDHT61MwEXkrCbcDqT0wFC1xMwti6mwTWS6uxfgG68E0G9in5GL/1Lr6XZFuUb7U75gBvnohv6JjoOwu+CezHzf1HC3UKeYHzGv+so14/vmRtBFadLlnLwQag3+3Hlz8KFoGSeYGnkqDjVDWrU/Jr6XkdrURpI/AJqUbj3A7MbsRRTLjAgm3aksiPFwq9wJpkSSHHh2oCbyJJl7XLQe2o9wJ/Rp4IE74H9iP1HdZFo2ZtBfb1urTMB5eBJ8EOoPneBiXzAqtfa7L1eUHOSsVtBH7ZjXEPvngW7nTxT/HHg9bmRd5G1WChMhdYQh1YyLOQCawjeiChkyBWp9YL7L/Bs+nbDESifqR2Tc3aCLyC4ofBQpAfezoZ7HLzIX7JcoEnkWQ1JvQaV9gk8AJyra6pvdiNu9Ot7Rh9a2TDQG/rjASanfYOnoTydgYPT/tAwdcu0N+IvTCJeiFYBWYBXVrOBNtBt6Zv61VgX3AF0HdxJEH3BV107B8ej+G3sa0k6W/TlS55qfOb3FtTgsa5Fog7b3oJl4Ep4BbwDNBnpbX5nZy/QXqjuzHbwRKjW6vtYBvnahxbX438ph08kTEuAW8CEWnj+XaE+BCoWb6DlacX5mugcd4C3jrtYJ0iNvdyX5T5/jKn9e9i+TG0S2d6kMjaybntT2A0D3Z41oL1ndDFY0OHvFKX3tBjUseXtN8VkuYTsxNlHX5+M5WA81KdCP8q+aVGn5ojwHQwDfwERoDGFek109/04lRjaw4zvVyHgo3gWwvSzgQHA71Qa4G3QR4OT4H1tFt8p/O10eamZ61Td5SubQUV9jZZ2+0O7nrSKOgvA7nIIXB/+e/LbF7kELgvlPd/EhM5BO4/913POKHrivKF638MEyXBQDAQDAQDwUAwEAwEA8FAMBAMBAPBQDAQDAQDwUAwEAwEA8FAMBAMBAPBQDCwZxn4F+pR9SxBFrRlAAAAAElFTkSuQmCC
name: RedLock_v1.1
script:
  commands:
  - arguments:
    - description: The maximum number of records to return. '; limit search records
        to {}' is appended to every query where {} is the maximum number of records
        to return. If no value is provided, only 1 record is returned.
      name: limit
    - description: 'The RQL query to run. Examples of RQL queries can be found here:
        https://docs.paloaltonetworks.com/prisma/prisma-cloud/prisma-cloud-rql-reference/rql-reference/rql-examples.
        Note that ` limit search records to 1` is automatically appended to each query
        and a `;` may need to be added to the end of the rql input to make the entire
        query valid.  The limit parameter adjusts this to be a value other than 1.'
      name: rql
      required: true
    description: Runs an RQL query on the Prisma Cloud.
    name: redlock-get-rql-response
    outputs:
    - contextPath: Redlock.RQL.Query
      description: The RQL query that was run.
      type: String
    - contextPath: Redlock.RQL.Response.AccountId
      description: The cloud account ID.
      type: Date
    - contextPath: Redlock.RQL.Response.AccountName
      description: The cloud account name.
      type: String
    - contextPath: Redlock.RQL.Response.AllowDrillDown
      description: Flag to allow drill down.
      type: Boolean
    - contextPath: Redlock.RQL.Response.CloudType
      description: The cloud type.
      type: String
    - contextPath: Redlock.RQL.Response.Data
      description: The data object returned by the RQL response.
      type: Object
    - contextPath: Redlock.RQL.Response.Deleted
      description: Flag if deleted.
      type: Boolean
    - contextPath: Redlock.RQL.Response.HasAlert
      description: Flag to check if RQL response has alerts.
      type: Boolean
    - contextPath: Redlock.RQL.Response.HasExtFindingRiskFactors
      description: Flag if query returns external risk factors.
      type: Boolean
    - contextPath: Redlock.RQL.Response.HasExternalFinding
      description: Flag for external findings.
      type: Boolean
    - contextPath: Redlock.RQL.Response.HasExternalIntegration
      description: Flag for external integration.
      type: Boolean
    - contextPath: Redlock.RQL.Response.HasNetwork
      description: Flag for determining if network exists.
      type: Boolean
    - contextPath: Redlock.RQL.Response.Id
      description: The RQL response ID.
      type: String
    - contextPath: Redlock.RQL.Response.InsertTs
      description: The response time.
      type: Date
    - contextPath: Redlock.RQL.Response.Name
      description: The RQL response name.
      type: String
    - contextPath: Redlock.RQL.Response.RegionId
      description: The cloud region ID.
      type: String
    - contextPath: Redlock.RQL.Response.RegionName
      description: The cloud region name.
      type: String
    - contextPath: Redlock.RQL.Response.ResourceType
      description: The resource type.
      type: String
    - contextPath: Redlock.RQL.Response.Rrn
      description: The account RRN.
      type: String
    - contextPath: Redlock.RQL.Response.Service
      description: The RQL response service.
      type: String
    - contextPath: Redlock.RQL.Response.StateId
      description: The response state ID.
      type: String
  - arguments:
    - description: Start time for search in the following string format -  MM/DD/YYYY
      name: time-range-date-from
    - description: End time for search in the following format -  MM/DD/YYYY
      name: time-range-date-to
    - description: The amount of units to go back in time
      name: time-range-value
    - auto: PREDEFINED
      description: The search unit. login and epoch are only available if timeRangeValue
        is not provided.
      name: time-range-unit
      predefined:
      - hour
      - day
      - week
      - month
      - year
      - login
      - epoch
    - auto: PREDEFINED
      description: The policy name
      name: policy-name
      predefined:
      - IAM password policy does not have a symbol
      - IAM password policy does not expire in 90 days
      - IAM password policy does not have a lowercase character
      - IAM password policy does not have a minimum of 14 characters
      - IAM password policy allows password reuse
      - Default Security Group does not restrict all traffic
      - IAM password policy does not have password expiration period
      - IAM password policy does not exist
      - Access keys are not rotated for 90 days
      - Security Groups allow internet traffic from internet to RDP port (3389)
      - Internet connectivity via tcp over insecure port
      - IAM policy allow full administrative privileges
      - Primitive IAM roles should not be used
      - Internet exposed instances
      - IAM user has both Console access and Access Keys
      - S3 buckets are accessible to public
      - Access logging not enabled on all CloudTrail buckets
      - CloudTrail trail is not integrated with CloudWatch Log
      - Security Groups allow internet traffic to SSH port (22)
      - CloudTrail logs are not encrypted using Customer Master Keys (CMKs)
      - Excessive login failures
      - VPC endpoints were not used for consuming S3 storage from within the VPC
      - Access logging not enabled on S3 buckets
      - S3 buckets do not have server side encryption
      - Account hijacking attempts
      - Security groups allow internet traffic
      - VPC subnets should not allow automatic public IP assignment
      - VPC Flow Logs not enabled
      - MFA not enabled for IAM users
      - Inactive users for more than 30 days
    - description: The policy label
      name: policy-label
    - description: The policy compliance standard
      name: policy-compliance-standard
    - description: The cloud account
      name: cloud-account
    - description: The cloud region
      name: cloud-region
    - description: The alert rule name
      name: alert-rule-name
    - description: The resource ID
      name: resource-id
    - description: The resource name
      name: resource-name
    - description: The resource type
      name: resource-type
    - auto: PREDEFINED
      defaultValue: open
      description: The alert status
      name: alert-status
      predefined:
      - open
      - resolved
      - dismissed
    - description: The alert ID
      name: alert-id
    - auto: PREDEFINED
      description: The cloud type
      name: cloud-type
      predefined:
      - aws
      - azure
      - gcp
    - auto: PREDEFINED
      description: The risk grade
      name: risk-grade
      predefined:
      - A
      - B
      - C
      - F
    - auto: PREDEFINED
      description: The policy type
      name: policy-type
      predefined:
      - anomaly
      - audit_event
      - config
      - network
    - auto: PREDEFINED
      description: The policy severity
      name: policy-severity
      predefined:
      - high
      - medium
      - low
    description: Search alerts on the Prisma Cloud (RedLock) platform
    name: redlock-search-alerts
    outputs:
    - contextPath: Redlock.Alert.ID
      description: The ID of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Status
      description: The status of the returned alert.
      type: string
    - contextPath: Redlock.Alert.AlertTime
      description: The time of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Policy.ID
      description: The policy ID of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Policy.Name
      description: The policy name of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Policy.Type
      description: The policy type of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Policy.Severity
      description: The policy severity of the returned alert.
      type: string
    - contextPath: Redlock.Alert.Policy.Remediable
      description: Whether or not the policy is remediable.
      type: boolean
    - contextPath: Redlock.Alert.RiskDetail.Rating
      description: The risk rating of the returned alert.
      type: string
    - contextPath: Redlock.Alert.RiskDetail.Score
      description: The risk score of the returned alert.
      type: string
    - contextPath: Redlock.Metadata.CountOfAlerts
      description: The number of alerts found.
      type: number
  - arguments:
    - default: true
      description: The alert ID
      name: alert-id
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Allows for retrieving entire / trimmed alert model
      name: detailed
      predefined:
      - "true"
      - "false"
    description: Gets the details of an alert based on alert ID
    name: redlock-get-alert-details
    outputs:
    - contextPath: Redlock.Alert.ID
      description: The alert ID
      type: string
    - contextPath: Redlock.Alert.Status
      description: The alert status
      type: string
    - contextPath: Redlock.Alert.AlertTime
      description: The time of the alert
      type: date
    - contextPath: Redlock.Alert.AlertRules
      description: Names of the alert rules that triggered this alert.
      type: string
    - contextPath: Redlock.Alert.Policy.ID
      description: The policy ID
      type: string
    - contextPath: Redlock.Alert.Policy.Name
      description: The policy name
      type: string
    - contextPath: Redlock.Alert.Policy.Type
      description: The type of policy
      type: string
    - contextPath: Redlock.Alert.Policy.Severity
      description: The policy severity
      type: string
    - contextPath: Redlock.Alert.Policy.Remediable
      description: Whether or not the policy is remediable
      type: boolean
    - contextPath: Redlock.Alert.RiskDetail.Rating
      description: The risk rating
      type: string
    - contextPath: Redlock.Alert.RiskDetail.Score
      description: The risk score
      type: string
  - arguments:
    - description: comma separated list of string IDs to be dismissed
      name: alert-id
    - description: The amount of time to snooze. Both snooze value and unit must be
        specified
      name: snooze-value
    - auto: PREDEFINED
      description: The time unit for if snoozing alert.  Both snooze value and unit
        must be specified if snoozing.
      name: snooze-unit
      predefined:
      - hour
      - day
      - week
      - month
      - year
      - epoch
    - description: Reason for dismissal
      name: dismissal-note
      required: true
    - description: Start time for search in the following string format -  MM/DD/YYYY
      name: time-range-date-from
    - description: End time for search in the following format -  MM/DD/YYYY
      name: time-range-date-to
    - description: The amount of units to go back in time
      name: time-range-value
    - auto: PREDEFINED
      description: The search unit
      name: time-range-unit
      predefined:
      - hour
      - day
      - week
      - month
      - year
      - login
      - epoch
    - auto: PREDEFINED
      description: The policy name
      name: policy-name
      predefined:
      - IAM password policy does not have a symbol
      - IAM password policy does not expire in 90 days
      - IAM password policy does not have a lowercase character
      - IAM password policy does not have a minimum of 14 characters
      - IAM password policy allows password reuse
      - Default Security Group does not restrict all traffic
      - IAM password policy does not have password expiration period
      - IAM password policy does not exist
      - Access keys are not rotated for 90 days
      - Security Groups allow internet traffic from internet to RDP port (3389)
      - Internet connectivity via tcp over insecure port
      - IAM policy allow full administrative privileges
      - Primitive IAM roles should not be used
      - Internet exposed instances
      - IAM user has both Console access and Access Keys
      - S3 buckets are accessible to public
      - Access logging not enabled on all CloudTrail buckets
      - CloudTrail trail is not integrated with CloudWatch Log
      - Security Groups allow internet traffic to SSH port (22)
      - CloudTrail logs are not encrypted using Customer Master Keys (CMKs)
      - Excessive login failures
      - VPC endpoints were not used for consuming S3 storage from within the VPC
      - Access logging not enabled on S3 buckets
      - S3 buckets do not have server side encryption
      - Account hijacking attempts
      - Security groups allow internet traffic
      - VPC subnets should not allow automatic public IP assignment
      - VPC Flow Logs not enabled
      - MFA not enabled for IAM users
      - Inactive users for more than 30 days
    - description: The policy label
      name: policy-label
    - description: The policy compliance standard
      name: policy-compliance-standard
    - description: The cloud account
      name: cloud-account
    - description: The cloud region
      name: cloud-region
    - description: The alert rule name
      name: alert-rule-name
    - description: The resource ID
      name: resource-id
    - description: The resource name
      name: resource-name
    - description: The resource type
      name: resource-type
    - auto: PREDEFINED
      description: The alert status
      name: alert-status
      predefined:
      - open
      - resolved
      - dismissed
    - auto: PREDEFINED
      description: The cloud type
      name: cloud-type
      predefined:
      - aws
      - azure
      - gcp
    - auto: PREDEFINED
      description: The risk grade
      name: risk-grade
      predefined:
      - A
      - B
      - C
      - F
    - auto: PREDEFINED
      description: The policy type
      name: policy-type
      predefined:
      - anomaly
      - audit_event
      - config
      - network
    - auto: PREDEFINED
      description: The policy severity
      name: policy-severity
      predefined:
      - high
      - medium
      - low
    - description: comma separated string of policy IDs
      name: policy-id
    description: Dismiss the alerts matching the given filter. Must provide either
      policy IDs or alert IDs.
    execution: true
    name: redlock-dismiss-alerts
    outputs:
    - contextPath: Redlock.DismissedAlert.ID
      description: The IDs of the dismissed alerts
      type: string
  - arguments:
    - description: The IDs of alerts to reopen
      name: alert-id
    - description: Start time for search in the following string format -  MM/DD/YYYY
      name: time-range-date-from
    - description: End time for search in the following format -  MM/DD/YYYY
      name: time-range-date-to
    - description: The amount of units to go back in time
      name: time-range-value
    - auto: PREDEFINED
      description: The search unit
      name: time-range-unit
      predefined:
      - hour
      - day
      - week
      - month
      - year
      - login
      - epoch
    - auto: PREDEFINED
      description: The policy name
      name: policy-name
      predefined:
      - IAM password policy does not have a symbol
      - IAM password policy does not expire in 90 days
      - IAM password policy does not have a lowercase character
      - IAM password policy does not have a minimum of 14 characters
      - IAM password policy allows password reuse
      - Default Security Group does not restrict all traffic
      - IAM password policy does not have password expiration period
      - IAM password policy does not exist
      - Access keys are not rotated for 90 days
      - Security Groups allow internet traffic from internet to RDP port (3389)
      - Internet connectivity via tcp over insecure port
      - IAM policy allow full administrative privileges
      - Primitive IAM roles should not be used
      - Internet exposed instances
      - IAM user has both Console access and Access Keys
      - S3 buckets are accessible to public
      - Access logging not enabled on all CloudTrail buckets
      - CloudTrail trail is not integrated with CloudWatch Log
      - Security Groups allow internet traffic to SSH port (22)
      - CloudTrail logs are not encrypted using Customer Master Keys (CMKs)
      - Excessive login failures
      - VPC endpoints were not used for consuming S3 storage from within the VPC
      - Access logging not enabled on S3 buckets
      - S3 buckets do not have server side encryption
      - Account hijacking attempts
      - Security groups allow internet traffic
      - VPC subnets should not allow automatic public IP assignment
      - VPC Flow Logs not enabled
      - MFA not enabled for IAM users
      - Inactive users for more than 30 days
    - description: The policy label
      name: policy-label
    - description: The policy compliance standard
      name: policy-compliance-standard
    - description: The cloud account
      name: cloud-account
    - description: The cloud region
      name: cloud-region
    - description: The alert rule name
      name: alert-rule-name
    - description: The resource ID
      name: resource-id
    - description: The resource name
      name: resource-name
    - description: The resource type
      name: resource-type
    - auto: PREDEFINED
      description: The alert status
      name: alert-status
      predefined:
      - open
      - resolved
      - dismissed
    - auto: PREDEFINED
      description: The cloud type
      name: cloud-type
      predefined:
      - aws
      - azure
      - gcp
    - auto: PREDEFINED
      description: The risk grade
      name: risk-grade
      predefined:
      - A
      - B
      - C
      - F
    - auto: PREDEFINED
      description: The policy type
      name: policy-type
      predefined:
      - anomaly
      - audit_event
      - config
      - network
    - auto: PREDEFINED
      description: The policy severity
      name: policy-severity
      predefined:
      - high
      - medium
      - low
    description: Re-open the alerts matching the given filter.  Must provide either
      policy IDs or alert IDs.
    execution: true
    name: redlock-reopen-alerts
    outputs:
    - contextPath: Redlock.ReopenedAlert.ID
      description: IDs of the re-opened alerts
      type: string
  - arguments: []
    description: List the acceptable filters and values for alerts
    name: redlock-list-alert-filters
  - arguments:
    - description: The alert ID for which to get remediation details.
      name: alert-id
    description: Gets remediation details for the given alert.
    name: redlock-get-remediation-details
    outputs:
    - contextPath: Redlock.Alert.Remediation.Description
      description: Description of CLI remediation instructions.
      type: string
    - contextPath: Redlock.Alert.ID
      description: The ID of the alert to which the remediation details apply.
      type: string
    - contextPath: Redlock.Alert.Remediation.CLI
      description: The exact CLI command string.
      type: string
  - arguments:
    - description: Start time for the search, in the following string format -  MM/DD/YYYY
      name: time-range-date-from
    - description: End time for the search, in the following format -  MM/DD/YYYY
      name: time-range-date-to
    - description: The number of time range value units for the search. For example,
        3 days, 5 weeks, etc.
      name: time-range-value
    - auto: PREDEFINED
      description: |-
        The search unit. Possible values are: "hour", "week", "month", "year", "login", or "epoch". The "login" and "epoch" options are only available if timeRangeValue
        is not provided.
      name: time-range-unit
      predefined:
      - hour
      - day
      - week
      - month
      - year
      - login
      - epoch
    - description: Query to run in Prisma Cloud config API using RQL language.
      name: query
      required: true
    - defaultValue: "100"
      description: Maximum number of entries to return.
      name: limit
    description: Search configuration inventory on the Prisma Cloud (RedLock) platform
      using RQL language.
    name: redlock-search-config
    outputs:
    - contextPath: Redlock.Asset.accountId
      description: Cloud Account ID
      type: Date
    - contextPath: Redlock.Asset.accountName
      description: Cloud Account Name
      type: String
    - contextPath: Redlock.Asset.allowDrillDown
      description: ""
      type: Boolean
    - contextPath: Redlock.Asset.cloudType
      description: Cloud Type
      type: String
    - contextPath: Redlock.Asset.deleted
      description: Asset was deleted?
      type: Boolean
    - contextPath: Redlock.Asset.hasAlert
      description: Asset has Prisma Cloud alert?
      type: Boolean
    - contextPath: Redlock.Asset.hasExtFindingRiskFactors
      description: Has External Finding Risk Factors?
      type: Boolean
    - contextPath: Redlock.Asset.hasExternalFinding
      description: Has External Finding?
      type: Boolean
    - contextPath: Redlock.Asset.hasExternalIntegration
      description: Has External Integration?
      type: Boolean
    - contextPath: Redlock.Asset.hasNetwork
      description: Has Network?
      type: Boolean
    - contextPath: Redlock.Asset.id
      description: Redlock Asset ID
      type: String
    - contextPath: Redlock.Asset.data
      description: Redlock Asset specific data
      type: Unknown
    - contextPath: Redlock.Asset.insertTs
      description: Insert Ts
      type: Date
    - contextPath: Redlock.Asset.name
      description: Asset Name
      type: String
    - contextPath: Redlock.Asset.regionId
      description: Cloud Region ID
      type: String
    - contextPath: Redlock.Asset.regionName
      description: Cloud Region Name
      type: String
    - contextPath: Redlock.Asset.resourceType
      description: Cloud Resource type
      type: String
    - contextPath: Redlock.Asset.rrn
      description: Cloud RRN
      type: String
    - contextPath: Redlock.Asset.service
      description: Cloud service
      type: String
    - contextPath: Redlock.Asset.stateId
      description: State ID
      type: String
  - arguments: []
    description: Returns an object whose keys are supported asset inventory filters
      and values contain default recent options.
    name: redlock-get-inventory
    outputs:
    - contextPath: Redlock.Account.Group.Options
      type: string
    - contextPath: Redlock.Account.Group.StaticFilter
      type: boolean
  dockerimage: demisto/python3:3.9.6.22912
  isfetch: true
  runonce: false
  script: |2


    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()  # pylint: disable=no-member

    URL = ''
    VERIFY = False
    DEFAULT_LIMIT = 100

    # Standard headers
    HEADERS = {'Content-Type': 'application/json', 'Accept': 'application/json'}
    TOKEN = None


    def get_token():
        """
        Retrieve the token using the credentials
        """
        response = requests.post(URL + 'login', headers=HEADERS, verify=VERIFY, json={
            'customerName': demisto.getParam('customer') or '',
            'username': demisto.getParam('credentials')['identifier'],
            'password': demisto.getParam('credentials')['password']
        })

        if response.status_code != requests.codes.ok:  # pylint: disable=no-member
            raise Exception('Error authenticating to RedLock service [%d] - %s' % (response.status_code, response.text))
        try:
            response_json = response.json()
            TOKEN = response_json.get('token')
            if not TOKEN:
                demisto.debug(json.dumps(response_json))
                message = 'Could not retrieve token from server: {}'.format(response_json.get("message"))
                if response_json.get('message') == 'login_needs_customer_name':
                    available_customer_names = [name.get('customerName') for name in response_json.get('customerNames')]
                    message = 'In order to login a customer name need to be configured. Available customer names: {}'.format(
                        {", ".join(available_customer_names)})
                raise Exception(message)
        except ValueError as exception:
            demisto.log(exception)
            raise Exception('Could not parse API response.')
        HEADERS['x-redlock-auth'] = TOKEN


    def req(method, path, data=None, param_data=None):
        """
        Generic request to Prisma Cloud (RedLock)
        """
        if not TOKEN:
            get_token()
        response = requests.request(method, URL + path, json=data, params=param_data, headers=HEADERS, verify=VERIFY)
        if response.status_code != requests.codes.ok:  # pylint: disable=no-member
            text = response.text
            if response.headers.get('x-redlock-status'):
                try:
                    statuses = json.loads(response.headers.get('x-redlock-status'))  # type: ignore
                    for status in statuses:
                        text += '\n%s [%s]' % (status.get('i18nKey', ''), status.get('subject', ''))
                        # Handle case for no remediation details
                        if status['i18nKey'] == 'remediation_unavailable':
                            return False
                        if status['i18nKey'] == 'alert_no_longer_in_expected_state':
                            return False
                except Exception:
                    pass
            raise Exception('Error in API call to RedLock service [%d] - %s' % (response.status_code, text))
        if not response.text:
            return {}
        return response.json()


    def format_response(response):
        if response and isinstance(response, dict):
            response = {pascalToSpace(key).replace(" ", ""): format_response(value) for key, value in response.items()}
        elif response and isinstance(response, list):
            response = [format_response(item) for item in response]
        return response


    def list_filters():
        """
        List the acceptable filters on alerts
        """
        response = req('GET', 'filter/alert/suggest', None, None)
        filters = [{
            'Name': filter_,
            'Options': ','.join(response.get(filter_).get('options')),
            'Static': response.get(filter_).get('staticFilter')
        } for filter_ in response]

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'HumanReadable': tableToMarkdown('Filter options', filters, ['Name', 'Options', 'Static'])
        })


    def convert_date_to_unix(date_str):
        """
        Convert a given string with MM/DD/YYYY format to millis since epoch
        """
        date = datetime.strptime(date_str, '%m/%d/%Y')
        return int((date - datetime.utcfromtimestamp(0)).total_seconds() * 1000)


    def convert_unix_to_date(timestamp):
        """
        Convert milliseconds since epoch to date formatted MM/DD/YYYY HH:MI:SS
        """
        if timestamp:
            date_time = datetime.utcfromtimestamp(timestamp / 1000)
            return date_time.strftime('%m/%d/%Y %H:%M:%S')
        return 'N/A'


    def convert_unix_to_demisto(timestamp):
        """
        Convert milliseconds since epoch to date formatted MM/DD/YYYYTHH:MI:SS
        """
        if timestamp:
            date_time = datetime.utcfromtimestamp(timestamp / 1000)
            return date_time.strftime('%Y-%m-%dT%H:%M:%SZ')
        return ''


    def handle_time_filter(payload, base_case):
        """
        Add the time filter to the payload
        """
        unit = demisto.getArg('time-range-unit')
        value = demisto.getArg('time-range-value')
        time_from = demisto.getArg('time-range-date-from')
        time_to = demisto.getArg('time-range-date-to')
        relative = ('hour', 'day', 'week', 'month', 'year')
        to_now = relative[1:] + ('epoch', 'login')
        if unit:
            if time_from or time_to:
                return_error('You cannot specify absolute times [time-range-date-from, time-range-date-to] '
                             + 'with relative times [time-range-unit, time-range-value]')
            if value:
                if unit not in relative:
                    return_error('Time unit for relative time must be one of the following: ' + ','.join(relative))
                payload['timeRange'] = {'type': 'relative', 'value': {'amount': int(value), 'unit': unit}}
            else:
                if unit not in to_now:
                    return_error('Time unit for to_now time must be one of the following: ' + ','.join(to_now))
                payload['timeRange'] = {'type': 'to_now', 'value': unit}
        else:
            if not time_from or not time_to:
                payload['timeRange'] = base_case
            else:
                payload['timeRange'] = {'type': 'absolute', 'value': {
                    'startTime': convert_date_to_unix(time_from), 'endTime': convert_date_to_unix(time_to)}}


    def handle_filters(payload):
        """
        Add filters to the filter object based on received arguments
        """
        args_conversion = {
            'alert-status': 'alert.status',
            'policy-name': 'policy.name',
            'policy-label': 'policy.label',
            'policy-compliance-standard': 'policy.complianceStandard',
            'cloud-account': 'cloud.account',
            'cloud-region': 'cloud.region',
            'alert-rule-name': 'alertRule.name',
            'resource-id': 'resource.id',
            'resource-name': 'resource.name',
            'resource-type': 'resource.type',
            'alert-id': 'alert.id',
            'cloud-type': 'cloud.type',
            'risk-grade': 'risk.grade',
            'policy-type': 'policy.type',
            'policy-severity': 'policy.severity'
        }
        payload['filters'] = []
        for filter_ in demisto.args():
            if filter_ in ('policy-name', 'policy-label', 'policy-compliance-standard', 'cloud-account', 'cloud-region',
                           'alert-rule-name', 'resource-id', 'resource-name', 'resource-type', 'alert-status', 'alert-id',
                           'cloud-type', 'risk-grade', 'policy-type', 'policy-severity') and demisto.getArg(filter_):
                payload['filters'].append(
                    {'name': args_conversion[filter_], 'operator': '=', 'value': demisto.getArg(filter_)})


    def alert_to_readable(alert):
        """
        Transform an alert to a nice readable object
        """
        return {
            'ID': alert.get('id'),
            'Status': alert.get('status'),
            'FirstSeen': convert_unix_to_date(alert.get('firstSeen')),
            'LastSeen': convert_unix_to_date(alert.get('lastSeen')),
            'AlertTime': convert_unix_to_date(alert.get('alertTime')),
            'PolicyName': demisto.get(alert, 'policy.name'),
            'PolicyType': demisto.get(alert, 'policy.policyType'),
            'PolicyDescription': demisto.get(alert, 'policy.description'),
            'PolicySeverity': demisto.get(alert, 'policy.severity'),
            'PolicyRecommendation': demisto.get(alert, 'policy.recommendation'),
            'PolicyDeleted': demisto.get(alert, 'policy.deleted'),
            'PolicyRemediable': demisto.get(alert, 'policy.remediable'),
            'RiskRating': demisto.get(alert, 'riskDetail.rating'),
            'ResourceName': demisto.get(alert, 'resource.name'),
            'ResourceAccount': demisto.get(alert, 'resource.account'),
            'ResourceType': demisto.get(alert, 'resource.resourceType'),
            'ResourceCloudType': demisto.get(alert, 'resource.cloudType')
        }


    def alert_to_context(alert):
        """
        Transform a single alert to context struct
        """
        ec = {
            'ID': alert.get('id'),
            'Status': alert.get('status'),
            'AlertTime': convert_unix_to_date(alert.get('alertTime')),
            'Policy': {
                'ID': demisto.get(alert, 'policy.policyId'),
                'Name': demisto.get(alert, 'policy.name'),
                'Type': demisto.get(alert, 'policy.policyType'),
                'Severity': demisto.get(alert, 'policy.severity'),
                'Remediable': demisto.get(alert, 'policy.remediable')
            },
            'RiskDetail': {
                'Rating': demisto.get(alert, 'riskDetail.rating'),
                'Score': demisto.get(alert, 'riskDetail.riskScore.score')
            },
            'Resource': {
                'ID': demisto.get(alert, 'resource.id'),
                'Name': demisto.get(alert, 'resource.name'),
                'Account': demisto.get(alert, 'resource.account'),
                'AccountID': demisto.get(alert, 'resource.accountId')
            }
        }
        if alert.get('alertRules'):
            ec['AlertRules'] = [alert_rule.get('name') for alert_rule in alert.get('alertRules')]

        return ec


    def search_alerts():
        """
        Retrieves alerts by filter
        """
        payload = {}  # type: dict
        handle_time_filter(payload, {'type': 'relative', 'value': {'amount': 7, 'unit': 'day'}})
        handle_filters(payload)
        response = req('POST', 'alert', payload, {'detailed': 'true'})
        alerts = []
        context_path = 'Redlock.Alert(val.ID === obj.ID)'
        context = {context_path: []}  # type: dict
        for alert in response:
            alerts.append(alert_to_readable(alert))
            context[context_path].append(alert_to_context(alert))
        context['Redlock.Metadata.CountOfAlerts'] = len(response)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'EntryContext': context,
            'HumanReadable': tableToMarkdown('Alerts', alerts, [
                'ID', 'Status', 'FirstSeen', 'LastSeen', 'AlertTime', 'PolicyName', 'PolicyType', 'PolicyDescription',
                'PolicySeverity', 'PolicyRecommendation', 'PolicyDeleted', 'PolicyRemediable', 'RiskRating', 'ResourceName',
                'ResourceAccount', 'ResourceType', 'ResourceCloudType'
            ])
        })


    def get_alert_details():
        """
        Retrieve alert details by given ID
        """
        response = req('GET', 'alert/' + demisto.getArg('alert-id'), None,
                       None)  # {'detailed': demisto.getArg('detailed')})
        alert = alert_to_readable(response)
        alert.update({
            'PolicyID': demisto.get(response, 'policy.policyID'),
            'PolicySystemDefault': demisto.get(response, 'policy.systemDefault'),
            'PolicyLabels': demisto.get(response, 'policy.labels'),
            'PolicyLastModifiedOn': demisto.get(response, 'policy.lastModifiedOn'),
            'PolicyLastModifiedBy': demisto.get(response, 'policy.lastModifiedBy'),
            'RiskScore': demisto.get(response, 'riskDetail.riskScore.score'),
            'ResourceRRN': demisto.get(response, 'resource.rrn'),
            'ResourceID': demisto.get(response, 'resource.id'),
            'ResourceAccountID': demisto.get(response, 'resource.accountId'),
            'ResourceRegionID': demisto.get(response, 'resource.regionId'),
            'ResourceApiName': demisto.get(response, 'resource.resourceApiName'),
            'ResourceUrl': demisto.get(response, 'resource.url'),
            'ResourceData': demisto.get(response, 'resource.data'),
            'ResourceAccessKeyAge': demisto.get(response, 'resource.additionalInfo.accessKeyAge'),
            'ResourceInactiveSinceTs': demisto.get(response, 'resource.additionalInfo.inactiveSinceTs')
        })

        context = {'Redlock.Alert(val.ID === obj.ID)': alert_to_context(response)}
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'EntryContext': context,
            'HumanReadable': tableToMarkdown('Alert', alert, removeNull=True)
        })


    def dismiss_alerts():
        """
        Dismiss the given list of alerts based on given filter
        """
        ids = argToList(demisto.getArg('alert-id'))
        policies = argToList(demisto.getArg('policy-id'))
        payload = {'alerts': ids, 'policies': policies, 'dismissalNote': demisto.getArg('dismissal-note'), 'filter': {}}
        demisto.args().pop('alert-id', None)
        args = demisto.args()
        snooze_value = args.get('snooze-value', None)
        snooze_unit = args.get('snooze-unit', None)
        msg_notes = ['dismissed', 'Dismissal']

        if snooze_value and snooze_unit:
            payload['dismissalTimeRange'] = {
                'type': 'relative',
                'value': {
                    'unit': snooze_unit,
                    'amount': int(snooze_value)
                }
            }
            msg_notes = ['snoozed', 'Snooze']
        handle_filters(payload['filter'])
        handle_time_filter(payload['filter'], {'type': 'to_now', 'value': 'epoch'})
        if not ids and not policies:
            return_error('You must specify either alert-id or policy-id for dismissing alerts')
        response = req('POST', 'alert/dismiss', payload, None)
        if response is False:
            demisto.results("Alert not in expected state.")
        else:
            context = {}
            if ids:
                context['Redlock.DismissedAlert.ID'] = ids

                md = '### Alerts {} successfully. {} Note: {}.'.format(msg_notes[0], msg_notes[1],
                                                                       demisto.getArg('dismissal-note'))

            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': response,
                'EntryContext': context,
                'HumanReadable': md
            })


    def reopen_alerts():
        """
        Reopen the given list of alerts based on given filter
        """
        ids = argToList(demisto.getArg('alert-id'))
        policies = argToList(demisto.getArg('policy-id'))
        payload = {'alerts': ids, 'policies': policies, 'filter': {}}
        demisto.args().pop('alert-id', None)
        handle_filters(payload['filter'])
        handle_time_filter(payload['filter'], {'type': 'to_now', 'value': 'epoch'})
        if not ids and not policies:
            return_error('You must specify either alert-id or policy-id for re-opening alerts')
        response = req('POST', 'alert/reopen', payload, None)
        context = {}
        if ids:
            context['Redlock.ReopenedAlert.ID'] = ids
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': response,
            'EntryContext': context,
            'HumanReadable': '### Alerts re-opened successfully.'
        })


    def translate_severity(alert):
        """
        Translate alert severity to demisto
        Might take risk grade into account in the future
        """
        severity = demisto.get(alert, 'policy.severity')
        if severity == 'high':
            return 3
        if severity == 'medium':
            return 2
        if severity == 'low':
            return 1
        return 0


    def get_rql_response(args):
        """"
        Retrieve any RQL
        """
        rql = args.get('rql').encode("utf-8")

        limit = str(args.get('limit', '1'))
        rql += " limit search records to {}".format(limit)

        payload = {"query": rql, "filter": {}}

        handle_filters(payload['filter'])
        handle_time_filter(payload['filter'], {'type': 'to_now', 'value': 'epoch'})

        response = req('POST', 'search/config', payload, None)

        human_readable = []

        items = response["data"]["items"]

        for item in items:
            tmp_human_readable = {
                "ResourceName": item["name"],
                "Service": item["service"],
                "Account": item["accountName"],
                "Region": item["regionName"],
                "Deleted": item["deleted"]
            }
            human_readable.append(tmp_human_readable)

        contents = format_response(items)
        rql_data = {
            "Query": rql,
            "Response": contents
        }

        md = tableToMarkdown(name="RQL Output:", t=human_readable, headerTransform=pascalToSpace, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': rql_data,
            'EntryContext': {'Redlock.RQL(val.Query === obj.Query)': rql_data},
            'HumanReadable': md
        })


    def get_remediation_details():
        """
        Retrieve remediation details for a given alert
        """
        alert_ids = argToList(demisto.getArg('alert-id'))
        payload = {'alerts': alert_ids, 'filter': {}}
        handle_filters(payload['filter'])
        handle_time_filter(payload['filter'], {'type': 'to_now', 'value': 'epoch'})

        md_data = []
        context = []
        response = req('POST', 'alert/remediation', payload, None)

        if response:
            for alert_id in alert_ids:
                details = {
                    'ID': alert_id,
                    'Remediation': {
                        'CLI': response['alertIdVsCliScript'][alert_id],
                        'Description': response['cliDescription']
                    }
                }
                human_readable_details = {
                    'ID': details['ID'],
                    'RemediationCLI': details['Remediation']['CLI'],
                    'RemediationDescription': details['Remediation']['Description']
                }
                context.append(details)
                md_data.append(human_readable_details)

            MD = tableToMarkdown("Remediation Details", md_data)
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': response,
                'EntryContext': {'Redlock.Alert(val.ID == obj.ID)': context},
                'HumanReadable': MD
            })
        else:
            demisto.results('No Remediation Details Found')


    def redlock_search_config():
        """
        Run query in config
        """
        query = demisto.args().get('query', None)
        limit = demisto.args().get('limit', None)
        if not limit:
            limit = DEFAULT_LIMIT
        else:
            limit = int(limit)

        if not query:
            return_error('You must specify a query to retrieve assets')
        payload = {
            'query': query,
            'limit': limit,
            'sort': [{"direction": "desc", "field": "insertTs"}],
            'withResourceJson': True
        }
        handle_time_filter(payload, {'type': 'to_now', 'value': 'epoch'})

        response = req('POST', 'search/config', payload, None)

        if (
                not response
                or 'data' not in response
                or not isinstance(response['data'], dict)
                or 'items' not in response['data']
                or not isinstance(response['data']['items'], list)
        ):
            demisto.results('No results found')
        else:
            items = response['data']['items']
            md = tableToMarkdown("Configuration Details", items)
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': items,
                'EntryContext': {'Redlock.Asset(val.id == obj.id)': items},
                'HumanReadable': md
            })

    def redlock_get_inventory():
        res=req('GET', 'filter/v2/inventory/suggest')
        return_results(res)
        command_results = CommandResults(
        outputs_prefix='Redlock',
        outputs=res
        )
        return_results(command_results)
        # return_results(fileResult(filename='asset_inventory_details.csv', data=(json.dumps(res)).encode('utf-8'), file_type=entryTypes['entryInfoFile']))



    def fetch_incidents():
        """
        Retrieve new incidents periodically based on pre-defined instance parameters
        """
        now = int((datetime.utcnow() - datetime.utcfromtimestamp(0)).total_seconds() * 1000)
        last_run = demisto.getLastRun().get('time')
        if not last_run:  # first time fetch
            last_run = now - parse_date_range(demisto.params().get('fetch_time', '3 days').strip(), to_timestamp=True)[0]

        payload = {'timeRange': {
            'type': 'absolute',
            'value': {
                'startTime': last_run,
                'endTime': now
            }
        }, 'filters': [{'name': 'alert.status', 'operator': '=', 'value': 'open'}]}
        if demisto.getParam('ruleName'):
            payload['filters'].append({'name': 'alertRule.name', 'operator': '=',  # type: ignore
                                       'value': demisto.getParam('ruleName')})
        if demisto.getParam('policySeverity'):
            payload['filters'].append({'name': 'policy.severity', 'operator': '=',  # type: ignore
                                       'value': demisto.getParam('policySeverity')})

        demisto.info("Executing Prisma Cloud (RedLock) fetch_incidents with payload: {}".format(payload))
        response = req('POST', 'alert', payload, {'detailed': 'true'})
        incidents = []
        for alert in response:
            incidents.append({
                'name': alert.get('policy.name', 'No policy') + ' - ' + alert.get('id'),
                'occurred': convert_unix_to_demisto(alert.get('alertTime')),
                'severity': translate_severity(alert),
                'rawJSON': json.dumps(alert)
            })

        return incidents, now


    def main():
        global URL, VERIFY
        handle_proxy()
        params = demisto.params()
        URL = params.get('url')
        if URL[-1] != '/':
            URL += '/'
        VERIFY = not params.get('unsecure', False)
        try:
            command = demisto.command()
            if command == 'test-module':
                get_token()
                return_results('ok')
            elif command == 'redlock-search-alerts':
                search_alerts()
            elif command == 'redlock-list-alert-filters':
                list_filters()
            elif command == 'redlock-get-alert-details':
                get_alert_details()
            elif command == 'redlock-dismiss-alerts':
                dismiss_alerts()
            elif command == 'redlock-reopen-alerts':
                reopen_alerts()
            elif command == 'redlock-get-remediation-details':
                get_remediation_details()
            elif command == 'redlock-get-rql-response':
                get_rql_response(demisto.args())
            elif command == 'redlock-search-config':
                redlock_search_config()
            elif command == 'redlock-get-inventory':
                redlock_get_inventory()
            elif command == 'fetch-incidents':
                incidents, new_run = fetch_incidents()
                demisto.incidents(incidents)
                demisto.setLastRun({'time': new_run})
            else:
                raise Exception('Unrecognized command: ' + command)
        except Exception as err:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
sourcemoduleid: RedLock
