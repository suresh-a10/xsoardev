category: Utilities
commonfields:
  id: AlgoSec Advanced Query
  version: -1
configuration:
- defaultvalue: https://soar.monstersofhack.com
  display: Server URL (e.g. https://soar.monstersofhack.com)
  name: url
  required: true
  type: 0
- display: username
  displaypassword: password
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: 'This is the AlgoSec AFA Advanced Query integration '
detaileddescription: |-
  AlgoSec Advanced Query

  https://www.algosec.com/docs/en/asms/a30.00/PDFs/SecurityManagementSuite-APIGuide.pdf

  https://www.algosec.com/docs/en/asms/a32.50/asms-help/content/api-guide/advancedsearch_full.htm

  https://www.algosec.com/docs/en/asms/a32.50/asms-help/content/api-guide/advancedsearch_basic.htm?tocpath=Suite%7CASMS%20API%20reference%7CAFA%20REST%20web%20services%7CRule%20data%20APIs%7C_____6
display: AlgoSec Advanced Query
image: data:image/png;base64,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
name: AlgoSec Advanced Query
script:
  commands:
  - arguments:
    - description: Can refer to a device, group or ALL_FIREWALLS.  To get the tree
        name, use GET /devices method from the device-setup-controller.
      name: service
    - description: 'Search query. For example:  Source ==1.2.3.4 or \"Service object\"
        !=\"tcp udp\" Equals to:  (Source equals to "1.2.3.4") or (Service object
        not equal to "tcp udp" )'
      name: searchQuery
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'For results that only list objects that contain the exact IP address(es)
        or service(s) you are searching for, select true.  true: enabled  false (default):
        disabled'
      name: exactMatch
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'In addition to the search query, also find rules that contain
        ''Any'' in any of the fields queried.  true: enabled  false (default): disabled'
      name: includeAny
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      defaultValue: "True"
      description: 'Enhance the query to search additionally for objects that contain
        the searched object/IP address.  true (default): enabled  false : disabled'
      name: includeContainment
      predefined:
      - "True"
      - "False"
    name: algosec-run-advanced-query
  dockerimage: demisto/python3:3.10.5.31928
  runonce: false
  script: |2-

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()  # pylint: disable=no-member

    URL = ''
    VERIFY = False
    DEFAULT_LIMIT = 100
    CREDENTIALS= demisto.params().get('credentials')
    USERNAME=CREDENTIALS.get('identifier').strip()
    PASSWORD=CREDENTIALS.get('password').strip()


    # Standard headers
    # HEADERS = {'Cookie':"PHPSESSID=cvj3o0mch66g9easi8h2b0g515"}
    HEADERS = {}

    TOKEN = None

    def authenticate_oauth():
        """
        Login using the credentials and store the cookie
        """
        integration_context = demisto.getIntegrationContext()
        # print(integration_context)
        TOKEN = integration_context.get('bearer_token')
        valid_until = integration_context.get('valid_until')
        time_now = int(time.time())
        # print(time_now)
        if TOKEN and valid_until:
            if time_now < valid_until:
                # Bearer Token is still valid - did not expire yet
                HEADERS['Cookie'] = f"PHPSESSID={TOKEN}"
                return TOKEN

        TOKEN = get_token()
        t = time.time()
        expiration_time = t + 120
        integration_context = {
            'bearer_token': TOKEN,
            'valid_until': expiration_time  # Assuming the expiration time is 2 minutes
        }
        demisto.setIntegrationContext(integration_context)
        # print(integration_context)
        HEADERS['Cookie'] = f"PHPSESSID={TOKEN}"
        return TOKEN


    def get_token():
        """
        Retrieve the session id using the credentials
        """
        requestURL = URL + 'fa/server/connection/login'
        response = requests.post(requestURL, verify=VERIFY, data={'username': USERNAME, 'password': PASSWORD})

        if response.status_code != requests.codes.ok:  # pylint: disable=no-member
            raise Exception('Error authenticating to AlgoSec [%d] - %s' % (response.status_code, response.text))
        try:
            response_json = response.json()
            TOKEN = response_json.get('SessionID')
            if not TOKEN:
                demisto.debug(json.dumps(response_json))
                message = 'Could not retrieve token from server: {}'.format(response_json.get("message"))

                raise Exception(message)
        except ValueError as exception:
            demisto.log(exception)
            raise Exception('Could not parse API response.')
        # json_data = json.loads(response.text)
        # print(response.status_code,json_data)

        bearer_token = f"PHPSESSID={TOKEN}"
        HEADERS['Cookie'] = bearer_token

        return TOKEN


    def search_query(treeName,ruleSearchQuery,exactMatch,includeAny,includeContainment):

        if not TOKEN:
            token=authenticate_oauth()

        # requestURL = URL + f'/api/v1/rule/advancedsearch/full/{treeName}'
        requestURL = URL + 'afa/api/v1/rule/advancedsearch/full/ALL_FIREWALLS?includeAny=true&includeContainment=true'

        # params={
        #     'ruleSearchQuery': ruleSearchQuery,
        #     'treeName': treeName,
        #     'exactMatch': exactMatch,
        #     'includeAny': includeAny,
        #     'includeContainment': includeContainment
        # }

        params={
            # 'ruleSearchQuery': "(SOURCE==1.0.0.0-9.255.255.255) or (SOURCE==11.0.0.0-100.63.255.255) or (SOURCE==100.128.0.0-126.255.255.255) or (SOURCE==169.255.0.0-172.15.255.255) or (SOURCE==172.32.0.0-191.255.255.255) or (SOURCE==192.0.1.0-192.0.1.255) or (SOURCE==192.0.3.0-192.88.98.255)",
            # 'ruleSearchQuery': "SOURCE == 10.10.10.1-10.11.10.0",
            # 'exactMatch': False,
            'includeAny': True,
            'includeContainment': True
        }

        json = {
        # "searchQuery": "source == 192.0.3.0-192.88.98.255"
        "searchQuery": "\"source address\" == 192.0.3.0-192.88.98.255"
        # "ruleSearchQuery": "\"source address\" == 10.10.10.1-10.11.10.0"
        }


        response = requests.post(requestURL, headers=HEADERS, verify=VERIFY, json=json)
        # json_data = json.loads(response.text)
        # print(response.status_code,json_data)
        print(response)
        print(response.status_code)
        print(response.text)



    def main():
        global URL, VERIFY
        handle_proxy()
        params = demisto.params()

        URL = params.get('url')


        if URL[-1] != '/':
            URL += '/'
        VERIFY = not params.get('insecure', False)
        try:
            command = demisto.command()
            args = demisto.args()

            if command == 'test-module':
                results=get_token()
                return_results('ok')

            if command == 'algosec-run-advanced-query':
                treeName=args.get('service')
                ruleSearchQuery=args.get('searchQuery')
                exactMatch=bool(args.get('exactMatch','False'))
                includeAny=bool(args.get('includeAny','False'))
                includeContainment=bool(args.get('includeContainment','True'))
                results=search_query(treeName,ruleSearchQuery,exactMatch,includeAny,includeContainment)


        except Exception as err:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
