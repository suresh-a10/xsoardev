category: Endpoint
commonfields:
  id: CS GraphQL
  version: -1
configuration:
- defaultvalue: https://api.crowdstrike.com/identity-protection/combined/graphql/v1/
  display: 'Server URL '
  name: url
  required: true
  type: 0
- display: Client ID
  name: client_id
  required: true
  type: 0
- display: Secret
  name: secret
  required: false
  type: 4
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "10"
  display: Maximum number of incidents per fetch
  name: max_fetch
  required: false
  type: 0
- defaultvalue: ACTIVE
  display: Fetch alerts with status (ACTIVE)
  name: alert_status
  options:
  - ACTIVE
  - new
  required: false
  type: 15
- additionalinfo: Comma-separated list of types of alerts to fetch. Types might change
    over time. Some examples are 'Bug' and 'Vulnerability'
  display: Fetch alerts with type
  name: alert_type
  required: false
  type: 0
- defaultvalue: medium
  display: Minimum severity of alerts to fetch
  name: min_severity
  options:
  - medium
  - high
  - critical
  required: true
  type: 16
- defaultvalue: 3 days
  display: First fetch time
  name: first_fetch
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
- defaultvalue: detections
  display: ""
  name: fetch_incidents_or_detections
  options:
  - detections
  - incidents
  required: false
  type: 16
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: This is the Hello World integration for getting started.
detaileddescription: |-
  ### Community Contributed Integration
   #### Integration Author: Cortex XSOAR
   No support or maintenance is provided by the author. Customers are encouraged to engage with the user community for questions and guidance at the [Cortex XSOAR Live Discussions](https://live.paloaltonetworks.com/t5/cortex-xsoar-discussions/bd-p/Cortex_XSOAR_Discussions).
  ***
  ## Hello World
  - This section explains how to configure the instance of HelloWorld in Cortex XSOAR.
  - You can use the following API Key: `43ea9b2d-4998-43a6-ae91-aba62a26868c`

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/hello-world)
display: CS GraphQL
image: data:image/png;base64,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
name: CS GraphQL
script:
  commands:
  - arguments:
    - description: The name of whom you want to say hello to.
      name: name
    description: Hello command - prints hello to anyone.
    name: helloworld-say-hello
    outputs:
    - contextPath: hello
      description: Should be Hello **something** here.
      type: String
  - arguments:
    - description: Filter by alert severity. Comma-separated value (Low,Medium,High,Critical)
      name: severity
    - auto: PREDEFINED
      description: Filter by alert status.
      name: status
      predefined:
      - ACTIVE
      - CLOSED
    - description: Filter by alert type
      name: alert_type
    - description: Maximum results to return.
      name: max_results
    - description: "Filter by start time. \nExamples:\n  \"3 days ago\"\n  \"1 month\"\n
        \ \"2019-10-10T12:22:00\"\n  \"2019-10-10\""
      name: start_time
    description: Search HelloWorld Alerts.
    name: helloworld-search-alerts
    outputs:
    - contextPath: HelloWorld.Alert.alert_id
      description: Alert ID.
      type: String
    - contextPath: HelloWorld.Alert.alert_status
      description: Alert status. Can be 'ACTIVE' or 'CLOSED'.
      type: String
    - contextPath: HelloWorld.Alert.alert_type
      description: Alert type. For example 'Bug' or 'Vulnerability'.
      type: String
    - contextPath: HelloWorld.Alert.created
      description: Alert created time. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: HelloWorld.Alert.name
      description: Alert name.
      type: String
    - contextPath: HelloWorld.Alert.severity
      description: Alert severity. Can be 'Low', 'Medium', 'High' or 'Critical'.
      type: String
  - arguments:
    - description: Alert ID.
      name: alert_id
      required: true
    description: Retrieve alert extra data by ID.
    name: helloworld-get-alert
    outputs:
    - contextPath: HelloWorld.Alert.alert_id
      description: Alert ID.
      type: String
    - contextPath: HelloWorld.Alert.created
      description: Alert created time. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: HelloWorld.Alert.description
      description: Alert description.
      type: String
    - contextPath: HelloWorld.Alert.device_id
      description: ID of the device involved in the alert.
      type: String
    - contextPath: HelloWorld.Alert.device_ip
      description: IP Address of the device involved in the alert.
      type: String
    - contextPath: HelloWorld.Alert.location
      description: Location of the device involved in the alert.
      type: String
    - contextPath: HelloWorld.Alert.user
      description: User involved in the alert.
      type: String
  - arguments:
    - description: Alert ID to update.
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: New status of the alert.
      name: status
      predefined:
      - ACTIVE
      - CLOSED
      required: true
    description: Update the status for an alert.
    name: helloworld-update-alert-status
    outputs:
    - contextPath: HelloWorld.Alert.alert_id
      description: Alert ID.
      type: String
    - contextPath: HelloWorld.Alert.updated
      description: Alert update time. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: HelloWorld.Alert.alert_status
      description: Alert status. Can be 'ACTIVE' or 'CLOSED'.
      type: String
  - arguments:
    - default: true
      description: List of IPs.
      isArray: true
      name: ip
    - defaultValue: "65"
      description: If the IP has reputation above the threshold then the IP defined
        as malicious. If threshold not set, then threshold from instance configuration
        is used.
      name: threshold
    description: Return IP information and reputation
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: HelloWorld.IP.asn
      description: The autonomous system name for the IP address.
      type: String
    - contextPath: HelloWorld.IP.asn_cidr
      description: The ASN CIDR.
      type: String
    - contextPath: HelloWorld.IP.asn_country_code
      description: The ASN country code.
      type: String
    - contextPath: HelloWorld.IP.asn_date
      description: The date on which the ASN was assigned.
      type: Date
    - contextPath: HelloWorld.IP.asn_description
      description: The ASN description.
      type: String
    - contextPath: HelloWorld.IP.asn_registry
      description: The registry the ASN belongs to.
      type: String
    - contextPath: HelloWorld.IP.entities
      description: Entities associated to the IP.
      type: String
    - contextPath: HelloWorld.IP.ip
      description: The actual IP address.
      type: String
    - contextPath: HelloWorld.IP.network.cidr
      description: Network CIDR for the IP address.
      type: String
    - contextPath: HelloWorld.IP.network.country
      description: The country of the IP address.
      type: Unknown
    - contextPath: HelloWorld.IP.network.end_address
      description: The last IP address of the CIDR.
      type: String
    - contextPath: HelloWorld.IP.network.events.action
      description: The action that happened on the event.
      type: String
    - contextPath: HelloWorld.IP.network.events.actor
      description: The actor that performed the action on the event.
      type: Unknown
    - contextPath: HelloWorld.IP.network.events.timestamp
      description: The timestamp when the event occurred.
      type: String
    - contextPath: HelloWorld.IP.network.handle
      description: The handle of the network.
      type: String
    - contextPath: HelloWorld.IP.network.ip_version
      description: The IP address version.
      type: String
    - contextPath: HelloWorld.IP.network.links
      description: Links associated to the IP address.
      type: String
    - contextPath: HelloWorld.IP.network.name
      description: The name of the network.
      type: String
    - contextPath: HelloWorld.IP.network.notices.description
      description: The description of the notice.
      type: String
    - contextPath: HelloWorld.IP.network.notices.links
      description: Links associated with the notice.
      type: Unknown
    - contextPath: HelloWorld.IP.network.notices.title
      description: Title of the notice.
      type: String
    - contextPath: HelloWorld.IP.network.parent_handle
      description: Handle of the parent network.
      type: String
    - contextPath: HelloWorld.IP.network.raw
      description: Additional raw data for the network.
      type: Unknown
    - contextPath: HelloWorld.IP.network.remarks
      description: Additional remarks for the network.
      type: Unknown
    - contextPath: HelloWorld.IP.network.start_address
      description: The first IP address of the CIDR.
      type: String
    - contextPath: HelloWorld.IP.network.status
      description: Status of the network.
      type: String
    - contextPath: HelloWorld.IP.network.type
      description: The type of the network.
      type: String
    - contextPath: HelloWorld.IP.query
      description: IP address that was queried.
      type: String
    - contextPath: HelloWorld.IP.raw
      description: Additional raw data for the IP address.
      type: Unknown
    - contextPath: HelloWorld.IP.score
      description: Reputation score from HelloWorld for this IP (0 to 100, where higher
        is worse).
      type: Number
    - contextPath: IP.Address
      description: IP address.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: The vendor reporting the IP address as malicious.
      type: String
    - contextPath: IP.Malicious.Description
      description: A description explaining why the IP address was reported as malicious.
      type: String
    - contextPath: IP.ASN
      description: The autonomous system name for the IP address.
      type: String
    - contextPath: IP.Relationships.EntityA
      description: The source of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityB
      description: The destination of the relationship.
      type: string
    - contextPath: IP.Relationships.Relationship
      description: The name of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: string
  - arguments:
    - default: true
      description: List of Domains.
      isArray: true
      name: domain
    - defaultValue: "65"
      description: If the domain has reputation above the threshold then the domain
        defined as malicious. If threshold not set, then threshold from instance configuration
        is used.
      name: threshold
    description: Returns Domain information and reputation.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: Domain.Name
      description: The domain name.
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: The vendor reporting the domain as malicious.
      type: String
    - contextPath: Domain.Malicious.Description
      description: A description explaining why the domain was reported as malicious.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.Organization
      description: The organization of the domain.
      type: String
    - contextPath: Domain.CreationDate
      description: The creation date of the domain. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: Domain.ExpirationDate
      description: The expiration date of the domain. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: Domain.UpdatedDate
      description: The date when the domain was last updated. Format is ISO8601 (i.e.
        '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: Domain.NameServers
      description: Name servers of the domain.
      type: String
    - contextPath: Domain.WHOIS.NameServers
      description: A CSV string of name servers, for example 'ns1.bla.com, ns2.bla.com'.
      type: String
    - contextPath: Domain.WHOIS.CreationDate
      description: The creation date of the domain. Format is ISO8601 (i.e. '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date when the domain was last updated. Format is ISO8601 (i.e.
        '2020-04-30T10:35:00.000Z').
      type: Date
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.WHOIS.Registrar.Name
      description: The name of the registrar, for example 'GoDaddy'
      type: String
    - contextPath: IP.ASN
      description: The autonomous system name for the IP address.
      type: String
    - contextPath: HelloWorld.Domain.address
      description: Domain admin address.
      type: String
    - contextPath: HelloWorld.Domain.city
      description: Domain admin city.
      type: String
    - contextPath: HelloWorld.Domain.country
      description: Domain admin country.
      type: String
    - contextPath: HelloWorld.Domain.creation_date
      description: Domain creation date. Format is ISO8601.
      type: Date
    - contextPath: HelloWorld.Domain.dnssec
      description: DNSSEC status.
      type: String
    - contextPath: HelloWorld.Domain.domain
      description: The domain name.
      type: String
    - contextPath: HelloWorld.Domain.domain_name
      description: Domain name options.
      type: String
    - contextPath: HelloWorld.Domain.emails
      description: Contact emails.
      type: String
    - contextPath: HelloWorld.Domain.expiration_date
      description: Expiration date. Format is ISO8601.
      type: Date
    - contextPath: HelloWorld.Domain.name
      description: Domain admin name.
      type: String
    - contextPath: HelloWorld.Domain.name_servers
      description: Name server.
      type: String
    - contextPath: HelloWorld.Domain.org
      description: Domain organization.
      type: String
    - contextPath: HelloWorld.Domain.referral_url
      description: Referral URL.
      type: Unknown
    - contextPath: HelloWorld.Domain.registrar
      description: Domain registrar.
      type: String
    - contextPath: HelloWorld.Domain.score
      description: Reputation score from HelloWorld for this domain (0 to 100, where
        higher is worse).
      type: Number
    - contextPath: HelloWorld.Domain.state
      description: Domain admin state.
      type: String
    - contextPath: HelloWorld.Domain.status
      description: Domain status.
      type: String
    - contextPath: HelloWorld.Domain.updated_date
      description: Updated date. Format is ISO8601.
      type: Date
    - contextPath: HelloWorld.Domain.whois_server
      description: WHOIS server.
      type: String
    - contextPath: HelloWorld.Domain.zipcode
      description: Domain admin zipcode.
      type: Unknown
  - arguments:
    - description: Asset to start the scan against.
      name: hostname
      required: true
    description: Start scan on an asset.
    name: helloworld-scan-start
    outputs:
    - contextPath: HelloWorld.Scan.scan_id
      description: Unique ID of the scan.
      type: string
    - contextPath: HelloWorld.Scan.status
      description: Status of the scan ('RUNNING' or 'COMPLETE').
      type: string
    - contextPath: HelloWorld.Scan.hostname
      description: The hostname the scan is run against.
      type: string
  - arguments:
    - description: List of Scan IDs. helloworld-scan-start returns "scan_id".
      isArray: true
      name: scan_id
      required: true
    description: Retrieve scan status for one or more scan IDs.
    name: helloworld-scan-status
    outputs:
    - contextPath: HelloWorld.Scan.scan_id
      description: Unique ID of the scan.
      type: string
    - contextPath: HelloWorld.Scan.status
      description: Status of the scan ('RUNNING' or 'COMPLETE').
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: file
      description: Results format (file or JSON).
      name: format
      predefined:
      - json
      - file
      required: true
    - description: Unique ID of the scan.
      name: scan_id
      required: true
    description: Retrieve scan status in Context or as a File (default) for a Scan.
    name: helloworld-scan-results
    outputs:
    - contextPath: HelloWorld.Scan.entities.entity-id
      description: Scanned entity ID.
      type: String
    - contextPath: HelloWorld.Scan.entities.ip_address
      description: Scanned entity IP address.
      type: String
    - contextPath: HelloWorld.Scan.entities.type
      description: Scanned entity type.
      type: String
    - contextPath: HelloWorld.Scan.entities.vulnerability_status
      description: Scanned entity vulnerability status.
      type: String
    - contextPath: HelloWorld.Scan.entities.vulns
      description: Scanned entity CVE.
      type: String
    - contextPath: HelloWorld.Scan.scan_id
      description: Unique ID of the scan.
      type: String
    - contextPath: HelloWorld.Scan.status
      description: Status of the scan ('RUNNING' or 'COMPLETE').
      type: String
    - contextPath: InfoFile.EntryID
      description: The EntryID of the report file.
      type: Unknown
    - contextPath: InfoFile.Extension
      description: The extension of the report file.
      type: string
    - contextPath: InfoFile.Name
      description: The name of the report file.
      type: string
    - contextPath: InfoFile.Info
      description: The info of the report file.
      type: string
    - contextPath: InfoFile.Size
      description: The size of the report file.
      type: number
    - contextPath: InfoFile.Type
      description: The type of the report file.
      type: string
    - contextPath: CVE.ID
      description: The ID of the CVE.
      type: string
  - arguments:
    - description: query to executre
      name: query
    description: 'query '
    name: graphql-query
  dockerimage: demisto/python3:3.10.5.31928
  isfetch: true
  runonce: false
  script: |2

    ''' IMPORTS '''
    import json
    import requests
    import base64
    import email
    import hashlib
    from typing import List
    from dateutil.parser import parse
    from typing import Dict, Tuple, Any, Optional, Union
    from threading import Timer

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''
    INTEGRATION_NAME = 'CrowdStrike Falcon GraphQL'
    CLIENT_ID = demisto.params().get('client_id')
    SECRET = demisto.params().get('secret')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else \
        demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('insecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    BYTE_CREDS = '{name}:{password}'.format(name=CLIENT_ID, password=SECRET).encode('utf-8')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic {}'.format(base64.b64encode(BYTE_CREDS).decode())
    }
    # Note: True life time of token is actually 30 mins
    TOKEN_LIFE_TIME = 28
    INCIDENTS_PER_FETCH = int(demisto.params().get('incidents_per_fetch', 15))
    # Remove proxy if not set to true in params
    handle_proxy()







    """CLIENT CLASS"""

    class Client(BaseClient):
        def whoami(self) -> Dict[str, Any]:
            """Entity lookup."""
            return self._http_request(
                method="get",
                #url_suffix="info/whoami",
                url_suffix="/identity-protection/combined/graphql/v1",
                timeout=60,
            )



    ''' HELPER FUNCTIONS '''
    def http_request(method, url_suffix, params=None, data=None, files=None, headers=HEADERS, safe=False,
                     get_token_flag=True, no_json=False, json=None, status_code=None):
        """
            A wrapper for requests lib to send our requests and handle requests and responses better.

            :param json: JSON body
            :type json ``dict`` or ``list``

            :type method: ``str``
            :param method: HTTP method for the request.

            :type url_suffix: ``str``
            :param url_suffix: The suffix of the URL (endpoint)

            :type params: ``dict``
            :param params: The URL params to be passed.

            :type data: ``str``
            :param data: The body data of the request.

            :type headers: ``dict``
            :param headers: Request headers

            :type safe: ``bool``
            :param safe: If set to true will return None in case of http error

            :type get_token_flag: ``bool``
            :param get_token_flag: If set to True will call get_token()

            :type no_json: ``bool``
            :param no_json: If set to true will not parse the content and will return the raw response object for successful
            response

            :type status_code: ``int``
            :param: status_code: The request codes to accept as OK.

            :return: Returns the http request response json
            :rtype: ``dict``
        """
        if get_token_flag:
            token = get_token()
            headers['Authorization'] = 'Bearer {}'.format(token)
        url = SERVER + url_suffix
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                data=data,
                headers=headers,
                files=files,
                json=json
            )
        except requests.exceptions.RequestException:
            return_error('Error in connection to the server. Please make sure you entered the URL correctly.')
        try:
            valid_status_codes = {200, 201, 202, 204}
            # Handling a case when we want to return an entry for 404 status code.
            if status_code:
                valid_status_codes.add(status_code)
            if res.status_code not in valid_status_codes:
                res_json = res.json()
                reason = res.reason
                resources = res_json.get('resources', {})
                if resources:
                    error_msg = resources[0].get('message')
                    reason += f'\n{error_msg}'
                elif res_json.get('errors'):
                    errors = res_json.get('errors', [])
                    for error in errors:
                        reason += f"\n{error.get('message')}"
                err_msg = 'Error in API call to CrowdStrike Falcon: code: {code} - reason: {reason}'.format(
                    code=res.status_code,
                    reason=reason
                )
                # try to create a new token
                if res.status_code == 403 and get_token_flag:
                    LOG(err_msg)
                    token = get_token(new_token=True)
                    headers['Authorization'] = 'Bearer {}'.format(token)
                    return http_request(
                        method=method,
                        url_suffix=url_suffix,
                        params=params,
                        data=data,
                        headers=headers,
                        files=files,
                        json=json,
                        safe=safe,
                        get_token_flag=False,
                        status_code=status_code,
                        no_json=no_json,
                    )
                elif safe:
                    return None
                return_error(err_msg)
            return res if no_json else res.json()
        except ValueError as exception:
            raise ValueError(
                f'Failed to parse json object from response: {exception} - {res.content}')  # type: ignore[str-bytes-safe]


    def create_entry_object(contents: Union[List[Any], Dict[str, Any]] = {}, ec: Union[List[Any], Dict[str, Any]] = None,
                            hr: str = ''):
        """
            Creates an entry object

            :type contents: ``dict``
            :param contents: Raw response to output

            :type ec: ``dict``
            :param ec: Entry context of the entry object

            :type hr: ``str``
            :param hr: Human readable

            :return: Entry object
            :rtype: ``dict``
        """
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }

    def severity_string_to_int(severity):
        """
            Converts a severity string to DBot score representation

            :type severity: ``str``
            :param severity: String representation of a severity

            :return: DBot score representation of the severity
            :rtype ``int``
        """
        if severity in ('Critical', 'High'):
            return 3
        elif severity in ('Medium', 'Low'):
            return 2
        return 0


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
            Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict

            :type old_dict: ``dict``
            :param old_dict: Old dictionary to pull values from

            :type transformation_dict: ``dict``
            :param transformation_dict: Transformation dictionary that contains oldkeys:newkeys

            :return Transformed dictionart (according to transformation_dict values)
            :rtype ``dict``
        """
        new_dict = {}
        for k in list(old_dict.keys()):
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict

    def get_passed_mins(start_time, end_time_str):
        """
            Returns the time passed in mins
            :param start_time: Start time in datetime
            :param end_time_str: End time in str
            :return: The passed mins in int
        """
        time_delta = start_time - datetime.fromtimestamp(end_time_str)
        return time_delta.seconds / 60


    def handle_response_errors(raw_res: dict, err_msg: str = None):
        """
        Raise exception if raw_res is empty or contains errors
        """
        if not err_msg:
            err_msg = "The server was unable to return a result, please run the command again."
        if not raw_res:
            raise DemistoException(err_msg)
        if raw_res.get('errors'):
            raise DemistoException(raw_res.get('errors'))
        return


    ''' COMMAND SPECIFIC FUNCTIONS '''

    def get_token(new_token=False):
        """
            Retrieves the token from the server if it's expired and updates the global HEADERS to include it

            :param new_token: If set to True will generate a new token regardless of time passed

            :rtype: ``str``
            :return: Token
        """
        now = datetime.now()
        ctx = demisto.getIntegrationContext()
        if ctx and not new_token:
            passed_mins = get_passed_mins(now, ctx.get('time'))
            if passed_mins >= TOKEN_LIFE_TIME:
                # token expired
                auth_token = get_token_request()
                demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
            else:
                # token hasn't expired
                auth_token = ctx.get('auth_token')
        else:
            # there is no token
            auth_token = get_token_request()
            demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
        return auth_token


    def get_token_request():
        """
            Sends token request

            :rtype ``str``
            :return: Access token
        """
        body = {
            'client_id': CLIENT_ID,
            'client_secret': SECRET
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        token_res = http_request('POST', '/oauth2/token', data=body, headers=headers, safe=True,
                                 get_token_flag=False)
        if not token_res:
            err_msg = 'Authorization Error: User has no authorization to create a token. Please make sure you entered the' \
                      ' credentials correctly.'
            raise Exception(err_msg)
        return token_res.get('access_token')


    def test_module():
        try:
            get_token(new_token=True)
        except ValueError:
            return 'Connection Error: The URL or The API key you entered is probably incorrect, please try again.'
        return 'ok'


    def execute_query(args):
        query = args.get('query')
        url = "/identity-protection/combined/graphql/v1"



        #payload=": ProgrammaticUserAccountR{\"query\":\"{\\r\\n\\r\\nentities(types: USER\\r\\n\\r\\n        rolesole\\r\\n\\r\\n        watched: true\\r\\n\\r\\n        first: 1000)\\r\\n\\r\\n    {\\r\\n\\r\\n        nodes {\\r\\n\\r\\n            primaryDisplayName\\r\\n\\r\\n            secondaryDisplayName\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n}\",\"variables\":{}}"
        #payload="{\"query\":\"{\\r\\n\\r\\nentities(types: USER\\r\\n\\r\\n        roles: ProgrammaticUserAccountRole\\r\\n\\r\\n        watched: true\\r\\n\\r\\n        first: 1000)\\r\\n\\r\\n    {\\r\\n\\r\\n        nodes {\\r\\n\\r\\n            primaryDisplayName\\r\\n\\r\\n            secondaryDisplayName\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n}\",\"variables\":{}}"
        #payload="{\"query ($types: [TimelineEventType!], $startTime: DateTimeInput, $endTime: DateTimeInput, $sourceEndpointQuery: EntityQueryInput, $sourceEntityQuery: EntityQueryInput, $targetEndpointQuery: EntityQueryInput, $targetEntityQuery: EntityQueryInput, $activityQuery: ActivityQueryInput, $alertQuery: AlertQueryInput, $relatedTo: EventId, $after: Cursor, $limit: Int!, $sortOrder: SortOrder) {\\r\\n  timeline(categories: [THREAT_HUNTER], sourceEntityQuery: $sourceEntityQuery, types: $types, startTime: $startTime, endTime: $endTime, activityQuery: $activityQuery, alertQuery: $alertQuery, sourceEndpointQuery: $sourceEndpointQuery, targetEndpointQuery: $targetEndpointQuery, targetEntityQuery: $targetEntityQuery, relatedTo: $relatedTo, after: $after, first: $limit, sortOrder: $sortOrder) {\\r\\n    edges {\\r\\n      cursor\\r\\n      node {\\r\\n        eventId\\r\\n        timestamp\\r\\n        eventType\\r\\n        eventLabel\\r\\n        eventSeverity\\r\\n        ... on TimelineEntityEvent {\\r\\n          entity {\\r\\n            ...MinimalEntityDescriptor\\r\\n            accounts {\\r\\n              dataSource\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n        ... on TimelineUserOnEndpointActivityEvent {\\r\\n          endpointEntity {\\r\\n            ...MinimalEntityDescriptor\\r\\n          }\\r\\n          endpointDisplayName\\r\\n          ipAddress\\r\\n          networkType\\r\\n          userEntity {\\r\\n            ...MinimalEntityDescriptor\\r\\n          }\\r\\n          userDisplayName\\r\\n          targetEntity {\\r\\n            ...MinimalEntityDescriptor\\r\\n            accounts {\\r\\n              dataSource\\r\\n            }\\r\\n          }\\r\\n          targetServiceIdentifier\\r\\n          targetServiceDescription\\r\\n          targetServiceType\\r\\n        }\\r\\n        ... on TimelineAuthenticationEvent {\\r\\n          authenticationType\\r\\n        }\\r\\n        ... on TimelineAlertEvent {\\r\\n          alertType\\r\\n          patternId\\r\\n          endpointEntity {\\r\\n            ...MinimalEntityDescriptor\\r\\n          }\\r\\n          userEntity {\\r\\n            ...MinimalEntityDescriptor\\r\\n          }\\r\\n        }\\r\\n        ... on TimelineDceRpcEvent {\\r\\n          dcerpcSignature\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    pageInfo {\\r\\n      hasNextPage\\r\\n      hasPreviousPage\\r\\n      endCursor\\r\\n      startCursor\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfragment MinimalEntityDescriptor on Entity {\\r\\n  entityId\\r\\n  type\\r\\n  primaryDisplayName\\r\\n  secondaryDisplayName\\r\\n  archived\\r\\n  ... on UserEntity {\\r\\n    emailAddresses\\r\\n  }\\r\\n  roles {\\r\\n    fullPath\\r\\n    type\\r\\n  }\\r\\n  ... on EntityContainerEntity {\\r\\n    containerType\\r\\n    accounts {\\r\\n      dataSource\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"variables\":{\"limit\":15,\"sourceEntityQuery\":{\"types\":[\"USER\",\"CLOUD_SERVICE\"],\"hasWeakPassword\":true},\"startTime\":\"PT-24H\",\"sortOrder\":\"DESCENDING\"}}"
        #payload="{ timeline(categories: [THREAT_HUNTER], types: [USER,CLOUD_SERVICE], startTime: PT-24H,first: 10, sortOrder: DESCENDING){ edges { cursor node { eventId timestamp eventType eventLabel eventSeverity ... on TimelineEntityEvent { entity { accounts { dataSource } entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } } ... on TimelineUserOnEndpointActivityEvent { endpointEntity { entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } endpointDisplayName ipAddress networkType userEntity { entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } userDisplayName targetEntity { accounts { dataSource } entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } targetServiceIdentifier targetServiceDescription targetServiceType } ... on TimelineAuthenticationEvent { authenticationType } ... on TimelineAlertEvent { alertType patternId endpointEntity { entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } userEntity { entityId type primaryDisplayName secondaryDisplayName archived ... on UserEntity { emailAddresses } roles { fullPath type } ... on EntityContainerEntity { containerType accounts { dataSource } } } } ... on TimelineDceRpcEvent { dcerpcSignature } } } pageInfo { hasNextPage hasPreviousPage endCursor startCursor } }}"
        payload={"query":query}
        """headers = {
            'Authorization': 'Bearer Q8Apj7PXZ1o0Vb4kwaHGJE5r3cBve9tdhism6q2K 5ef24379d593456aa1a401cafe8065ee',
            'Content-Type': 'application/json'

        }"""


        res= http_request('POST',url,headers=HEADERS,json=payload)
        print(res)

    def main():
        command = demisto.command()
        # should raise error in case of issue

        args = demisto.args()
        try:
            if command == 'test-module':
                result = test_module()
                return_results(result)

            elif command == 'graphql-query':
                return_results(execute_query(demisto.args()))




        except Exception as e:
            return_error(str(e))


    if __name__ in ('__main__', 'builtin', 'builtins'):
        main()
  subtype: python3
  type: python
