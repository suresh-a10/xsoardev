category: Case Management
commonfields:
  id: RSA Archer v2 test
  version: -1
configuration:
- display: Server URL (e.g., https://192.168.0.1/)
  name: url
  required: true
  type: 0
- additionalinfo: Change only if you have other API Endpoint.
  defaultvalue: rsaarcher/api
  display: 'Advanced: API Endpoint'
  name: api_endpoint
  required: false
  type: 0
- display: Instance name
  name: instanceName
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: User domain
  name: userDomain
  required: false
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Application ID for fetch
  name: applicationId
  required: true
  type: 0
- defaultvalue: Date/Time Occurred
  display: Application date field for fetch
  name: applicationDateField
  required: true
  type: 0
- defaultvalue: "10"
  display: Maximum number of incidents to pull per fetch
  name: fetch_limit
  required: false
  type: 0
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: fetch_time
  required: false
  type: 0
- display: List of fields from the application to get into the incident
  name: fields_to_fetch
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: The RSA Archer GRC Platform provides a common foundation for managing
  policies, controls, risks, assessments, and deficiencies across lines of business.
detaileddescription: " \n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/rsa-archer-v2)"
display: RSA Archer v2 test
image: data:image/png;base64,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
name: RSA Archer v2 test
script:
  commands:
  - arguments:
    - description: The application ID for which to get details. Leave empty to get
        a list of all applications.
      name: applicationId
    - defaultValue: "20"
      description: The maximum number of applications to return.
      name: limit
    description: Gets application details or a list of all applications.
    name: archer-search-applications
    outputs:
    - contextPath: Archer.Application.Guid
      description: The application GUID.
      type: String
    - contextPath: Archer.Application.Id
      description: Unique ID of the application.
      type: Number
    - contextPath: Archer.Application.Status
      description: The application status.
      type: Number
    - contextPath: Archer.Application.Type
      description: The application type.
      type: Number
    - contextPath: Archer.Application.Name
      description: The application name.
      type: String
  - arguments:
    - description: The application ID for which to get the application fields.
      name: applicationId
      required: true
    description: Gets all application fields by application ID.
    name: archer-get-application-fields
    outputs:
    - contextPath: Archer.ApplicationField.FieldId
      description: Unique ID of the field.
      type: Number
    - contextPath: Archer.ApplicationField.FieldName
      description: The field name.
      type: String
    - contextPath: Archer.ApplicationField.FieldType
      description: The field type.
      type: String
    - contextPath: Archer.ApplicationField.LevelID
      description: The field level ID.
      type: Number
  - arguments:
    - description: ID of the field.
      name: fieldID
      required: true
    description: Returns mapping from list value name to list value ID.
    name: archer-get-field
    outputs:
    - contextPath: Archer.ApplicationField.FieldId
      description: Unique ID of the field.
      type: Number
    - contextPath: Archer.ApplicationField.FieldName
      description: The field name.
      type: String
    - contextPath: Archer.ApplicationField.FieldType
      description: The field type.
      type: String
    - contextPath: Archer.ApplicationField.LevelID
      description: The field level ID.
      type: Number
  - arguments:
    - description: ID of the level.
      name: level
      required: true
    description: Returns mapping of fields by level ID.
    name: archer-get-mapping-by-level
    outputs:
    - contextPath: Archer.LevelMapping.Id
      description: Unique ID of the field.
      type: Number
    - contextPath: Archer.LevelMapping.Name
      description: The field name.
      type: String
    - contextPath: Archer.LevelMapping.Type
      description: The field type.
      type: String
    - contextPath: Archer.LevelMapping.LevelId
      description: The field level ID.
      type: Number
  - arguments:
    - description: The record ID.
      name: contentId
      required: true
    - description: The application ID.
      name: applicationId
      required: true
    description: Gets information about a content record in the given application.
    name: archer-get-record
    outputs:
    - contextPath: Archer.Record.Id
      description: Unique ID of the record.
      type: Number
  - arguments:
    - description: The application ID.
      name: applicationId
      required: true
    - description: 'Record fields in JSON format: { "Name1": Value1, "Name2": Value2
        }. Field names are case sensitive.'
      name: fieldsToValues
      required: true
    - description: The Level ID to use to create the record. If empty, the command
        will take the first level as default.
      name: levelId
    description: Creates a new content record in the given application.
    name: archer-create-record
    outputs:
    - contextPath: Archer.Record.Id
      description: Unique ID of the record.
      type: Number
  - arguments:
    - description: The ID of the record to delete.
      name: contentId
      required: true
    description: Deletes an existing content record in the given application.
    name: archer-delete-record
  - arguments:
    - description: The application ID.
      name: applicationId
      required: true
    - description: 'Record fields in JSON format: { "Name1": Value1, "Name2": Value2
        }. Field names are case sensitive.'
      name: fieldsToValues
      required: true
    - description: The ID of the record to update.
      name: contentId
      required: true
    - description: The Level ID to use to update the record. If empty, the command
        will take the first level as default.
      name: levelId
    description: Updates an existing content record in the given application.
    name: archer-update-record
  - arguments:
    - description: The report GUID.
      name: reportGuid
      required: true
    - defaultValue: "100"
      description: Maximum number of pages for the reports.
      name: maxResults
      required: true
    description: Performs a statistic search by report GUID.
    name: archer-execute-statistic-search-by-report
  - arguments: []
    description: Gets all reports from Archer.
    name: archer-get-reports
  - arguments:
    - description: The report GUID.
      name: reportGuid
      required: true
    description: Returns search criteria by report GUID.
    name: archer-get-search-options-by-guid
  - arguments: []
    description: Resets Archer's integration cache. Run this command if you change
      the fields of your Archer application.
    name: archer-reset-cache
  - arguments:
    - description: The field ID.
      name: fieldID
      required: true
    description: Returns a list of values for a specified field, e.g., fieldID=16114.
      This command only works for value list fields (type 4).
    name: archer-get-valuelist
    outputs:
    - contextPath: Archer.ApplicationField.ValuesList.Id
      description: The field value ID.
      type: Number
    - contextPath: Archer.ApplicationField.ValuesList.IsSelectable
      description: Specifies whether you can select the field value.
      type: Boolean
    - contextPath: Archer.ApplicationField.ValuesList.Name
      description: The field value name.
      type: String
  - arguments:
    - description: The entry ID of the file in Cortex XSOAR context.
      name: entryId
      required: true
    - description: ID of the application to upload the file to.
      name: applicationId
    - description: The Content (record) ID to update.
      name: contentId
    - defaultValue: Supporting Documentation
      description: Archer field name to associate the file with.
      name: associatedField
    description: Uploads a file to Archer.
    name: archer-upload-file
  - arguments:
    - description: The attachment ID.
      name: fileId
      required: true
    description: Downloads a file from Archer to Cortex XSOAR context.
    name: archer-get-file
    outputs:
    - contextPath: File
      description: The file details command results.
      type: Unknown
    - contextPath: File.Name
      description: The full file name (including the file extension).
      type: String
    - contextPath: File.EntryID
      description: The ID for locating the file in the War Room.
      type: String
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: Number
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Extension
      description: 'The file extension. For example: "xls".'
      type: String
    - contextPath: File.Type
      description: The file type, as determined by libmagic (same as displayed in
        file entries).
      type: String
  - arguments:
    - description: The ID of the user for which to get details. Leave empty to get
        a list of all users.
      name: userId
    description: Gets details for a user or a list of all users.
    name: archer-list-users
    outputs:
    - contextPath: Archer.User.AccountStatus
      description: The status of the user.
      type: String
    - contextPath: Archer.User.DisplayName
      description: The display name of the user.
      type: String
    - contextPath: Archer.User.FirstName
      description: The first name of the user.
      type: String
    - contextPath: Archer.User.Id
      description: Unique ID of the user.
      type: Number
    - contextPath: Archer.User.LastLoginDate
      description: Last login date of user.
      type: Date
    - contextPath: Archer.User.LastName
      description: The last name of the user.
      type: String
    - contextPath: Archer.User.MiddleName
      description: The middle name of the user.
      type: String
    - contextPath: Archer.User.UserName
      description: The username associated with the account.
      type: String
  - arguments:
    - description: ID of the application in which to search for records.
      name: applicationId
      required: true
    - description: Name of the field on which to search. Leave empty to search for
        all fields.
      name: fieldToSearchOn
    - description: Search value. Leave empty to search for all.
      name: searchValue
    - defaultValue: "10"
      description: Maximum number of results to return from the search. Default is
        10.
      name: maxResults
    - description: 'Fields to present in the search results (in array format). For
        example: "Title,Incident Summary".'
      name: fieldsToDisplay
    - auto: PREDEFINED
      description: Numeric search operator. Can be "Equals", "NotEqual", "GreaterThan",
        or "LessThan".
      name: numericOperator
      predefined:
      - Equals
      - NotEqual
      - GreaterThan
      - LessThan
    - auto: PREDEFINED
      description: Date search operator. Can be "Equals", "DoesNotEqual", "GreaterThan",
        or "LessThan".
      name: dateOperator
      predefined:
      - Equals
      - DoesNotEqual
      - GreaterThan
      - LessThan
    - description: Fields to fetch from the application.
      name: fieldsToGet
    - auto: PREDEFINED
      defaultValue: "False"
      description: Whether to get extended responses with all of the data regarding
        this search. For example, "fullData=true".
      name: fullData
      predefined:
      - "True"
      - "False"
      required: true
    - auto: PREDEFINED
      description: Whether to order by descending order.
      name: isDescending
      predefined:
      - "true"
      - "false"
    - description: The Level ID to use for searching. This argument is relevant when
        fullData is True. If empty, the command will take the first level as default.
      name: levelId
    description: Searches for records in the given application.
    name: archer-search-records
    outputs:
    - contextPath: Archer.Record
      description: The content object.
      type: Unknown
    - contextPath: Archer.Record.Id
      description: The content ID.
      type: Number
  - arguments:
    - description: The report GUID.
      name: reportGuid
      required: true
    description: Searches records by report GUID.
    name: archer-search-records-by-report
    outputs:
    - contextPath: Archer.SearchByReport.ReportGUID
      description: The report GUID.
      type: String
    - contextPath: Archer.SearchByReport.RecordsAmount
      description: Number of records found by the search.
      type: Number
    - contextPath: Archer.SearchByReport.Record
      description: The records found by the search.
      type: Unknown
  - arguments: []
    description: prints Archer's integration cache.
    name: archer-print-cache
  dockerimage: demisto/python3:3.9.6.22912
  isfetch: true
  runonce: false
  script: |
    from datetime import timezone
    from typing import Dict, Tuple, Union

    import dateparser
    import urllib3



    ''' IMPORTS '''

    # Disable insecure warnings
    urllib3.disable_warnings()

    FETCH_PARAM_ID_KEY = 'field_time_id'
    LAST_FETCH_TIME_KEY = 'last_fetch'
    OCCURRED_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'

    REQUEST_HEADERS = {
        'Accept': 'application/json,text/html,application/xhtml +xml,application/xml;q=0.9,*/*;q=0.8',
        'Content-Type': 'application/json'
    }

    FIELD_TYPE_DICT = {
        1: 'Text', 2: 'Numeric', 3: 'Date', 4: 'Values List', 6: 'TrackingID', 7: 'External Links',
        8: 'Users/Groups List', 9: 'Cross-Reference', 11: 'Attachment', 12: 'Image',
        14: 'Cross-Application Status Tracking (CAST)', 16: 'Matrix', 19: 'IP Address', 20: 'Record Status',
        21: 'First Published', 22: 'Last Updated Field', 23: 'Related Records', 24: 'Sub-Form',
        25: 'History Log', 26: 'Discussion', 27: 'Multiple Reference Display Control',
        28: 'Questionnaire Reference', 29: 'Access History', 30: 'V oting', 31: 'Scheduler',
        1001: 'Cross-Application Status Tracking Field Value'
    }

    ACCOUNT_STATUS_DICT = {1: 'Active', 2: 'Inactive', 3: 'Locked'}

    API_ENDPOINT = demisto.params().get('api_endpoint', 'rsaarcher/api').lower().replace('rsaarcher', '')


    def parser(date_str, date_formats=None, languages=None, locales=None, region=None, settings=None) -> datetime:
        """Wrapper of dateparser.parse to support return type value
        """
        date_obj = dateparser.parse(
            date_str, date_formats=date_formats, languages=languages, locales=locales, region=region, settings=settings
        )
        assert isinstance(date_obj, datetime), f'Could not parse date {date_str}'  # MYPY Fix
        return date_obj.replace(tzinfo=timezone.utc)


    def get_token_soap_request(user, password, instance):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.orecord_to_incidentrg/2001/XMLSchema-instance" ' \
               'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <CreateUserSessionFromInstance xmlns="http://archer-tech.com/webservices/">' + \
               f'            <userName>{user}</userName>' + \
               f'            <instanceName>{instance}</instanceName>' + \
               f'            <password>{password}</password>' + \
               '        </CreateUserSessionFromInstance>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def terminate_session_soap_request(token):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' \
               ' xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <TerminateSession xmlns="http://archer-tech.com/webservices/">' + \
               f'            <sessionToken>{token}</sessionToken>' + \
               '        </TerminateSession>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def get_reports_soap_request(token):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' \
               'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <GetReports xmlns="http://archer-tech.com/webservices/">' + \
               f'            <sessionToken>{token}</sessionToken>' + \
               '        </GetReports>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def get_statistic_search_report_soap_request(token, report_guid, max_results):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' \
               ' xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <ExecuteStatisticSearchByReport xmlns="http://archer-tech.com/webservices/">' + \
               f'            <sessionToken>{token}</sessionToken>' + \
               f'            <reportIdOrGuid>{report_guid}</reportIdOrGuid>' + \
               f'            <pageNumber>{max_results}</pageNumber>' + \
               '        </ExecuteStatisticSearchByReport>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def get_search_options_soap_request(token, report_guid):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' \
               'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <GetSearchOptionsByGuid xmlns="http://archer-tech.com/webservices/">' + \
               f'            <sessionToken>{token}</sessionToken>' + \
               f'            <searchReportGuid>{report_guid}</searchReportGuid>' + \
               '        </GetSearchOptionsByGuid>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def search_records_by_report_soap_request(token, report_guid):
        return '<?xml version="1.0" encoding="utf-8"?>' + \
               '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' \
               'xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' + \
               '    <soap:Body>' + \
               '        <SearchRecordsByReport xmlns="http://archer-tech.com/webservices/">' + \
               f'            <sessionToken>{token}</sessionToken>' + \
               f'            <reportIdOrGuid>{report_guid}</reportIdOrGuid>' + \
               '            <pageNumber>1</pageNumber>' + \
               '        </SearchRecordsByReport>' + \
               '    </soap:Body>' + \
               '</soap:Envelope>'


    def search_records_soap_request(
            token, app_id, display_fields, field_id, field_name, search_value, date_operator='',
            numeric_operator='', max_results=10,
            sort_type: str = 'Ascending'
    ):
        request_body = '<?xml version="1.0" encoding="UTF-8"?>' + \
                       '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" ' \
                       'xmlns:xsd="http://www.w3.org/2001/XMLSchema"' \
                       ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' + \
                       '    <soap:Body>' + \
                       '        <ExecuteSearch xmlns="http://archer-tech.com/webservices/">' + \
                       f'            <sessionToken>{token}</sessionToken>' + \
                       '            <searchOptions>' + \
                       '                <![CDATA[<SearchReport>' + \
                       f'                <PageSize>{max_results}</PageSize>' + \
                       '                 <PageNumber>1</PageNumber>' + \
                       f'                <MaxRecordCount>{max_results}</MaxRecordCount>' + \
                       '                <ShowStatSummaries>false</ShowStatSummaries>' + \
                       f'                <DisplayFields>{display_fields}</DisplayFields>' + \
                       f'             <Criteria><ModuleCriteria><Module name="appname">{app_id}</Module></ModuleCriteria>'

        if search_value:
            request_body += '<Filter><Conditions>'

            if date_operator:
                request_body += '<DateComparisonFilterCondition>' + \
                                f'        <Operator>{date_operator}</Operator>' + \
                                f'        <Field name="{field_name}">{field_id}</Field>' + \
                                f'        <Value>{search_value}</Value>' + \
                                '        <TimeZoneId>UTC Standard Time</TimeZoneId>' + \
                                '        <IsTimeIncluded>TRUE</IsTimeIncluded>' + \
                                '</DateComparisonFilterCondition >'
            elif numeric_operator:
                request_body += '<NumericFilterCondition>' + \
                                f'        <Operator>{numeric_operator}</Operator>' + \
                                f'        <Field name="{field_name}">{field_id}</Field>' + \
                                f'        <Value>{search_value}</Value>' + \
                                '</NumericFilterCondition >'
            else:
                request_body += '<TextFilterCondition>' + \
                                '        <Operator>Contains</Operator>' + \
                                f'        <Field name="{field_name}">{field_id}</Field>' + \
                                f'        <Value>{search_value}</Value>' + \
                                '</TextFilterCondition >'

            request_body += '</Conditions></Filter>'

        if date_operator:  # Fetch incidents must present date_operator
            request_body += '<Filter>' + \
                            '<Conditions>' + \
                            '    <DateComparisonFilterCondition>' + \
                            f'        <Operator>{date_operator}</Operator>' + \
                            f'        <Field name="{field_name}">{field_id}</Field>' + \
                            f'        <Value>{search_value}</Value>' + \
                            '        <TimeZoneId>UTC Standard Time</TimeZoneId>' + \
                            '        <IsTimeIncluded>TRUE</IsTimeIncluded>' + \
                            '    </DateComparisonFilterCondition >' + \
                            '</Conditions>' + \
                            '</Filter>'

        if field_id:
            request_body += '<SortFields>' + \
                            '    <SortField>' + \
                            f'        <Field>{field_id}</Field>' + \
                            f'        <SortType>{sort_type}</SortType>' + \
                            '    </SortField >' + \
                            '</SortFields>'

        request_body += ' </Criteria></SearchReport>]]>' + \
                        '</searchOptions>' + \
                        '<pageNumber>1</pageNumber>' + \
                        '</ExecuteSearch>' + \
                        '</soap:Body>' + \
                        '</soap:Envelope>'

        return request_body


    SOAP_COMMANDS = {
        'archer-get-reports': {'soapAction': 'http://archer-tech.com/webservices/GetReports', 'urlSuffix': 'ws/search.asmx',
                               'soapBody': get_reports_soap_request,
                               'outputPath': 'Envelope.Body.GetReportsResponse.GetReportsResult'},
        'archer-execute-statistic-search-by-report': {
            'soapAction': 'http://archer-tech.com/webservices/ExecuteStatisticSearchByReport',
            'urlSuffix': 'ws/search.asmx',
            'soapBody': get_statistic_search_report_soap_request,
            'outputPath': 'Envelope.Body.ExecuteStatisticSearchByReportResponse.ExecuteStatistic'
                          'SearchByReportResult'
        },
        'archer-get-search-options-by-guid':
            {'soapAction': 'http://archer-tech.com/webservices/GetSearchOptionsByGuid',
             'urlSuffix': 'ws/search.asmx',
             'soapBody': get_search_options_soap_request,
             'outputPath': 'Envelope.Body.GetSearchOptionsByGuidResponse.GetSearchOptionsByGuidResult'
             },
        'archer-search-records':
            {'soapAction': 'http://archer-tech.com/webservices/ExecuteSearch',
             'urlSuffix': 'ws/search.asmx',
             'soapBody': search_records_soap_request,
             'outputPath': 'Envelope.Body.ExecuteSearchResponse.ExecuteSearchResult'},
        'archer-search-records-by-report': {
            'soapAction': 'http://archer-tech.com/webservices/SearchRecordsByReport',
            'urlSuffix': 'ws/search.asmx',
            'soapBody': search_records_by_report_soap_request,
            'outputPath': 'Envelope.Body.SearchRecordsByReportResponse.SearchRecordsByReportResult'
        }
    }


    def get_occurred_time(fields: Union[List[dict], dict], field_id: str) -> str:
        """
        Occurred time is part of the raw 'Field' key in the response.
        It should be under @xmlConvertedValue, but field can be both a list or a dict.

        Arguments:
            fields: Field to find the occurred utc time on
            field_id: The @id in the response the time should be on

        Returns:
             Time of occurrence according to the field ID.
        """
        try:
            field_id = str(field_id)  # In case it passed as a integer
            if isinstance(fields, dict):
                return fields['@xmlConvertedValue']
            else:
                for field in fields:
                    if str(field['@id']) == field_id:  # In a rare case @id is an integer
                        return str(field['@xmlConvertedValue'])
            raise KeyError('Could not find @xmlConvertedValue in record.')  # No xmlConvertedValue
        except KeyError as exc:
            raise DemistoException(
                f'Could not find the property @xmlConvertedValue in field id {field_id}. Is that a date field?'
            ) from exc


    class Client(BaseClient):
        def __init__(self, base_url, username, password, instance_name, domain, **kwargs):
            self.username = username
            self.password = password
            self.instance_name = instance_name
            self.domain = domain
            super(Client, self).__init__(base_url=base_url, headers=REQUEST_HEADERS, **kwargs)

        def do_request(self, method, url_suffix, data=None, params=None):
            if not REQUEST_HEADERS.get('Authorization'):
                self.update_session()

            res = self._http_request(method, url_suffix, headers=REQUEST_HEADERS, json_data=data, params=params,
                                     resp_type='response', ok_codes=(200, 401), timeout=20)

            if res.status_code == 401:
                self.update_session()
                res = self._http_request(method, url_suffix, headers=REQUEST_HEADERS, json_data=data,
                                         resp_type='response', ok_codes=(200, 401))

            return res.json()

        def update_session(self):
            body = {
                'InstanceName': self.instance_name,
                'Username': self.username,
                'UserDomain': self.domain,
                'Password': self.password
            }
            try:
                res = self._http_request('POST', f'{API_ENDPOINT}/core/security/login', json_data=body, timeout=20)
            except DemistoException as e:
                if '<html>' in str(e):
                    raise DemistoException(f"Check the given URL, it can be a redirect issue. Failed with error: {str(e)}")
                raise e
            is_successful_response = res.get('IsSuccessful')
            if not is_successful_response:
                return_error(res.get('ValidationMessages'))
            session = res.get('RequestedObject', {}).get('SessionToken')
            REQUEST_HEADERS['Authorization'] = f'Archer session-id={session}'

        def get_token(self):
            body = get_token_soap_request(self.username, self.password, self.instance_name)
            headers = {'SOAPAction': 'http://archer-tech.com/webservices/CreateUserSessionFromInstance',
                       'Content-Type': 'text/xml; charset=utf-8'}
            res = self._http_request('POST'
                                     '', 'ws/general.asmx', headers=headers, data=body, resp_type='content')

            return extract_from_xml(res,
                                    'Envelope.Body.CreateUserSessionFromInstanceResponse.'
                                    'CreateUserSessionFromInstanceResult')

        def destroy_token(self, token):
            body = terminate_session_soap_request(token)
            headers = {'SOAPAction': 'http://archer-tech.com/webservices/TerminateSession',
                       'Content-Type': 'text/xml; charset=utf-8'}
            self._http_request('POST', 'ws/general.asmx', headers=headers, data=body, resp_type='content')

        def do_soap_request(self, command, **kwargs):
            req_data = SOAP_COMMANDS[command]
            headers = {'SOAPAction': req_data['soapAction'], 'Content-Type': 'text/xml; charset=utf-8'}
            token = self.get_token()
            body = req_data['soapBody'](token, **kwargs)  # type: ignore
            res = self._http_request('POST', req_data['urlSuffix'], headers=headers, data=body, resp_type='content')
            self.destroy_token(token)
            return extract_from_xml(res, req_data['outputPath']), res

        def get_level_by_app_id(self, app_id, specify_level_id=None):
            levels = []
            cache = get_integration_context()

            if cache.get(app_id):
                levels = cache[app_id]
            else:
                all_levels_res = self.do_request('GET', f'{API_ENDPOINT}/core/system/level/module/{app_id}')
                for level in all_levels_res:
                    if level.get('RequestedObject') and level.get('IsSuccessful'):
                        level_id = level.get('RequestedObject').get('Id')

                        fields = {}
                        level_res = self.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/level/{level_id}')
                        for field in level_res:
                            if field.get('RequestedObject') and field.get('IsSuccessful'):
                                field_item = field.get('RequestedObject')
                                field_id = str(field_item.get('Id'))
                                fields[field_id] = {'Type': field_item.get('Type'),
                                                    'Name': field_item.get('Name'),
                                                    'FieldId': field_id,
                                                    'IsRequired': field_item.get('IsRequired', False),
                                                    'RelatedValuesListId': field_item.get('RelatedValuesListId')}

                        levels.append({'level': level_id, 'mapping': fields})
                if levels:
                    cache[int(app_id)] = levels
                    set_integration_context(cache)

            level_data = None
            if specify_level_id:
                level_data = next((level for level in levels if level.get('level') == int(specify_level_id)), None)
            elif levels:
                level_data = levels[0]

            if not level_data:
                raise DemistoException('Got no level by app id. You might be using the wrong application id or level id.')

            return level_data

        def get_record(self, app_id, record_id):
            res = self.do_request('GET', f'{API_ENDPOINT}/core/content/{record_id}')

            if not isinstance(res, dict):
                res = res.json()

            errors = get_errors_from_res(res)
            record = {}
            if res.get('RequestedObject') and res.get('IsSuccessful'):
                content_obj = res.get('RequestedObject')
                level_id = content_obj.get('LevelId')
                level = self.get_level_by_app_id(app_id, level_id)
                if level:
                    level_fields = level['mapping']
                else:
                    return {}, res, errors

                for _id, field in content_obj.get('FieldContents').items():
                    field_data = level_fields.get(str(_id))  # type: ignore
                    field_type = field_data.get('Type')

                    # when field type is IP Address
                    if field_type == 19:
                        field_value = field.get('IpAddressBytes')
                    # when field type is Values List
                    elif field_type == 4 and field.get('Value') and field['Value'].get('ValuesListIds'):
                        list_data = self.get_field_value_list(_id)
                        list_ids = field['Value']['ValuesListIds']
                        list_ids = list(filter(lambda x: x['Id'] in list_ids, list_data['ValuesList']))
                        field_value = list(map(lambda x: x['Name'], list_ids))
                    else:
                        field_value = field.get('Value')

                    if field_value:
                        record[field_data.get('Name')] = field_value

                record['Id'] = content_obj.get('Id')
            return record, res, errors

        @staticmethod
        def record_to_incident(
                record_item, app_id, fetch_param_id
        ) -> Tuple[dict, datetime]:
            """Transform a record to incident

            Args:
                record_item: The record item dict
                app_id: ID of the app
                fetch_param_id: ID of the fetch param.

            Returns:
                incident, incident created time (UTC Time)
            """
            labels = []
            raw_record = record_item['raw']
            record_item = record_item['record']
            try:
                occurred_time = get_occurred_time(raw_record['Field'], fetch_param_id)
            except KeyError as exc:
                raise DemistoException(
                    f'Could not find occurred time in record {record_item.get("Id")=}'
                ) from exc
            # Will convert value to strs
            for k, v in record_item.items():
                if isinstance(v, str):
                    labels.append({
                        'type': k,
                        'value': v
                    })
                else:
                    labels.append({
                        'type': k,
                        'value': json.dumps(v)
                    })

            labels.append({'type': 'ModuleId', 'value': app_id})
            labels.append({'type': 'ContentId', 'value': record_item.get("Id")})
            labels.append({'type': 'rawJSON', 'value': json.dumps(raw_record)})
            incident = {
                'name': f'RSA Archer Incident: {record_item.get("Id")}',
                'details': json.dumps(record_item),
                'occurred': occurred_time,
                'labels': labels,
                'rawJSON': json.dumps(raw_record)
            }
            return incident, parser(occurred_time)

        def search_records(
                self, app_id, fields_to_display=None, field_to_search='', search_value='',
                numeric_operator='', date_operator='', max_results=10,
                sort_type: str = 'Ascending'
        ):
            demisto.debug(f'searching for records {field_to_search}:{search_value}')
            if fields_to_display is None:
                fields_to_display = []

            level_data = self.get_level_by_app_id(app_id)

            # Building request fields
            fields_xml = ''
            search_field_name = ''
            search_field_id = ''
            fields_mapping = level_data['mapping']
            for field in fields_mapping.keys():
                field_name = fields_mapping[field]['Name']
                if field_name in fields_to_display:
                    fields_xml += f'<DisplayField name="{field_name}">{field}</DisplayField>'
                if field_name == field_to_search:
                    search_field_name = field_name
                    search_field_id = field

            res, raw_res = self.do_soap_request(
                'archer-search-records',
                app_id=app_id, display_fields=fields_xml,
                field_id=search_field_id, field_name=search_field_name,
                numeric_operator=numeric_operator,
                date_operator=date_operator, search_value=search_value,
                max_results=max_results,
                sort_type=sort_type,
            )

            if not res:
                return [], raw_res

            records = self.xml_to_records(res, fields_mapping)
            return records, raw_res

        def xml_to_records(self, xml_response, fields_mapping):
            res = json.loads(xml2json(xml_response))
            records = []
            if res.get('Records') and res['Records'].get('Record'):
                records_data = res['Records']['Record']
                if isinstance(records_data, dict):
                    records_data = [records_data]

                for item in records_data:
                    record = {'Id': item.get('@contentId')}
                    record_fields = item.get('Field')

                    if isinstance(record_fields, dict):
                        record_fields = [record_fields]

                    for field in record_fields:
                        field_name = fields_mapping[field.get('@id')]['Name']
                        field_type = field.get('@type')
                        field_value = ''
                        if field_type == '3':
                            field_value = field.get('@xmlConvertedValue')
                        elif field_type == '4':
                            if field.get('ListValues'):
                                field_value = field['ListValues']['ListValue']['@displayName']
                        elif field_type == '8':
                            field_value = json.dumps(field)
                        else:
                            field_value = field.get('#text')

                        record[field_name] = field_value
                    records.append({'record': record, 'raw': item})
            return records

        def get_field_value_list(self, field_id):
            cache = get_integration_context()

            if cache['fieldValueList'].get(field_id):
                return cache.get('fieldValueList').get(field_id)

            res = self.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/{field_id}')

            errors = get_errors_from_res(res)
            if errors:
                return_error(errors)

            if res.get('RequestedObject') and res.get('IsSuccessful'):
                list_id = res['RequestedObject']['RelatedValuesListId']
                values_list_res = self.do_request('GET', f'{API_ENDPOINT}/core/system/valueslistvalue/valueslist/{list_id}')
                if values_list_res.get('RequestedObject') and values_list_res.get('IsSuccessful'):
                    values_list = []
                    for value in values_list_res['RequestedObject'].get('Children'):
                        values_list.append({'Id': value['Data']['Id'],
                                            'Name': value['Data']['Name'],
                                            'IsSelectable': value['Data']['IsSelectable']})
                    field_data = {'FieldId': field_id, 'ValuesList': values_list}

                    cache['fieldValueList'][field_id] = field_data
                    set_integration_context(cache)
                    return field_data
            return {}

        def get_field_id(self, app_id: str, field_name: str) -> str:
            """Get field ID by field name

            Args:
                app_id: app id to search on
                field_name: field name to search on

            Raises:
                DemistoException: If could not find field ID

            Returns:
                The ID of the field
            """
            fields, _ = self.get_application_fields(app_id)
            for field in fields:
                if field_name == field.get('FieldName'):
                    try:
                        return str(field['FieldId'])
                    except KeyError:
                        raise DemistoException(f'Could not find FieldId for {field_name=}')
            raise DemistoException(f'Could not find field ID {field_name}')

        def get_application_fields(self, app_id: str) -> Tuple[list, list]:
            """Getting all fields in the application

            Args:
                app_id: Application to find the fields on

            Returns:
                fields, raw response
            """
            res = self.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/application/{app_id}')

            fields = []
            for field in res:
                if field.get('RequestedObject') and field.get('IsSuccessful'):
                    field_obj = field['RequestedObject']
                    field_type = field_obj.get('Type')
                    fields.append({
                        'FieldId': field_obj.get('Id'),
                        'FieldType': FIELD_TYPE_DICT.get(field_type, 'Unknown'),
                        'FieldName': field_obj.get('Name'),
                        'LevelID': field_obj.get('LevelId')
                    })
                else:
                    errors = get_errors_from_res(field)
                    if errors:
                        raise DemistoException(errors)
            return fields, res


    def extract_from_xml(xml, path):
        xml = json.loads(xml2json(xml))
        path = path.split('.')

        for item in path:
            if xml.get(item):
                xml = xml[item]
                continue
            return ''
        return xml


    def generate_field_contents(client, fields_values, level_fields):
        if fields_values and not isinstance(fields_values, dict):
            try:
                fields_values = json.loads(fields_values)
            except Exception:
                raise Exception('Failed to parese fields-values argument')

        field_content = {}
        for field_name in fields_values.keys():
            field_data = None

            for _id, field in level_fields.items():
                if field.get('Name') == field_name:
                    field_data = field
                    break

            if field_data:
                field_key, field_value = generate_field_value(client, field_name, field_data, fields_values[field_name])

                field_content[_id] = {'Type': field_data['Type'],
                                      field_key: field_value,
                                      'FieldId': _id}
        return field_content


    def generate_field_value(client, field_name, field_data, field_val):
        field_type = field_data['Type']

        # when field type is Values List, call get_field_value_list method to get the value ID
        # for example: {"Type":["Switch"], fieldname:[value1, value2]}
        if field_type == 4:
            field_data = client.get_field_value_list(field_data['FieldId'])
            list_ids = []
            if not isinstance(field_val, list):
                field_val = [field_val]
            for item in field_val:
                tmp_id = next(f for f in field_data['ValuesList'] if f['Name'] == item)
                if tmp_id:
                    list_ids.append(tmp_id['Id'])
                else:
                    raise Exception(f'Failed to create field {field_name} with the value {field_data}')
            return 'Value', {'ValuesListIds': list_ids}

        # when field type is External Links
        # for example: {"Patch URL":[{"value":"github", "link": "https://github.com"}]}
        elif field_type == 7:
            list_urls = []
            for item in field_val:
                list_urls.append({'Name': item.get('value'), 'URL': item.get('link')})
            return 'Value', list_urls

        # when field type is Users/Groups List
        # for example: {"Policy Owner":{"users":[20],"groups":[30]}}
        elif field_type == 8:
            try:
                users = field_val.get('users')
                groups = field_val.get('groups')
            except AttributeError:
                raise DemistoException(f"The value of the field: {field_name} must be a dictionary type and include a list"
                                       f" under \"users\" key or \"groups\" key e.g: {{\"Policy Owner\":{{\"users\":[20],"
                                       f"\"groups\":[30]}}}}")

            field_val = {'UserList': [], 'GroupList': []}
            if users:
                for user in users:
                    field_val['UserList'].append({'ID': user})
            if groups:
                for group in groups:
                    field_val['GroupList'].append({'ID': group})
            return 'Value', field_val

        # when field type is Cross- Reference
        # for example: {"Area Reference(s)":[20]}
        elif field_type == 9:
            list_cross_reference = []
            if isinstance(field_val, list):
                for content in field_val:
                    list_cross_reference.append({'ContentID': content})

            else:
                list_cross_reference = [{'ContentID': field_val}]
            return 'Value', list_cross_reference

        elif field_type == 19:
            return 'IpAddressBytes', field_val

        else:
            return 'Value', field_val


    def get_errors_from_res(res):
        if isinstance(res, dict) and res.get('ValidationMessages'):
            messages = []
            for message in res.get('ValidationMessages'):  # type: ignore
                messages.append(message.get('ResourcedMessage'))
            return '\n'.join(messages)


    def get_file(entry_id):
        get_file_path_res = demisto.getFilePath(entry_id)
        file_path = get_file_path_res["path"]
        file_name = get_file_path_res["name"]
        with open(file_path, 'rb') as fopen:
            file_bytes = fopen.read()

        file_bytes = base64.b64encode(file_bytes)
        return file_name, file_bytes.decode('utf-8')


    def test_module(client: Client, params: dict) -> str:
        if params.get('isFetch', False):
            last_run = {
                FETCH_PARAM_ID_KEY: get_fetch_param_id(
                    client, {}, params['applicationId'], params['applicationDateField']
                )}
            fetch_incidents_command(client, params, last_run)

            return 'ok'

        return 'ok' if client.do_request('GET', f'{API_ENDPOINT}/core/system/application') else 'Connection failed.'


    def search_applications_command(client: Client, args: Dict[str, str]):
        app_id = args.get('applicationId')
        limit = args.get('limit')
        endpoint_url = f'{API_ENDPOINT}/core/system/application/'

        if app_id:
            endpoint_url = f'{API_ENDPOINT}/core/system/application/{app_id}'
            res = client.do_request('GET', endpoint_url)
        elif limit:
            res = client.do_request('GET', endpoint_url, params={"$top": limit})

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if isinstance(res, dict):
            res = [res]

        applications = []
        for app in res:
            if app.get('RequestedObject') and app.get('IsSuccessful'):
                app_obj = app['RequestedObject']
                applications.append({'Id': app_obj.get('Id'),
                                     'Type': app_obj.get('Type'),
                                     'Name': app_obj.get('Name'),
                                     'LanguageId': app_obj.get('LanguageId'),
                                     'Status': app_obj.get('Status'),
                                     'Guid': app_obj.get('Guid')})

        markdown = tableToMarkdown('Search applications results', applications)
        context: dict = {
            'Archer.Application(val.Id && val.Id == obj.Id)': applications}
        return_outputs(markdown, context, res)


    def get_application_fields_command(client: Client, args: Dict[str, str]):
        app_id = args['applicationId']
        fields, res = client.get_application_fields(app_id)

        markdown = tableToMarkdown('Application fields', fields)
        context: dict = {'Archer.ApplicationField(val.FieldId && val.FieldId == obj.FieldId)': fields}
        return_outputs(markdown, context, res)


    def get_field_command(client: Client, args: Dict[str, str]):
        field_id = args.get('fieldID')

        res = client.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/{field_id}')

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        field = {}
        if res.get('RequestedObject') and res.get('IsSuccessful'):
            field_obj = res['RequestedObject']
            item_type = field_obj.get('Type')
            item_type = FIELD_TYPE_DICT.get(item_type, 'Unknown')
            field = {'FieldId': field_obj.get('Id'),
                     'FieldType': item_type,
                     'FieldName': field_obj.get('Name'),
                     'LevelID': field_obj.get('LevelId')}

        markdown = tableToMarkdown('Application field', field)
        context: dict = {
            'Archer.ApplicationField(val.FieldId && val.FieldId == obj.FieldId)':
                field
        }
        return_outputs(markdown, context, res)


    def get_mapping_by_level_command(client: Client, args: Dict[str, str]):
        level = args.get('level')

        res = client.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/level/{level}')

        items = []
        for item in res:
            if item.get('RequestedObject') and item.get('IsSuccessful'):
                item_obj = item['RequestedObject']
                item_type = item_obj.get('Type')
                if item_type:
                    item_type = FIELD_TYPE_DICT.get(item_type, 'Unknown')
                else:
                    item_type = 'Unknown'
                items.append({'Id': item_obj.get('Id'),
                              'Name': item_obj.get('Name'),
                              'Type': item_type,
                              'LevelId': item_obj.get('LevelId')})
            else:
                errors = get_errors_from_res(item)
                if errors:
                    return_error(errors)

        markdown = tableToMarkdown(f'Level mapping for level {level}', items)
        context: dict = {'Archer.LevelMapping(val.Id && val.Id == obj.Id)': items}
        return_outputs(markdown, context, res)


    def get_record_command(client: Client, args: Dict[str, str]):
        record_id = args.get('contentId')
        app_id = args.get('applicationId')

        record, res, errors = client.get_record(app_id, record_id)
        if errors:
            return_error(errors)

        markdown = tableToMarkdown('Record details', record)
        context: dict = {
            'Archer.Record(val.Id && val.Id == obj.Id)':
                record
        }
        return_outputs(markdown, context, res)


    def create_record_command(client: Client, args: Dict[str, str]):
        app_id = args.get('applicationId')
        fields_values = args.get('fieldsToValues')
        level_id = args.get('levelId')
        level_data = client.get_level_by_app_id(app_id, level_id)

        field_contents = generate_field_contents(client, fields_values, level_data['mapping'])

        body = {'Content': {'LevelId': level_data['level'], 'FieldContents': field_contents}}

        res = client.do_request('Post', f'{API_ENDPOINT}/core/content', data=body)

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if res.get('RequestedObject') and res.get('IsSuccessful'):
            rec_id = res['RequestedObject']['Id']
            return_outputs(f'Record created successfully, record id: {rec_id}', {'Archer.Record.Id': rec_id}, res)


    def delete_record_command(client: Client, args: Dict[str, str]):
        record_id = args.get('contentId')
        res = client.do_request('Delete', f'{API_ENDPOINT}/core/content/{record_id}')

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)
        return_outputs(f'Record {record_id} deleted successfully', {}, res)


    def update_record_command(client: Client, args: Dict[str, str]):
        app_id = args.get('applicationId')
        record_id = args.get('contentId')
        fields_values = args.get('fieldsToValues')
        level_id = args.get('levelId')
        level_data = client.get_level_by_app_id(app_id, level_id)

        field_contents = generate_field_contents(client, fields_values, level_data['mapping'])

        body = {'Content': {'Id': record_id, 'LevelId': level_data['level'], 'FieldContents': field_contents}}
        res = client.do_request('Put', f'{API_ENDPOINT}/core/content', data=body)

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if res.get('IsSuccessful'):
            return_outputs(f'Record {record_id} updated successfully', {}, res)
        else:
            raise DemistoException('Update record failed')


    def execute_statistics_command(client: Client, args: Dict[str, str]):
        report_guid = args.get('reportGuid')
        max_results = args.get('maxResults')
        res, raw_res = client.do_soap_request('archer-execute-statistic-search-by-report',
                                              report_guid=report_guid, max_results=max_results)
        if res:
            res = json.loads(xml2json(res))
        return_outputs(res, {}, {})


    def get_reports_command(client: Client, args: Dict[str, str]):
        res, raw_res = client.do_soap_request('archer-get-reports')
        res = json.loads(xml2json(res))
        ec = res.get('ReportValues').get('ReportValue')

        context: dict = {
            'Archer.Report(val.ReportGUID && val.ReportGUID == obj.ReportGUID)': ec
        }
        return_outputs(ec, context, {})


    def search_options_command(client: Client, args: Dict[str, str]):
        report_guid = args.get('reportGuid')
        res, raw_res = client.do_soap_request('archer-get-search-options-by-guid', report_guid=report_guid)
        if res.startswith('<'):
            res = json.loads(xml2json(res))
        return_outputs(res, {}, {})


    def reset_cache_command(client: Client, args: Dict[str, str]):
        set_integration_context({})
        return_outputs('', {}, '')


    def get_value_list_command(client: Client, args: Dict[str, str]):
        field_id = args.get('fieldID')
        field_data = client.get_field_value_list(field_id)

        markdown = tableToMarkdown(f'Value list for field {field_id}', field_data['ValuesList'])

        context: dict = {
            'Archer.ApplicationField(val.FieldId && val.FieldId == obj.FieldId)':
                field_data
        }
        return_outputs(markdown, context, {})


    def upload_file_command(client: Client, args: Dict[str, str]) -> str:
        """Uploading a file to archer as an attachment

        Arguments:
            client: A client to use in order to send the api callarcher-get-file
            args: demisto args

        Returns:
            An attachment id from Archer
        """
        entry_id = args.get('entryId')
        file_name, file_bytes = get_file(entry_id)
        body = {'AttachmentName': file_name, 'AttachmentBytes': file_bytes}

        res = client.do_request('POST', f'{API_ENDPOINT}/core/content/attachment', data=body)

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if res.get('RequestedObject') and res.get('IsSuccessful'):
            attachment_id = res['RequestedObject'].get('Id')
        else:
            raise DemistoException('Upload file failed')

        return_outputs(f'File uploaded successfully, attachment ID: {attachment_id}', {}, res)
        return attachment_id


    def upload_and_associate_command(client: Client, args: Dict[str, str]):
        """Uploading an entry to archer. than, if needed, associate it to a record.
        """
        app_id = args.get('applicationId')
        content_id = args.get('contentId')
        associate_field = args.get('associatedField')

        should_associate_to_record = app_id and content_id
        if not should_associate_to_record:  # If both app_id and content_id
            if app_id or content_id:  # If one of them, raise error. User's mistake
                raise DemistoException(
                    'Found arguments to associate an attachment to a record, but not all required arguments supplied'
                )

        attachment_id = upload_file_command(client, args)
        if should_associate_to_record:
            args['fieldsToValues'] = json.dumps({associate_field: [attachment_id]})
            update_record_command(client, args)


    def download_file_command(client: Client, args: Dict[str, str]):
        attachment_id = args.get('fileId')
        res = client.do_request('GET', f'{API_ENDPOINT}/core/content/attachment/{attachment_id}')

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if res.get('RequestedObject') and res.get('IsSuccessful'):
            content = base64.b64decode(res['RequestedObject'].get('AttachmentBytes'))
            filename = res['RequestedObject'].get('AttachmentName')
            return demisto.results(fileResult(filename, content))
        else:
            return_error('File downloading failed', outputs=res)


    def list_users_command(client: Client, args: Dict[str, str]):
        user_id = args.get('userId')
        if user_id:
            res = client.do_request('GET', f'{API_ENDPOINT}/core/system/user/{user_id}')
        else:
            res = client.do_request('GET', f'{API_ENDPOINT}/core/system/user')

        errors = get_errors_from_res(res)
        if errors:
            return_error(errors)

        if isinstance(res, dict):
            res = [res]

        users = []
        for user in res:
            if user.get('RequestedObject') and user.get('IsSuccessful'):
                user_obj = user['RequestedObject']
                users.append({'Id': user_obj.get('Id'),
                              'DisplayName': user_obj.get('DisplayName'),
                              'FirstName': user_obj.get('FirstName'),
                              'MiddleName': user_obj.get('MiddleName'),
                              'LastName': user_obj.get('LastName'),
                              'AccountStatus': ACCOUNT_STATUS_DICT[user_obj.get('AccountStatus')],
                              'LastLoginDate': user_obj.get('LastLoginDate'),
                              'UserName': user_obj.get('UserName')})

        markdown = tableToMarkdown('Users list', users)
        context: dict = {
            'Archer.User(val.Id && val.Id == obj.Id)':
                users
        }
        return_outputs(markdown, context, res)


    def search_records_command(client: Client, args: Dict[str, str]):
        app_id = args.get('applicationId')
        field_to_search = args.get('fieldToSearchOn')
        search_value = args.get('searchValue')
        max_results = args.get('maxResults', 10)
        date_operator = args.get('dateOperator')
        numeric_operator = args.get('numericOperator')
        fields_to_display = argToList(args.get('fieldsToDisplay'))
        fields_to_get = argToList(args.get('fieldsToGet'))
        full_data = argToBoolean(args.get('fullData'))
        sort_type = 'Descending' if argToBoolean(args.get('isDescending', 'false')) else 'Ascending'
        level_id = args.get('levelId')

        if fields_to_get and 'Id' not in fields_to_get:
            fields_to_get.append('Id')

        if not all(f in fields_to_get for f in fields_to_display):
            return_error('fields-to-display param should have only values from fields-to-get')

        if full_data:
            level_data = client.get_level_by_app_id(app_id, level_id)
            fields_mapping = level_data['mapping']
            fields_to_get = [fields_mapping[next(iter(fields_mapping))]['Name']]

        records, raw_res = client.search_records(
            app_id, fields_to_get, field_to_search, search_value,
            numeric_operator, date_operator, max_results=max_results,
            sort_type=sort_type,
        )

        records = list(map(lambda x: x['record'], records))

        if full_data:
            records_full = []
            for rec in records:
                record_item, _, errors = client.get_record(app_id, rec['Id'])
                if not errors:
                    records_full.append(record_item)
            records = records_full

        hr = []

        if full_data:
            hr = records
        else:
            for record in records:
                hr.append({f: record[f] for f in fields_to_display})

        markdown = tableToMarkdown('Search records results', hr)
        context: dict = {'Archer.Record(val.Id && val.Id == obj.Id)': records}
        return_outputs(markdown, context, {})


    def search_records_by_report_command(client: Client, args: Dict[str, str]):
        report_guid = args.get('reportGuid')
        res, raw_res = client.do_soap_request('archer-search-records-by-report', report_guid=report_guid)
        if not res:
            return_outputs(f'No records found for report {report_guid}', {}, json.loads(xml2json(raw_res)))
            return

        raw_records = json.loads(xml2json(res))
        records = []
        ec = {}
        if raw_records.get('Records') and raw_records['Records'].get('Record'):
            if isinstance(raw_records['Records'].get('Record'), list):
                level_id = raw_records['Records']['Record'][0]['@levelId']
            else:
                level_id = raw_records['Records']['Record']['@levelId']

            level_res = client.do_request('GET', f'{API_ENDPOINT}/core/system/fielddefinition/level/{level_id}')
            fields = {}
            for field in level_res:
                if field.get('RequestedObject') and field.get('IsSuccessful'):
                    field_item = field.get('RequestedObject')
                    field_id = str(field_item.get('Id'))
                    fields[field_id] = {'Type': field_item.get('Type'),
                                        'Name': field_item.get('Name')}

            records = client.xml_to_records(res, fields)
            records = list(map(lambda x: x['record'], records))

            ec = {'Record': records, 'RecordsAmount': len(records), 'ReportGUID': report_guid}

        markdown = tableToMarkdown('Search records by report results', records)
        context: dict = {'Archer.SearchByReport(val.ReportGUID && val.ReportGUID == obj.ReportGUID)': ec}

        return_outputs(markdown, context, json.loads(xml2json(raw_res)))


    def print_cache_command(client: Client, args: Dict[str, str]):
        cache = get_integration_context()
        return_outputs(cache, {}, {})


    def fetch_incidents(
            client: Client, params: dict, from_time: datetime, fetch_param_id: str
    ) -> Tuple[list, datetime]:
        """Fetches incidents.

        Args:
            client: Client derived from BaseClient
            params: demisto.params dict.
            from_time: Time to start the fetch from
            fetch_param_id: Param ID to find occurred time. can be acquired by get_fetch_param_id

        Returns:
            incidents, next_run datetime in archer's local time
        """
        # Not using get method as those params are a must
        app_id = params['applicationId']
        date_field = params['applicationDateField']
        max_results = params.get('fetch_limit', 10)
        fields_to_display = argToList(params.get('fields_to_fetch'))
        fields_to_display.append(date_field)
        # API Call
        records, _ = client.search_records(
            app_id, fields_to_display, date_field,
            from_time.strftime(OCCURRED_FORMAT),
            date_operator='GreaterThan',
            max_results=max_results
        )
        demisto.debug(f'Found {len(records)=}.')
        # Build incidents
        incidents = list()
        # Encountered that sometimes, somehow, on of next_fetch is not UTC.
        last_fetch_time = from_time.replace(tzinfo=timezone.utc)
        next_fetch = last_fetch_time
        for record in records:
            incident, incident_created_time = client.record_to_incident(record, app_id, fetch_param_id)
            # Encountered that sometimes, somehow, incident_created_time is not UTC.
            incident_created_time = incident_created_time.replace(tzinfo=timezone.utc)
            if last_fetch_time < incident_created_time:
                incidents.append(incident)
                if next_fetch < incident_created_time:
                    next_fetch = incident_created_time
            else:
                demisto.debug(
                    f'The newly fetched incident is older than last fetch. {incident_created_time=} {next_fetch=}'
                )
        demisto.debug(f'Going out fetch incidents with {next_fetch=}, {len(incidents)=}')
        return incidents, next_fetch


    def get_fetch_time(last_fetch: dict, first_fetch_time: str) -> datetime:
        """Gets lastRun object and first fetch time (str, 3 days) and returns
        a datetime object of the last run if exists, else datetime of the first fetch time

        Args:
            last_fetch: a dict that may contain 'last_fetch'
            first_fetch_time: time back in simple format (3 days)

        Returns:
            Time to start fetch from. UTC timezone.
        """
        if next_run := last_fetch.get(LAST_FETCH_TIME_KEY):
            start_fetch = parser(next_run)
        else:
            start_fetch, _ = parse_date_range(first_fetch_time)
        start_fetch.replace(tzinfo=timezone.utc)
        return start_fetch


    def get_fetch_param_id(client: Client, last_run: dict, app_id: str, app_date_field: str) -> str:
        """ Get the from lastRun if available. Else ask the instance for the ID
        Args:
            client: Archer's client
            last_run: Last run object
            app_id: app id to search on
            app_date_field: the name of the date_field
        Returns:
            ID of the field
        """
        try:  # If exists
            fetch_param_id = last_run[FETCH_PARAM_ID_KEY]
        except KeyError:  # If not, search for it
            fetch_param_id = client.get_field_id(app_id, app_date_field)
        demisto.debug(f'Found a field ID {fetch_param_id=}')
        return fetch_param_id


    def fetch_incidents_command(client: Client, params: dict, last_run: dict) -> Tuple[list, datetime]:
        """Fetches incidents
        Arguments:
            client: Archer's client
            params: demisto.params()
            last_run: demisto.getLastRun()
        Returns:
            incidents, next fetch
        """
        from_time = get_fetch_time(last_run, params.get('fetch_time', '3 days'))
        fetch_param_id = last_run[FETCH_PARAM_ID_KEY]
        demisto.debug(f'Starting fetch incidents with {from_time=} and {fetch_param_id=}')
        return fetch_incidents(
            client=client,
            params=params,
            from_time=from_time,
            fetch_param_id=fetch_param_id
        )


    def main():
        params = demisto.params()
        credentials = params.get('credentials')
        base_url = params.get('url').strip('/')

        compiled = re.compile(re.escape('rsaarcher'), re.IGNORECASE)
        base_url = compiled.sub("", base_url)
        api_endpoint = params.get('api_endpoint', 'rsaarcher/api').lower()
        if 'rsaarcher' in api_endpoint:
            base_url = urljoin(base_url, 'rsaarcher')

        cache = get_integration_context()
        if not cache.get('fieldValueList'):
            cache['fieldValueList'] = {}
            set_integration_context(cache)

        client = Client(
            base_url,
            credentials.get('identifier'), credentials.get('password'),
            params.get('instanceName'),
            params.get('userDomain'),
            verify=not params.get('insecure', False),
            proxy=params.get('proxy', False),
        )
        commands = {
            'archer-search-applications': search_applications_command,
            'archer-get-application-fields': get_application_fields_command,
            'archer-get-field': get_field_command,
            'archer-get-mapping-by-level': get_mapping_by_level_command,
            'archer-get-record': get_record_command,
            'archer-create-record': create_record_command,
            'archer-delete-record': delete_record_command,
            'archer-update-record': update_record_command,
            'archer-execute-statistic-search-by-report': execute_statistics_command,
            'archer-get-reports': get_reports_command,
            'archer-get-search-options-by-guid': search_options_command,
            'archer-reset-cache': reset_cache_command,
            'archer-get-valuelist': get_value_list_command,
            'archer-upload-file': upload_and_associate_command,
            'archer-get-file': download_file_command,
            'archer-list-users': list_users_command,
            'archer-search-records': search_records_command,
            'archer-search-records-by-report': search_records_by_report_command,
            'archer-print-cache': print_cache_command,
        }

        command = demisto.command()
        LOG(f'Command being called is {command}')
        try:
            if command == 'fetch-incidents':
                last_run = demisto.getLastRun()
                last_run[FETCH_PARAM_ID_KEY] = get_fetch_param_id(
                    client, last_run, params['applicationId'], params['applicationDateField']
                )
                incidents, next_fetch = fetch_incidents_command(client, params, last_run)
                demisto.debug(f'Setting next run to {next_fetch}')
                last_run[LAST_FETCH_TIME_KEY] = next_fetch.strftime(OCCURRED_FORMAT)
                demisto.setLastRun(last_run)
                demisto.incidents(incidents)
            elif command == 'test-module':
                demisto.results(test_module(client, params))
            elif command in commands:
                return commands[command](client, demisto.args())
            else:
                return_error('Command not found.')
        except Exception as e:
            return_error(f'Unexpected error: {str(e)}, traceback: {traceback.format_exc()}')


    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()
  subtype: python3
  type: python
