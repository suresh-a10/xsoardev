category: Vulnerability Management
commonfields:
  id: Tenable.io
  version: -1
configuration:
- defaultvalue: https://cloud.tenable.com/
  display: Server URL
  name: url
  required: true
  section: Connect
  type: 0
- display: Access key
  hidden: true
  name: access-key
  required: false
  section: Connect
  type: 4
- display: ""
  displaypassword: Access Key
  hiddenusername: true
  name: credentials_access_key
  required: true
  section: Connect
  type: 9
- display: Secret key
  hidden: true
  name: secret-key
  required: false
  section: Connect
  type: 4
- display: ""
  displaypassword: Secret Key
  hiddenusername: true
  name: credentials_secret_key
  required: true
  section: Connect
  type: 9
- advanced: true
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- defaultvalue: 7 days
  display: Events first fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  hidden: true
  name: first_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: The maximum number of audit logs to retrieve for each event type.
    For more information about event types see the help section.
  advanced: true
  defaultvalue: "1000"
  display: Events max fetch
  hidden: true
  name: max_fetch
  required: false
  section: Collect
  type: 0
- advanced: true
  defaultvalue: "720"
  display: Assets and vulnerabilities fetch interval
  hidden: true
  name: assetsFetchInterval
  required: false
  section: Collect
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.2.2
    packID: Tenable_io
    packName: Tenable Vulnerability Management (formerly Tenable.io)
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: A comprehensive asset-centric solution to accurately track resources
  while accommodating dynamic assets such as cloud, mobile devices, containers, and
  web applications.
detaileddescription: |-
  ## Configuration Parameters

  #### Access key and Secret key
  Tenable.io generates a unique set of API keys for each user account (**access key** and **secret key**). These keys allow your application to authenticate to the Tenable.io API without creating a session.
  The method to generate API keys varies depending on the role assigned to your user account. Administrators can generate API keys for any user account. For more information, see Tenable.io documentation.



  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/tenableio)
display: Tenable Vulnerability Management (formerly Tenable.io)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAABBVBMVEUAAABFVWVIV2ZEVWZIV2hJW2lFVWVFVWVKXGpOXnMAqLYAp7ZEVGQAp7UAqLYAqLZsdIAAp7ZEVWUAp7UAp7UAqLUAp7VFVWUAp7UAqLUAqLZEVGQAqLZFVWUAqLYAqLdEVGUAp7UAp7UAp7VEVWQAp7YAussAp7UAp7UAp7UAqLZFVmZHV2YAr7xQZHNEVWRFVWRFVWVFV2YAqbYAt8FEVGVEVWVFVWZGVmUAqrhIWGlMWmxFVGVEVWVFVWVFVWRGVWYAqLZHV2YAqrYArbtFVGUAqbVFWGlHV2lFVWREVWUAp7QAp7VGV2ZEVWVGVmVFVmYArLdEVWREVmUAq7dEVWVEVGQidPTWAAAAVnRSTlMAjCF7JhjRmRUMdmD0h2pSBIv8k4+voZ+Yb0/qZGRKRLy1qZyWgwXFgH5ZRjMQCPm1h008CfB1XEIoHxDj24+CbkE5LhewNyob5sK8pC+rVFEgpqEz5PhyY/gAAAQ1SURBVFjD7ZTZctowFEAva8DGNsZL7GDM4pp9h7AECBAC2ZukTfX/n1ItcQwkM51Op+lDOQ/oXkvWsdCV4MCBAwcO/D4be9yHf4BQbUiKXukV4XMRpJ7r3JXypVJBHMPnIQj31lJdFkWh52qybpzAH/AFIRTz0yBOA/Axap6/dK2GxHFiybpU+L5ZBcZjIBCI/zWxWlqZjpzXtILCibrSs8pFAxhHZJK/JZbvqiVBtmyxAStx495XZc7S/0B89EvxpHZFvIWCmS1nTVZTtsVrDa4krD6apNnccyST4NPcEzffi5Ns20adIfZWS32zzGXhlSKv3vdPShydoj3Fb+Xa30hydXyDUPpbncSZdrsdiQVmqVZ0QN1nnWgLJWbnZ564vk6gxNfwtvj6fIZQYl3D0WMNXIlTQTGK4HOpCS/3GolmiJHGcSiFGHOcBHCbOWX5Gi+k43Wmukw8YA8SQ188TCDGd/qpOiiVfn73+HC8IZaKu+I5eiNDxT4juPCTRJiIfeqeeMg+DJGMihvlii3vinmzXL1b4mAxj+Jx5/MB1HE7fZrER/hBesLEt4vRgKw6BNBGucxDcDgjo5k4t6iFSOftqziC13uaiTXrOYRaZAfKWb4i23tiUZUc4e1oRHC7xsOvABNLI9Sh4nO62Tg4xvufAcIVMVLxnKRhLEMXTNzBv11aX/jTv+K2J9sVY/NerOjb4iae4jZOOUYoSsVBOjcTw+RxMHxIQpp0HtF3MNQ2YGKsu4lTBng/kriINUmoZPfEriipcsMX0/l9Wr44wsQDWjg3j1MiZu8QuuSPYeIU2oYUf0EsjK09cWEjqXZvS/yAdojviTNe4aR2VkyL7oiKm2gHciZN3TjhdsViYVWV+9aW+Bo3s9AbzT1xGv8u4qRwtsWskjtsxaS2/Amucef4riyVK9ve4j23cu2s5InJqCnemIk/ZFd8hki9EG488RlNyYcMqZiGV7BDXgNJE5/BI1t2N6t8VgFP3H01teO0nBYfir8D4YcnjgbJtULq4ZqJM+RhhL4SAoaR54q8Y/N9mo3NpWg+awrzQohcH19z+BSR4HzRyaXQaF+cTGPBE0DsGHlilIq2bxBVUjE9RShxtJivWygDlGrVkE9454XHG90Qs5J1knfzCjBGiBKBi1PkEQX4qLhO01vFNUWMH5NXMQTZIzoyzq5mYWlmVZOzTNWVhYLrOOO8AR7fEWL/djiHKKl18J0Y5i16XWamnvjhFhHaMf+ujn1LIcrtBTB0WAp9scCPObnS2yi9Z80Bn/CoO2KlEruodWsPExqGw+EkvYdwEKF9T916E4Lh8BlEaGew9lQLe0NiQJjU8QT1mF9NellSpYahNPDq+UbFMeCzeLac/J3BFRzdFCoS2V+bW8En8cJpmmpfwtKgFcfZ8Hn0s4Kuq0Vacb0iHDhw4MCB/5yfYHowcdS9KS4AAAAASUVORK5CYII=
name: Tenable.io
script:
  commands:
  - arguments:
    - description: |-
        The ID of the folder whose scans should be listed. Scans are stored
        in specific folders on Tenable, e.g.: folderId=8.
      name: folderId
    - description: Limit the results to those that have only changed since this time.
        Date format will be YYYY-MM-DD format or relational expressions like “7 days
        ago”.
      name: lastModificationDate
    description: Retrieves scans from the Tenable platform.
    name: tenable-io-list-scans
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Target
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: date
    - contextPath: TenableIO.Scan.EndTime
      description: The scheduled end time for the scan.
      type: date
    - contextPath: TenableIO.Scan.Enabled
      description: If true, the schedule for the scan is enabled.
      type: boolean
    - contextPath: TenableIO.Scan.Type
      description: The type of scan (local, remote, or agent).
      type: string
    - contextPath: TenableIO.Scan.Owner
      description: The owner of the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.CreationDate
      description: The creation date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.LastModificationDate
      description: The last modification date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.FolderId
      description: The unique ID of the folder where the scan has been stored.
      type: number
  - arguments:
    - default: true
      description: The ID of the scan to launch.
      name: scanId
      required: true
    - description: If specified, targets to be scanned instead of the default. This
        value can be an array where each index is a target, or an array with a single
        index of comma-separated targets.
      name: scanTargets
    description: Launches a scan with existing or custom targets. You can specify
      custom targets in the command arguments.
    name: tenable-io-launch-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Targets
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
  - arguments:
    - default: true
      description: The ID of the scan to retrieve.
      name: scanId
      required: true
    - auto: PREDEFINED
      defaultValue: "no"
      description: 'If true, the report will contain remediation and host information
        for the specified scan. Otherwise, the report will only contain vulnerabilities.
        Possible values: "yes" and "no".'
      name: detailed
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      defaultValue: "no"
      description: 'Whether to return the basic details of the specified scan. Possible
        values: "yes" and "no".'
      name: info
      predefined:
      - "yes"
      - "no"
    description: Retrieves a scan report for the specified scan.
    name: tenable-io-get-scan-report
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Targets
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan ("completed", "aborted", "imported", "pending",
        "running", "resuming", "canceling", "cancelled", "pausing", "paused", "stopping",
        "stopped").
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: string
    - contextPath: TenableIO.Scan.EndTime
      description: The scheduled end time for the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned to the scan.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The unique ID of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: The severity level of the vulnerability.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Assets.Hostname
      description: The name of the host.
      type: string
    - contextPath: TenableIO.Assets.Score
      description: The overall score for the host.
      type: number
    - contextPath: TenableIO.Assets.Critical
      description: The percentage of critical findings on the host.
      type: number
    - contextPath: TenableIO.Assets.High
      description: The number of high findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Medium
      description: The number of medium findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Low
      description: The number of low findings on the host.
      type: number
    - contextPath: TenableIO.Remediations.Id
      description: The unique ID of the remediation.
      type: string
    - contextPath: TenableIO.Remediations.Description
      description: Specific information related to the vulnerability and steps to
        remediate.
      type: string
    - contextPath: TenableIO.Remediations.AffectedHosts
      description: The number of hosts affected.
      type: number
    - contextPath: TenableIO.Remediations.AssociatedVulnerabilities
      description: The number of vulnerabilities associated with the remedy.
      type: number
  - arguments:
    - default: true
      description: The unique ID of the vulnerability.
      name: vulnerabilityId
      required: true
    description: Retrieves details for the specified vulnerability.
    name: tenable-io-get-vulnerability-details
    outputs:
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Type
      description: The type of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Family
      description: Object containing plugin information such as family, type, and
        publication and modification dates.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.PublicationDate
      description: The publication date of the vulnerability.
      type: date
    - contextPath: TenableIO.Vulnerabilities.ModificationDate
      description: The last modification date for the vulnerability in Unix time.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Vulnerabilities.CvssVector
      description: The Common Vulnerability Scoring System vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.CvssBaseScore
      description: The Common Vulnerability Scoring System allotted base score.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3Vector
      description: The Common Vulnerability Scoring System version 3 vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3BaseScore
      description: The Common Vulnerability Scoring System version 3 allotted base
        score.
      type: string
  - arguments:
    - description: Hostname of the asset.
      name: hostname
    - description: IP of the asset.
      name: ip
    - description: The number of days of data prior to and including today that should
        be returned.
      name: dateRange
    description: Gets a list of up to 5000 of the vulnerabilities recorded for a specified
      asset.
    name: tenable-io-get-vulnerabilities-by-asset
    outputs:
    - contextPath: TenableIO.Assets.Hostname
      description: Hostname of the asset.
      type: number
    - contextPath: TenableIO.Assets.Vulnerabilities
      description: A list of all the vulnerability IDs associated with the asset.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The vulnerability unique ID.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Family
      description: The vulnerability family.
      type: string
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: The number of times the vulnerability was found.
      type: number
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityState
      description: The current state of the reported vulnerability ("Active", "Fixed",
        "New", etc.).
      type: string
  - arguments:
    - default: true
      description: The unique ID of the scan.
      name: scanId
      required: true
    description: 'Checks the status of a specific scan using the scan ID. Possible
      values: "Running", "Completed", and "Empty" (Ready to run).'
    name: tenable-io-get-scan-status
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan specified.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan specified.
      type: string
  - arguments:
    - description: Comma-separated list of scan IDs.
      isArray: true
      name: scanId
      required: true
    description: Resumes all scans inputted as an array. Will resume scans whose status
      is 'Paused'.
    name: tenable-io-resume-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: String
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: String
  - arguments:
    - description: Comma-separated list of scan IDs.
      isArray: true
      name: scanId
      required: true
    description: Pauses all scans inputted as an array. Will pause scans whose status
      is 'Running'.
    name: tenable-io-pause-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique id of the scan.
      type: String
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: String
  - arguments:
    - description: IP Address of the asset.
      name: ip
      required: true
    description: Retrieves details for the specified asset including custom attributes.
    name: tenable-io-get-asset-details
    outputs:
    - contextPath: TenableIO.AssetDetails.attributes
      description: Array of custom attributes of asset.
      type: unknown
    - contextPath: TenableIO.AssetDetails.counts
      description: Array of audit statuses and vulnerabilities by type.
      type: unknown
    - contextPath: TenableIO.AssetDetails.created_at
      description: Date asset was created.
      type: date
    - contextPath: TenableIO.AssetDetails.first_seen
      description: Date asset was first seen.
      type: date
    - contextPath: TenableIO.AssetDetails.fqdn
      description: Array of fully-qualified domain names.
      type: unknown
    - contextPath: TenableIO.AssetDetails.id
      description: GUID of tenable.io asset.
      type: string
    - contextPath: TenableIO.AssetDetails.interfaces
      description: Array of interface information.
    - contextPath: TenableIO.AssetDetails.ipv4
      description: Array of IPv4 addresses.
      type: unknown
    - contextPath: TenableIO.AssetDetails.operating_system
      description: Array of operating systems.
      type: unknown
    - contextPath: TenableIO.AssetDetails.tags
      description: Array of tags added to asset.
      type: unknown
    - contextPath: TenableIO.AssetDetails.updated_at
      description: Date the asset was last updated.
      type: date
  - arguments:
    - defaultValue: "100"
      description: Specifies the number of assets per exported chunk. The range is
        100-10000. Tenable does not recommend using a chunk size larger than 5000
        as the potential for an error increases above this amount.
      name: chunkSize
    - defaultValue: "10"
      description: The interval in seconds between each poll.
      name: intervalInSeconds
    - defaultValue: "600"
      description: The timeout for the polling in seconds.
      name: timeOut
    - description: When specified, the results returned in the list are limited to
        assets created later than the date specified. Date format will be epoch date
        format or relational expressions like “7 days ago”.'
      name: createdAt
    - description: When specified, the results returned in the list are limited to
        assets updated later than the date specified. Date format will be epoch date
        format or relational expressions like “7 days ago”.'
      name: updatedAt
    - description: When specified, the results returned in the list are limited to
        assets terminated later than the date specified. Date format will be epoch
        date format or relational expressions like “7 days ago”.'
      name: terminatedAt
    - description: When set to true, returns assets which have any value for the terminatedAt
        attribute.
      name: isTerminated
    - description: When specified, the results returned in the list are limited to
        assets deleted later than the date specified. Date format will be epoch date
        format or relational expressions like “7 days ago”.'
      name: deletedAt
    - auto: PREDEFINED
      description: When set to true, returns assets which have any value for the deletedAt
        attribute.
      name: isDeleted
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Specifies whether the asset is included in the asset count for
        the Tenable.io instance. If true, returns only licensed assets. If false,
        returns only unlicensed assets.
      name: isLicensed
      predefined:
      - "true"
      - "false"
    - description: When specified, the results returned in the list are limited to
        assets with a first scan time later than the date specified. Date format will
        be epoch date format or relational expressions like “7 days ago”.'
      name: firstScanTime
    - description: When specified, the results returned in the list are limited to
        assets with a last credentialed scan time later than the date specified. Date
        format will be epoch date format or relational expressions like “7 days ago”.'
      name: lastAuthenticatedScanTime
    - description: When specified, the results returned in the list are limited to
        assets with a last assessed time later than the date specified. Date format
        will be epoch date format or relational expressions like “7 days ago”.'
      name: lastAssessed
    - auto: PREDEFINED
      description: If true, returns all assets that have a ServiceNow Sys ID, regardless
        of value. If false, returns all assets that do not have a ServiceNow Sys ID.
      name: serviceNowSysId
      predefined:
      - "true"
      - "false"
    - description: 'A comma-separated list of sources. Commonly used values are: AWS,
        NESSUS_AGENT, PVS,NESSUS_SCAN, WAS. When specified, the results returned in
        the list are limited to assets that have the specified source.'
      isArray: true
      name: sources
    - auto: PREDEFINED
      description: If true, returns all assets that have a plugin results associated
        with it.
      name: hasPluginResults
      predefined:
      - "true"
      - "false"
    - description: When specified, the results returned in the list are limited to
        assets with the specified tag category.
      name: tagCategory
    - description: When specified, the results returned in the list are limited to
        assets with the specified tag value.
      name: tagValue
    - description: The export UUID.
      hidden: true
      name: exportUuid
    description: Retrieves details for the specified asset to include custom attributes.
    name: tenable-io-export-assets
    outputs:
    - contextPath: TenableIO.Asset.id
      description: The UUID of the asset in Tenable.io. Use this value as the unique
        key for the asset.
      type: String
    - contextPath: TenableIO.Asset.has_agent
      description: Specifies whether a Nessus agent scan identified the asset.
      type: Boolean
    - contextPath: TenableIO.Asset.has_plugin_results
      description: Specifies whether the asset has plugin results associated with
        it.
      type: Boolean
    - contextPath: TenableIO.Asset.created_at
      description: The time and date when Tenable.io created the asset record.
      type: Date
    - contextPath: TenableIO.Asset.terminated_at
      description: The time and date when a user terminated the Amazon Web Service
        (AWS) virtual machine instance of the asset.
      type: Date
    - contextPath: TenableIO.Asset.terminated_by
      description: The user who terminated the AWS instance of the asset.
      type: String
    - contextPath: TenableIO.Asset.updated_at
      description: The time and date when the asset record was last updated.
      type: Date
    - contextPath: TenableIO.Asset.deleted_at
      description: The time and date when a user deleted the asset record. When a
        user deletes an asset record, Tenable.io retains the record until the asset
        ages out of the license count.
      type: Date
    - contextPath: TenableIO.Asset.deleted_by
      description: The user who deleted the asset record.
      type: String
    - contextPath: TenableIO.Asset.first_seen
      description: The time and date when a scan first identified the asset.
      type: Date
    - contextPath: TenableIO.Asset.last_seen
      description: The time and date of the scan that most recently identified the
        asset.
      type: Date
    - contextPath: TenableIO.Asset.first_scan_time
      description: The time and date of the first scan run against the asset.
      type: Date
    - contextPath: TenableIO.Asset.last_scan_time
      description: The time and date of the last scan run against the asset.
      type: Date
    - contextPath: TenableIO.Asset.last_authenticated_scan_date
      description: The time and date of the last credentialed scan run on the asset.
      type: Date
    - contextPath: TenableIO.Asset.last_licensed_scan_date
      description: The time and date of the last scan that identified the asset as
        licensed. Tenable.io categorizes an asset as licensed if a scan of that asset
        has returned results from a non-discovery plugin within the last 90 days.
      type: Date
    - contextPath: TenableIO.Asset.last_scan_id
      description: The UUID of the scan configuration used during the last scan of
        the asset.
      type: String
    - contextPath: TenableIO.Asset.last_schedule_id
      description: The schedule id for the last scan of the asset.
      type: String
    - contextPath: TenableIO.Asset.azure_vm_id
      description: The unique identifier of the Microsoft Azure virtual machine instance.
        For more information, see "Accessing and Using Azure VM Unique ID" in the
        Microsoft Azure documentation.
      type: String
    - contextPath: TenableIO.Asset.azure_resource_id
      description: The unique identifier of the resource in the Azure Resource Manager.
        For more information, see the Azure Resource Manager Documentation.
      type: String
    - contextPath: TenableIO.Asset.gcp_project_id
      description: The unique identifier of the virtual machine instance in Google
        Cloud Platform (GCP).
      type: String
    - contextPath: TenableIO.Asset.gcp_zone
      description: The customized name of the project to which the virtual machine
        instance belongs in GCP. For more information see "Creating and Managing Projects"
        in the GCP documentation.
      type: String
    - contextPath: TenableIO.Asset.gcp_instance_id
      description: The zone where the virtual machine instance runs in GCP. For more
        information, see "Regions and Zones" in the GCP documentation.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_instance_ami_id
      description: The unique identifier of the Linux AMI image in Amazon Elastic
        Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute
        Cloud Documentation.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_instance_id
      description: The unique identifier of the Linux instance in Amazon EC2. For
        more information, see the Amazon Elastic Compute Cloud Documentation.
      type: String
    - contextPath: TenableIO.Asset.agent_uuid
      description: The unique identifier of the Nessus agent that identified the asset.
      type: String
    - contextPath: TenableIO.Asset.bios_uuid
      description: The BIOS UUID of the asset.
      type: String
    - contextPath: TenableIO.Asset.network_id
      description: The ID of the network object associated with scanners that identified
        the asset.
      type: String
    - contextPath: TenableIO.Asset.network_name
      description: The ID of the network object associated with scanners that identified
        the asset.
      type: String
    - contextPath: TenableIO.Asset.aws_owner_id
      description: The canonical user identifier for the AWS account associated with
        the virtual machine instance.
      type: String
    - contextPath: TenableIO.Asset.aws_availability_zone
      description: The availability zone where Amazon Web Services hosts the virtual
        machine instance.
      type: String
    - contextPath: TenableIO.Asset.aws_region
      description: The region where AWS hosts the virtual machine instance.
      type: String
    - contextPath: TenableIO.Asset.aws_vpc_id
      description: The unique identifier for the virtual public cloud that hosts the
        AWS virtual machine instance.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_instance_group_name
      description: The virtual machine instance's group in AWS.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_instance_state_name
      description: The state of the virtual machine instance in AWS at the time of
        the scan.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_instance_type
      description: The type of instance in AWS EC2.
      type: String
    - contextPath: TenableIO.Asset.aws_subnet_id
      description: The unique identifier of the AWS subnet where the virtual machine
        instance was running at the time of the scan.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_product_code
      description: The product code associated with the AMI used to launch the virtual
        machine instance in AWS EC2.
      type: String
    - contextPath: TenableIO.Asset.aws_ec2_name
      description: The name of the virtual machine instance in AWS EC2.
      type: String
    - contextPath: TenableIO.Asset.mcafee_epo_guid
      description: The unique identifier of the asset in McAfee ePolicy Orchestrator
        (ePO).
      type: String
    - contextPath: TenableIO.Asset.mcafee_epo_agent_guid
      description: The unique identifier of the McAfee ePO agent that identified the
        asset.
      type: String
    - contextPath: TenableIO.Asset.servicenow_sysid
      description: The unique record identifier of the asset in ServiceNow.
      type: String
    - contextPath: TenableIO.Asset.bigfix_asset_id
      description: The unique identifiers of the asset in HCL BigFix.
      type: String
    - contextPath: TenableIO.Asset.agent_names
      description: The names of any Nessus agents that scanned and identified the
        asset.
      type: String
    - contextPath: TenableIO.Asset.installed_software
      description: A list of Common Platform Enumeration (CPE) values that represent
        software applications a scan identified as present on an asset.
      type: String
    - contextPath: TenableIO.Asset.ipv4s
      description: The IPv4 addresses that scans have associated with the asset record.
      type: String
    - contextPath: TenableIO.Asset.ipv6s
      description: The IPv6 addresses that scans have associated with the asset record.
      type: String
    - contextPath: TenableIO.Asset.fqdns
      description: The fully-qualified domain names that scans have associated with
        the asset record.
      type: String
    - contextPath: TenableIO.Asset.mac_addresses
      description: The MAC addresses that scans have associated with the asset record.
      type: String
    - contextPath: TenableIO.Asset.netbios_names
      description: The NetBIOS names that scans have associated with the asset record.
      type: String
    - contextPath: TenableIO.Asset.operating_systems
      description: The operating systems that scans have associated with the asset
        record.
      type: String
    - contextPath: TenableIO.Asset.system_types
      description: The system types as reported by Plugin ID 54615. Possible values
        include router, general-purpose, scan-host, and embedded.
      type: String
    - contextPath: TenableIO.Asset.hostnames
      description: The hostnames that scans have associated with the asset record.
      type: String
    - contextPath: TenableIO.Asset.ssh_fingerprints
      description: The SSH key fingerprints that scans have associated with the asset
        record.
      type: String
    - contextPath: TenableIO.Asset.qualys_asset_ids
      description: The Asset ID of the asset in Qualys. For more information, see
        the Qualys documentation.
      type: String
    - contextPath: TenableIO.Asset.qualys_host_ids
      description: The Host ID of the asset in Qualys. For more information, see the
        Qualys documentation.
      type: String
    - contextPath: TenableIO.Asset.manufacturer_tpm_ids
      description: The manufacturer's unique identifiers of the Trusted Platform Module
        (TPM) associated with the asset.
      type: String
    - contextPath: TenableIO.Asset.symantec_ep_hardware_keys
      description: The hardware keys for the asset in Symantec Endpoint Protection.
      type: String
    - contextPath: TenableIO.Asset.sources.name
      description: The name of the entity that reported the asset details. Sources
        can include sensors, connectors, and API imports.
      type: String
    - contextPath: TenableIO.Asset.sources.first_seen
      description: The ISO timestamp when the source first reported the asset.
      type: Date
    - contextPath: TenableIO.Asset.sources.last_seen
      description: The ISO timestamp when the source last reported the asset.
      type: Date
    - contextPath: TenableIO.Asset.tags.uuid
      description: The UUID of the tag.
      type: String
    - contextPath: TenableIO.Asset.tags.key
      description: The tag category (the first half of the category:value pair).
      type: String
    - contextPath: TenableIO.Asset.tags.value
      description: The tag value (the second half of the category:value pair).
      type: String
    - contextPath: TenableIO.Asset.tags.added_by
      description: The UUID of the user who assigned the tag to the asset.
      type: String
    - contextPath: TenableIO.Asset.tags.added_at
      description: The ISO timestamp when the tag was assigned to the asset.
      type: Date
    - contextPath: TenableIO.Asset.network_interfaces.name
      description: The name of the interface.
      type: String
    - contextPath: TenableIO.Asset.network_interfaces.mac_address
      description: The MAC addresses of the interface.
      type: String
    - contextPath: TenableIO.Asset.network_interfaces.ipv6
      description: One or more IPv6 addresses belonging to the interface.
      type: String
    - contextPath: TenableIO.Asset.network_interfaces.fqdns
      description: One or more FQDNs belonging to the interface.
      type: String
    - contextPath: TenableIO.Asset.network_interfaces.ipv4s
      description: One or more IPv4 addresses belonging to the interface.
      type: String
    - contextPath: TenableIO.Asset.acr_score
      description: The Asset Criticality Rating (ACR) for the asset.
      type: String
    - contextPath: TenableIO.Asset.exposure_score
      description: The Asset Exposure Score (AES) for the asset.
      type: String
    polling: true
  - arguments:
    - defaultValue: "50"
      description: The number of assets used to chunk the vulnerabilities. The range
        for number of assets in a chunk is 50-5000.
      name: numAssets
    - defaultValue: "10"
      description: The interval in seconds between each poll.
      name: intervalInSeconds
    - defaultValue: "50"
      description: The timeout for the polling in seconds.
      name: timeOut
    - auto: PREDEFINED
      description: Specifies whether or not to include unlicensed assets.
      name: includeUnlicensed
      predefined:
      - "true"
      - "false"
    - description: When specified, restricts the search for vulnerabilities to assets
        assigned an IP address within the specified CIDR range.
      name: cidrRange
    - description: When specified, the results returned in the list are limited to
        vulnerabilities that were first found between the specified date and now.
        Date format will be epoch date format or relational expressions like “7 days
        ago”.
      name: firstFound
    - description: When specified, the results returned in the list are limited to
        vulnerabilities that were fixed between the specified date and now. Date format
        will be epoch date format or relational expressions like “7 days ago”.
      name: lastFixed
    - description: When specified, the results returned in the list are limited to
        vulnerabilities that were last found between the specified date and now. Date
        format will be epoch date format or relational expressions like “7 days ago”.
      name: lastFound
    - defaultValue: 00000000-0000-0000-0000-000000000000
      description: The ID of the network object associated with scanners that detected
        the vulnerabilities you want to export.
      name: networkId
    - description: A comma-separated list of plugin IDs for which you want to filter
        the vulnerabilities.
      isArray: true
      name: pluginId
    - auto: PREDEFINED
      description: The plugin type for which you want to filter the vulnerabilities.
        If not set, export includes all vulnerabilities regardless of plugin type.
      name: pluginType
      predefined:
      - remote
      - local
      - combined
      - settings
      - summary
      - third-party
      - reputation
    - description: 'A comma-separated list of severities of the vulnerabilities to
        include in the export. Defaults to all severity levels. The severity of a
        vulnerability is defined using the Common Vulnerability Scoring System (CVSS)
        base score. Supported array values are: info, low, medium, high, critical.'
      isArray: true
      name: severity
    - description: 'The start date for the range of data you want to export. Date
        format will be epoch date format or relational expressions like “7 days ago”.
        Note: This filter cannot be used in conjunction with the firstFound, lastFound,
        or lastFixed.'
      isArray: true
      name: since
    - description: 'A comma-separated list of states of the vulnerabilities you want
        the export to include. Supported, case-insensitive values are: open, reopened,
        fixed. This parameter is required if your request includes firstFound, lastFound,
        or lastFixed parameters. If your request omits this parameter, the export
        includes default states open and reopened only.'
      isArray: true
      name: state
    - description: When specified, the results returned in the list are limited to
        assets with the specified tag category.
      name: tagCategory
    - description: When specified, the results returned in the list are limited to
        assets with the specified tag value.
      name: tagValue
    - auto: PREDEFINED
      description: 'An operator that determines the limitation on Vulnerability Priority
        Rating (VPR), scores value specified at vprScoreValue argument. Supported
        values are: equal, not equal, lt-lesser, lte-lesser than or equal , gt-greater
        than , gte-greater than or equal.'
      name: vprScoreOperator
      predefined:
      - gte
      - gt
      - lte
      - lt
      - equal
      - not equal
    - description: When specified, the results returned in the list are limited to
        vulnerabilities with the specified Vulnerability Priority Rating (VPR), score
        or scores according to the score operator (vprScoreOperator) argument. VPR
        values range are 0.1-10.0.
      isArray: true
      name: vprScoreValue
    - description: 'When specified, the results returned in the list are limited to
        vulnerabilities with the specified Vulnerability Priority Rating (VPR) score
        range. Example value: 2.5-3.5.'
      name: vprScoreRange
    - description: The export UUID.
      hidden: true
      name: exportUuid
    - auto: PREDEFINED
      defaultValue: "false"
      description: Set this argument to True in order to create vulnerabilities, otherwise
        the command will only display the vulnerabilities.
      name: should_push_events
      predefined:
      - "true"
      - "false"
    description: Retrieves details for the specified asset to include custom attributes.
    name: tenable-io-export-vulnerabilities
    outputs:
    - contextPath: TenableIO.Vulnerability.asset.agent_uuid
      description: The UUID of the agent that performed the scan where the vulnerability
        was found.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.bios_uuid
      description: The BIOS UUID of the asset where the vulnerability was found.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.device_type
      description: The type of asset where the vulnerability was found.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.fqdn
      description: The fully-qualified domain name of the asset where a scan found
        the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.hostname
      description: The host name of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.uuid
      description: The UUID of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.ipv6
      description: The IPv6 address of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.last_authenticated_results
      description: The last date credentials that were used successfully to scan the
        asset.
      type: Date
    - contextPath: TenableIO.Vulnerability.asset.last_unauthenticated_results
      description: The last date when the asset was scanned without using credentials.
      type: Date
    - contextPath: TenableIO.Vulnerability.asset.mac_address
      description: The MAC address of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.netbios_name
      description: The NETBIOS name of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.netbios_workgroup
      description: The NETBIOS workgroup of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.operating_system
      description: The operating system of the asset where a scan found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.network_id
      description: The ID of the network object associated with scanners that identified
        the asset.
      type: String
    - contextPath: TenableIO.Vulnerability.asset.tracked
      description: A value specifying whether Tenable.io tracks the asset in the asset
        management system.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.output
      description: The text output of the Nessus scanner.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.bid
      description: The Bugtraq ID for the plugin.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.canvas_package
      description: The name of the CANVAS exploit pack that includes the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.checks_for_default_account
      description: A value specifying whether the plugin checks for default accounts.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.checks_for_malware
      description: A value specifying whether the plugin checks for malware.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.cpe
      description: The Common Platform Enumeration (CPE) number for the plugin.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cve
      description: The Common Vulnerability and Exposure (CVE) ID for the plugin.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_base_score
      description: The CVSSv3 base score (intrinsic and fundamental characteristics
        of a vulnerability that are constant over time and user environments).
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_temporal_score
      description: The CVSSv3 temporal score (characteristics of a vulnerability that
        change over time but not among user environments).
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_temporal_vector.exploitability
      description: The CVSSv3 Exploit Maturity Code (E) for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_temporal_vector.remediation_level
      description: The CVSSv3 Remediation Level (RL) temporal metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_temporal_vector.report_confidence
      description: The CVSSv3 Report Confidence (RC) temporal metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_temporal_vector.raw
      description: The complete CVSSv3 temporal vector metrics and result values for
        the vulnerability the plugin covers in a condensed and coded format.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.access_vector
      description: The CVSSv3 Attack Vector (AV) metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.access_complexity
      description: The CVSSv3 Access Complexity (AC) metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.authentication
      description: The CVSSv3 Authentication (Au) metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.confidentiality_impact
      description: The CVSSv3 integrity impact metric for the vulnerability the plugin
        covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.integrity_impact
      description: The CVSSv3 integrity impact metric for the vulnerability the plugin
        covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.availability_impact
      description: The CVSSv3 availability impact metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss3_vector.raw
      description: The complete cvss3_vector metrics and result values for the vulnerability
        the plugin covers in a condensed and coded format.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_temporal_vector.exploitability
      description: The CVSSv2 Exploitability (E) temporal metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_temporal_vector.remediation_level
      description: The CVSSv2 Remediation Level (RL) temporal metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_temporal_vector.report_confidence
      description: The CVSSv2 Report Confidence (RC) temporal metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_temporal_vector.raw
      description: The complete CVSS temporal vector metrics and result values for
        the vulnerability the plugin covers in a condensed and coded format.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.access_vector
      description: The CVSSv2 Access Vector (AV) metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.access_complexity
      description: The CVSSv2 Access Complexity (AC) metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.authentication
      description: The CVSSv2 Authentication (Au) metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.confidentiality_impact
      description: The CVSSv2 confidentiality impact metric for the vulnerability
        the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.integrity_impact
      description: The CVSSv2 integrity impact metric for the vulnerability the plugin
        covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.availability_impact
      description: The CVSSv2 availability impact metric for the vulnerability the
        plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_vector.raw
      description: The complete CVSSv2 vector metrics and result values for the vulnerability
        the plugin covers in a condensed and coded format.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.cvss_base_score
      description: The CVSSv2 base score (intrinsic and fundamental characteristics
        of a vulnerability that are constant over time and user environments).
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.cvss_temporal_score
      description: The CVSSv2 temporal score (characteristics of a vulnerability that
        change over time but not among user environments).
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.d2_elliot_name
      description: The name of the exploit in the D2 Elliot Web Exploitation framework.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.description
      description: Full text description of the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.exploit_available
      description: A value specifying whether a public exploit exists for the vulnerability.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploit_framework_canvas
      description: A value specifying whether an exploit exists in the Immunity CANVAS
        framework.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploit_framework_core
      description: A value specifying whether an exploit exists in the CORE Impact
        framework.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploit_framework_d2_elliot
      description: A value specifying whether an exploit exists in the D2 Elliot Web
        Exploitation framework.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploit_framework_exploithub
      description: A value specifying whether an exploit exists in the ExploitHub
        framework.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploit_framework_metasploit
      description: A value specifying whether an exploit exists in the Metasploit
        framework.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploitability_ease
      description: Description of how easy it is to exploit the issue.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.exploited_by_malware
      description: Whether the vulnerability discovered by this plugin is known to
        be exploited by malware.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploited_by_nessus
      description: A value specifying whether Nessus exploited the vulnerability during
        the process of identification.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.exploithub_sku
      description: The SKU number of the exploit in the ExploitHub framework.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.family
      description: The family to which the plugin belongs.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.family_id
      description: The ID of the plugin family.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.has_patch
      description: A value specifying whether the vendor has published a patch for
        the vulnerability.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.id
      description: The ID of the plugin that identified the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.in_the_news
      description: A value specifying whether this plugin has received media attention
        (for example, ShellShock, Meltdown).
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.metasploit_name
      description: The name of the related exploit in the Metasploit framework.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.ms_bulletin
      description: The Microsoft security bulletin that the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.name
      description: The name of the plugin that identified the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.patch_publication_date
      description: The date on which the vendor published a patch for the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.modification_date
      description: The date on which the plugin was last modified.
      type: Date
    - contextPath: TenableIO.Vulnerability.plugin.publication_date
      description: The date on which the plugin was published.
      type: Date
    - contextPath: TenableIO.Vulnerability.plugin.risk_factor
      description: 'The risk factor associated with the plugin. Possible values are:
        Low, Medium, High, or Critical.'
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.see_also
      description: Links to external websites that contain helpful information about
        the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.solution
      description: Remediation information for the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.stig_severity
      description: Security Technical Implementation Guide (STIG) severity code for
        the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.synopsis
      description: Brief description of the plugin or vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.type
      description: The general type of plugin check (for example, local or remote).
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.unsupported_by_vendor
      description: Whether software found by this plugin is unsupported by the software's
        vendor (for example, Windows 95 or Firefox 3).
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.usn
      description: Ubuntu security notice that the plugin covers.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.version
      description: The version of the plugin used to perform the check.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vuln_publication_date
      description: The publication date of the plugin.
      type: Date
    - contextPath: TenableIO.Vulnerability.plugin.xrefs.type
      description: References to third-party information about the vulnerability,
        exploit, or update associated with the plugin.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.xrefs.id
      description: References to third-party information about the vulnerability,
        exploit, or update associated with the plugin.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.score
      description: The Vulnerability Priority Rating (VPR) for the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.age_of_vuln
      description: A range representing the number of days since the National Vulnerability
        Database (NVD) published the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.age_of_vuln.lower_bound
      description: The lower bound of the range.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.age_of_vuln.upper_bound
      description: The upper bound of the range.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.exploit_code_maturity
      description: The relative maturity of a possible exploit for the vulnerability
        based on the existence, sophistication, and prevalence of exploit intelligence
        from internal and external sources.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.cvss3_impact_score
      description: The NVD-provided CVSSv3 impact score for the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.cvss_impact_score_predicted
      description: A value specifying whether Tenable.io predicted the CVSSv3 impact
        score for the vulnerability.
      type: Boolean
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.threat_intensity_last28
      description: 'The relative intensity based on the number and frequency of recently
        observed threat events related to this vulnerability: Very Low, Low, Medium,
        High, or Very High.'
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.threat_recency
      description: A range representing the number of days since a threat event occurred
        for the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.threat_recency.lower_bound
      description: The lower bound of the range.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.threat_recency.upper_bound
      description: The upper bound of the range.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.threat_sources_last28
      description: A list of all sources (for example, social media channels, the
        dark web, etc.) where threat events related to this vulnerability occurred.
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.drivers.product_coverage
      description: 'The relative number of unique products affected by the vulnerability:
        ''Low'', ''Medium'', ''High'', or ''Very High''.'
      type: String
    - contextPath: TenableIO.Vulnerability.plugin.vpr.updated
      description: The ISO timestamp when Tenable.io last imported the VPR for this
        vulnerability.
      type: Date
    - contextPath: TenableIO.Vulnerability.port.port
      description: The port the scanner used to communicate with the asset.
      type: Number
    - contextPath: TenableIO.Vulnerability.port.protocol
      description: The protocol the scanner used to communicate with the asset.
      type: String
    - contextPath: TenableIO.Vulnerability.port.service
      description: The service the scanner used to communicate with the asset.
      type: String
    - contextPath: TenableIO.Vulnerability.recast_reason
      description: The text that appears in the Comment field of the recast rule in
        the Tenable.io user interface.
      type: String
    - contextPath: TenableIO.Vulnerability.recast_rule_uuid
      description: The UUID of the recast rule that applies to the plugin.
      type: String
    - contextPath: TenableIO.Vulnerability.scan.completed_at
      description: The ISO timestamp when the scan completed.
      type: Date
    - contextPath: TenableIO.Vulnerability.scan.schedule_uuid
      description: The schedule UUID for the scan that found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.scan.started_at
      description: The ISO timestamp when the scan started.
      type: Date
    - contextPath: TenableIO.Vulnerability.scan.uuid
      description: The UUID of the scan that found the vulnerability.
      type: String
    - contextPath: TenableIO.Vulnerability.severity
      description: The severity of the vulnerability as defined using the Common Vulnerability
        Scoring System (CVSS) base score.
      type: String
    - contextPath: TenableIO.Vulnerability.severity_id
      description: The code for the severity assigned when a user recast the risk
        associated with the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.severity_default_id
      description: The code for the severity originally assigned to a vulnerability
        before a user recast the risk associated with the vulnerability.
      type: Number
    - contextPath: TenableIO.Vulnerability.severity_modification_type
      description: The type of modification a user made to the vulnerability's severity.
      type: String
    - contextPath: TenableIO.Vulnerability.first_found
      description: The ISO date when a scan first detected the vulnerability on the
        asset.
      type: Date
    - contextPath: TenableIO.Vulnerability.last_fixed
      description: The ISO date when a scan no longer detects the previously detected
        vulnerability on the asset.
      type: Date
    - contextPath: TenableIO.Vulnerability.last_found
      description: The ISO date when a scan last detected the vulnerability on the
        asset.
      type: Date
    - contextPath: TenableIO.Vulnerability.state
      description: The state of the vulnerability as determined by the Tenable.io
        state service.
      type: String
    - contextPath: TenableIO.Vulnerability.indexed
      description: The date and time (in Unix time) when the vulnerability was indexed
        into Tenable.io.
      type: Date
    polling: true
  - arguments: []
    description: Lists the filtering, sorting, and pagination capabilities available
      for scan records on endpoints/commands that support them.
    name: tenable-io-list-scan-filters
    outputs:
    - contextPath: TenableIO.ScanFilter.name
      description: The name of the scan filter.
      type: String
    - contextPath: TenableIO.ScanFilter.readable_name
      description: The readable name of the scan filter.
      type: String
    - contextPath: TenableIO.ScanFilter.control.type
      description: The type of control associated with the scan filter.
      type: String
    - contextPath: TenableIO.ScanFilter.control.regex
      description: The regular expression used by the scan filter.
      type: String
    - contextPath: TenableIO.ScanFilter.control.readable_regex
      description: An example expression that the filter's regular expression would
        match.
      type: String
    - contextPath: TenableIO.ScanFilter.operators
      description: The operators available for the scan filter.
      type: String
    - contextPath: TenableIO.ScanFilter.group_name
      description: The group name associated with the scan filter.
      type: String
  - arguments:
    - description: The ID of the scan of which to get the runs.
      name: scanId
      required: true
    - auto: PREDEFINED
      description: A comma-separated list of fields by which to sort, in the order
        defined by "sortOrder".
      isArray: true
      name: sortFields
      predefined:
      - start_date
      - end_date
      - status
    - auto: PREDEFINED
      defaultValue: asc
      description: |
        A comma-separated list of directions in which to sort the fields defined by "sortFields".
        If multiple directions are chosen, they will be sequentially matched with "sortFields".
        If only one direction is chosen it will be used to sort all values in "sortFields".
        For example:
          If sortFields is "start_date,status" and sortOrder is "asc,desc",
          then start_date is sorted in ascending order and status in descending order.
          If sortFields is "start_date,status" and sortOrder is simply "asc",
          then both start_date and status are sorted in ascending order.
      isArray: true
      name: sortOrder
      predefined:
      - asc
      - desc
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to exclude rollover scans from the scan history.
      name: excludeRollover
      predefined:
      - "true"
      - "false"
    - description: The page number of scan records to retrieve (used for pagination)
        starting from 1. The page size is defined by the "pageSize" argument.
      name: page
    - description: The number of scan records per page to retrieve (used for pagination).
        The page number is defined by the "page" argument.
      name: pageSize
    - defaultValue: "50"
      description: The maximum number of records to retrieve. If "pageSize" is defined,
        this argument is ignored.
      name: limit
    description: Lists the individual runs of the specified scan.
    name: tenable-io-get-scan-history
    outputs:
    - contextPath: TenableIO.ScanHistory.time_end
      description: The end time of the scan.
      type: Number
    - contextPath: TenableIO.ScanHistory.scan_uuid
      description: The UUID (Universally Unique Identifier) of the scan.
      type: String
    - contextPath: TenableIO.ScanHistory.id
      description: The ID of the scan history.
      type: Number
    - contextPath: TenableIO.ScanHistory.is_archived
      description: Indicates whether the scan is archived or not.
      type: Boolean
    - contextPath: TenableIO.ScanHistory.time_start
      description: The start time of the scan.
      type: Number
    - contextPath: TenableIO.ScanHistory.visibility
      description: The visibility of the scan.
      type: String
    - contextPath: TenableIO.ScanHistory.targets.custom
      description: Indicates whether custom targets were used in the scan.
      type: Boolean
    - contextPath: TenableIO.ScanHistory.targets.default
      description: Indicates whether the default targets were used in the scan.
      type: Boolean
    - contextPath: TenableIO.ScanHistory.status
      description: The status of the scan.
      type: String
  - arguments:
    - description: The identifier for the scan to export. Run the "tenable-io-list-scans"
        command to get all available scans.
      name: scanId
      required: true
    - description: The unique identifier of the historical data to export. Run the
        "tenable-io-get-scan-history" command to get history IDs.
      name: historyId
    - description: The UUID of the historical data to export. Run the "tenable-io-get-scan-history"
        command to get history UUIDs.
      name: historyUuid
    - auto: PREDEFINED
      defaultValue: CSV
      description: |
        The file format to export the scan in. Scans can be export in the HTML and PDF formats for up to 35 days.
         For scans that are older than 35 days, only the Nessus and CSV formats are supported.
         The "chapters" argument must be defined if the chosen format is HTML or PDF.
      name: format
      predefined:
      - Nessus
      - HTML
      - PDF
      - CSV
      required: true
    - auto: PREDEFINED
      description: A comma-separated list of chapters to include in the export. This
        argument is required if the file format is PDF or HTML.
      isArray: true
      name: chapters
      predefined:
      - vuln_hosts_summary
      - vuln_by_host
      - compliance_exec
      - remediations
      - vuln_by_plugin
      - compliance
    - description: |
        A comma-separated list of filters, in the format of "name quality value" to apply to the exported scan report.
         Example: "port.protocol eq tcp, plugin_id eq 1234567"
         Note: when used literally, commas and spaces should be escaped. (i.e. "\\," for comma and "\\s" for space)
         Filters cannot be applied to scans older than 35 days.
         Run "tenable-io-list-scan-filters" to get all available filters, ("Filter name" (name), "Filter operators" (quality) and "Readable regex" (value) in response).
         For more information: https://developer.tenable.com/docs/scan-export-filters-tio
      isArray: true
      name: filter
    - auto: PREDEFINED
      defaultValue: AND
      description: For multiple filters, specifies whether to use the AND or the OR
        logical operator.
      name: filterSearchType
      predefined:
      - AND
      - OR
    - description: The ID of the asset scanned.
      name: assetId
    - hidden: true
      name: fileId
    - hidden: true
      name: hide_polling_output
    description: |-
      Export and download a scan report.
      Scan results older than 35 days are supported in Nessus and CSV formats only, and filters cannot be applied.
      Scans that are actively running cannot be exported (run "tenable-io-list-scans" to view scan statuses).
    name: tenable-io-export-scan
    outputs:
    - contextPath: InfoFile.Size
      description: The size of the file in bytes.
      type: number
    - contextPath: InfoFile.Name
      description: The name of the file.
      type: string
    - contextPath: InfoFile.EntryID
      description: The War Room entry ID of the file.
      type: string
    - contextPath: InfoFile.Info
      description: The format and encoding of the file.
      type: string
    - contextPath: InfoFile.Type
      description: The type of the file.
      type: string
    - contextPath: InfoFile.Extension
      description: The file extension of the file.
    polling: true
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Set this argument to True in order to create events, otherwise
        the command will only display the events.
      name: should_push_events
      predefined:
      - "true"
      - "false"
      required: true
    - description: The maximum number of alerts to return (maximum value - 5000).
      name: limit
    - description: Return events that occurred after the specified date.
      name: from_date
    - description: Return events that occurred before the specified date.
      name: to_date
    - description: Return events that contain the specified actor UUID.
      name: actor_id
    - description: Return events matching the specified target UUID.
      name: target_id
    description: Returns audit logs extracted from Tenable io.
    name: tenable-io-get-audit-logs
  dockerimage: demisto/python3:3.10.13.90168
  runonce: false
  script: |
    register_module_line('Tenable.io', 'start', __line__())
    ### pack version: 2.2.2


    import sys
    import time
    import traceback
    from datetime import datetime
    import urllib3
    import re

    import requests

    from requests.exceptions import HTTPError

    # Disable insecure warnings
    urllib3.disable_warnings()


    FIELD_NAMES_MAP = {
        'ScanType': 'Type',
        'ScanStart': 'StartTime',
        'ScanEnd': 'EndTime',
        'ScannerName': 'Scanner',
        'SeenLast': 'LastSeen',
        'SeenFirst': 'FirstSeen',
        'PluginId': 'Id',
        'Count': 'VulnerabilityOccurences'
    }

    REMEDIATIONS_NAMES_MAP = {
        'Value': 'Id',
        'Vulns': 'AssociatedVulnerabilities',
        'Hosts': 'AffectedHosts',
        'Remediation': 'Description'
    }

    ASSET_VULNS_NAMES_MAP = {
        'PluginId': 'Id',
        'PluginFamily': 'Family',
        'PluginName': 'Name',
        'Count': 'VulnerabilityOccurences'
    }

    GET_SCANS_HEADERS = [
        'FolderId',
        'Id',
        'Name',
        'Targets',
        'Status',
        'StartTime',
        'EndTime',
        'Enabled',
        'Type',
        'Owner',
        'Scanner',
        'Policy',
        'CreationDate',
        'LastModificationDate'
    ]

    LAUNCH_SCAN_HEADERS = [
        'Id',
        'Targets',
        'Status'
    ]

    SCAN_REPORT_INFO_HEADERS = [
        'Id',
        'Name',
        'Targets',
        'Status',
        'StartTime',
        'EndTime',
        'Scanner',
        'Policy'
    ]

    SCAN_REPORT_VULNERABILITIES_HEADERS = [
        'Id',
        'Name',
        'Severity',
        'Description',
        'Synopsis',
        'Solution',
        'FirstSeen',
        'LastSeen',
        'VulnerabilityOccurences'
    ]

    SCAN_REPORT_HOSTS_HEADERS = [
        'Hostname',
        'Score',
        'Severity',
        'Critical',
        'High',
        'Medium',
        'Low'
    ]

    SCAN_REPORT_REMEDIATIONS_HEADERS = [
        'Id',
        'Description',
        'AffectedHosts',
        'AssociatedVulnerabilities'
    ]

    VULNERABILITY_DETAILS_HEADERS = [
        'Name',
        'Severity',
        'Type',
        'Family',
        'Description',
        'Synopsis',
        'Solution',
        'FirstSeen',
        'LastSeen',
        'PublicationDate',
        'ModificationDate',
        'VulnerabilityOccurences',
        'CvssVector',
        'CvssBaseScore',
        'Cvss3Vector',
        'Cvss3BaseScore'
    ]

    ASSET_VULNS_HEADERS = [
        'Id',
        'Name',
        'Severity',
        'Family',
        'VulnerabilityOccurences',
        'VulnerabilityState'
    ]

    severity_to_text = [
        'None',
        'Low',
        'Medium',
        'High',
        'Critical'
    ]
    PARAMS = demisto.params()
    BASE_URL = PARAMS['url']
    ACCESS_KEY = PARAMS.get('credentials_access_key', {}).get('password') or PARAMS.get('access-key')
    SECRET_KEY = PARAMS.get('credentials_secret_key', {}).get('password') or PARAMS.get('secret-key')
    USER_AGENT_HEADERS_VALUE = 'Integration/1.0 (PAN; Cortex-XSOAR; Build/2.0)'
    AUTH_HEADERS = {'X-ApiKeys': f"accessKey={ACCESS_KEY}; secretKey={SECRET_KEY}"}
    HEADERS = AUTH_HEADERS | {
        'accept': "application/json",
        'content-type': "application/json",
        'User-Agent': USER_AGENT_HEADERS_VALUE
    }
    USE_SSL = not PARAMS['unsecure']
    USE_PROXY = PARAMS.get('proxy', False)

    if not USE_PROXY:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    DATE_FORMAT = '%Y-%m-%d'
    VENDOR = 'tenable'
    PRODUCT = 'io'
    CHUNK_SIZE = 5000
    MAX_CHUNKS_PER_FETCH = 10
    ASSETS_FETCH_FROM = '90 days'
    MIN_ASSETS_INTERVAL = 60


    class Client(BaseClient):

        def list_scan_filters(self):
            return self._http_request(
                'GET', 'filters/scans/reports')

        def get_scan_history(self, scan_id, params) -> dict:
            remove_nulls_from_dictionary(params)
            return self._http_request(
                'GET', f'scans/{scan_id}/history',
                params=params)

        def initiate_export_scan(self, scan_id: str, params: dict, body: dict) -> dict:
            remove_nulls_from_dictionary(params)
            remove_nulls_from_dictionary(body)
            return self._http_request(
                'POST',
                f'scans/{scan_id}/export',
                params=params, json_data=body)

        def check_export_scan_status(self, scan_id: str, file_id: str) -> dict:
            return self._http_request(
                'GET', f'scans/{scan_id}/export/{file_id}/status')

        def download_export_scan(self, scan_id: str, file_id: str, file_format: str) -> dict:
            return fileResult(
                f'scan_{scan_id}_{file_id}.{file_format.lower()}',
                self._http_request(
                    'GET', f'scans/{scan_id}/export/{file_id}/download',
                    resp_type='content'),
                EntryType.ENTRY_INFO_FILE)

        @staticmethod
        def add_query(query, param_to_add):
            if query:
                return f'{query}&{param_to_add}'
            return f'?{param_to_add}'

        def get_audit_logs_request(self, from_date: str = None, to_date: str = None, actor_id: str = None,
                                   target_id: str = None, limit: int = None):
            """

            Args:
                limit: limit number of audit logs to get.
                from_date: date to fetch audit logs from.
                to_date: date which until to fetch audit logs.
                actor_id: fetch audit logs with matching actor id.
                target_id:fetch audit logs with matching target id.

            Returns:
                audit logs fetched from the API.
            """
            query = ''
            if from_date:
                query = self.add_query(query, f'f=date.gt:{from_date}')
            if to_date:
                query = self.add_query(query, f'f=date.lt:{to_date}')
            if actor_id:
                query = self.add_query(query, f'f=actor_id.match:{actor_id}')
            if target_id:
                query = self.add_query(query, f'f=target_id.match:{target_id}')
            if limit:
                query = self.add_query(query, f'limit={limit}')
            else:
                query = self.add_query(query, 'limit=5000')
            res = self._http_request(method='GET', url_suffix=f'/audit-log/v1/events{query}', headers=self._headers)
            return res.get('events', [])

        def get_vuln_export_uuid(self, num_assets: int, last_found: Optional[float]):
            """

            Args:
                num_assets: number of assets used to chunk the vulnerabilities.
                last_found: vulnerabilities that were last found between the specified date (in Unix time) and now.

            Returns: The UUID of the vulnerabilities export job.

            """
            payload: dict[str, Any] = {
                "filters":
                    {
                        "last_found": last_found
                    },
                "num_assets": num_assets
            }

            res = self._http_request(method='POST', url_suffix='/vulns/export', headers=self._headers, json_data=payload)
            return res.get('export_uuid', '')

        def get_vuln_export_status(self, export_uuid: str):
            """

            Args:
                export_uuid: The UUID of the vulnerabilities export job.

            Returns: The status of the job, and number of chunks available if succeeded.

            """
            res = self._http_request(method='GET', url_suffix=f'/vulns/export/{export_uuid}/status',
                                     headers=self._headers)
            status = res.get('status')
            chunks_available = res.get('chunks_available', [])
            return status, chunks_available

        def download_vulnerabilities_chunk(self, export_uuid: str, chunk_id: int):
            """

            Args:
                export_uuid: The UUID of the vulnerabilities export job.
                chunk_id: The ID of the chunk you want to export.

            Returns: Chunk of vulnerabilities from API.

            """
            return self._http_request(method='GET', url_suffix=f'/vulns/export/{export_uuid}/chunks/{chunk_id}',
                                      headers=self._headers)

        def get_asset_export_uuid(self, fetch_from):
            """

            Args:
                fetch_from: the last asset that was fetched previously.

            Returns: The UUID of the assets export job.

            """
            payload = {
                'chunk_size': CHUNK_SIZE,
                "filters": {
                    "updated_at": fetch_from
                }
            }
            demisto.debug(f"my payload is: {payload}")
            res = self._http_request(method='POST', url_suffix='assets/export', json_data=payload,
                                     headers=self._headers)
            return res.get('export_uuid')

        def get_assets_export_status(self, export_uuid):
            """
            Args:
                    export_uuid: The UUID of the assets export job.

            Returns: The assets' chunk id.

            """
            res = self._http_request(method='GET', url_suffix=f'assets/export/{export_uuid}/status', headers=self._headers)
            return res.get('status'), res.get('chunks_available')

        def download_assets_chunk(self, export_uuid: str, chunk_id: int):
            """

            Args:
                export_uuid: The UUID of the assets export job.
                chunk_id: The ID of the chunk you want to export.

            Returns: Chunk of assets from API.

            """
            return self._http_request(method='GET', url_suffix=f'/assets/export/{export_uuid}/chunks/{chunk_id}',
                                      headers=self._headers)


    def flatten(d):
        r = {}  # type: ignore
        for v in d.values():
            if isinstance(v, dict):
                r.update(flatten(v))
        d.update(r)
        return d


    def filter_dict_null(d):
        if isinstance(d, dict):
            return {k: v for k, v in d.items() if v is not None}
        return d


    def filter_dict_keys(d, keys):
        if isinstance(d, list):
            return [filter_dict_keys(x, keys) for x in d]
        if isinstance(d, dict):
            return {k: v for k, v in d.items() if k in keys}
        return d


    def convert_severity_values(d):
        if isinstance(d, list):
            return list(map(convert_severity_values, d))
        if isinstance(d, dict):
            return {k: (severity_to_text[v] if k == 'Severity' else v) for k, v in d.items()}
        return d


    def convert_dict_context_dates(d):
        def convert_epoch_to_date(k, v):
            if any(s in k.lower() for s in ('date', 'time')):
                try:
                    return datetime.utcfromtimestamp(int(v)).strftime('%Y-%m-%dT%H:%M:%SZ')
                except Exception:
                    pass
            return v

        if isinstance(d, list):
            return list(map(convert_dict_context_dates, d))
        if isinstance(d, dict):
            return {k: convert_dict_context_dates(convert_epoch_to_date(k, v)) for k, v in d.items()}
        return d


    def convert_dict_readable_dates(d):
        def convert_epoch_to_date(k, v):
            return formatEpochDate(v) if isinstance(v, int) and any(s in k.lower() for s in ('date', 'time')) else v

        if isinstance(d, list):
            return list(map(convert_dict_readable_dates, d))
        if isinstance(d, dict):
            return {k: convert_dict_readable_dates(convert_epoch_to_date(k, v)) for k, v in d.items()}
        return d


    def get_entry_for_object(title, context_key, obj, headers=None, remove_null=False):
        def intersection(lst1, lst2):
            return [value for value in lst1 if value in lst2]

        if len(obj) == 0:
            return "There is no output result"
        filtered_obj = filter_dict_null(obj)
        if isinstance(filtered_obj, list):
            filtered_obj = list(map(filter_dict_null, filtered_obj))
        if headers and isinstance(filtered_obj, dict):
            headers = intersection(headers, list(filtered_obj.keys()))

        hr_obj = convert_dict_readable_dates(filtered_obj)
        context_obj = convert_dict_context_dates(filter_dict_keys(filtered_obj, headers) if headers else filtered_obj)

        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr_obj, headers, removeNull=remove_null),
            'EntryContext': {
                context_key: context_obj
            }
        }


    def replace_keys(src, trans_map=FIELD_NAMES_MAP, camelize=True):
        def snake_to_camel(snake_str):
            components = snake_str.split('_')
            return ''.join([x.title() for x in components])

        def replace(key, trans_map):
            if key in trans_map:
                return trans_map[key]
            return key

        if isinstance(src, list):
            return [replace_keys(x, trans_map, camelize) for x in src]
        if camelize:
            src = {snake_to_camel(k): v for k, v in src.items()}
        if trans_map:
            src = {replace(k, trans_map): v for k, v in src.items()}
        return src


    def date_range_to_param(date_range):
        params = {}
        if date_range:
            try:
                date_range = int(date_range)
                params['date_range'] = date_range
            except ValueError:
                return_error(f"Invalid date range: {date_range}")
        return params


    def get_scan_error_message(response, scan_id):
        code = response.status_code
        message = "Error processing request"
        if scan_id:
            message += f" for scan with id {scan_id}"
        message += f". Got response status code: {code}"
        if code == 401:
            message += " - Scan is disabled."
        elif code == 403:
            message += f" - {response.json()['error']}"
        elif code == 404:
            message += " - Scan does not exist."
        elif code == 409:
            message += " - Scan cannot be launched in its current status."
        return message


    # Request/Response methods
    # kwargs: request parameters
    def send_scan_request(scan_id="", endpoint="", method='GET', ignore_license_error=False, body=None, **kwargs):
        if endpoint:
            endpoint = '/' + endpoint
        full_url = f"{BASE_URL}scans/{scan_id!s}{endpoint}"
        try:
            res = requests.request(method, full_url, headers=AUTH_HEADERS, verify=USE_SSL, json=body, params=kwargs)
            res.raise_for_status()
            return res.json()
        except HTTPError as e:
            demisto.debug(str(e))
            if ignore_license_error and res.status_code in (403, 500):
                return None
            err_msg = get_scan_error_message(res, scan_id)
            if demisto.command() != 'test-module':
                return_error(err_msg)
            else:
                demisto.results(err_msg)
            demisto.error(traceback.format_exc())
            sys.exit(0)
        except ValueError:
            return "No JSON to decode."


    def get_scan_info(scans_result_elem):
        response = send_scan_request(scans_result_elem['id'], ignore_license_error=True)
        if response:
            response['info'].update(scans_result_elem)
            return response['info']
        return None


    def send_vuln_details_request(plugin_id, date_range=None):
        full_url = f"{BASE_URL}workbenches/vulnerabilities/{plugin_id}/info"
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        return res.json()


    def get_vuln_info(vulns):
        vulns_info = {v['plugin_id']: v for v in vulns}
        infos = []
        errors = []
        for pid, info in vulns_info.items():
            vuln_details = send_vuln_details_request(pid)
            if 'error' in vuln_details:
                errors.append(info)
            else:
                info.update(flatten(vuln_details['info']))
                infos.append(info)
        return infos, errors


    def send_assets_request(params):
        full_url = f"{BASE_URL}workbenches/assets"
        res = requests.request("GET", full_url, headers=AUTH_HEADERS, params=params, verify=USE_SSL)
        return res.json()


    def get_asset_id(params):
        assets = send_assets_request(params)
        if 'error' in assets:
            return_error(assets['error'])
        if assets.get('assets'):
            return assets['assets'][0]['id']
        return None


    def send_asset_vuln_request(asset_id, date_range):
        full_url = f"{BASE_URL}workbenches/assets/{asset_id}/vulnerabilities/"
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        res.raise_for_status()
        return res.json()


    def send_asset_details_request(asset_id: str) -> Dict[str, Any]:
        """Gets asset details using the '{BASE_URL}workbenches/assets/{asset_id}/info' endpoint.

        Args:
            asset_id (string): id of the asset.

        Returns:
            dict: dict containing information on an asset.
        """
        full_url = f"{BASE_URL}workbenches/assets/{asset_id}/info"
        try:
            res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL)
            res.raise_for_status()
        except HTTPError as exc:
            return_error(f'Error calling for url {full_url}: error message {exc}')

        return res.json()


    def send_asset_attributes_request(asset_id: str) -> Dict[str, Any]:
        """Gets asset attributes using the '{BASE_URL}api/v3/assets/{asset_id}/attributes' endpoint.

        Args:
            asset_id (string): id of the asset.

        Returns:
            dict: dict containing information on an asset.
        """
        full_url = f"{BASE_URL}api/v3/assets/{asset_id}/attributes"
        try:
            res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL)
            res.raise_for_status()
        except HTTPError as exc:
            return_error(f'Error calling for url {full_url}: error message {exc}')

        return res.json()


    def get_timestamp(timestamp):
        return time.mktime(timestamp.timetuple())


    def generate_export_uuid(client: Client, last_run):
        """
        Generate a job export uuid in order to fetch vulnerabilities.

        Args:
            client: Client class object.
            first_fetch: time to first fetch from.
            last_run: last run object.
        """
        demisto.info("Getting vulnerabilities export uuid for report.")
        last_found: float = get_timestamp(arg_to_datetime(ASSETS_FETCH_FROM))   # type: ignore

        export_uuid = client.get_vuln_export_uuid(num_assets=CHUNK_SIZE, last_found=last_found)

        demisto.info(f'vulnerabilities export uuid is {export_uuid}')
        last_run.update({'vuln_export_uuid': export_uuid})


    def generate_assets_export_uuid(client: Client, assets_last_run):
        """
        Generate a job export uuid in order to fetch assets.

        Args:
            client: Client class object.
            first_fetch: time to first fetch assets from.
            assets_last_run: assets last run object.

        """

        demisto.info("Getting assets export uuid.")
        fetch_from = round(get_timestamp(arg_to_datetime(ASSETS_FETCH_FROM)))

        export_uuid = client.get_asset_export_uuid(fetch_from=fetch_from)
        demisto.debug(f'assets export uuid is {export_uuid}')

        assets_last_run.update({'assets_export_uuid': export_uuid})


    def handle_assets_chunks(client: Client, assets_last_run):
        """
        Handle assets chunks stored in the last run object.

        Args:
            client: Client class object.
            assets_last_run: assets last run object.

        """
        stored_chunks = assets_last_run.get('assets_available_chunks', [])
        updated_stored_chunks = stored_chunks.copy()
        export_uuid = assets_last_run.get('assets_export_uuid')
        assets = []
        for chunk_id in stored_chunks[:MAX_CHUNKS_PER_FETCH]:
            assets.extend(client.download_assets_chunk(export_uuid=export_uuid, chunk_id=chunk_id))
            updated_stored_chunks.remove(chunk_id)
        if updated_stored_chunks:
            assets_last_run.update({'assets_available_chunks': updated_stored_chunks,
                                    'nextTrigger': '0', "type": 1})
        else:
            assets_last_run.pop('nextTrigger', None)
            assets_last_run.pop('type', None)
            assets_last_run.pop('assets_available_chunks', None)
            assets_last_run.pop('assets_export_uuid', None)
        return assets, assets_last_run


    def get_asset_export_job_status(client: Client, assets_last_run):
        """
        If job has succeeded (status FINISHED) get all information from all chunks available.
        Args:
            client: Client class object.
            assets_last_run: The last run.

        Returns: All information from all chunks available.

        """
        status, chunks_available = client.get_assets_export_status(export_uuid=assets_last_run.get("assets_export_uuid"))
        demisto.info(f'Assets report status is {status}, and number of available chunks is {chunks_available}')
        if status == 'FINISHED':
            assets_last_run.update({'assets_available_chunks': chunks_available})

        return status


    def get_vulnerabilities_chunks(client: Client, export_uuid: str):
        """
        If job has succeeded (status FINISHED) get all information from all chunks available.
        Args:
            client: Client class object.
            export_uuid: The UUID of the vulnerabilities export job.

        Returns: All information from all chunks available.

        """
        vulnerabilities = []
        status, chunks_available = client.get_vuln_export_status(export_uuid=export_uuid)
        demisto.info(f'Report status is {status}, and number of available chunks is {chunks_available}')
        if status == 'FINISHED':
            for chunk_id in chunks_available:
                vulnerabilities.extend(client.download_vulnerabilities_chunk(export_uuid=export_uuid, chunk_id=chunk_id))
        for vuln in vulnerabilities:
            vuln['_time'] = vuln.get('received') or vuln.get('indexed')
        return vulnerabilities, status


    def test_module(client: Client, params):
        if int(params.get('assetsFetchInterval')) < 60:
            return_error("Assets and vulnerabilities fetch Interval is supposed to be 1 hour minimum.")
        client.list_scan_filters()
        return 'ok'


    def relational_date_to_epoch_date_format(date: Optional[str]) -> Optional[int]:
        """ Retrieves date string or relational expression to date YYYY-MM-DD format.
            Example arg is "7 days ago".
            Args:
                date: str - date or relational expression.
            Returns:
                A str in epoch date format or None.
        """
        if date:
            if date.isnumeric():
                return int(date)
            else:
                date_datetime = dateparser.parse(date)  # parser for human readable dates
                if date_datetime:  # dateparser.parse returns datetime representing parsed date if successful, else returns None
                    if date := date_datetime.strftime('%Y-%m-%d'):
                        date_int = (int(time.mktime(datetime.strptime(date, "%Y-%m-%d").timetuple())))
                        return date_int
                else:
                    raise DemistoException('Tenable.io: Date format is invalid')
        return None


    def get_scans_command():
        folder_id = demisto.args().get('folderId'),
        last_modification_date = relational_date_to_epoch_date_format(demisto.getArg('lastModificationDate'))
        response = send_scan_request(folder_id=folder_id, last_modification_date=last_modification_date)
        scan_entries = list(map(get_scan_info, response['scans']))
        valid_scans = [x for x in scan_entries if x is not None]
        invalid_scans = [k for k, v in zip(response['scans'], scan_entries) if v is None]
        res = [get_entry_for_object('Tenable.io - List of Scans', 'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                    replace_keys(valid_scans), GET_SCANS_HEADERS)]
        if invalid_scans:
            res.append(get_entry_for_object('Inactive Web Applications Scans - Renew WAS license to use these scans',
                                            'TenableIO.Scan(val.Id && val.Id === obj.Id)', replace_keys(invalid_scans),
                                            GET_SCANS_HEADERS, remove_null=True))
        return res


    def launch_scan_command():
        scan_id, targets = demisto.getArg('scanId'), demisto.getArg('scanTargets')
        scan_info = send_scan_request(scan_id)['info']
        if not targets:
            targets = scan_info.get('targets', '')
        target_list = argToList(targets)
        body = assign_params(alt_targets=target_list)
        res = send_scan_request(scan_id, 'launch', 'POST', body=body)
        res.update({
            'id': scan_id,
            'targets': targets,
            'status': 'pending'
        })

        return get_entry_for_object('The requested scan was launched successfully',
                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)', replace_keys(res), LAUNCH_SCAN_HEADERS)


    def get_report_command():
        scan_id, info, detailed = demisto.getArg('scanId'), demisto.getArg('info'), demisto.getArg('detailed')
        results = []
        scan_details = send_scan_request(scan_id)
        if info == 'yes':
            scan_details['info']['id'] = scan_id
            scan_details['info'] = replace_keys(scan_details['info'])
            results.append(
                get_entry_for_object('Scan basic info', 'TenableIO.Scan(val.Id && val.Id === obj.Id)', scan_details['info'],
                                     SCAN_REPORT_INFO_HEADERS))

        if 'vulnerabilities' not in scan_details:
            return "No vulnerabilities found."
        vuln_info, vulns_not_found = get_vuln_info(scan_details['vulnerabilities'])
        vuln_info = convert_severity_values(replace_keys(vuln_info))
        results.append(get_entry_for_object('Vulnerabilities', 'TenableIO.Vulnerabilities', vuln_info,
                                            SCAN_REPORT_VULNERABILITIES_HEADERS))
        if len(vulns_not_found) > 0:
            vulns_not_found = replace_keys(vulns_not_found)
            results.append(get_entry_for_object('Vulnerabilities - Missing From Workbench', 'TenableIO.Vulnerabilities',
                                                vulns_not_found, SCAN_REPORT_VULNERABILITIES_HEADERS, True))

        if detailed == 'yes':
            assets = replace_keys(scan_details['hosts'] + scan_details['comphosts'])
            results.append(get_entry_for_object('Assets', 'TenableIO.Assets', assets, SCAN_REPORT_HOSTS_HEADERS))
            if 'remediations' in scan_details and 'remediations' in scan_details['remediations'] and len(
                    scan_details['remediations']['remediations']) > 0:
                remediations = replace_keys(scan_details['remediations']['remediations'], REMEDIATIONS_NAMES_MAP)
                results.append(get_entry_for_object('Remediations', 'TenableIO.Remediations', remediations,
                                                    SCAN_REPORT_REMEDIATIONS_HEADERS))
        return results


    def get_vulnerability_details_command():
        plugin_id, date_range = demisto.getArg('vulnerabilityId'), demisto.getArg('dateRange')
        info = send_vuln_details_request(plugin_id, date_range)
        if 'error' in info:
            return_error(info['error'])
        return get_entry_for_object(f'Vulnerability details - {plugin_id}', 'TenableIO.Vulnerabilities',
                                    convert_severity_values(replace_keys(flatten(info['info']))),
                                    VULNERABILITY_DETAILS_HEADERS)


    def args_to_request_params(hostname, ip, date_range):
        if not hostname and not ip:
            return_error("Please provide one of the following arguments: hostname, ip")

        indicator = hostname if hostname else ip

        params = {
            "filter.0.filter": "host.target",
            "filter.0.quality": "eq",
            "filter.0.value": indicator
        }

        if date_range:
            if not date_range.isdigit():
                return_error(f"Invalid date range: {date_range}")
            else:
                params["date_range"] = date_range

        return params, indicator


    def get_asset_details_command() -> CommandResults:
        """
        tenable-io-get-asset-details: Retrieves details for the specified asset to include custom attributes.

        Args:
            None

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``, that contains asset
            details.
        """
        ip = demisto.getArg('ip')

        if not ip:
            return_error("Please provide an IP address")

        params = {
            "filter.0.filter": "host.target",
            "filter.0.quality": "eq",
            "filter.0.value": ip
        }

        asset_id = get_asset_id(params)
        if not asset_id:
            return CommandResults(readable_output=f'Asset not found: {ip}')

        try:
            info = send_asset_details_request(asset_id)
            attrs = send_asset_attributes_request(asset_id)
            if attrs:
                info["info"]["attributes"] = [
                    {attr.get('name', ''): attr.get('value', '')}
                    for attr in attrs.get("attributes", [])
                ]

        except DemistoException as e:
            return_error(f'Failed to include custom attributes. {e}')

        readable_output = tableToMarkdown(
            f'Asset Info for {ip}', info["info"], headers=["attributes", "fqdn", "interfaces", "ipv4", "id", "last_seen"])
        return CommandResults(
            readable_output=readable_output,
            raw_response=info["info"],
            outputs_prefix='TenableIO.AssetDetails',
            outputs_key_field='id',
            outputs=info["info"]
        )


    def get_vulnerabilities_by_asset_command():
        hostname, ip, date_range = demisto.getArg('hostname'), demisto.getArg('ip'), demisto.getArg('dateRange')
        params, indicator = args_to_request_params(hostname, ip, date_range)

        asset_id = get_asset_id(params)
        if not asset_id:
            return f'No Vulnerabilities for asset {indicator}'

        info = send_asset_vuln_request(asset_id, date_range)
        if 'error' in info:
            return_error(info['error'])

        vulns = convert_severity_values(replace_keys(info['vulnerabilities'], ASSET_VULNS_NAMES_MAP))
        if vulns:
            entry = get_entry_for_object(f'Vulnerabilities for asset {indicator}', 'TenableIO.Vulnerabilities',
                                         vulns, ASSET_VULNS_HEADERS)
            entry['EntryContext']['TenableIO.Assets(val.Hostname === obj.Hostname)'] = {
                'Vulnerabilities': [x['plugin_id'] for x in info['vulnerabilities']],
                'Hostname': indicator
            }
            return entry
        return None


    def get_scan_status_command():
        scan_id = demisto.getArg('scanId')
        scan_details = send_scan_request(scan_id)
        scan_status = {
            'Id': scan_id,
            'Status': scan_details['info']['status']
        }
        return get_entry_for_object(f'Scan status for {scan_id}', 'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                    scan_status)


    def pause_scan_command():
        scan_ids = str(demisto.getArg('scanId')).split(",")

        results = []

        for scan_id in scan_ids:
            scan_id = scan_id.strip()

            scan_details = send_scan_request(scan_id)
            scan_status = {
                'Id': scan_id,
                'Status': scan_details['info']['status']
            }

            if scan_status["Status"].lower() == "running":
                send_scan_request(scan_id, "pause", "POST")
                resumed_scan = {
                    "Id": scan_id,
                    "Status": "Pausing"
                }
                results.append(get_entry_for_object("The requested scan was paused successfully",
                                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                                    replace_keys(resumed_scan), ["Id", "Status"]))

            else:
                results.append(
                    f"Command 'tenable-io-pause-scan' cannot be called while scan status is {scan_status['Status']} for scanID"
                    " {scan_id}")

        return results


    def resume_scan_command():
        scan_ids = str(demisto.getArg('scanId')).split(",")

        results = []

        for scan_id in scan_ids:
            scan_id = scan_id.strip()
            scan_details = send_scan_request(scan_id)
            scan_status = {
                'Id': scan_id,
                'Status': scan_details['info']['status']
            }

            if scan_status["Status"].lower() == "paused":
                send_scan_request(scan_id, "resume", "POST")
                resumed_scan = {
                    "Id": scan_id,
                    "Status": "Resuming"
                }
                results.append(get_entry_for_object("The requested scan was resumed successfully",
                                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                                    replace_keys(resumed_scan), ["Id", "Status"]))

            else:
                results.append(
                    f"Command 'tenable-io-resume-scan' cannot be called while scan status is {scan_status['Status']} for scanID "
                    "{scan_id}")

        return results


    def export_request(request_params: dict, assets_or_vulns: str) -> dict:
        """Gets the UUID of the assets/vulnerabilities export job.

        Args:
            request_params (dict): The request params.
            assets_or_vulns (string): A string represents part of the endpoint according to the requested (assets or vulnerabilities)

        Returns:
            dict: The UUID of the assets export job or raise DemistoException.
        """
        full_url = f'{BASE_URL}{assets_or_vulns}/export'
        res = requests.post(full_url, headers=HEADERS, verify=USE_SSL, json=request_params)
        if res.status_code != 200:
            raise DemistoException(res.text)
        return res.json()


    def export_request_with_export_uuid(export_uuid: str, assets_or_vulns: str) -> dict:
        """Gets status details of the export job.

        Args:
            export_uuid (string): The UUID of the assets/vulnerabilities export job.
            assets_or_vulns (string): A string represents part of the endpoint according to the requested (assets or vulnerabilities)

        Returns:
            dict: Status of the export job or raise DemistoException.
        """
        full_url = f'{BASE_URL}{assets_or_vulns}/export/{export_uuid}/status'
        res = requests.get(full_url, headers=HEADERS, verify=USE_SSL)
        if res.status_code != 200:
            raise DemistoException(res.text)
        return res.json()


    def get_chunks_request(export_uuid: str, chunk_id: str, assets_or_vulns: str) -> dict:
        """Gets chunks of assets or vulnerabilities

        Args:
            export_uuid (string): The UUID of the assets/vulnerabilities export job.
            assets_or_vulns (string): A string represents part of the endpoint according to the
                                      requested data (assets or vulnerabilities)
            chunk_id (string): the id of assets/vulnerabilities the chunk requested to export.
        Returns:
            dict: Status of the export job or raise DemistoException.
        """
        full_url = f'{BASE_URL}{assets_or_vulns}/export/{export_uuid}/chunks/{chunk_id}'
        res = requests.get(full_url, headers=HEADERS, verify=USE_SSL)
        if res.status_code != 200:
            raise DemistoException(res.text)
        return res.json()


    def get_export_chunks_details(export_uuid_status_response: dict, export_uuid: str, assets_or_vulns: str) -> list[Dict]:
        """Gets All chunks of assets or vulnerabilities export.

        Args:
            export_uuid_status_response (dict): The response with the chunks details.
            export_uuid (string): The UUID of the assets/vulnerabilities export job.
            assets_or_vulns (string): A string represents part of
                                      the endpoint according to the requested data (assets or vulnerabilities)
        Returns:
            dict: Status of the export job.
        """
        chunks_list_id = export_uuid_status_response.get('chunks_available')
        chunks_response_list: list = []
        if chunks_list_id:
            for chunk_id in chunks_list_id:
                chunk_response = get_chunks_request(export_uuid, chunk_id, assets_or_vulns)
                chunks_response_list.extend(chunk_response)
        return chunks_response_list


    def export_assets_build_command_result(chunks_details_list: list[dict]) -> CommandResults:
        """Builds command result object from chunks details list

        Args:
            chunks_details_list (list[dict]): a list[dict] of assets details.
        Returns:
            CommandResults: Command Results object with the relevant data.
        """
        headers = ['ASSET ID', 'DNS NAME (FQDN)', 'SYSTEM TYPE', 'OPERATING SYSTEM', 'IPV4 ADDRESS', 'NETWORK',
                   'FIRST SEEN', 'LAST SEEN', 'LAST LICENSED SCAN', 'SOURCE', 'TAGS']
        human_readable = []
        for chunk_details in chunks_details_list:
            human_readable_to_append = {}
            if fqdns := chunk_details.get('fqdns'):
                human_readable_to_append['DNS NAME (FQDN)'] = fqdns[0]
            if (tag := chunk_details.get("tags")) and (first_tag := tag[0]):
                human_readable_to_append['TAGS'] = f'{first_tag.get("key")}:{first_tag.get("value")}'
            if (sources := chunk_details.get("sources")) and (first_source := sources[0]):
                human_readable_to_append['SOURCE'] = first_source.get('name')
            if (
                (network_interfaces := chunk_details.get('network_interfaces'))
                and (first_network_interfaces := network_interfaces[0])
            ):
                human_readable_to_append['IPV4 ADDRESS'] = first_network_interfaces.get('ipv4s')
            human_readable_to_append.update(
                {'ASSET ID': chunk_details.get('id'),
                 'SYSTEM TYPE': chunk_details.get('system_types'),
                 'OPERATING SYSTEM': chunk_details.get('operating_systems'),
                 'NETWORK': chunk_details.get('network_name'),
                 'FIRST SEEN': chunk_details.get('first_seen'),
                 'LAST SEEN': chunk_details.get('last_seen'),
                 'LAST LICENSED SCAN': chunk_details.get('last_licensed_scan_date')}
            )
            remove_nulls_from_dictionary(chunk_details)
            human_readable.append(human_readable_to_append)
        return CommandResults(
            outputs_key_field='id',
            outputs_prefix='TenableIO.Asset',
            outputs=chunks_details_list,
            raw_response=chunks_details_list,
            readable_output=tableToMarkdown('Assets', human_readable, headers=headers, removeNull=True)
        )


    def request_uuid_export_assets(args: Dict[str, Any]) -> PollResult:
        """
        Gets the UUID of the assets export job.

        Args:
            args (Dict[str, Any]): Arguments passed down by the CLI to provide in the HTTP request.

        Returns:
            PollResult: A result to return to the user which will be set as a CommandResults.
        """
        tag_category = args.get('tagCategory')
        tag_value = args.get('tagValue')
        request_params = remove_empty_elements(
            {
                "chunk_size": arg_to_number(args.get("chunkSize")),
                "include_unlicensed": args.get("isLicensed"),
                "filters": {
                    "created_at": relational_date_to_epoch_date_format(
                        args.get("createdAt")
                    ),
                    "updated_at": relational_date_to_epoch_date_format(args.get("updatedAt")),
                    "terminated_at": relational_date_to_epoch_date_format(
                        args.get("terminatedAt")
                    ),
                    "is_terminated": argToBoolean(args.get("isTerminated")) if args.get("isTerminated") else None,
                    "deleted_at": relational_date_to_epoch_date_format(args.get("deletedAt")),
                    "is_deleted": argToBoolean(args.get("isDeleted")) if args.get("isDeleted") else None,
                    "is_licensed": argToBoolean(args.get("isLicensed")) if args.get("isLicensed") else None,
                    "first_scan_time": relational_date_to_epoch_date_format(args.get("firstScanTime")),
                    "last_authenticated_scan_time": relational_date_to_epoch_date_format(args.get("lastAuthenticatedScanTime")),
                    "last_assessed": relational_date_to_epoch_date_format(args.get("lastAssessed")),
                    "servicenow_sysid": argToBoolean(args.get("serviceNowSysId")) if args.get("serviceNowSysId") else None,
                    "sources": argToList(args.get("sources")),
                    "has_plugin_results": argToBoolean(args.get("hasPluginResults")) if args.get("hasPluginResults") else None,
                },
            })
        if tag_category and tag_value:
            if request_params.get('filters'):
                request_params.get('filters')[f'tag.{tag_category}'] = tag_value
            else:
                request_params['filters'] = {f'tag.{tag_category}': tag_value}

        if (tag_category and not tag_value) or (not tag_category and tag_value):
            raise DemistoException('Please specify tagCategory and tagValue')

        demisto.debug("request params export assets", request_params)
        api_response = export_request(request_params, 'assets')
        export_uuid = api_response.get('export_uuid')
        demisto.debug(f'export_uuid: {export_uuid}')
        status = api_response.get('status')
        return PollResult(
            response=None,
            partial_result=CommandResults(
                outputs_prefix="TenableIO.Asset",
                outputs_key_field="id",
                readable_output="Waiting for export assets to finish...",
            ),
            continue_to_poll=True,
            args_for_next_run={"exportUuid": export_uuid, "status": status, **args},
        )


    def build_vpr_score(args: Dict[str, Any]) -> dict:
        """
        Builds the vpr score request body.

        Args:
            args (Dict[str, Any]): Arguments vprScoreOperator, vprScoreRange, vprScoreValue
            passed down by the CLI to provide in the HTTP request.

        Returns:
            dict: vpr score dict.
        """
        if not args.get('vprScoreValue') and args.get('vprScoreOperator'):
            raise DemistoException('Please specify vprScoreValue and vprScoreOperator')
        elif args.get('vprScoreRange') and args.get('vprScoreOperator'):
            raise DemistoException('Please specify only one of vprScoreRange or vprScoreOperator')
        elif args.get('vprScoreValue') and not args.get('vprScoreOperator'):
            raise DemistoException('Please specify vprScoreValue and vprScoreOperator')
        vpr_score_value = args.get('vprScoreValue')
        vpr_score = {}
        if vpr_score_value:
            vpr_score = {'eq': [float(x) for x in argToList(vpr_score_value)] if args.get('vprScoreOperator') == 'equal' else None,
                         'neq': [float(x) for x in argToList(vpr_score_value)]
                         if args.get('vprScoreOperator') == 'not equal' else None,
                         'gt': float(vpr_score_value) if args.get('vprScoreOperator') == 'gt' else None,
                         'lt': float(vpr_score_value) if args.get('vprScoreOperator') == 'lt' else None,
                         'gte': float(vpr_score_value) if args.get('vprScoreOperator') == 'gte' else None,
                         'lte': float(vpr_score_value) if args.get('vprScoreOperator') == 'lte' else None}

        if args.get('vprScoreRange'):
            lower_range_bound, upper_range_bound = validate_range(args.get('vprScoreRange'))
            vpr_score['lte'] = upper_range_bound
            vpr_score['gte'] = lower_range_bound
        return vpr_score


    def request_uuid_export_vulnerabilities(args: Dict[str, Any]) -> PollResult:
        """
        Gets the UUID of the vulnerabilities export job.

        Args:
            args (Dict[str, Any]): Arguments passed down by the CLI to provide in the HTTP request.

        Returns:
            PollResult: A result to return to the user which will be set as a CommandResults.
        """
        tag_category = args.get("tagCategory")
        tag_value = args.get("tagValue")
        request_params = remove_empty_elements(
            {
                'num_assets': arg_to_number(args.get('numAssets')),
                'include_unlicensed': argToBoolean(args.get('includeUnlicensed')) if args.get('includeUnlicensed') else None,
                'filters': {
                    'cidr_range': args.get('cidrRange'),
                    'first_found': relational_date_to_epoch_date_format(args.get('firstFound')),
                    'last_fixed': relational_date_to_epoch_date_format(args.get('lastFixed')),
                    'last_found': relational_date_to_epoch_date_format(args.get('lastFound')),
                    'network_id': args.get('networkId'),
                    'plugin_id': [arg_to_number(x) for x in argToList(args.get('pluginId'))],
                    'plugin_type': args.get('pluginType'),
                    'severity': argToList(args.get('severity')),
                    'since': relational_date_to_epoch_date_format(args.get('since')),
                    'state': argToList(args.get('state')),
                    'vpr_score': build_vpr_score(args),
                }
            }
        )
        if tag_category and tag_value:
            if request_params.get('filters'):
                request_params.get('filters')[f'tag.{tag_category}'] = tag_value
            else:
                request_params['filters'] = {f'tag.{tag_category}': tag_value}

        if (tag_category and not tag_value) or (not tag_category and tag_value):
            raise DemistoException('Please specify tagCategory and tagValue')

        demisto.debug("request params export vulnerabilities", request_params)
        api_response = export_request(request_params, 'vulns')
        export_uuid = api_response.get('export_uuid')
        demisto.debug(f'export_uuid: {export_uuid}')
        return PollResult(
            response=None,
            partial_result=CommandResults(
                outputs_prefix="TenableIO.Vulnerability",
                readable_output="Waiting for export vulnerabilities to finish...",
            ),
            continue_to_poll=True,
            args_for_next_run={"exportUuid": export_uuid, **args},
        )


    @polling_function(name=demisto.command(), timeout=arg_to_number(demisto.args().get('timeout', 720)),
                      interval=arg_to_number(demisto.args().get('intervalInSeconds', 15)),
                      requires_polling_arg=False)
    def export_assets_command(args: Dict[str, Any]) -> PollResult:
        """
        Polling command to export_assets.
        After the first run, progress will be shown through the status QUEUED, PROCESSING, CANCELED, ERROR and FINISHED.
        Export assets command will run till its status is 'FINISHED'.

        Args:
            args (Dict[str, Any]): Arguments passed down by the CLI to provide in the HTTP request.

        Returns:
            PollResult: A result to return to the user which will be set as a CommandResults.
                The result itself will depend on the stage of polling.
        """
        export_uuid = demisto.args().get('exportUuid')
        if export_uuid:
            demisto.debug(f'export_uuid: {export_uuid}')
            export_uuid_status_response = export_request_with_export_uuid(export_uuid, 'assets')
            status = export_uuid_status_response.get('status')
            if status == 'FINISHED':
                chunks_details_list = get_export_chunks_details(export_uuid_status_response, export_uuid, 'assets')
                command_results = export_assets_build_command_result(chunks_details_list)
                return PollResult(command_results)
            elif status in ('PROCESSING', 'QUEUED'):
                return PollResult(
                    response=None,
                    partial_result=CommandResults(
                        outputs_prefix="TenableIO.Asset",
                        outputs_key_field="id",
                        readable_output="Waiting for export assets to finish...",
                    ),
                    continue_to_poll=True,
                    args_for_next_run={"exportUuid": export_uuid, "status": status, **args},
                )
            else:
                return PollResult(
                    response=CommandResults(
                        outputs_key_field='id',
                        outputs_prefix='TenableIO.Asset',
                        readable_output=f'TenableIO: {status}',
                    ),
                    continue_to_poll=False,
                )
        else:
            return request_uuid_export_assets(args)


    def export_vulnerabilities_build_command_result(chunks_details_list: list[dict]) -> CommandResults:
        """Builds command result object from chunks details list

        Args:
            chunks_details_list (list[dict]): a list[dict] of assets details.
        Returns:
            CommandResults: Command Results object with the relevant data.
        """
        headers = ['ASSET ID', 'ASSET NAME', 'IPV4 ADDRESS', 'OPERATING SYSTEM', 'SYSTEM TYPE', 'DNS NAME (FQDN)',
                   'SEVERITY', 'PLUGIN ID', 'PLUGIN NAME', 'VULNERABILITY PRIORITY RATING', 'CVSSV2 BASE SCORE'
                   'CVE', 'PROTOCOL', 'PORT', 'FIRST SEEN', 'LAST SEEN', 'DESCRIPTION', 'SOLUTION']
        human_readable = []
        for chunk_details in chunks_details_list:
            asset_details = chunk_details.get('asset')
            plugin_details = chunk_details.get('plugin')
            port_details = chunk_details.get('port')
            human_readable_to_append = {}
            if asset_details:
                human_readable_to_append.update(
                    {'ASSET ID': asset_details.get('uuid'),
                     'ASSET NAME': asset_details.get('hostname'),
                     'IPV4 ADDRESS': asset_details.get('ipv4'),
                     'OPERATING SYSTEM': asset_details.get('operating_system'),
                     'SYSTEM TYPE': asset_details.get('device_type'),
                     'DNS NAME (FQDN)': asset_details.get('fqdn')}
                )
            if plugin_details:
                human_readable_to_append.update(
                    {'PLUGIN ID': plugin_details.get('id'),
                     'PLUGIN NAME': plugin_details.get('name'),
                     'VULNERABILITY PRIORITY RATING': plugin_details.get("vpr").get("score") if plugin_details.get("vpr") else None,
                     'CVSSV2 BASE SCORE': plugin_details.get('cvss_base_score'),
                     'CVE': plugin_details.get('cve'),
                     'DESCRIPTION': plugin_details.get('description'),
                     'SOLUTION': plugin_details.get('solution')}
                )
            if port_details:
                human_readable_to_append.update(
                    {'PORT': port_details.get('port'),
                     'PROTOCOL': port_details.get('protocol')}
                )
            human_readable_to_append.update(
                {'SEVERITY': chunk_details.get('severity'),
                 'FIRST SEEN': chunk_details.get('first_found'),
                 'LAST SEEN': chunk_details.get('last_found')}
            )

            remove_nulls_from_dictionary(chunk_details)
            human_readable.append(human_readable_to_append)
        return CommandResults(
            outputs_prefix='TenableIO.Vulnerability',
            outputs=chunks_details_list,
            raw_response=chunks_details_list,
            readable_output=tableToMarkdown('Vulnerabilities', human_readable, headers=headers, removeNull=True)
        )


    def validate_range(range: Optional[str]) -> tuple[Optional[float], Optional[float]]:
        """
        Validates the vprScoreRange argument for export asset command
        Args:
            range (str): A str represents a range for example 3-5.
        Returns:
            Range if valid else raise DemistoException.
        """
        if range:
            nums = tuple(map(float, range.split("-")))
            if len(nums) != 2 or not 0.1 <= nums[0] <= nums[1] <= 10.0:
                raise DemistoException('Please specify a valid vprScoreRange. The VPR values range is 0.1-10.0.')
            return nums  # type: ignore
        return None, None


    @polling_function(name=demisto.command(), timeout=arg_to_number(demisto.args().get('timeout', 600)),
                      interval=arg_to_number(demisto.args().get('intervalInSeconds', 10)),
                      requires_polling_arg=False)
    def export_vulnerabilities_command(args: Dict[str, Any]) -> PollResult:
        """
        Polling command to export vulnerabilities.
        After the first run, progress will be shown through the status QUEUED, PROCESSING, CANCELED, ERROR and FINISHED.
        Export vulnerabilities command will run till its status is 'FINISHED' and all the data chunks are exoprted.

        Args:
            args (Dict[str, Any]): Arguments passed down by the CLI to provide in the HTTP request.

        Returns:
            PollResult: A result to return to the user which will be set as a CommandResults.
                The result itself will depend on the stage of polling.
        """
        export_uuid = demisto.args().get('exportUuid')
        if export_uuid:
            demisto.debug(f'export_uuid: {export_uuid}')
            export_uuid_status_response = export_request_with_export_uuid(export_uuid, 'vulns')
            status = export_uuid_status_response.get('status')
            if status == 'FINISHED':
                chunks_details_list = get_export_chunks_details(export_uuid_status_response, export_uuid, 'vulns')
                command_results = export_vulnerabilities_build_command_result(chunks_details_list)
                return PollResult(command_results)
            elif status in ('PROCESSING', 'QUEUED'):
                return PollResult(
                    response=None,
                    partial_result=CommandResults(
                        outputs_prefix="TenableIO.Vulnerability",
                        readable_output="Waiting for export vulnerabilities to finish...",
                    ),
                    continue_to_poll=True,
                    args_for_next_run={"exportUuid": export_uuid, "status": status, **args},
                )
            else:
                return PollResult(
                    response=CommandResults(
                        outputs_prefix='TenableIO.Vulnerability',
                        readable_output=f'TenableIO: {status}',
                    ),
                    continue_to_poll=False,
                )
        else:
            return request_uuid_export_vulnerabilities(args)


    def scan_filters_human_readable(filters: list) -> str:
        context_to_hr = {
            'name': 'Filter name',
            'readable_name': 'Filter Readable name',
            'type': 'Filter Control type',
            'regex': 'Filter regex',
            'readable_regex': 'Readable regex',
            'operators': 'Filter operators',
            'group_name': 'Filter group name',
        }
        return tableToMarkdown(
            'Tenable IO Scan Filters',
            [d | d.get('control', {}) for d in filters],
            headers=list(context_to_hr),
            headerTransform=context_to_hr.get,
            removeNull=True)


    def list_scan_filters_command(client: Client) -> CommandResults:

        response_dict = client.list_scan_filters()
        filters = response_dict.get('filters', [])

        return CommandResults(
            outputs_prefix='TenableIO.ScanFilter',
            outputs_key_field='name',
            outputs=filters,
            readable_output=scan_filters_human_readable(filters),
            raw_response=response_dict)


    def scan_history_readable(history: list) -> str:
        context_to_hr = {
            'id': 'History id',
            'scan_uuid': 'History uuid',
            'status': 'Status',
            'is_archived': 'Is archived',
            'custom': 'Targets custom',
            'default': 'Targets default',
            'visibility': 'Visibility',
            'time_start': 'Time start',
            'time_end': 'Time end',
        }
        return tableToMarkdown(
            'Tenable IO Scan History',
            [d | d.get('targets', {}) for d in history],
            headers=list(context_to_hr),
            headerTransform=context_to_hr.get,
            removeNull=True)


    def scan_history_pagination_params(args: dict) -> dict:
        '''
        Generate pagination parameters for scanning history based on the given arguments.

        This function calculates the 'limit' and 'offset' parameters for pagination
        based on the provided 'page' and 'pageSize' arguments. If 'page' and 'pageSize'
        are valid integer values, the function returns a dictionary containing 'limit'
        and 'offset' calculated accordingly. If 'page' or 'pageSize' are not valid integers,
        the function falls back to using the 'limit' argument or defaults to 50 with an
        'offset' of 0.

        Args:
            args (dict): The demisto.args() dictionary containing the optional arguments for pagination: 'page', 'pageSize', 'limit'.

        Returns:
            dict: A dictionary containing the calculated 'limit' and 'offset' parameters
                  for pagination.
        '''
        page = arg_to_number(args.get('page'))
        page_size = arg_to_number(args.get('pageSize'))
        if isinstance(page, int) and isinstance(page_size, int):
            return {
                'limit': page_size,
                'offset': (page - 1) * page_size
            }

        else:
            return {
                'limit': args.get('limit', 50),
                'offset': 0
            }


    def scan_history_params(args: dict) -> dict:
        sort_fields = argToList(args.get('sortFields'))
        sort_order = argToList(args.get('sortOrder'))

        if len(sort_order) == 1:
            sort_order *= len(sort_fields)

        return {
            'sort': ','.join(
                f'{field}:{order}'
                for field, order
                in zip(sort_fields, sort_order)),
            'exclude_rollover': args['excludeRollover'],
        } | scan_history_pagination_params(args)


    def get_scan_history_command(args: dict[str, Any], client: Client) -> CommandResults:

        response_json = client.get_scan_history(
            args['scanId'],
            scan_history_params(args))
        history = response_json.get('history', '')

        return CommandResults(
            outputs_prefix='TenableIO.ScanHistory',
            outputs_key_field='id',
            outputs=history,
            readable_output=scan_history_readable(history))


    def build_filters(filters) -> dict:
        """
        Build a dictionary of filter information from a filters string.

        Args:
            filters (str, optional): A string containing filters in the format "name quality value" separated by commas.
                                     Escaped commas (\\,) and spaces (\\s) are treated as literal characters.
                                     Defaults to None.

        Returns:
            dict: A dictionary where keys are in the format 'filter.i.filter', 'filter.i.quality', and 'filter.i.value',
                  and values correspond to the name, quality, and value of each filter component.

        Example:
            filters = "name1 good value1\\,with\\,commas, name2\\swith\\sspaces excellent value2"
            result = build_filters(filters)
            # Output:
            # {
            #     'filter.0.filter': 'name1',
            #     'filter.0.quality': 'good',
            #     'filter.0.value': 'value1,with,commas',
            #     'filter.1.filter': 'name2 with spaces',
            #     'filter.1.quality': 'excellent',
            #     'filter.1.value': 'value2'
            # }
        """
        if not filters:
            return {}

        # split by comma without escaped commas
        split_filters = re.split(r'(?<!\\),', filters)
        # remove delimiters and split into name, quality and value
        filters = (f.replace('\\,', ',').split() for f in split_filters)

        result: dict = {}
        for i, (name, quality, value) in enumerate(filters):
            result |= {
                f'filter.{i}.filter': re.sub(r'(?<!\\)\\s', ' ', name),
                f'filter.{i}.quality': re.sub(r'(?<!\\)\\s', ' ', quality),
                f'filter.{i}.value': re.sub(r'(?<!\\)\\s', ' ', value)
            }

        return result


    def export_scan_body(args: dict) -> dict:

        if chapters := args.get('chapters'):
            chapters = ';'.join(argToList(chapters))
        elif args['format'] in ('PDF', 'HTML'):
            raise DemistoException('The "chapters" field must be provided for PDF or HTML formats.')

        body = {
            'format': args['format'].lower(),
            'chapters': chapters,
            'filter.search_type': args['filterSearchType'].lower(),
            'asset_id': args.get('assetId'),
        } | build_filters(args.get('filter'))

        return body


    def initiate_export_scan(args: dict, client: Client) -> str:
        return client.initiate_export_scan(
            args['scanId'],
            params={
                'history_id': args.get('historyId'),
                'history_uuid': args.get('historyUuid')
            },
            body=export_scan_body(args)
        ).get('file', '')


    @polling_function(
        'tenable-io-export-scan',
        poll_message='Preparing scan report:',
        interval=15,
        requires_polling_arg=False)
    def export_scan_command(args: dict[str, Any], client: Client) -> PollResult:
        '''
        Calls three endpoints. The first (called with initiate_export_scan) initiates an export and returns a file ID.
        The second (called with client.check_export_scan_status) checks the status of the export and the function polls
        until the status is 'ready'. The third endpoint is then called (with client.download_export_scan) which downloads
        the file and returns a dict with it's contents (using fileResult).
        '''

        scan_id = args['scanId']
        file_id = (
            args.get('fileId')
            or initiate_export_scan(args, client))
        demisto.debug(f'{file_id=}')

        status_response = client.check_export_scan_status(scan_id, file_id)
        demisto.debug(f'{status_response=}')

        match status_response.get('status'):
            case 'ready':
                return PollResult(
                    client.download_export_scan(
                        scan_id, file_id, args['format']),
                    continue_to_poll=False)

            case 'loading':
                return PollResult(
                    None,
                    continue_to_poll=True,
                    args_for_next_run={
                        'fileId': file_id,
                        'scanId': scan_id,
                        'format': args['format'],  # not necessary but avoids confusion
                    })

            case _:
                raise DemistoException(
                    'Tenable IO encountered an error while exporting the scan report file.\n'
                    f'Scan ID: {scan_id}\n'
                    f'File ID: {file_id}\n')


    def get_audit_logs_command(client: Client, from_date: Optional[str] = None, to_date: Optional[str] = None,
                               actor_id: Optional[str] = None, target_id: Optional[str] = None,
                               limit: Optional[int] = None):
        """

        Args:
            client: Client class object.
            from_date: date to fetch audit logs from.
            to_date: date which until to fetch audit logs.
            actor_id: fetch audit logs with matching actor id.
            target_id:fetch audit logs with matching target id.
            limit: limit number of audit logs to get.

        Returns: CommandResults of audit logs from API.

        """
        audit_logs = client.get_audit_logs_request(from_date=from_date,
                                                   to_date=to_date,
                                                   actor_id=actor_id,
                                                   target_id=target_id,
                                                   limit=limit)

        readable_output = tableToMarkdown('Audit Logs List:', audit_logs,
                                          removeNull=True,
                                          headerTransform=string_to_table_header)

        results = CommandResults(readable_output=readable_output,
                                 raw_response=audit_logs)
        return results, audit_logs


    ''' FETCH COMMANDS '''


    def fetch_events_command(client: Client, first_fetch: datetime, last_run: dict, limit: int = 1000):
        """
        Fetches audit logs.
        Args:
            client: Client class object.
            first_fetch: time to first fetch from.
            last_run: last run object.
            limit: number of audit logs to max fetch.

        Returns: vulnerabilities, audit logs and updated last run object

        """

        last_fetch = last_run.get('last_fetch_time')
        last_index_fetched = last_run.get('index_audit_logs', 0)
        if not last_fetch:
            start_date = first_fetch.strftime(DATE_FORMAT)
        else:
            start_date = last_fetch  # type: ignore

        audit_logs: List[dict] = []
        audit_logs_from_api = client.get_audit_logs_request(from_date=start_date)
        demisto.debug(f"got {len(audit_logs_from_api)} events from api")

        if last_index_fetched < len(audit_logs_from_api):
            audit_logs.extend(audit_logs_from_api[last_index_fetched:last_index_fetched + limit])

        for audit_log in audit_logs:
            audit_log['_time'] = audit_log.get('received') or audit_log.get('indexed')

        next_run: str = datetime.now(tz=timezone.utc).strftime(DATE_FORMAT)
        last_run.update({'index_audit_logs': len(audit_logs) + last_index_fetched if audit_logs else last_index_fetched,
                         'last_fetch_time': next_run})
        demisto.info(f'Done fetching {len(audit_logs)} audit logs, Setting {last_run=}.')
        return audit_logs, last_run


    def fetch_assets_command(client: Client, assets_last_run):
        """
        Fetches assets.
        Args:
            assets_last_run: last run object.
            client: Client class object.

        Returns:
            assets fetched from the API.
        """
        assets = []
        # if already in assets_last_run meaning its still polling chunks from api
        export_uuid = assets_last_run.get('assets_export_uuid')
        # if exists, still downloading chunks from prev fetch call
        available_chunks = assets_last_run.get('assets_available_chunks', [])
        if available_chunks:
            assets, assets_last_run = handle_assets_chunks(client, assets_last_run)
        elif export_uuid:
            status = get_asset_export_job_status(client=client, assets_last_run=assets_last_run)

            if status in ['PROCESSING', 'QUEUED']:
                assets_last_run.update({'nextTrigger': '30', "type": 1})
            # set params for next run
            if status == 'FINISHED':
                assets, assets_last_run = handle_assets_chunks(client, assets_last_run)
            elif status in ['CANCELLED', 'ERROR']:
                export_uuid = client.get_asset_export_uuid(fetch_from=round(get_timestamp(arg_to_datetime(ASSETS_FETCH_FROM))))
                assets_last_run.update({'assets_export_uuid': export_uuid})
                assets_last_run.update({'nextTrigger': '30', "type": 1})

        demisto.info(f'Done fetching {len(assets)} assets, {assets_last_run=}.')
        return assets


    def run_assets_fetch(client, last_run):

        demisto.info("fetch assets from the API")
        # starting new fetch for assets, not polling from prev call
        if not last_run.get('assets_export_uuid'):
            generate_assets_export_uuid(client, last_run)

        return fetch_assets_command(client, last_run)


    def fetch_vulnerabilities(client: Client, last_run: dict):
        """
        Fetches vulnerabilities if job has succeeded.
        Args:
            last_run: last run object.
            client: Client class object.

        Returns:
            Vulnerabilities fetched from the API.
        """
        vulnerabilities = []
        export_uuid = last_run.get('vuln_export_uuid')
        if export_uuid:
            demisto.info(f'Got export uuid from API {export_uuid}')
            vulnerabilities, status = get_vulnerabilities_chunks(client=client, export_uuid=export_uuid)
            if status in ['PROCESSING', 'QUEUED']:
                last_run.update({'nextTrigger': '30', "type": 1})
            # set params for next run
            if status == 'FINISHED':
                last_run.pop('vuln_export_uuid', None)
                if not last_run.get('assets_export_uuid'):
                    last_run.pop('nextTrigger', None)
                    last_run.pop('type', None)
            elif status in ['CANCELLED', 'ERROR']:
                export_uuid = client.get_vuln_export_uuid(num_assets=CHUNK_SIZE,
                                                          last_found=get_timestamp(arg_to_datetime(ASSETS_FETCH_FROM)))
                last_run.update({'vuln_export_uuid': export_uuid})

        demisto.info(f'Done fetching {len(vulnerabilities)} vulnerabilities, {last_run=}.')
        return vulnerabilities


    def run_vulnerabilities_fetch(client, last_run):

        demisto.info("fetch vulnerabilies from the API")
        if not last_run.get('vuln_export_uuid'):
            generate_export_uuid(client, last_run)

        return fetch_vulnerabilities(client, last_run)


    def skip_fetch_assets(last_run):
        time_to_check = last_run.get("assets_last_fetch")
        if not time_to_check:
            return False
        passed_time = (time.time() - time_to_check) / 60
        to_skip = not last_run.get('nextTrigger') and (passed_time < MIN_ASSETS_INTERVAL)
        if to_skip:
            demisto.info(f"Skipping fetch-assets command. Only {passed_time} minutes have passed since the last fetch. "
                         f"It should be a minimum of 1 hour.")
        return to_skip


    def main():  # pragma: no cover
        """main function, parses params and runs command functions
        """
        args = demisto.args()
        command = demisto.command()
        params = demisto.params()

        access_key = params.get('credentials_access_key', {}).get('password') or params.get('access-key')
        secret_key = params.get('credentials_secret_key', {}).get('password') or params.get('secret-key')
        url = params.get('url')
        verify_certificate = not params.get('unsecure', False)
        proxy = params.get('proxy', False)

        # Events Params
        max_fetch = arg_to_number(params.get('max_fetch')) or 1000
        first_fetch: datetime = arg_to_datetime(params.get('first_fetch', '3 days'))  # type: ignore

        demisto.debug(f'Command being called is {command}')
        try:
            headers = {'X-ApiKeys': f'accessKey={access_key}; secretKey={secret_key}',
                       "Accept": "application/json"}
            client = Client(
                base_url=url,
                verify=verify_certificate,
                headers=headers,
                proxy=proxy)

            if command == 'test-module':
                demisto.results(test_module(client, params))
            elif command == 'tenable-io-list-scans':
                demisto.results(get_scans_command())
            elif command == 'tenable-io-launch-scan':
                demisto.results(launch_scan_command())
            elif command == 'tenable-io-get-scan-report':
                demisto.results(get_report_command())
            elif command == 'tenable-io-get-vulnerability-details':
                demisto.results(get_vulnerability_details_command())
            elif command == 'tenable-io-get-vulnerabilities-by-asset':
                demisto.results(get_vulnerabilities_by_asset_command())
            elif command == 'tenable-io-get-scan-status':
                demisto.results(get_scan_status_command())
            elif command == 'tenable-io-pause-scan':
                demisto.results(pause_scan_command())
            elif command == 'tenable-io-resume-scan':
                demisto.results(resume_scan_command())
            elif command == 'tenable-io-get-asset-details':
                return_results(get_asset_details_command())
            elif command == 'tenable-io-export-assets':
                return_results(export_assets_command(args))
            elif command == 'tenable-io-export-vulnerabilities':
                vulnerabilities: list = []
                results = export_vulnerabilities_command(args)
                if isinstance(results, CommandResults):
                    if results.raw_response:
                        vulnerabilities = results.raw_response  # type: ignore
                return_results(results)
                if argToBoolean(args.get('should_push_events', 'false')) and is_xsiam():
                    send_data_to_xsiam(vulnerabilities, product=f'{PRODUCT}_vulnerabilities', vendor=VENDOR)

            elif command == 'tenable-io-list-scan-filters':
                return_results(list_scan_filters_command(client))
            elif command == 'tenable-io-get-scan-history':
                return_results(get_scan_history_command(args, client))
            elif command == 'tenable-io-export-scan':
                return_results(export_scan_command(args, client))
            elif command == 'tenable-io-get-audit-logs':
                results, events = get_audit_logs_command(client,
                                                         from_date=args.get('from_date'),
                                                         to_date=args.get('to_date'),
                                                         actor_id=args.get('actor_id'),
                                                         target_id=args.get('target_id'),
                                                         limit=args.get('limit'))
                return_results(results)

                if argToBoolean(args.get('should_push_events', 'false')) and is_xsiam():
                    send_data_to_xsiam(events, vendor=VENDOR, product=PRODUCT)
            # Fetch Commands
            elif command == 'fetch-events':

                last_run = demisto.getLastRun()
                demisto.debug(f"saved lastrun events: {last_run}")
                events, new_last_run = fetch_events_command(client, first_fetch, last_run, max_fetch)
                send_data_to_xsiam(events, vendor=VENDOR, product=PRODUCT)
                demisto.debug(f"new lastrun events: {last_run}")
                demisto.setLastRun(new_last_run)

            elif command == 'fetch-assets':
                assets = []
                vulnerabilities = []
                assets_last_run = demisto.getAssetsLastRun()
                demisto.debug(f"saved lastrun assets: {assets_last_run}")
                assets_last_run_copy = assets_last_run.copy()
                if skip_fetch_assets(assets_last_run):
                    return
                elif not assets_last_run.get("nextTrigger"):
                    # starting a whole new fetch process for assets
                    assets_last_run.update({"assets_last_fetch": time.time()})
                # Fetch Assets (no nextTrigger -> new fetch, or assets_export_uuid -> continue prev fetch)
                if assets_last_run_copy.get('assets_export_uuid') or not assets_last_run_copy.get('nextTrigger'):
                    assets = run_assets_fetch(client, assets_last_run)

                # Fetch Vulnerabilities
                if assets_last_run_copy.get('vuln_export_uuid') or not assets_last_run_copy.get('nextTrigger'):
                    vulnerabilities = run_vulnerabilities_fetch(client, last_run=assets_last_run)

                demisto.info(f"Sending {len(assets)} assets and {len(vulnerabilities)} vulnerabilities to XSIAM.")

                send_data_to_xsiam(data=assets, vendor=VENDOR, product=f'{PRODUCT}_assets', data_type='assets')
                send_data_to_xsiam(data=vulnerabilities, vendor=VENDOR, product=f'{PRODUCT}_vulnerabilities')

                demisto.info("Done Sending data to XSIAM.")

                demisto.debug(f"new lastrun assets: {assets_last_run}")
                demisto.setAssetsLastRun(assets_last_run)

        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Tenable.io', 'end', __line__())
  subtype: python3
  type: python
system: true
