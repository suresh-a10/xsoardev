category: Vulnerability Management
commonfields:
  id: Cortex Xpanse
  version: -1
configuration:
- additionalinfo: The web UI with `api-` appended to front (e.g., https://api-xsiam.paloaltonetworks.com).
    For more information, see https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-api/cortex-xdr-api-overview/get-started-with-cortex-xdr-apis.
  display: Server URL
  name: url
  required: true
  section: Connect
  type: 0
- additionalinfo: For more information, see https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-api/cortex-xdr-api-overview/get-started-with-cortex-xdr-apis.  Only
    standard API key type is supported.
  display: API Key ID
  displaypassword: API Key
  name: credentials
  required: true
  section: Connect
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Connect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  section: Collect
  type: 19
- display: Incident type
  name: incidentType
  required: false
  section: Collect
  type: 13
- additionalinfo: The maximum number of alerts per fetch. Cannot exceed 100.
  defaultvalue: "10"
  display: Maximum number of alerts per fetch
  name: max_fetch
  required: false
  section: Collect
  type: 0
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  required: false
  section: Collect
  type: 0
- additionalinfo: 'The severity of the alerts that will be fetched. If no severity
    is provided then alerts of all the severities will be fetched. Note: An alert
    whose status was changed to a filtered status after its creation time will not
    be fetched.'
  display: Alert Severities to Fetch
  name: severity
  options:
  - low
  - medium
  - high
  - critical
  - informational
  required: false
  section: Collect
  type: 16
- additionalinfo: 'The statuses of the alerts that will be fetched. If no status is
    provided then alerts of all the statuses will be fetched. Note: An alert whose
    status was changed to a filtered status after its creation time will not be fetched.'
  display: Alert Statuses to fetch
  name: status
  options:
  - new
  - reopened
  - under_investigation
  - resolved_no_longer_observed
  - resolved_no_risk
  - resolved_risk_accepted
  - resolved_contested_asset
  - resolved_remediated_automatically
  - resolved
  required: false
  section: Collect
  type: 16
- additionalinfo: The tags of the alerts that will be fetched. If no tags are provided
    then no tag filtering will be applied on fetched alerts. These should include
    the tag prefix, ex. AT:Asset Tag.
  display: Fetch alerts with tags (comma separated string)
  name: tags
  required: false
  section: Collect
  type: 0
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: A+ - 3rd party enrichment
  display: Source Reliability
  name: integration_reliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  section: Collect
  type: 15
- additionalinfo: Maximum amount of search results for listing commands.
  defaultvalue: "100"
  display: Search Limit
  name: search_limit
  required: false
  section: Collect
  type: 0
- additionalinfo: Use this parameter to determine how far back in time to look in
    the search for incidents that were created before the last run time and did not
    match the query when they were created.
  defaultvalue: "0"
  display: 'Advanced: Minutes to look back when fetching (Warning: exceeding 720 could
    lead to issues with fetching)'
  name: look_back
  required: false
  section: Collect
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.5.0
    itemVersion: 1.2.5
    packID: CortexXpanse
    packName: Cortex Xpanse
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: Xpanse - Classifier
defaultmapperin: Xpanse - Incoming Mapper
description: Integration to pull assets and other ASM related information.
detaileddescription: "## Configure Cortex Xpanse\n\n1. Navigate to **Settings** >
  **Integrations** > **Servers & Services**.\n2. Search for Cortex Xpanse.\n3. Click
  **Add instance** to create and configure a new integration instance.\n\n    | **Parameter**
  | **Description** | **Required** |\n    | --- | --- | --- |\n     Server URL | The
  web UI with \\`api-\\` appended to front (e.g., https://api-xsiam.paloaltonetworks.com).
  For more information, see [get-started-with-cortex-xdr-apis](https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-api/cortex-xdr-api-overview/get-started-with-cortex-xdr-apis).
  | True \n     API Key ID | See [get-started-with-cortex-xdr-apis](https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-api/cortex-xdr-api-overview/get-started-with-cortex-xdr-apis).
  | True \n     API Key | See [get-started-with-cortex-xdr-apis](https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-api/cortex-xdr-api-overview/get-started-with-cortex-xdr-apis).
  \ **Only standard API key type is supported**. | True \n    \n4. Click **Test**
  to validate the URLs, token, and connection.\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/cortex-xpanse)"
display: Cortex Xpanse
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsSAAALEgHS3X78AAAD6klEQVR4nO2cS24bMQyGyaL75AbJCeo5QIH6BnVPkOkN3BPER8gN4tzA3XQbB+gBHHTbRbzq1kH3ZaGA4ygUNaPxxBOA4AcIqPWgHv9QosZOkYjAscs719Y2LrBxXGDjuMDGcYGN4wIbxwU2jgtsHBfYOC6wcVxg47jAxnGBjeMCG+f9W04PEacAENIDES2TCs7wNR77+2BEPAeABQBcRNl3RDRNKjuDGdWDEbEGgCsAOEkKnaPQW2BErHhbPY2ydwCwJqJN0uCluNdJQf/+Q79VUiAgonWS+WyjEuMvIRwjDwPs7OL14eMpJrGfm2+YGyLOAeAPAPwloh9Jb1HlogQAQaAwAGpJD5otfiC0dksuW/LnYH+u2SiwpaVg91SxsVbqdqXFQDtr0bYW5cFJKlEniLsR9eZc9hsA/gHAL22d9ja0TKWT4olkbMgHYxNPhs9kWZ4Ic4DAT7YUG28ucMm8owd/7xBR2UdOH7R1alLJFh06+STybnhyQbhz3kJmAHCmbDG1yH8MdbXtKGICACsWs4tvvDDNw1ixdzR9TsJ2KLbsJY8/5jL6951Snt3ymS3bzZHMl4gWHHQ2Aed+3ogoA9EbIqqjtj8z/SSdZBMvVvwEPQnaUn+m5MmnUPME+SQ3aarUlR5cUifpU2nTq77iwYmH9jj+5BrJneFg210ePBOf6zbPI6JVkpl64VVSI8+swHM0kgBGqfPanLPXSTrv+MEzOWCbcFa8Y94rOhTTK4pui0xbeLFtE9EuXzWhM1oODwwixjYrcQ175G3v2JyJbb7hrmPrbpjyUSOPs2nPNXtBL4FDyD6ksyMxaTE7eIFGRIthTnjHqw8dRte7aLkw86RGN9u4BgcVpWTv1RH37CVbkf+d44USG69BeBuHSuoMFDveEVxw+UF0CbxkL2i4DOcMX77jAZ6GQSCidtbJbb3PYEu21jkvYsViN3wecnaNBSLOhLhhvb+Idb8+WGQt8hIRnryQxxH1Wl7EC9vLC70WRa8y48lG0XxN2rX1lUuvEEUfcg+uxHj3LzuUMuIgNxlHW2otFCLJztSUaS9fdOyEMFLgdY8XHdPSRWtLYwusjDN5GBXnKJpLn2tS4+VLRFxxhzMlUt3yZHNRdmh3G30ObW8RsYkwm3M5bLFXHdeKHZ+58ed4rBt+zxtfxxYF23VsUztqNPqc77LuQuQtZbzA6w7iWAtHZF0aOI72dWFHIOFfFx6J0X7RwV75VQQPjhWB4Vnkit9lOyPwpn/h7z/ZOT7+XzgYx39VaRwX2DgusHFcYOO4wMZxgY3jAhvHBTaOC2wcF9g4LrBxXGDjuMDGcYEtAwD/AbjPSozwVJX9AAAAAElFTkSuQmCC
name: Cortex Xpanse
script:
  commands:
  - arguments:
    - description: IP address on which to search.
      name: ip_address
    - description: Domain on which to search.
      name: domain
    - auto: PREDEFINED
      description: Whether the service is active.
      name: is_active
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      description: How service was discovered.
      name: discovery_type
      predefined:
      - colocated_on_ip
      - directly_discovery
      - unknown
    description: Get a list of all your external services filtered by business units,
      externally detected providers, domain, externally inferred CVEs, active classifications,
      inactive classifications, service name, service type, protocol, IP address,
      is active, and discovery type. Maximum result limit is 100 assets.
    name: asm-list-external-service
    outputs:
    - contextPath: ASM.ExternalService.service_id
      description: External service UUID.
      type: String
    - contextPath: ASM.ExternalService.service_name
      description: Name of the external service.
      type: String
    - contextPath: ASM.ExternalService.service_type
      description: Type of the external service.
      type: String
    - contextPath: ASM.ExternalService.ip_address
      description: IP address of the external service.
      type: String
    - contextPath: ASM.ExternalService.externally_detected_providers
      description: Providers of external service.
      type: String
    - contextPath: ASM.ExternalService.is_active
      description: Whether the external service is active.
      type: String
    - contextPath: ASM.ExternalService.first_observed
      description: Date of the first observation of the external service.
      type: Date
    - contextPath: ASM.ExternalService.last_observed
      description: Date of the last observation of the external service.
      type: Date
    - contextPath: ASM.ExternalService.port
      description: Port number of the external service.
      type: Number
    - contextPath: ASM.ExternalService.protocol
      description: Protocol number of the external service.
      type: String
    - contextPath: ASM.ExternalService.inactive_classifications
      description: External service classifications that are no longer active.
      type: String
    - contextPath: ASM.ExternalService.discovery_type
      description: How the external service was discovered.
      type: String
    - contextPath: ASM.ExternalService.business_units
      description: External service associated business units.
      type: String
    - contextPath: ASM.ExternalService.externally_inferred_vulnerability_score
      description: External service vulnerability score.
      type: Unknown
  - arguments:
    - description: A string representing the service ID you want to get details for.
      name: service_id
      required: true
    description: Get service details according to the service ID.
    name: asm-get-external-service
    outputs:
    - contextPath: ASM.ExternalService.service_id
      description: External service UUID.
      type: String
    - contextPath: ASM.ExternalService.service_name
      description: Name of the external service.
      type: String
    - contextPath: ASM.ExternalService.service_type
      description: Type of the external service.
      type: String
    - contextPath: ASM.ExternalService.ip_address
      description: IP address of the external service.
      type: String
    - contextPath: ASM.ExternalService.externally_detected_providers
      description: Providers of the external service.
      type: String
    - contextPath: ASM.ExternalService.is_active
      description: Whether the external service is active.
      type: String
    - contextPath: ASM.ExternalService.first_observed
      description: Date of the first observation of the external service.
      type: Date
    - contextPath: ASM.ExternalService.last_observed
      description: Date of the last observation of the external service.
      type: Date
    - contextPath: ASM.ExternalService.port
      description: Port number of the external service.
      type: Number
    - contextPath: ASM.ExternalService.protocol
      description: Protocol of the external service.
      type: String
    - contextPath: ASM.ExternalService.inactive_classifications
      description: External service classifications that are no longer active.
      type: String
    - contextPath: ASM.ExternalService.discovery_type
      description: How the external service was discovered.
      type: String
    - contextPath: ASM.ExternalService.business_units
      description: External service associated business units.
      type: String
    - contextPath: ASM.ExternalService.externally_inferred_vulnerability_score
      description: External service vulnerability score.
      type: Unknown
    - contextPath: ASM.ExternalService.details
      description: Additional details.
      type: String
  - arguments: []
    description: Get a list of all your internet exposures filtered by business units
      and organization handles. Maximum result limit is 100 ranges.
    name: asm-list-external-ip-address-range
    outputs:
    - contextPath: ASM.ExternalIpAddressRange.range_id
      description: External IP address range UUID.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.first_ip
      description: First IP address of the external IP address range.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.last_ip
      description: Last IP address of the external IP address range.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.ips_count
      description: Number of IP addresses of the external IP address range.
      type: Number
    - contextPath: ASM.ExternalIpAddressRange.active_responsive_ips_count
      description: The number of IPs in the external address range that are actively
        responsive.
      type: Number
    - contextPath: ASM.ExternalIpAddressRange.date_added
      description: Date the external IP address range was added.
      type: Date
    - contextPath: ASM.ExternalIpAddressRange.business_units
      description: External IP address range associated business units.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.organization_handles
      description: External IP address range associated organization handles.
      type: String
  - arguments:
    - description: A string representing the range ID for which you want to get the
        details.
      name: range_id
      required: true
    description: Get the external IP address range details according to the range
      IDs.
    name: asm-get-external-ip-address-range
    outputs:
    - contextPath: ASM.ExternalIpAddressRange.range_id
      description: External IP address range UUID.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.first_ip
      description: First IP address of the external IP address range.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.last_ip
      description: Last IP address of the external IP address range.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.ips_count
      description: Number of IP addresses of the external IP address range.
      type: Number
    - contextPath: ASM.ExternalIpAddressRange.active_responsive_ips_count
      description: The number of IPs in the external address range that are actively
        responsive.
      type: Number
    - contextPath: ASM.ExternalIpAddressRange.date_added
      description: Date the external IP address range was added.
      type: Date
    - contextPath: ASM.ExternalIpAddressRange.business_units
      description: External IP address range associated business units.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.organization_handles
      description: External IP address range associated organization handles.
      type: String
    - contextPath: ASM.ExternalIpAddressRange.details
      description: Additional information.
      type: String
  - arguments:
    - description: IP address on which to search.
      name: ip_address
    - description: Name of the asset on which to search.
      name: name
    - auto: PREDEFINED
      description: Type of the external service.
      name: type
      predefined:
      - certificate
      - cloud_compute_instance
      - on_prem
      - domain
      - unassociated_responsive_ip
    - auto: PREDEFINED
      description: Whether the internet exposure has an active external service.
      name: has_active_external_services
      predefined:
      - "yes"
      - "no"
    - description: Represents the start offset index of results. Default is 0.
      name: search_from
    - description: Represents the end offset index of results.
      name: search_to
    - description: List of asm ids.
      name: asm_id_list
    - description: IPv6 address on which to search.
      name: ipv6_address
    - description: Search based on GCP cloud tags.
      name: gcp_cloud_tags
    - description: Search based on AWS cloud tags.
      name: aws_cloud_tags
    - description: Search based on AZURE cloud tags.
      name: azure_cloud_tags
    - description: Search based on xdr agent.
      name: has_xdr_agent
    - description: Search on externally detected providers.
      name: externally_detected_providers
    - description: Search on externally inferred cve.
      name: externally_inferred_cves
    - description: Search on Business units list.
      name: business_units_list
    - auto: PREDEFINED
      description: Whether it has BU overrides.
      name: has_bu_overrides
      predefined:
      - "True"
      - "False"
    - description: Search based on MAC address.
      name: mac_address
    description: Get a list of all your internet exposures filtered by IP address,
      domain, type, asm id, IPv6 address, AWS/GCP/Azure tags, has XDR agent, Externally
      detected providers, Externally inferred cves, Business units list, has BU overrides
      and/or if there is an active external service. Maximum result limit is 100 assets.
    name: asm-list-asset-internet-exposure
    outputs:
    - contextPath: ASM.AssetInternetExposure.asm_ids
      description: Attack surface management UUID.
      type: String
    - contextPath: ASM.AssetInternetExposure.name
      description: Name of the exposed asset.
      type: String
    - contextPath: ASM.AssetInternetExposure.asset_type
      description: Type of the exposed asset.
      type: String
    - contextPath: ASM.AssetInternetExposure.cloud_provider
      description: The cloud provider used to collect these cloud assets as either
        GCP, AWS, or Azure.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.region
      description: Displays the region as provided by the cloud provider.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.last_observed
      description: Last time the exposure was observed.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.first_observed
      description: First time the exposure was observed.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.has_active_externally_services
      description: Whether the internet exposure is associated with an active external
        service(s).
      type: Boolean
    - contextPath: ASM.AssetInternetExposure.has_xdr_agent
      description: Whether the internet exposure asset has an XDR agent.
      type: String
    - contextPath: ASM.AssetInternetExposure.cloud_id
      description: Displays the resource ID as provided from the cloud provider.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.domain_resolves
      description: Whether the asset domain is resolvable.
      type: Boolean
    - contextPath: ASM.AssetInternetExposure.operation_system
      description: The operating system reported by the source for this asset.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.agent_id
      description: The endpoint ID if there is an endpoint installed on this asset.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.externally_detected_providers
      description: The provider of the asset as determined by an external assessment.
      type: String
    - contextPath: ASM.AssetInternetExposure.service_type
      description: Type of the asset.
      type: String
    - contextPath: ASM.AssetInternetExposure.externally_inferred_cves
      description: If the internet exposure has associated CVEs.
      type: String
    - contextPath: ASM.AssetInternetExposure.ips
      description: IP addresses associated with the internet exposure.
      type: String
  - arguments:
    - description: A string representing the asset ID for which you want to get the
        details.
      name: asm_id
      required: true
    description: Get internet exposure asset details according to the asset ID.
    name: asm-get-asset-internet-exposure
    outputs:
    - contextPath: ASM.AssetInternetExposure.asm_ids
      description: Attack surface management UUID.
      type: String
    - contextPath: ASM.AssetInternetExposure.name
      description: Name of the exposed asset.
      type: String
    - contextPath: ASM.AssetInternetExposure.type
      description: Type of the exposed asset.
      type: String
    - contextPath: ASM.AssetInternetExposure.last_observed
      description: Last time the exposure was observed.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.first_observed
      description: First time the exposure was observed.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.created
      description: Date the ASM issue was created.
      type: Date
    - contextPath: ASM.AssetInternetExposure.business_units
      description: Asset associated business units.
      type: String
    - contextPath: ASM.AssetInternetExposure.domain
      description: Asset associated domain.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.certificate_issuer
      description: Asset certificate issuer.
      type: String
    - contextPath: ASM.AssetInternetExposure.certificate_algorithm
      description: Asset certificate algorithm.
      type: String
    - contextPath: ASM.AssetInternetExposure.certificate_classifications
      description: Asset certificate.classifications
      type: String
    - contextPath: ASM.AssetInternetExposure.resolves
      description: Whether the asset has a DNS resolution.
      type: Boolean
    - contextPath: ASM.AssetInternetExposure.details
      description: Additional details.
      type: Unknown
    - contextPath: ASM.AssetInternetExposure.externally_inferred_vulnerability_score
      description: Asset vulnerability score.
      type: Unknown
  - arguments:
    - description: Comma-separated list of integers of the alert ID.
      name: alert_id_list
    - description: Comma-separated list of strings of alert severity (valid values
        are low, medium, high, critical, informational).
      name: severity
    - description: Comma separated list of strings of alert tags. These should include
        the tag prefix, ex. AT:Asset Tag.
      name: tags
    - auto: PREDEFINED
      description: Comma-separated list of strings of the alert status.
      name: status
      predefined:
      - new
      - reopened
      - under_investigation
      - resolved_no_longer_observed
      - resolved_no_risk
      - resolved_risk_accepted
      - resolved_contested_asset
      - resolved_remediated_automatically
      - resolved
    - description: Comma-separated list of strings of the business units.
      name: business_units_list
    - description: A date in the format 2019-12-31T23:59:00. Only incidents that were
        created on or before the specified date/time will be retrieved.
      name: lte_creation_time
    - description: A date in the format 2019-12-31T23:59:00. Only incidents that were
        created on or after the specified date/time will be retrieved.
      name: gte_creation_time
    - description: Comma-separated list of case (incident) IDs.
      name: case_id_list
    - auto: PREDEFINED
      description: Sorts returned incidents by the date/time that the incident was
        created ("asc" - ascending, "desc" - descending).
      name: sort_by_creation_time
      predefined:
      - asc
      - desc
    - auto: PREDEFINED
      description: Sorts returned incidents by the date/time that the incident was
        created ("asc" - ascending, "desc" - descending).
      name: sort_by_severity
      predefined:
      - asc
      - desc
    - defaultValue: "0"
      description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - defaultValue: "100"
      description: Maximum number of incidents to return per page. The default and
        maximum is 100.
      name: limit
    description: Get a list of all your ASM alerts filtered by alert IDs, severity
      and/or creation time. Can also sort by creation time or severity. Maximum result
      limit is 100 assets.
    name: asm-list-alerts
    outputs:
    - contextPath: ASM.Alert.alert_id
      description: A unique identifier that Cortex XSIAM assigns to each alert.
      type: String
    - contextPath: ASM.Alert.severity
      description: The severity that was assigned to this alert when it was triggered
        (Options are Informational, Low, Medium, High, Critical, or Unknown).
      type: String
    - contextPath: ASM.Alert.external_id
      description: The alert ID as recorded in the detector from which this alert
        was sent.
      type: String
    - contextPath: ASM.Alert.name
      description: Summary of the ASM internet exposure alert.
      type: String
    - contextPath: ASM.Alert.description
      description: More detailed explanation of internet exposure alert.
      type: String
    - contextPath: ASM.Alert.host_name
      description: The hostname of the endpoint or server on which this alert triggered.
      type: String
    - contextPath: ASM.Alert.dynamic_fields
      description: Alert fields pulled from Cortex XSOAR context.
      type: Unknown
    - contextPath: ASM.Alert.events
      description: Individual events that comprise the alert.
      type: Unknown
    - contextPath: ASM.Alert.detection_timestamp
      description: Date the alert was created.
      type: Date
  - arguments:
    - auto: PREDEFINED
      description: Enablement status to search rules with.
      name: enabled_status
      predefined:
      - "On"
      - "Off"
    - description: Comma separated list of strings attack surface rule categories.
      name: category
    - description: Comma separated list of strings attack surface rule priorities.
        Options include Low, Medium, High, and Critical.
      name: priority
    - description: Comma-separated list of strings attack surface rule IDs.
      name: attack_surface_rule_id
    - description: Maximum number of results to return.
      name: limit
    description: Fetches attack surface rules related to how Cortex Xpanse does assessment.
    name: asm-get-attack-surface-rule
    outputs:
    - contextPath: ASM.AttackSurfaceRules.priority
      description: Priority level for the different rules. Low, Medium, High, Critical.
    - contextPath: ASM.AttackSurfaceRules.attack_surface_rule_name
      description: Name of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.attack_surface_rule_id
      description: ID of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.description
      description: Description of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.category
      description: Category of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.remediation_guidance
      description: Guidance for how to address various ASM risks.
    - contextPath: ASM.AttackSurfaceRules.enabled_status
      description: Enablement status of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.created
      description: Creation date of the attack surface rule.
    - contextPath: ASM.AttackSurfaceRules.modified
      description: Last modification of the attack surface rule.
  - arguments:
    - description: Comma-separated list of asset IDs to add tags to.
      name: asm_id_list
      required: true
    - description: The name of the tags to apply to supplied assets.
      name: tags
      required: true
    description: Assigns tags to a list of assets.
    name: asm-tag-asset-assign
  - arguments:
    - description: The asset ID to add a note to.
      name: asset_id
      required: true
    - auto: PREDEFINED
      description: 'The type of Xpanse asset. Allowed values are: ''asset'' or ''ip_range''.'
      name: entity_type
      predefined:
      - ip_range
      - asset
      required: true
    - description: The custom note to be added to the notes section of the asset in
        Cortex Xpanse.
      name: note_to_add
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Set to 'false' to overwrite the current note on the asset. Set
        to 'true' to append to the current note.
      name: should_append
      predefined:
      - "True"
      - "False"
    description: Adds a note to an asset in Xpanse.
    name: asm-add-note-to-asset
    outputs:
    - contextPath: ASM.AssetAnnotation.status
      description: Status of the note being added to the asset in Cortex Xpanse.
      type: String
  - arguments:
    - description: Comma-separated list of asset IDs to remove tags from.
      name: asm_id_list
    - description: The name of the tags to remove from supplied assets.
      name: tags
    description: Removes tags from a list of assets.
    name: asm-tag-asset-remove
  - arguments:
    - description: Comma-separated list of range IDs to add tags to.
      name: range_id_list
    - description: The name of the tags to apply to supplied assets.
      name: tags
    description: Assigns tags to a list of IP ranges.
    name: asm-tag-range-assign
  - arguments:
    - description: Comma-separated list of range IDs to remove tags from.
      name: range_id_list
    - description: The name of the tags to remove from supplied IP ranges.
      name: tags
    description: Removes tags from a list of IP ranges.
    name: asm-tag-range-remove
  - arguments:
    - description: 'Incident IDs to filter on. Note: Incident IDs may also be references
        as "Case IDs'' elsewhere in the API.'
      name: incident_id_list
    - description: String to search for within the incident description field.
      name: description
    - auto: PREDEFINED
      description: Status to search incidents for.
      name: status
      predefined:
      - new
      - under_investigation
      - resolved
    - description: A date in the format 2019-12-31T23:59:00. Only incidents that were
        created on or before the specified date/time will be retrieved.
      name: lte_creation_time
    - description: A date in the format 2019-12-31T23:59:00. Only incidents that were
        created on or after the specified date/time will be retrieved.
      name: gte_creation_time
    - description: Sorts returned incidents by the date/time that the incident was
        created ("asc" - ascending, "desc" - descending).
      name: sort_by_creation_time
    - description: Sorts returned incidents by the severity of the incident.
      name: sort_by_severity
    - description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - description: Maximum number of incidents to return per page. The default and
        maximum is 100.
      name: limit
    description: 'Fetches ASM incidents that match provided filters. Incidents are
      an aggregation of related alerts. Note: Incident IDs may also be references
      as "Case IDs'' elsewhere in the API.'
    name: asm-list-incidents
    outputs:
    - contextPath: ASM.Incident.alert_count
      description: Number of alerts included in the incident.
      type: Number
    - contextPath: ASM.Incident.alerts_grouping_status
      description: Whether alert grouping is enabled.
      type: String
    - contextPath: ASM.Incident.assigned_user_mail
      description: Email of the assigned user.
      type: Unknown
    - contextPath: ASM.Incident.assigned_user_pretty_name
      description: Friendly name of the assigned user.
      type: Unknown
    - contextPath: ASM.Incident.creation_time
      description: Creation timestamp.
      type: Date
    - contextPath: ASM.Incident.critical_severity_alert_count
      description: Number of critical alerts.
      type: Number
    - contextPath: ASM.Incident.description
      description: Description of the incident.
      type: String
    - contextPath: ASM.Incident.high_severity_alert_count
      description: Number of high alerts.
      type: Number
    - contextPath: ASM.Incident.incident_id
      description: ID of the incident.
      type: String
    - contextPath: ASM.Incident.incident_name
      description: Incident name.
      type: Unknown
    - contextPath: ASM.Incident.incident_sources
      description: Incident source.
      type: String
    - contextPath: ASM.Incident.low_severity_alert_count
      description: Number of low alerts.
      type: Number
    - contextPath: ASM.Incident.manual_severity
      description: Severity override.
      type: Unknown
    - contextPath: ASM.Incident.med_severity_alert_count
      description: Number of medium alerts.
      type: Number
    - contextPath: ASM.Incident.modification_time
      description: Modification timestamp.
      type: Date
    - contextPath: ASM.Incident.notes
      description: Incident notes.
      type: Unknown
    - contextPath: ASM.Incident.original_tags
      description: Tags on the incident at creation time.
      type: Unknown
    - contextPath: ASM.Incident.resolve_comment
      description: Resolution comment (optional).
      type: Unknown
    - contextPath: ASM.Incident.resolved_timestamp
      description: Resolution timestamp.
      type: Unknown
    - contextPath: ASM.Incident.severity
      description: Severity of the incident.
      type: String
    - contextPath: ASM.Incident.starred
      description: Whether the incident has been starred.
      type: Boolean
    - contextPath: ASM.Incident.status
      description: Status of the incident.
      type: String
    - contextPath: ASM.Incident.tags
      description: Tags on the incident.
      type: String
    - contextPath: ASM.Incident.xdr_url
      description: Link to navigate to the incident.
      type: String
    - contextPath: ASM.Incident.xpanse_risk_score
      description: Risk score of the incident.
      type: Unknown
  - arguments:
    - description: ID of the incident to modify.
      name: incident_id
      required: true
    - description: Used for scoping updates such as comments to the alert level.
      name: alert_id
    - description: Email address of the user to assign incident to. This user must
        exist within your Expander instance.
      name: assigned_user_mail
    - auto: PREDEFINED
      description: Administrator-defined severity for the incident.
      name: manual_severity
      predefined:
      - Low
      - Medium
      - High
      - Critical
    - auto: PREDEFINED
      description: Incident status.
      name: status
      predefined:
      - new
      - under_investigation
      - resolved
    - description: Optional resolution comment when resolving the incident.
      name: resolve_comment
    - description: A comment to add to the incident. If an alert_id is supplied it
        will be prefixed to the comment.
      name: comment
    description: Updates a given incident. Can be used to modify the status, severity,
      assignee, or add comments.
    name: asm-update-incident
    outputs:
    - contextPath: ASM.IncidentUpdate
      description: Whether the incident update was successful.
  - arguments:
    - description: Comma-separated list of integers of the alert ID.
      name: alert_id_list
    - auto: PREDEFINED
      description: Updated alert status.
      name: status
      predefined:
      - new
      - reopened
      - under_investigation
      - resolved
      - resolved_contested_asset
      - resolved_risk_accepted
      - resolved_no_risk
      - resolved_remediated_automatically
    - auto: PREDEFINED
      description: The severity of the alert.
      name: severity
      predefined:
      - low
      - medium
      - high
      - critical
    - description: Descriptive comment explaining the alert change.
      name: resolution_comment
    description: Updates the state of one or more alerts.
    name: asm-update-alerts
    outputs:
    - contextPath: ASM.UpdatedAlerts
      description: IDs of the updated alerts.
  - arguments:
    - default: true
      description: IP address to enrich.
      isArray: true
      name: ip
      required: true
    description: Returns enrichment for an IP address.
    name: ip
    outputs:
    - contextPath: ASM.IP.ip
      description: The IP address of the asset.
      type: string
    - contextPath: ASM.IP.domain
      description: The domain affiliated with an asset.
      type: string
    - contextPath: ASM.IP.name
      description: The asset name.
      type: string
    - contextPath: ASM.IP.asset_type
      description: The asset type.
      type: string
    - contextPath: ASM.IP.first_observed
      description: When the asset was first observed.
    - contextPath: ASM.IP.last_observed
      description: When the asset was last observed.
    - contextPath: ASM.IP.asm_ids
      description: The ID of the asset.
    - contextPath: ASM.IP.service_type
      description: Affiliated service types for the asset.
    - contextPath: ASM.IP.tags
      description: A list of tags that have been assigned to the asset.
    - contextPath: ASM.IP.asset_explainers
      description: The asset explanation details.
    - contextPath: ASM.IP.domain_details
      description: Additional domain details.
    - contextPath: ASM.IP.recent_ips
      description: Details about the recent IP observations.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: The reliability of the source providing the intelligence data.
      type: String
    - contextPath: IP.Address
      description: IP address.
      type: String
    - contextPath: ASM.TIM.IP.name
      description: The existing Cortex Xpanse IP address recently updated in the Cortex
        XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.IP.indicator_type
      description: The existing Cortex Xpanse indicator type in the Cortex XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.IP.id
      description: The existing indicator ID in the Cortex XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.IP.reliability
      description: The existing indicator reliability recently updated in the Cortex
        XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.IP.score
      description: The existing indicator score recently updated in the Cortex XSOAR
        indicators.
      type: Number
  - arguments:
    - default: true
      description: Domain to enrich.
      isArray: true
      name: domain
      required: true
    description: Returns enrichment for a domain.
    name: domain
    outputs:
    - contextPath: ASM.Domain.domain
      description: The domain affiliated with an asset.
      type: string
    - contextPath: ASM.Domain.name
      description: The asset name.
      type: string
    - contextPath: ASM.Domain.asset_type
      description: The asset type.
      type: string
    - contextPath: ASM.Domain.first_observed
      description: When the asset was first observed.
    - contextPath: ASM.Domain.last_observed
      description: When the asset was last observed.
    - contextPath: ASM.Domain.asm_ids
      description: The ID of the asset.
    - contextPath: ASM.Domain.service_type
      description: Affiliated service types for the asset.
    - contextPath: ASM.Domain.tags
      description: A list of tags that have been assigned to the asset.
    - contextPath: ASM.Domain.asset_explainers
      description: The asset explanation details.
    - contextPath: ASM.Domain.domain_details
      description: Additional domain details.
    - contextPath: ASM.Domain.recent_ips
      description: Details about the recent IP observations.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: The reliability of the source providing the intelligence data.
      type: String
    - contextPath: Domain.Name
      description: 'The domain name, for example: "google.com".'
      type: String
    - contextPath: ASM.TIM.Domain.name
      description: The existing Cortex Xpanse domain recently updated in XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.Domain.indicator_type
      description: The existing Cortex Xpanse indicator type in the Cortex XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.Domain.id
      description: The existing indicator ID in the Cortex XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.Domain.reliability
      description: The existing indicator reliability recently updated in the Cortex
        XSOAR indicators.
      type: String
    - contextPath: ASM.TIM.Domain.score
      description: The existing indicator score recently updated in the Cortex XSOAR
        indicators.
      type: Number
  - arguments:
    - description: The ID of the incident to be fetched.
      name: incident_id
      required: true
    description: Returns additional details about a specific incident.
    name: asm-get-incident
    outputs:
    - contextPath: ASM.Incident.incident_id
      description: The ID of the incident.
      type: string
    - contextPath: ASM.Incident.xpanse_risk_score
      description: The Xpanse risk score of the incident.
      type: number
    - contextPath: ASM.Incident.alerts
      description: The alerts included in the incident.
    - contextPath: ASM.Incident.tags
      description: Tags assigned to assets included in the incident.
    - contextPath: ASM.Incident.status
      description: The status of the incident.
      type: string
    - contextPath: ASM.Incident.severity
      description: The severity of the incident.
      type: string
    - contextPath: ASM.Incident.description
      description: A brief description of the incident.
      type: string
    - contextPath: ASM.Incident.notes
      description: User-provided notes related to the incident.
      type: string
  - arguments:
    - description: Authentication type string on which to search.
      name: authentication
    - defaultValue: "100"
      description: Maximum number of assets to return. The maximum value is 100.
      name: limit
    description: Get external websites assets.
    name: asm-list-external-websites
    outputs:
    - contextPath: ASM.ExternalWebsite
      description: A list of the websites results assets.
  - arguments: []
    description: Resets the fetch incidents last run value, which resets the fetch
      to its initial fetch state.
    name: asm-reset-last-run
  dockerimage: demisto/python3:3.11.10.115186
  isFetchSamples: true
  isfetch: true
  runonce: false
  script: |
    register_module_line('Cortex Xpanse', 'start', __line__())
    demisto.debug('pack name = Cortex Xpanse, pack version = 1.2.5')




    from typing import Any
    from datetime import datetime, timedelta
    from dateutil import parser
    import ipaddress

    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    DEFAULT_SEARCH_LIMIT = int(demisto.params().get('search_limit', 100))
    MAX_ALERTS = 100  # max alerts per fetch
    TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"
    TIME_FORMAT_Z = "%Y-%m-%dT%H:%M:%SZ"
    V1_URL_SUFFIX = "/public_api/v1"
    V2_URL_SUFFIX = "/public_api/v2"
    PACK_VERSION = get_pack_version()
    DEMISTO_VERSION = demisto.demistoVersion()
    SEVERITY_DICT = {
        'informational': IncidentSeverity.INFO,
        'low': IncidentSeverity.LOW,
        'medium': IncidentSeverity.MEDIUM,
        'high': IncidentSeverity.HIGH,
        'critical': IncidentSeverity.CRITICAL
    }
    ASSIGN = "assign"
    REMOVE = 'remove'
    INCIDENT_STATUSES = [
        "new",
        "under_investigation",
        "resolved_-_no_longer_observed",
        "resolved_-_no_risk",
        "resolved_-_risk_accepted",
        "resolved_-_contested_asset",
        "resolved_-_remediated_automatically",
        "resolved"
    ]

    ALERT_STATUSES = [
        "new",
        "reopened",
        "under_investigation",
        "resolved_no_risk",
        "resolved_risk_accepted",
        "resolved_contested_asset",
        "resolved_remediated_automatically",
        "resolved"
    ]
    ASSET_HEADER_HEADER_LIST = [
        "name",
        "ip",
        "first_observed",
        "last_observed",
        "domain",
        "asset_type",
        "asm_ids",
        "asset_explainers",
        "service_type",
        "tags",
        "recent_ips",
        "domain_details"
    ]


    class Client(BaseClient):
        """
        Client class to interact with the service API.
        """

        def __init__(self, base_url, verify, proxy, headers):
            """
            Class initialization.
            """
            super().__init__(base_url, verify=verify, proxy=proxy, headers=headers)

        def list_alerts_request(self, request_data: dict) -> dict[str, Any]:
            """Get a list of all asm alerts '/alerts/get_alerts_multi_events/' endpoint.

            Args:
                request_data (dict): dict of parameters for API call.

            Returns:
                dict: dict containing list of external services.
            """

            response = self._http_request('POST', f'{V2_URL_SUFFIX}/alerts/get_alerts_multi_events/', json_data=request_data)

            return response

        def list_external_service_request(self, search_params: list[dict]) -> dict[str, Any]:
            """Get a list of all your external services using the '/assets/get_external_services/' endpoint.

            Args:
                search_params (list): list of search parameters to add to the API call body.

            Returns:
                dict: dict containing list of external services.
            """
            data = {"request_data": {"filters": search_params, "search_to": DEFAULT_SEARCH_LIMIT}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_external_services/', json_data=data)

            return response

        def get_external_service_request(self, service_id_list: list[str]) -> dict[str, Any]:
            """Get service details using the '/assets/get_external_service/' endpoint.

            Args:
                service_id_list (list): single service id in list format.

            Returns:
                dict: dict containing information on single external service.
            """
            data = {"request_data": {"service_id_list": service_id_list}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_external_service', json_data=data)

            return response

        def list_external_ip_address_range_request(self) -> dict[str, Any]:
            """Get a list of all your internet exposure IP ranges using the '/assets/get_external_ip_address_ranges/' endpoint.

            Returns:
                dict: dict containing list of external ip address ranges.
            """
            data = {"request_data": {"search_to": DEFAULT_SEARCH_LIMIT}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_external_ip_address_ranges/', json_data=data)

            return response

        def get_external_ip_address_range_request(self, range_id_list: list[str]) -> dict[str, Any]:
            """Get external IP address range details using the '/assets/get_external_ip_address_range/' endpoint.

            Args:
                range_id_list (list): single range id in list format.

            Returns:
                dict: dict containing information on external ip address range.
            """
            data = {"request_data": {"range_id_list": range_id_list}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_external_ip_address_range/', json_data=data)

            return response

        def list_asset_internet_exposure_request(self, search_params: list[dict], search_from: int = 0,
                                                 search_to: int = DEFAULT_SEARCH_LIMIT) -> dict[str, Any]:
            """Get a list of all your internet exposure assets using the '/assets/get_assets_internet_exposure/' endpoint.

            Args:
                search_params (list): list of search parameters to add to the API call body.
                search_from (int): Starting search index.
                search_to (int): Ending search index.

            Returns:
                dict: dict containing list of internet exposure assets.
            """
            data = {"request_data": {"filters": search_params, "search_to": int(search_to), "search_from": int(search_from)}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_assets_internet_exposure/', json_data=data)

            return response

        def get_asset_internet_exposure_request(self, asm_id_list: list[str]) -> dict[str, Any]:
            """Get internet exposure asset details using the '/assets/get_asset_internet_exposure/' endpoint.

            Args:
                asm_id_list (list): single attack surface management id in list format.

            Returns:
                dict: dict containing information on an internet exposure asset.
            """
            data = {"request_data": {"asm_id_list": asm_id_list}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_asset_internet_exposure/', json_data=data)

            return response

        def list_attack_surface_rules_request(self, search_params: list[dict], limit: int = DEFAULT_SEARCH_LIMIT) -> dict[str, Any]:
            """List attack surface rules using the '/get_attack_surface_rules/' endpoint.

            Args:
                search_params (list): list of search parameters to add to the API call body.

            Returns:
                dict: dict containing list of attack surface rules.
            """
            data = {"request_data": {"filters": search_params, "search_to": limit}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/get_attack_surface_rules/', json_data=data)

            return response

        def apply_tags_to_assets_request(self, search_params: list[dict], tags: str, operation: str) -> dict[str, Any]:
            """Assigns tags to assets with the 'tags/assets_internet_exposure/assign' endpoint.

            Args:
                search_params (list): list of request parameters to add to the API call body.

            Returns:
                dict: dict containing whether the assignment request was successful.
            """
            data = {"request_data": {"filters": search_params, "tags": [tags]}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/tags/assets_internet_exposure/{operation}/',
                                          json_data=data)

            return response

        def apply_tags_to_ranges_request(self, search_params: list[dict], tags: str, operation: str) -> dict[str, Any]:
            """Assigns tags to assets with the 'tags/external_ip_address_ranges/assign' endpoint.

            Args:
                search_params (list): list of request parameters to add to the API call body.

            Returns:
                dict: dict containing whether the assignment request was successful.
            """
            data = {"request_data": {"filters": search_params, "tags": [tags]}}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/tags/external_ip_address_ranges/{operation}/',
                                          json_data=data)

            return response

        def list_incidents_request(self, request_data: dict[str, Any]) -> dict[str, Any]:
            """Fetches matching incidents from the 'incidents/get_incidents' endpoint.

            Args:
                request_data (dict): Parameters to add to the API call body.

            Returns:
                dict: dict containing whether the assignment request was successful.
            """
            response = self._http_request('POST', f'{V1_URL_SUFFIX}/incidents/get_incidents/', json_data=request_data)

            return response

        def get_incident_request(self, incident_id: str) -> dict[str, Any]:
            """Fetches an incident from the 'incidents/get_incident_extra_data' endpoint.

            Args:
                incident_id (str): Incident ID

            Returns:
                dict: dict containing whether the assignment request was successful.
            """
            request_data = {
                "request_data": {"incident_id": incident_id}
            }
            response = self._http_request('POST', f'{V1_URL_SUFFIX}/incidents/get_incident_extra_data/', json_data=request_data)

            return response

        def update_incident_request(self, request_data: dict[str, Any]) -> dict[str, Any]:
            """Updates an incident via the 'incidents/update_incident' endpoint.

            Args:
                request_data (dict): Parameters to add to the API call body.

            Returns:
                dict: dict containing whether the update request was successful.
            """
            data = {"request_data": request_data}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/incidents/update_incident/', json_data=data)

            return response

        def update_alert_request(self, request_data: dict[str, Any]) -> dict[str, Any]:
            """Updates alerts via the 'alerts/update_alerts' endpoint.

            Args:
                request_data (dict): Parameters to add to the API call body.

            Returns:
                dict: dict containing whether the update request was successful.
            """
            data = {"request_data": request_data}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/alerts/update_alerts/', json_data=data)

            return response

        def get_external_websites(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
            data = {"request_data": request_data}

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/get_external_websites/', json_data=data)

            return response

        def add_note_to_asset(self, asm_asset_id: str, entity_type: str, annotation_note: str, should_append: bool) -> dict[str, Any]:
            """Adds an annotation (also called a note) to an asset or IP range
            using the /assets/assets_internet_exposure/annotation endpoint.

            Args:
                asm_asset_id (str): The Xpanse asset ID.
                entity_type (str): The type of Xpanse asset, Allowed values: 'asset' or 'ip_range'.
                annotation_note (str): The custom note to be added to the notes section of the asset in Xpanse

            Returns:
                dict[str, Any]: a response that indicates if adding the note succeeded.
            """
            data = {
                "request_data":
                    {"assets":
                        [{"entity_id": asm_asset_id,
                            "entity_type": entity_type,
                            "annotation": annotation_note
                          }],
                        "should_append": should_append
                     }
            }

            response = self._http_request('POST', f'{V1_URL_SUFFIX}/assets/assets_internet_exposure/annotation', json_data=data)

            return response


    ''' HELPER FUNCTIONS '''


    def is_timestamp_within_days(timestamp, days: int):
        """_summary_

        Args:
            timestamp (_type_): _description_
            days (int): _description_
            debug_msg (str): _description_

        Returns:
            _type_: _description_
        """
        timestamp = timestamp.replace(" ", "").replace("Z", "")
        date_part, time_part = timestamp.split('T')
        main_time, fractional_seconds = time_part.split('.')
        fractional_seconds = fractional_seconds[:6]
        timestamp = f"{date_part}T{main_time}.{fractional_seconds}"
        target_time = datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S.%f')

        current_time = datetime.now()
        time_difference = current_time - target_time

        if time_difference >= timedelta(days=days):
            demisto.debug(f"The timestamp was not within the last {days} days.")
            return False
        else:
            demisto.debug(f"The timestamp was within the last {days} days.")
            return True


    def append_search_param(search_params, field, operator, value):
        """
        Appends a search parameter to the given list of search parameters.

        Args:
            search_params (list): The list of search parameters to append to.
            field (str): The name of the field to search on.
            operator (str): The operator to use for the search (e.g. "eq", "contains", "in").
            value (any): The value to search for.

        Returns:
            None
        """

        search_params.append(
            {
                "field": field,
                "operator": operator,
                "value": value
            }
        )


    def format_asm_id(formatted_response: list[dict]) -> list[dict]:
        """
        Takes the response from the asm-list-asset-internet-exposure command and converts `asm_id` key from list to str

        Args:
            formatted_response (list): response from asm-list-asset-internet-exposure command (json)

        Returns:
            list: list of dictionaries of parsed/formatted json object
        """

        if formatted_response:
            for entry in formatted_response:
                if entry.get('asm_ids'):
                    entry['asm_ids'] = entry['asm_ids'][0]

        return formatted_response


    ''' COMMAND FUNCTIONS '''


    def list_alerts_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-alerts command: Returns list of asm alerts.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['alert_id_list']`` List of integers of the Alert ID.
                ``args['severity']`` List of strings of the Alert severity.
                ``args['status']`` List of strings of the Alert status.
                ``args['business_units_list']`` List of business units of the Alert status.
                ``args['lte_creation_time']`` string of time format "2019-12-31T23:59:00".
                ``args['gte_creation_time']`` string of time format "2019-12-31T23:59:00".
                ``args['case_id_list']`` List of integers of the Case ID.
                ``args['tags']`` List of tags.
                ``args['sort_by_creation_time']`` optional - enum (asc,desc).
                ``args['sort_by_severity']`` optional - enum (asc,desc).
                ``args['page']`` Page number (for pagination). The default is 0 (the first page).
                ``args['limit']`` Maximum number of incidents to return per page. The default and maximum is 100.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``, that contains external
            services.
        """
        alert_id_list = argToList(args.get('alert_id_list'))
        severity = argToList(args.get('severity'))
        status = argToList(args.get('status'))
        business_units_list = argToList(args.get('business_units_list'))
        lte_creation_time = args.get('lte_creation_time')
        gte_creation_time = args.get('gte_creation_time')
        case_id_list = argToList(args.get('case_id_list'))
        sort_by_creation_time = args.get('sort_by_creation_time')
        sort_by_severity = args.get('sort_by_severity')
        tags = argToList(args.get('tags'))
        page = int(args.get('page', 0))
        limit = int(args.get('limit', MAX_ALERTS))

        search_from = page * limit
        search_to = search_from + limit

        if limit > MAX_ALERTS:
            raise ValueError('Limit cannot be more than 100, please try again')
        if sort_by_creation_time and sort_by_severity:
            raise ValueError('Should be provide either sort_by_creation_time or '
                             'sort_by_severity. Can\'t provide both')

        # starts with param to only look for ASM alerts.  Can add others if defined.
        search_params = [{"field": "alert_source", "operator": "in", "value": ["ASM"]}]
        if alert_id_list:
            alert_id_ints = [int(i) for i in alert_id_list]
            search_params.append({"field": "alert_id_list", "operator": "in", "value": alert_id_ints})  # type: ignore
        if severity:
            search_params.append({"field": "severity", "operator": "in", "value": severity})
        if status:
            search_params.append({"field": "status", "operator": "in", "value": status})
        if business_units_list:
            search_params.append({"field": "business_units_list", "operator": "in", "value": business_units_list})
        if lte_creation_time:
            search_params.append({
                'field': 'creation_time',
                'operator': 'lte',
                'value': date_to_timestamp(lte_creation_time, TIME_FORMAT)
            })
        if gte_creation_time:
            search_params.append({
                'field': 'creation_time',
                'operator': 'gte',
                'value': date_to_timestamp(gte_creation_time, TIME_FORMAT)
            })
        if tags:
            search_params.append({"field": "tags", "operator": "in", "value": tags})
        if case_id_list:
            case_id_ints = [int(i) for i in case_id_list]
            search_params.append({"field": "case_id_list", "operator": "in", "value": case_id_ints})  # type: ignore

        if sort_by_creation_time:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from,
                                             'search_to': search_to,
                                             "sort": {"field": "creation_time", "keyword": sort_by_creation_time}}}
        elif sort_by_severity:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from,
                                             'search_to': search_to, "sort": {"field": "severity", "keyword": sort_by_severity}}}
        else:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from, 'search_to': search_to}}

        try:
            response = client.list_alerts_request(request_data)
        except Exception:
            command_results = CommandResults(
                outputs_prefix='ASM.Alert',
                outputs_key_field='alert_id',
                outputs=[],
                raw_response={'reply': {'alerts': []}},
                readable_output=tableToMarkdown('ASM Alerts', [], removeNull=True, headerTransform=string_to_table_header)
            )
            return command_results

        parsed = response.get('reply', {}).get('alerts')
        markdown = tableToMarkdown('ASM Alerts', parsed, removeNull=True, headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.Alert',
            outputs_key_field='alert_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def list_external_service_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-external-service command: Returns list of external services.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['ip_address']`` IP Address to search on.
                ``args['domain']`` Domain to search on.
                ``args['is_active']`` If the service active or not.
                ``args['discovery_type']`` how service was discovered.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``, that contains external
            services.
        """
        ip_address = args.get('ip_address')
        domain = args.get('domain')
        is_active = args.get('is_active')
        discovery_type = args.get('discovery_type')
        # create list of search parameters or pass empty list.
        search_params = []
        if ip_address:
            search_params.append({"field": "ip_address", "operator": "eq", "value": ip_address})
        if domain:
            search_params.append({"field": "domain", "operator": "contains", "value": domain})
        if is_active:
            search_params.append({"field": "is_active", "operator": "in", "value": [is_active]})
        if discovery_type:
            search_params.append({"field": "discovery_type", "operator": "in", "value": [discovery_type]})

        response = client.list_external_service_request(search_params)
        parsed = response.get('reply', {}).get('external_services')
        markdown = tableToMarkdown('External Services', parsed, removeNull=True, headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.ExternalService',
            outputs_key_field='service_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def get_external_service_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-get-external-service command: Returns details of single external service.
        Returns error if more than one service_id was provided in comma separated format.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['service_id']`` A string representing the service ID you want to get details for.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains external service information.
        """
        # assume that only one service_id was passed in or fail.
        service_id = str(args.get('service_id'))
        service_id_list = service_id.split(",")
        if len(service_id_list) > 1:
            raise ValueError("This command only supports one service_id at this time")

        response = client.get_external_service_request(service_id_list)
        parsed = response.get('reply', {}).get('details')
        markdown = tableToMarkdown('External Service', parsed, removeNull=True, headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.ExternalService',
            outputs_key_field='service_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def list_external_ip_address_range_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-external-ip-address-range command: Returns list of external ip ranges.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()`` (not used in this function).

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains external IP address ranges.
        """
        response = client.list_external_ip_address_range_request()
        parsed = response.get('reply', {}).get('external_ip_address_ranges')
        markdown = tableToMarkdown('External IP Address Ranges', parsed, removeNull=True,
                                   headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.ExternalIpAddressRange',
            outputs_key_field='range_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def get_external_ip_address_range_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-get-external-ip-address-range command: Returns details of single external ip range.
        Returns error if more than one range_id was provided in comma separated format.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['range_id']`` A string representing the range ID for which you want to get the details for.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains external ip range information.
        """
        # assume that only one range_id was passed in or fail.
        range_id = str(args.get('range_id'))
        range_id_list = range_id.split(",")
        if len(range_id_list) > 1:
            raise ValueError("This command only supports one range_id at this time")

        response = client.get_external_ip_address_range_request(range_id_list)
        parsed = response.get('reply', {}).get('details')
        markdown = tableToMarkdown('External IP Address Range', parsed, removeNull=True,
                                   headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.ExternalIpAddressRange',
            outputs_key_field='range_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def list_asset_internet_exposure_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-asset-internet-exposure command: Returns list of external internet exposures.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['ip_address']`` IP Address to search on.
                ``args['name']`` name of asset to search on.
                ``args['type']`` type of external service.
                ``args['has_active_external_services']`` if the internet exposure have an active external service.
                ``args['search_from']`` Represents the start offset index of results.
                ``args['search_to']`` Represents the end offset index of results.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains external internet exposures.
        """
        ip_address = args.get('ip_address')
        name = args.get('name')
        asm_type = args.get('type')
        has_active_external_services = args.get('has_active_external_services')
        search_from = int(args.get('search_from', 0))
        search_to = int(args.get('search_to', DEFAULT_SEARCH_LIMIT))
        asm_id_list = args.get("asm_id_list")
        ipv6_address = args.get("ipv6_address")
        gcp_cloud_tags = args.get("gcp_cloud_tags")
        azure_cloud_tags = args.get("azure_cloud_tags")
        aws_cloud_tags = args.get("aws_cloud_tags")
        has_xdr_agent = args.get("has_xdr_agent")
        externally_detected_providers = args.get("externally_detected_providers")
        externally_inferred_cves = args.get("externally_inferred_cves")
        business_units_list = args.get("business_units_list")
        has_bu_overrides = args.get("has_bu_overrides")
        mac_addresses = args.get("mac_addresses")
        # create list of search parameters or pass empty list.
        search_params: List[Dict[str, Any]] = []

        if ip_address:
            append_search_param(search_params, "ip_address", "eq", ip_address)

        if name:
            append_search_param(search_params, "name", "contains", name)

        if asm_type:
            append_search_param(search_params, "type", "in", [asm_type])

        if has_active_external_services:
            append_search_param(search_params, "has_active_external_services", "in", [has_active_external_services])

        if asm_id_list:
            append_search_param(search_params, "asm_id_list", "in", str(asm_id_list).split(","))

        if ipv6_address:
            append_search_param(search_params, "ipv6_address", "eq", str(ipv6_address))

        if aws_cloud_tags:
            append_search_param(search_params, "aws_cloud_tags", "in", str(aws_cloud_tags).split(","))

        if gcp_cloud_tags:
            append_search_param(search_params, "gcp_cloud_tags", "in", str(gcp_cloud_tags).split(","))

        if azure_cloud_tags:
            append_search_param(search_params, "azure_cloud_tags", "in", str(azure_cloud_tags).split(","))

        if has_xdr_agent:
            append_search_param(search_params, "has_xdr_agent", "in", str(has_xdr_agent).split(","))

        if externally_detected_providers:
            append_search_param(search_params, "externally_detected_providers", "contains", externally_detected_providers)

        if externally_inferred_cves:
            append_search_param(search_params, "externally_inferred_cves", "contains", str(externally_inferred_cves))

        if business_units_list:
            append_search_param(search_params, "business_units_list", "in", str(business_units_list).split(","))

        if has_bu_overrides:
            append_search_param(search_params, "has_bu_overrides", "eq", has_bu_overrides.lower() != 'false')

        if mac_addresses:
            append_search_param(search_params, "mac_addresses", "contains", mac_addresses)

        response = client.list_asset_internet_exposure_request(
            search_params=search_params, search_to=search_to, search_from=search_from)
        formatted_response = response.get('reply', {}).get('assets_internet_exposure')
        parsed = format_asm_id(formatted_response)
        markdown = tableToMarkdown('Asset Internet Exposures', parsed, removeNull=True,
                                   headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.AssetInternetExposure',
            outputs_key_field='asm_ids',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def get_asset_internet_exposure_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-get-asset-internet-exposure command: Returns details of single external internet exposure.
        Returns error if more than one asm_id was provided in comma separated format.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['asm_id']`` A string representing the asset ID for which you want to get the details for.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains internet exposure information.
        """
        # assume that only one asm_id was passed in or fail.
        asm_id = str(args.get('asm_id'))
        asm_id_list = asm_id.split(",")
        if len(asm_id_list) > 1:
            raise ValueError("This command only supports one asm_id at this time")

        response = client.get_asset_internet_exposure_request(asm_id_list)
        parsed = response.get('reply', {}).get('details')
        markdown = tableToMarkdown('Asset Internet Exposure', parsed, removeNull=True,
                                   headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.AssetInternetExposure',
            outputs_key_field='asm_ids',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def list_attack_surface_rules_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-attack_surface_rules command: Returns list of attack surface rules.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['enabled_status']`` Enablement status to search rules with.
                ``args['category']`` Category of rule to search on.
                ``args['priority']`` Priority of rule to search on.
                ``args['attack_surface_rule_id']`` ID of attack surface rule.
                ``args['limit']`` How many rules to return.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``,
            that contains attack surface rules.
        """
        enabled_status = argToList(args.get('enabled_status'))
        category = argToList(args.get('category'))
        priority = argToList(args.get('priority'))
        attack_surface_rule_id = argToList(args.get('attack_surface_rule_id'))
        limit = int(args.get('limit', DEFAULT_SEARCH_LIMIT))
        # create list of search parameters or pass empty list.
        search_params = []
        if enabled_status:
            search_params.append({"field": "enabled_status", "operator": "in", "value": enabled_status})
        if category:
            search_params.append({"field": "category", "operator": "in", "value": category})
        if priority:
            search_params.append({"field": "priority", "operator": "in", "value": priority})
        if attack_surface_rule_id:
            search_params.append({"field": "attack_surface_rule_id", "operator": "in", "value": attack_surface_rule_id})

        response = client.list_attack_surface_rules_request(search_params=search_params, limit=limit)
        formatted_response = response.get('reply', {}).get('attack_surface_rules')
        parsed = format_asm_id(formatted_response)
        markdown = tableToMarkdown('Attack Surface Rules', parsed, removeNull=True,
                                   headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.AttackSurfaceRules',
            outputs_key_field='attack_surface_rule_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def assign_tag_to_assets_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-tag-asset-assign command: Assigns a tag to a list of assets.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['asm_id_list']`` Asset IDs to assign a tag to.
                ``args['tags']`` Name of the tag to add to the assets.


        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        asm_id_list = argToList(args.get('asm_id_list'))
        tags = argToList(args.get('tags'))

        search_params = []
        if asm_id_list:
            search_params.append({"field": "asm_id_list", "operator": "in", "value": asm_id_list})
        else:
            raise ValueError('asm_id_list must contain at least one entry.')

        if not tags:
            raise ValueError('a value for "tags" must be provided.')

        response = client.apply_tags_to_assets_request(search_params=search_params, tags=tags, operation=ASSIGN)

        formatted_response = response.get('reply', {}).get('assign_tags')
        command_results = CommandResults(
            outputs=f"Assignment operation: {formatted_response}",
            raw_response=response,
            readable_output=f"Assignment operation: {formatted_response}",
            outputs_prefix='ASM.TagAssignment'
        )

        return command_results


    def remove_tag_to_assets_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-tag-asset-remove command: Assigns a tag to a list of assets.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['asm_id_list']`` Asset IDs to remove a tag from.
                ``args['tags']`` Name of the tags to remove from the assets.


        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        asm_id_list = argToList(args.get('asm_id_list'))
        tags = argToList(args.get('tags'))

        search_params = []
        if asm_id_list:
            search_params.append({"field": "asm_id_list", "operator": "in", "value": asm_id_list})
        else:
            raise ValueError('asm_id_list must contain at least one entry.')

        if not tags:
            raise ValueError('a value for "tags" must be provided.')

        response = client.apply_tags_to_assets_request(search_params=search_params, tags=tags, operation=REMOVE)

        formatted_response = response.get('reply', {}).get('remove_tags')
        command_results = CommandResults(
            outputs=f"Removal operation: {formatted_response}",
            raw_response=response,
            readable_output=f"Removal operation: {formatted_response}",
            outputs_prefix='ASM.TagRemoval'
        )

        return command_results


    def assign_tag_to_ranges_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-tag-range-assign command: Assigns a tag to a list of IP ranges.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['range_id_list']`` Range IDs to assign a tag to.
                ``args['tags']`` Name of the tag to add to the ranges.


        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        range_id_list = argToList(args.get('range_id_list'))
        tags = argToList(args.get('tags'))

        search_params = []
        if range_id_list:
            search_params.append({"field": "range_id_list", "operator": "in", "value": range_id_list})
        else:
            raise ValueError('range_id_list must contain at least one entry.')

        if not tags:
            raise ValueError('a value for "tags" must be provided.')

        response = client.apply_tags_to_ranges_request(search_params=search_params, tags=tags, operation=ASSIGN)

        formatted_response = response.get('reply', {}).get('assign_tags')
        command_results = CommandResults(
            outputs=f"Assignment operation: {formatted_response}",
            raw_response=response,
            readable_output=f"Assignment operation: {formatted_response}",
            outputs_prefix='ASM.TagAssignment'
        )

        return command_results


    def remove_tag_to_ranges_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-tag-range-remove command: Assigns a tag to a list of IP Ranges.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['range_id_list']`` Range IDs to remove a tag from.
                ``args['tags']`` Name of the tags to remove from the ranges.


        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        range_id_list = argToList(args.get('range_id_list'))
        tags = argToList(args.get('tags'))

        search_params = []
        if range_id_list:
            search_params.append({"field": "range_id_list", "operator": "in", "value": range_id_list})
        else:
            raise ValueError('range_id_list must contain at least one entry.')

        if not tags:
            raise ValueError('a value for "tags" must be provided.')

        response = client.apply_tags_to_ranges_request(search_params=search_params, tags=tags, operation=REMOVE)

        formatted_response = response.get('reply', {}).get('remove_tags')
        command_results = CommandResults(
            outputs=f"Removal operation: {formatted_response}",
            raw_response=response,
            readable_output=f"Removal operation: {formatted_response}",
            outputs_prefix='ASM.TagRemoval'
        )

        return command_results


    def list_incidents_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-list-incidents command: Returns list of asm incidents.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['incident_id_list']`` List of integers of the Incident ID.
                ``args['description']`` A string to search for in the Incident description.
                ``args['status']`` The status of the incident.
                ``args['lte_creation_time']`` string of time format "2019-12-31T23:59:00".
                ``args['gte_creation_time']`` string of time format "2019-12-31T23:59:00".
                ``args['sort_by_creation_time']`` optional - enum (asc,desc).
                ``args['sort_by_severity']`` optional - enum (asc,desc).
                ``args['page']`` Page number (for pagination). The default is 0 (the first page).
                ``args['limit']`` Maximum number of incidents to return per page. The default and maximum is 100.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``, that contains external
            services.
        """
        incident_id_list = argToList(args.get('incident_id_list'))
        description = args.get('description')
        status = args.get('status')
        starred = args.get('starred')
        cloud_management_status = args.get('cloud_management_status')
        lte_creation_time = args.get('lte_creation_time')
        gte_creation_time = args.get('gte_creation_time')
        sort_by_creation_time = args.get('sort_by_creation_time')
        sort_by_severity = args.get('sort_by_severity')
        page = int(args.get('page', 0))
        limit = int(args.get('limit', MAX_ALERTS))

        search_from = page * limit
        search_to = search_from + limit

        if limit > MAX_ALERTS:
            raise ValueError('Limit cannot be more than 100, please try again')
        if sort_by_creation_time and sort_by_severity:
            raise ValueError('Should be provide either sort_by_creation_time or '
                             'sort_by_severity. Can\'t provide both')

        # starts with param to only look for ASM incidents.  Can add others if defined.
        search_params = [{"field": "alert_sources", "operator": "in", "value": ["ASM"]}]
        if incident_id_list:
            search_params.append({"field": "incident_id_list", "operator": "in", "value": incident_id_list})  # type: ignore
        if description:
            search_params.append({"field": "description", "operator": "contains", "value": description})
        if status:
            search_params.append({"field": "status", "operator": "eq", "value": status})
        if starred:
            search_params.append({"field": "starred", "operator": "eq", "value": starred})
        if cloud_management_status:
            search_params.append({"field": "cloud_management_status", "operator": "eq", "value": cloud_management_status})
        if lte_creation_time:
            search_params.append({
                'field': 'creation_time',
                'operator': 'lte',
                'value': date_to_timestamp(lte_creation_time, TIME_FORMAT)
            })
        if gte_creation_time:
            search_params.append({
                'field': 'creation_time',
                'operator': 'gte',
                'value': date_to_timestamp(gte_creation_time, TIME_FORMAT)
            })

        if sort_by_creation_time:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from,
                                             'search_to': search_to,
                                             "sort": {"field": "creation_time", "keyword": sort_by_creation_time}}}
        elif sort_by_severity:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from,
                                             'search_to': search_to, "sort": {"field": "severity", "keyword": sort_by_severity}}}
        else:
            request_data = {"request_data": {"filters": search_params, 'search_from': search_from, 'search_to': search_to}}

        response = client.list_incidents_request(request_data)

        parsed = response.get('reply', {}).get('incidents')
        markdown = tableToMarkdown('ASM Incidents', parsed, removeNull=True, headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.Incident',
            outputs_key_field='incident_id',
            outputs=parsed,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def get_incident_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-get-incident command: Returns a single incident

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['incident_id']`` Integer of the Incident ID.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``, that contains incident details
        """
        incident_id = args.get('incident_id')

        if not incident_id:
            raise ValueError('Incident ID must be provided.')

        response = client.get_incident_request(incident_id)

        parsed = response.get('reply', {})
        incident = parsed.get('incident', {})
        alerts = []
        for alert in parsed.get("alerts", {}).get("data", {}):
            alerts.append({
                "alert_id": alert.get("alert_id"),
                "name": alert.get("name"),
                "description": alert.get("description"),
                "resolution_status": alert.get("resolution_status"),
            })
        incident["alerts"] = alerts
        markdown = tableToMarkdown('ASM Incident', incident, removeNull=True, headerTransform=string_to_table_header)
        command_results = CommandResults(
            outputs_prefix='ASM.Incident',
            outputs_key_field='incident_id',
            outputs=incident,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def list_external_websites_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        list_external_websites command: Get external websites .

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['filter']`` Used for filter websites based on authentication type
                ``args['limit']`` Used for limit num of results

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        limit = int(args.get('limit', DEFAULT_SEARCH_LIMIT))
        searchFilter = args.get('authentication')
        if limit > 500:
            raise ValueError('Limit cannot be more than 500, please try again')

        filters = {'filters': [], 'search_to': limit}
        if searchFilter:
            filters['filters'] = [{'field': 'authentication',
                                   'operator': 'contains',
                                   'value': searchFilter}]

        response = client.get_external_websites(filters)

        hosts = []
        for each in response['reply']['websites']:
            hosts.append({'Host': each['host'], 'Authentication type': each['authentication']})

        human_readable = (f"Total results: {len(hosts)}\n \
            {tableToMarkdown('External Websites', hosts, ['Host', 'Authentication type'])}" if hosts else "No Results")
        command_results = CommandResults(
            outputs_prefix='ASM.ExternalWebsite',
            outputs_key_field='',
            raw_response=response,
            readable_output=human_readable
        )

        if outputs := response.get('reply', {}).get('websites', None):
            command_results.outputs = outputs

        return command_results


    def update_incident_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-update-incident command: Updates the state of an incident.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['incident_id']`` ID of the incident to modify
                ``args['alert_id']`` Used for scoping updates such as comments
                ``args['assigned_user_mail']`` Email address of the user to assign incident to
                ``args['manual_severity']`` Administrator-defined severity for the incident
                ``args['status']`` Updated incident status
                ``args['resolve_comment']`` Optional resolution comment when resolving the incident
                ``args['comment']`` A comment to add to the incident. If an alert_id is supplied it will be prefixed to the comment.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        incident_id = args.get('incident_id')
        alert_id = args.get('alert_id')
        assigned_user_mail = args.get('assigned_user_mail')
        manual_severity = args.get('manual_severity')
        status = args.get('status')
        resolve_comment = args.get('resolve_comment')
        comment = args.get('comment')

        update_params = {"update_data": {}}  # type: ignore
        if incident_id:
            update_params["incident_id"] = str(incident_id)  # type: ignore
        else:
            raise ValueError('incident_id must be defined.')

        if assigned_user_mail:
            update_params["update_data"]["assigned_user_mail"] = assigned_user_mail
        if manual_severity:
            update_params["update_data"]["manual_severity"] = manual_severity
        if status:
            if status in INCIDENT_STATUSES:
                update_params["update_data"]["status"] = status
            else:
                raise ValueError(f'status must be one of {INCIDENT_STATUSES}')
        if resolve_comment and status and "resolved" in status:
            update_params["update_data"]["resolve_comment"] = resolve_comment
        if comment:
            if alert_id:
                update_params["update_data"]["comment"] = {"comment_action": "add", "value": f"[Alert: {alert_id}] {comment}"}
            else:
                update_params["update_data"]["comment"] = {"comment_action": "add", "value": comment}

        response = client.update_incident_request(request_data=update_params)

        formatted_response = response.get('reply')
        command_results = CommandResults(
            outputs=f"Update operation successful: {formatted_response}",
            raw_response=response,
            readable_output=f"Update operation successful: {formatted_response}",
            outputs_prefix='ASM.IncidentUpdate'
        )

        return command_results


    def update_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        asm-update-alerts command: Updates the state of an alert.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['alert_id_list']`` IDs of the alerts to modify
                ``args['severity']`` The severity of the alert
                ``args['status']`` Updated alert status
                ``args['resolution_comment']`` A comment to add to the alert.

        Returns:
            CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        alert_id_list = argToList(args.get('alert_id_list'))
        severity = args.get('severity')
        status = args.get('status')
        comment = str(args.get('resolution_comment'))

        update_params = {"update_data": {}}  # type: ignore
        if alert_id_list:
            update_params["alert_id_list"] = alert_id_list
        else:
            raise ValueError('alert_id_list must be defined.')

        if severity:
            update_params["update_data"]["severity"] = severity
        if status:
            if status in ALERT_STATUSES:
                update_params["update_data"]["status"] = status
            else:
                raise ValueError(f'status must be one of {ALERT_STATUSES}')
        if comment:
            update_params["update_data"]["comment"] = comment

        response = client.update_alert_request(request_data=update_params)

        formatted_response = response.get('reply', {}).get("alerts_ids")
        command_results = CommandResults(
            outputs=f"Updated alerts: {formatted_response}",
            raw_response=response,
            readable_output=f"Updated alerts: {formatted_response}",
            outputs_prefix='ASM.UpdatedAlerts'
        )

        return command_results


    def add_note_to_asset_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """Adds an annotation (also called a note) to an asset or IP range
           using the /assets/assets_internet_exposure/annotation endpoint.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from demisto.args().
                args['asset_id'] (str): The Xpanse asset ID.
                args['entity_type'] (str): The type of Xpanse asset, Allowed values: 'asset' or 'ip_range'.
                args['annotation_note'] (str): The custom note to be added to the notes section of the asset in Xpanse

        Returns:
            CommandResults: A CommandResults demisto object that is then passed to return_results
        """
        asset_id = str(args.get('asset_id'))
        entity_type = str(args.get('entity_type'))
        note_to_add = str(args.get('note_to_add'))
        should_append = argToBoolean(args.get('should_append'))

        response = client.add_note_to_asset(asm_asset_id=asset_id,
                                            entity_type=entity_type,
                                            annotation_note=note_to_add,
                                            should_append=should_append)
        response_message = {"status": response.get('reply', {})}
        response_message['asset'] = asset_id
        markdown = tableToMarkdown('Add Note to Asset Command Results:',
                                   response_message.get('status'),
                                   headers=['Status'],
                                   removeNull=True)
        command_results = CommandResults(
            outputs_prefix='ASM.AssetAnnotation',
            outputs_key_field='',
            outputs=response_message,
            raw_response=response,
            readable_output=markdown
        )

        return command_results


    def ip_command(client: Client, args: dict[str, Any]) -> list[CommandResults]:
        """
        ip command returns enrichment for an IP address.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['ip']`` IP to enrich

        Returns:
            List of CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        ips = argToList(args.get('ip'))
        if len(ips) == 0:
            raise ValueError('ip(s) not specified')

        if len(ips) > DEFAULT_SEARCH_LIMIT:
            ips = ips[:DEFAULT_SEARCH_LIMIT]

        xpanse_ip_list_command_output: list[dict[str, Any]] = []
        xsoar_xpanse_indicator_list_command_output: list[dict[str, Any]] = []
        xsoar_indicator_list_command_output: list[dict[str, Any]] = []
        command_results = []
        ips_not_found = []

        for ip in ips:
            is_xsoar_timestamp_within_three_days = None
            xsoar_ips_of_indicators = []
            xsoar_indicators = []

            ip_version_type = ipaddress.ip_address(ip).version

            if ip_version_type == 4:
                search_xsoar_indicator_results = demisto.searchIndicators(query=f"{ip} type:IP")
                search_params = [{"field": "ip_address", "operator": "eq", "value": ip}]
            elif ip_version_type == 6:
                search_xsoar_indicator_results = demisto.searchIndicators(query=f"{ip} type:IPv6")
                search_params = [{"field": "ipv6_address", "operator": "eq", "value": ip}]
            else:
                ips_not_found.append(ip)
                continue

            if "total" in search_xsoar_indicator_results and search_xsoar_indicator_results.get('total') != 0:
                xsoar_indicators = search_xsoar_indicator_results.get('iocs')
                if not isinstance(xsoar_indicators, list):
                    xsoar_indicators = [xsoar_indicators]
                xsoar_ips_of_indicators = [entry['value'] for entry in xsoar_indicators if 'value' in entry]

            if ip in xsoar_ips_of_indicators:
                xsoar_indicators = [entry for entry in xsoar_indicators if entry.get('value') == ip]
                if len(xsoar_indicators) == 1 and "insightCache" in xsoar_indicators[0]:
                    indicator_timestamp = xsoar_indicators[0].get('insightCache').get('modified')
                    is_xsoar_timestamp_within_three_days = is_timestamp_within_days(timestamp=indicator_timestamp, days=3)

            if xsoar_indicators and is_xsoar_timestamp_within_three_days and "insightCache" in xsoar_indicators[0]:
                insight_cache = xsoar_indicators[0].get('insightCache')
                score_data = insight_cache.get('scores')
                if score_data:
                    cortex_xpanse_score = score_data.get('Cortex Xpanse')
                    if cortex_xpanse_score:
                        xpanse_indicator_data_subset = {
                            'name': xsoar_indicators[0].get('value'),
                            'indicator_type': xsoar_indicators[0].get('indicator_type'),
                            'score': xsoar_indicators[0].get('score'),
                            'reliability': cortex_xpanse_score.get('reliability'),
                            'id': xsoar_indicators[0].get('id')
                        }
                        xsoar_xpanse_indicator_list_command_output.append(xpanse_indicator_data_subset)
                    elif insight_cache and not cortex_xpanse_score:
                        indicator_sources: list = xsoar_indicators[0].get('sourceBrands')
                        non_xpanse_indicator_data_subset = {
                            'name': xsoar_indicators[0].get('value'),
                            'integrations': indicator_sources
                        }
                        xsoar_indicator_list_command_output.append(non_xpanse_indicator_data_subset)
            elif not is_xsoar_timestamp_within_three_days:
                ip_data = client.list_asset_internet_exposure_request(search_params=search_params)
                formatted_response = ip_data.get("reply", {}).get("assets_internet_exposure", {})
                if len(formatted_response) > 0:
                    formatted_response = formatted_response[0]
                else:
                    ips_not_found.append(ip)
                    continue
                formatted_response['ip'] = ip

                xpanse_ip_list_command_output.append({
                    k: formatted_response.get(k) for k in formatted_response if k in ASSET_HEADER_HEADER_LIST
                })
            else:
                ips_not_found.append(ip)

            xpanse_api_response_ip_list = [entry['ip'] for entry in xpanse_ip_list_command_output if 'ip' in entry]

            if ip in xpanse_api_response_ip_list:
                ip_standard_context = Common.IP(
                    ip=ip,
                    dbot_score=Common.DBotScore(
                        indicator=ip,
                        indicator_type=DBotScoreType.IP,
                        integration_name="CortexXpanse",
                        score=Common.DBotScore.NONE,
                        reliability=demisto.params().get('integration_reliability')
                    )
                )
                command_results.append(CommandResults(
                    readable_output=tableToMarkdown("IP indicator was found from Xpanse API", {"IP": ip}),
                    indicator=ip_standard_context
                ))

        if len(xpanse_ip_list_command_output) > 0:
            readable_output = tableToMarkdown('Xpanse Discovered IP List', xpanse_ip_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='ASM.IP',
                outputs_key_field=['name', 'asset_type'],
                outputs=xpanse_ip_list_command_output,
                raw_response=xpanse_ip_list_command_output
            ))

        if len(xsoar_indicator_list_command_output) > 0:
            markdown_body = ("This IP list is from existing records found in XSOAR within the last 3 days.\n"
                             "These IPs have not been found to be attributed to Xpanse`.")
            readable_output = tableToMarkdown("XSOAR Indicator Discovered IP List (Not Related to Xpanse)\n" + markdown_body,
                                              xsoar_indicator_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output
            ))

        if len(xsoar_xpanse_indicator_list_command_output) > 0:
            markdown_body = ("This IP list is from existing records found in XSOAR within the last 3 days.\n"
                             "If you would additional Xpanse specific information about these please use "
                             "`asm-list-asset-internet-exposure`.")
            readable_output = tableToMarkdown(name="Xpanse Discovered IP List (Existing Indicators)\n" + markdown_body,
                                              t=xsoar_xpanse_indicator_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='ASM.TIM.IP',
                outputs_key_field='name',
                outputs=xsoar_xpanse_indicator_list_command_output,
                raw_response=xsoar_xpanse_indicator_list_command_output
            ))

        if ips_not_found:
            command_results.append(CommandResults(
                readable_output=tableToMarkdown(name="IPs Not Found", t={"ip": ips_not_found})
            ))

        return command_results


    def domain_command(client: Client, args: dict[str, Any]) -> list[CommandResults]:
        """
        domain command returns enrichment for a domain.

        Args:
            client (Client): CortexXpanse client to use.
            args (dict): all command arguments, usually passed from ``demisto.args()``.
                ``args['domain']`` Domain to enrich

        Returns:
            List of CommandResults: A ``CommandResults`` object that is then passed to ``return_results``
        """
        domains = argToList(args.get('domain'))
        if len(domains) == 0:
            raise ValueError('domains(s) not specified')

        if len(domains) > DEFAULT_SEARCH_LIMIT:
            domains = domains[:DEFAULT_SEARCH_LIMIT]

        xpanse_domain_list_command_output: list[dict[str, Any]] = []
        xsoar_xpanse_indicator_list_command_output: list[dict[str, Any]] = []
        xsoar_indicator_list_command_output: list[dict[str, Any]] = []
        command_results = []
        is_xsoar_timestamp_within_three_days = None
        domains_not_found = []

        for domain in domains:
            xsoar_indicators = []
            xsoar_domains_of_indicators = []
            is_xsoar_timestamp_within_three_days = False

            if domain.startswith('*.'):
                search_xsoar_indicator_results = demisto.searchIndicators(query=f"{domain} type:DomainGlob")
            else:
                search_xsoar_indicator_results = demisto.searchIndicators(query=f"{domain} type:Domain")

            if "total" in search_xsoar_indicator_results and search_xsoar_indicator_results.get('total') != 0:
                xsoar_indicators = search_xsoar_indicator_results.get('iocs')
                if not isinstance(xsoar_indicators, list):
                    xsoar_indicators = [xsoar_indicators]
                xsoar_domains_of_indicators = [entry['value'] for entry in xsoar_indicators if 'value' in entry]

            if domain in xsoar_domains_of_indicators:
                xsoar_indicators = [entry for entry in xsoar_indicators if entry.get('value') == domain]
                if len(xsoar_indicators) == 1 and "insightCache" in xsoar_indicators[0]:
                    indicator_timestamp = xsoar_indicators[0].get('insightCache').get('modified')
                    is_xsoar_timestamp_within_three_days = is_timestamp_within_days(timestamp=indicator_timestamp, days=3)

            if xsoar_indicators and is_xsoar_timestamp_within_three_days and "insightCache" in xsoar_indicators[0]:
                insight_cache = xsoar_indicators[0].get('insightCache')
                score_data = insight_cache.get('scores')
                if score_data:
                    cortex_xpanse_score = score_data.get('Cortex Xpanse')
                    if cortex_xpanse_score:
                        indicator_data_subset = {
                            'name': xsoar_indicators[0].get('value'),
                            'indicator_type': xsoar_indicators[0].get('indicator_type'),
                            'score': xsoar_indicators[0].get('score'),
                            'reliability': cortex_xpanse_score.get('reliability'),
                            'id': xsoar_indicators[0].get('id')
                        }
                        xpanse_indicator_data = indicator_data_subset
                        xsoar_xpanse_indicator_list_command_output.append(xpanse_indicator_data)
                    elif insight_cache and not cortex_xpanse_score:
                        indicator_sources: list = xsoar_indicators[0].get('sourceBrands')
                        indicator_data_subset = {
                            'name': xsoar_indicators[0].get('value'),
                            'integrations': indicator_sources
                        }
                        non_xpanse_indicator_data = indicator_data_subset
                        xsoar_indicator_list_command_output.append(non_xpanse_indicator_data)
            elif not is_xsoar_timestamp_within_three_days:
                search_params = [
                    {"field": "name", "operator": "eq", "value": domain},
                    {"field": "type", "operator": "in", "value": ['domain']}
                ]
                domain_data = client.list_asset_internet_exposure_request(search_params=search_params)
                formatted_response = domain_data.get("reply", {}).get("assets_internet_exposure", {})
                if len(formatted_response) > 0:
                    formatted_response = formatted_response[0]
                else:
                    domains_not_found.append(domain)
                    continue
                formatted_response['domain'] = domain

                xpanse_domain_list_command_output.append({
                    k: formatted_response.get(k) for k in formatted_response if k in ASSET_HEADER_HEADER_LIST
                })
            else:
                domains_not_found.append(domain)

            xpanse_api_response_domain_list = [entry['domain'] for entry in xpanse_domain_list_command_output if 'domain' in entry]

            if domain in xpanse_api_response_domain_list:
                if domain.startswith('*.'):
                    indicator_type = DBotScoreType.DOMAINGLOB
                else:
                    indicator_type = DBotScoreType.DOMAIN

                domain_standard_context = Common.Domain(
                    domain=domain,
                    dbot_score=Common.DBotScore(
                        indicator=domain,
                        indicator_type=indicator_type,
                        integration_name="CortexXpanse",
                        score=Common.DBotScore.NONE,
                        reliability=demisto.params().get('integration_reliability')
                    )
                )

                command_results.append(CommandResults(
                    readable_output=tableToMarkdown("Domain indicator was found from Xpanse API", {"domain": domain}),
                    indicator=domain_standard_context
                ))

        if len(xpanse_domain_list_command_output) > 0:
            readable_output = tableToMarkdown('Xpanse Discovered Domain List', xpanse_domain_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='ASM.Domain',
                outputs_key_field=['name', 'asset_type'],
                outputs=xpanse_domain_list_command_output,
                raw_response=xpanse_domain_list_command_output
            ))

        if len(xsoar_indicator_list_command_output) > 0:
            markdown_body = ("This domain list is from existing records found in XSOAR within the last 3 days.\n"
                             "These domains have not been found to be attributed to Xpanse`.")
            readable_output = tableToMarkdown("XSOAR Indicator Discovered Domain List (Not Related to Xpanse)\n" + markdown_body,
                                              xsoar_indicator_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output
            ))

        if len(xsoar_xpanse_indicator_list_command_output) > 0:
            markdown_body = ("This domain list is from existing records found in XSOAR within the last 3 days.\n"
                             "If you would additional Xpanse specific information about these please use"
                             "  `asm-list-asset-internet-exposure`.")
            readable_output = tableToMarkdown(name="Xpanse Discovered Domain List (Existing Indicators)\n" + markdown_body,
                                              t=xsoar_xpanse_indicator_list_command_output)
            command_results.append(CommandResults(
                readable_output=readable_output,
                outputs_prefix='ASM.TIM.Domain',
                outputs_key_field='name',
                outputs=xsoar_xpanse_indicator_list_command_output,
                raw_response=xsoar_xpanse_indicator_list_command_output
            ))

        if domains_not_found:
            command_results.append(CommandResults(
                readable_output=tableToMarkdown(name="Domains Not Found", t={"domain": domains_not_found})
            ))

        return command_results


    def reset_last_run_command() -> str:
        """
        Puts the reset flag inside integration context.
        Returns:
            (str): 'fetch-incidents was reset successfully'.
        """
        try:
            demisto.setLastRun([])
            return 'fetch-incidents was reset successfully.'
        except DemistoException as e:
            raise DemistoException(f'Error: fetch-incidents was not reset. Reason: {e}')


    def fetch_incidents(client: Client, max_fetch: int, last_run: dict[str, int],
                        first_fetch_time: Optional[int], severity: Optional[list],
                        status: Optional[list], tags: Optional[str], look_back: int = 0
                        ) -> List[Any]:
        """
        This function will execute each interval (default is 1 minute).

        Args:
            client (Client): CortexXpanse client to use.
            max_fetch (int): Maximum numbers of incidents per fetch.
            last_run: The greatest incident created_time we fetched from last fetch
            first_fetch_time: If last_run is None then fetch all incidents since first_fetch_time
            severity: The severity of the alerts that will be fetched.

        Returns:
            next_run: This will be last_run in the next fetch-incidents
            incidents: Incidents that will be created in Cortex XSOAR
        """
        next_page_token = last_run.get('next_page_token')
        xsoar_incidents = []

        start_xpanse_fetch_time, end_xpanse_fetch_time = get_fetch_run_time_range(
            last_run=last_run, first_fetch=str(first_fetch_time), look_back=look_back, date_format=TIME_FORMAT_Z
        )

        # Create epoch timestamp for list_alerts_request()
        parsed_time = parser.isoparse(start_xpanse_fetch_time)
        look_back_epoch_time = int(parsed_time.timestamp() * 1000)
        demisto.debug(f"CortexXpanse - last fetched alert timestamp with look back: {look_back_epoch_time}")

        request_data: dict = {"request_data": {}}
        # `server_creation_time` is used to reflect the most accurate timestamp of the creation of Xpanse alerts
        filters = [
            {'field': 'alert_source', 'operator': 'in', 'value': ['ASM']},
            {'field': 'server_creation_time', 'operator': 'gte', 'value': look_back_epoch_time}
        ]

        optional_filters = {
            "severity": severity,
            "status": status,
            "tags": tags.split(',') if tags else None
        }

        for field, value in optional_filters.items():
            if value:
                filters.append({"field": field, "operator": "in", "value": value})

        if next_page_token:
            request_data["request_data"].update({"next_page_token": next_page_token})

        request_data["request_data"].update({
            'filters': filters,
            'search_from': 0,
            'search_to': max_fetch + 1,  # Alerts indexed higher than this value are not returned in the final results set.
            'use_page_token': True,
            'sort': {'field': 'server_creation_time', 'keyword': 'asc'}
        })

        demisto.debug(f"CortexXpanse - Logger - request data: {request_data}")

        raw = client.list_alerts_request(request_data)

        next_page_token = raw.get('reply', {}).get('next_page_token')
        alerts = raw.get('reply', {}).get('alerts')
        if next_page_token:
            alerts = sorted(alerts, key=lambda alert: alert['local_insert_ts'])  # Sort is not supported when using the use_page_token / next_page_token fields.  # noqa: E501

        filtered_alerts = filter_incidents_by_duplicates_and_limit(
            incidents_res=alerts, last_run=last_run, fetch_limit=(max_fetch + 1), id_field='alert_id'
        )

        for alert in filtered_alerts:
            alert_created_time = datetime.fromtimestamp(alert.get('local_insert_ts') / 1000.0).strftime(TIME_FORMAT_Z)  # local_insert_ts is the closest time to alert creation time in Xpanse.  # noqa: E501

            alert = {
                'name': alert['name'],
                'details': alert['description'],
                'occurred': alert_created_time,  # occurred in XSOAR same time a Xpanse alert was created.
                'rawJSON': json.dumps(alert),
                'xpanse_alert_id': alert['alert_id'],
                'severity': SEVERITY_DICT[alert.get('severity', 'Low')]
            }
            xsoar_incidents.append(alert)

        demisto.debug(f"CortexXpanse - Logger - Number of incidents: {len(xsoar_incidents)}")
        if len(xsoar_incidents) > 0:
            demisto.debug(f"CortexXpanse - Logger - Last fetched alert timestamp: {str(last_run.get('last_fetch', None))}")
            alert_id_list = [alert['alert_id'] for alert in filtered_alerts]
            demisto.debug(f"CortexXpanse - Logger - Xpanse alerts ingested: {alert_id_list}")
            demisto.debug(f"CortexXpanse - Logger - Request data: {request_data}")

        last_run = update_last_run_object(
            last_run=last_run,
            incidents=xsoar_incidents,
            fetch_limit=max_fetch,
            start_fetch_time=start_xpanse_fetch_time,
            end_fetch_time=end_xpanse_fetch_time,
            look_back=look_back,
            created_time_field='occurred',
            id_field='xpanse_alert_id',
            date_format=TIME_FORMAT_Z
        )
        last_run.update({'next_page_token': next_page_token})
        demisto.debug(f"CortexXpanse - Logger - last_run: {str(last_run)}")
        demisto.setLastRun(last_run)

        return xsoar_incidents


    def test_module(client: Client, params: dict[str, Any], first_fetch_time: Optional[int]) -> None:
        """
        Tests API connectivity and authentication'
        When 'ok' is returned it indicates the integration works like it is supposed to and connection to the service is
        successful.
        Raises exceptions if something goes wrong.

        Args:
            client (Client): CortexXpanse client to use.
            params (Dict): Integration parameters.
            first_fetch_time (int): The first fetch time as configured in the integration params.

        Returns:
            str: 'ok' if test passed, anything else will raise an exception and will fail the test.
        """
        try:
            client.list_external_service_request([])

            if params.get('isFetch'):  # Tests fetch incident:
                severity = params.get('severity')
                status = params.get('status')
                tags = params.get('tags')
                look_back = int(params.get('look_back', 0))
                max_fetch = int(params.get('max_fetch', 10))

                if look_back > 720:
                    raise DemistoException('The Look Back value is currently set too high. Please adjust it to 720 minutes or less.')
                fetch_incidents(
                    client=client,
                    max_fetch=max_fetch,
                    last_run={},
                    look_back=look_back,
                    first_fetch_time=first_fetch_time,
                    severity=severity,
                    status=status,
                    tags=tags
                )
        except DemistoException as e:
            if 'Forbidden' in str(e):
                raise DemistoException('Authorization Error: make sure API Key is correctly set')
            else:
                raise e
        return_results('ok')


    def main() -> None:
        """
        main function
        """
        params: dict[str, Any] = demisto.params()
        args: dict[str, Any] = demisto.args()

        command = demisto.command()
        demisto.debug(f'Command being called is {command}')

        try:
            first_fetch_time = arg_to_datetime(
                arg=params.get('first_fetch', '3 days'),
                arg_name='First fetch timestamp',
                required=True
            )
            first_fetch_timestamp = int(first_fetch_time.timestamp()) * 1000 if first_fetch_time else None
            severity = params.get('severity')
            status = params.get('status')
            tags = params.get('tags')
            look_back = int(params.get('look_back', 0))
            max_fetch = int(params.get('max_fetch', 10))
            creds = params.get('credentials', {})
            api = creds.get('password', '')
            auth_id = creds.get('identifier', '')
            headers = {
                'Authorization': f'{api}',
                'x-xdr-auth-id': f'{auth_id}',
                'Content-Type': 'application/json',
                "User-Agent": f"Cortex Xpanse Integration Pack/{PACK_VERSION} XSOAR/{DEMISTO_VERSION}"
            }

            proxy = params.get('proxy', False)
            handle_proxy()
            verify_certificate = not params.get('insecure', False)

            url = params.get('url', '')
            add_sensitive_log_strs(api)
            base_url = url
            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                headers=headers,
                proxy=proxy)

            # To debug integration instance configuration.
            integration_context = demisto.getIntegrationContext()
            if 'xpanse_integration_severity' in integration_context:
                xpanse_integration_severity = integration_context.get('xpanse_integration_severity')
                if xpanse_integration_severity != severity:
                    demisto.setIntegrationContext({"xpanse_integration_severity": severity})
                    demisto.debug(demisto.debug(f"CortexXpanse - Integration Severity: {severity}"))

            commands = {
                'asm-add-note-to-asset': add_note_to_asset_command,
                'asm-get-asset-internet-exposure': get_asset_internet_exposure_command,
                'asm-get-attack-surface-rule': list_attack_surface_rules_command,
                'asm-get-external-ip-address-range': get_external_ip_address_range_command,
                'asm-get-external-service': get_external_service_command,
                'asm-get-incident': get_incident_command,
                'asm-list-alerts': list_alerts_command,
                'asm-list-asset-internet-exposure': list_asset_internet_exposure_command,
                'asm-list-external-ip-address-range': list_external_ip_address_range_command,
                'asm-list-external-service': list_external_service_command,
                'asm-list-external-websites': list_external_websites_command,
                'asm-list-incidents': list_incidents_command,
                'asm-tag-asset-assign': assign_tag_to_assets_command,
                'asm-tag-asset-remove': remove_tag_to_assets_command,
                'asm-tag-range-assign': assign_tag_to_ranges_command,
                'asm-tag-range-remove': remove_tag_to_ranges_command,
                'asm-update-alerts': update_alert_command,
                'asm-update-incident': update_incident_command,
                'domain': domain_command,
                'ip': ip_command,
            }

            if command == 'test-module':
                test_module(client, params, first_fetch_timestamp)
            elif command == 'fetch-incidents':
                incidents = fetch_incidents(
                    client=client,
                    max_fetch=max_fetch,
                    last_run=demisto.getLastRun(),
                    first_fetch_time=first_fetch_timestamp,
                    severity=severity,
                    status=status,
                    tags=tags,
                    look_back=look_back
                )
                demisto.incidents(incidents)
            elif command == 'asm-reset-last-run':
                return_results(reset_last_run_command())
            elif command in commands:
                return_results(commands[command](client, args))
            else:
                raise NotImplementedError(f'{command} command is not implemented.')

        except Exception as e:
            return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Cortex Xpanse', 'end', __line__())
  subtype: python3
  type: python
sectionorder:
- Connect
- Collect
system: true
