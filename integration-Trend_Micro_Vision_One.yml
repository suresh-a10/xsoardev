category: Data Enrichment & Threat Intelligence
commonfields:
  id: Trend Micro Vision One
  version: -1
configuration:
- additionalinfo: The base url for the Trend Micro Vision One API
  defaultvalue: https://api.xdr.trendmicro.com
  display: API URL (e.g. https://api.xdr.trendmicro.com)
  name: url
  required: true
  type: 0
- additionalinfo: The API token to access data
  display: ""
  displaypassword: API Key
  hiddenusername: true
  name: apikey
  required: true
  type: 9
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: "5"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
- defaultvalue: Trend Micro Vision One XDR Incident
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "30"
  display: Sync On First Run (days)
  name: first_fetch
  required: false
  type: 0
- defaultvalue: "50"
  display: Max Incidents
  name: max_fetch
  required: false
  type: 0
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: B - Usually reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  type: 15
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.2.0
    itemVersion: 4.1.4
    packID: TrendMicroVisionOne
    packName: Trend Micro Vision One
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultmapperin: Trend Micro Vision One XDR - Incoming Mapper
description: Trend Micro Vision One is a purpose-built threat defense platform that
  provides added value and new benefits beyond XDR solutions, allowing you to see
  more and respond faster. Providing deep and broad extended detection and response
  (XDR) capabilities that collect and automatically correlate data across multiple
  security layers—email, endpoints, servers, cloud workloads, and networks—Trend Micro
  Vision One prevents the majority of attacks with automated protection.
detaileddescription: |
  ### Partner Contributed Integration
  #### Integration Author: Trend Micro
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [integrations@trendmicro.com](mailto:integrations@trendmicro.com)
  - **URL**: [https://success.trendmicro.com](https://success.trendmicro.com)
  ***
  # Integration Author: Trend Micro

  Support and maintenance for this integration are provided by the author. Please use the following contact details:

  - **Email**: [integrations@trendmicro.com](mailto:integrations@trendmicro.com)

  ***
  Trend Micro Vision One is a purpose-built threat defense platform that provides added value and new benefits beyond XDR solutions, allowing you to see more and respond faster. Providing deep and broad extended detection and response (XDR) capabilities that collect and automatically correlate data across multiple security layers—email, endpoints, servers, cloud workloads, and networks—Trend Micro Vision One prevents the majority of attacks with automated protection.

  ## Obtaining Trend Micro Vision One API Credentials

  Configuring the Trend Micro Vision One integration requires API credentials generated in Trend Micro Vision One. It is recommended that a new role be created with just the permissions required for this integration. You can create a new role for this integration by following these steps in Trend Micro Vision One.

  1. Navigate to **Administration** > **User Roles**
  2. Click on the **Add** button
  3. Provide a name and descriptions for the role such as **Cortex XSOAR**
  4. Click on the **Permissions** button and assign the following permissions to the role:

  | **Category**        | **Application**              | **Permission**                          |
  | ------------------- | ---------------------------- | --------------------------------------- |
  | Threat Intelligence | Suspicious Object Management | View, filter, and search                |
  | Threat Intelligence | Suspicious Object Management | Manage lists and configure settings     |
  | Threat Intelligence | Suspicious Object Management | View object in Sandbox Analysis         |
  | Threat Intelligence | Sandbox Analysis             | View, filter, and search                |
  | Threat Intelligence | Sandbox Analysis             | Submit objects                          |
  | XDR                 | Workbench                    | Add exceptions                          |
  | XDR                 | Workbench                    | Modify alert details                    |
  | XDR                 | Workbench                    | View, filter, and search                |
  | Response Management | Response Management          | View, filter, and search Task List tab  |
  | Response Management | Response Management          | Approve/Reject Automated Response tasks |
  | Response Management | Response Management          | Collect file                            |
  | Response Management | Response Management          | Delete/Quarantine messages              |
  | Response Management | Response Management          | Isolate endpoint                        |
  | Response Management | Response Management          | Terminate process                       |
  | Response Management | Response Management          | View network exceptions                 |
  | Response Management | Response Management          | Add to block list                       |
  | Response Management | Response Management          | Edit network exceptions                 |
  | Response Management | Response Management          | Submit to sandbox                       |

  You can then create a user account and generate an API key to be used for the Cortex XSOAR integration by following these steps in Trend Micro Vision One.

  1. Navigate to **Administration** > **User Accounts**
  2. Click on the **Add Account** button
  3. Fill in the **Add Account** details assigning the role you created in the previous step and choosing **APIs only** as the access level
  4. Complete the account creation process by following the steps in the email sent
  4. This will generate an **Authentication token** that can then be used to configure the Cortex XSOAR integration

  ## Configure Trend Micro Vision One on Cortex XSOAR

  1. Navigate to **Settings** > **Integrations** > **Servers & Services**.
  2. Search for Trend Micro Vision One.
  3. Click **Add instance** to create and configure a new integration instance.

  | **Parameter**            | **Description**                                                             | **Required** |
  | ------------------------ | --------------------------------------------------------------------------- | ------------ |
  | Name                     | Unique name for this Trend Micro Vision One instance                        | True         |
  | Fetch Incidents          | Choose if the integration should sync incidents                             | True         |
  | Incident Type            | Endsure the "Trend Micro Vision One XDR Incident" type is selected          | True         |
  | Mapper (Incoming)        | Endsure the "Trend Micro Vision One XDR - Incoming Mapper" type is selected | True         |
  | API URL                  | Base URL for Trend Micro Vision One API                                     | True         |
  | API Key                  | API token for authentication                                                | True         |
  | Incidents Fetch Interval | How often do you want to check for new incidents                            | False        |
  | Sync On First Run (days) | How many days to go back during first sync                                  | False        |
  | Max Incidents            | Maximum Number of Workbenches to Retrieve                                   | False        |

  4. Click **Test** to validate the URLs, token, and connection.

  ***
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/trend-micro-vision-one)
display: Trend Micro Vision One (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAACplBMVEUAAAADBQUAAAACBQUAAAAAAAACBQYAAAADBQUDBQUEBQUDBQUDBAUCBQUAAAACBQYDBAUDBgYEBgYCBQUDBQUCBQUCAwMAAAAAAAACBgYBAwMAAAAAAAAAAAADBAUCBgYDBQYCBQUCBQUCBAQCAwUAAgMEBAUDBQUAAwQDBAUCBQUCBQUDBAUCAwMABAQABATcFxzYFx4AAADTOk4ASiX/X1/eHicCBAYCBQUCBQUDAwUDBQYCBAQCBAQCBAQDAwUABATaGCH52dvhHyjdGyMCBAUDBAYCBQUEBAXeHyfeHSQDBAXbGSMAAADUDx7mpqbcGyPdGyPcGyQEBAXcFR7dICYDBgYDBgYCBQXdGiIEBgbgOEDaGCIDAwbjQ0naGR8ABATaLzbfV1feICngISvfJy7eJC3dFx/hNTzcGyPhMznbGyIEBgbdGyICBATgPEPgOULbGiDdMDndSk4AAwT97+/kVFoAAADeISnaEBn////eGyTcGyL0xsn//v7fGyTkSlDfKDH////eKzPeNDvxsrXxsLL//f3aGyP64+XdJi7bGyICBAYEBgb////cHyfdOD/bMTnbMDbdGCbcQknvur7f///cHCQDBQb////aDxjcGCHkHSfbFR3gHCTdHCThHSbbExvbERrgNDvdHyjeGyPvnaDtjpL//f364eLcFh7dIyz99fXqfYDnZ23hQkngOUDjHSb+9/f97/D77O376er2y83yq67peHzlW2H++fn64+T639/1xsf0wMLys7XvoqXul5vtkpbrgYXncHTmX2XeKDDlHSbhEBn75eb30dP1yMr0vb/zuLvwpanrhYrkV13jT1biSU/iR07gPUTfLzfhFyD/3+D53N70wsT4r7Hwe4DncXbnbHHkWmDsWWDmJy/ZCxBTAkaxAAAAl3RSTlMAXwOqJgndGfbwjPz6zivgu7GKavjUTi4j2kcVDwXr17aonXxRM8KQOr9uZ2NMQD08JQwFBALp5NCmlYB/dnNXQhj+/vjo5s/LqWxcMh8NCuze0cW6srCuoJmHelpaSUU+IRf49dnOrqufmpSLgXloXk5MPDgtKQf69fTy7u3l5ODSzMK6t7eloJSGhoWEdXVyY1VKQj8QLmikJQAABh9JREFUWMPtl1VXG1EQgCchJIRAUiGQ4qWlRVukRkuBuru7u7u7u3fvJpsQEpxSoE7d3d3ln3RWswu0T4Vzeg7fA3fnLocvM3d2lkA99dQdU5ctPjxu3KKJKwdBHbJy3LZ23RiGecB0mzZj7sS6ci+bPZ1x5FE82Q6m25ZFdaGeOnd1RTalwMHMnAi1zfEZD5Ram91ltT4s3psKtcri6Q6FNcfmfll6O//WnR+zB0ItcqSbQ66lyu/m37h+4eplmqY/7KjFg146TZFv+b3Tr9y5djvlLi1C9a62UEtMaSf3lpSXo9TGpW59dwHNB6F2aDuCoWTkYqkl7OXnaHrtCuDxzlSJxABk8VeBGmBRNxdvBWEUrVJNSMFVp1Jp+BA3ggcoxUed1J+x3sSUdwrFDvEjIk0BIgmPTySr8m5PBPZj1BLXzrhmERInhIg+TQMeUmc6/iJ2fUPxxUmCONbf32wgen//XukADQmJwKsehGhDUKwlAR38kV7x+JuNUNNDB9CKkMYY+hISbuqJeyajrLOc1F+wV6L48yzgUavVGh/SABdgxX5BeKWLJSSREzdJUbOAICYd5eLMlJBWwwhp0EYS96mQJCUl1cQ5p1Gcv2YKiFhQjAsvNgLSjJDmvBidiCT2CZKJE3HR9SSGaGlUii1tc5UWvcipdsYFKL70sC+IaKqKQ1oQEs2JTdFGRKPmxHrcHgmTJXEgIKPZUGCS4M3JzS88U1ZcrdSfaPpM2fs+NYpJ79jYFthUEd6cmBhYTKGc2Cc4nBhaLVeKsThjQeAQw2nt3x9jE1mreovLTtH0BZtjaGpNYgF9IHBig54lghcH6NDSIkspXkhIIxAYw+CcyK18VkjTp97+qlpqaz5baWve4C41iQ1RYxv1JH6JwIu1Fh2LmhdbQk341PkpxC3Zh0xghNPmzu9Ks5wvKCjNVRa67CxNfyyxZXdPrvGMLVz15gviJmEggmINxBNELlb7ExIMAsOdrjuPztJI4dWiolt2pfgp7n91UdlU/xrFODkG6InewosjQCn27i0To1CNH1Ib6hFTJdRTGrlG5ebalIW+g9vXce+PYr5TfXlx+IH0TkimKIZEmTgt3XcYRhNAZFYFlVNZyCZ82lr1gCuxs869xSLIS40tAwg3MllxFkGJfGQ24A8T99SRRDEySXsVSMxjKPt1GumaW3Vavj4vfhxZc+nSvJoBR2evpgPYVDt6eeEACcOFJwM3+3ml6XAJwpA9VBV3o6NKB2GrQKAvY39zmUYKrFXyffNI2nXi4/RvCE6IMyYAS1IeDifk8mu70vsS86Vv8pvMHPhH6CbHpfNP1MAh76/RSFGJ8p+uS6dw87mN77aK8SAQ1ob/IaLGSwlvnbcnUIeFhSmcIWxDh2qMwdHCBPl5hUYeK9J9d5FG8ovRqzjiaLO/BTLMaSDiG6kGkTiTjzZeiuZHaLUdMqS7MbH68JEWkJHkPsf1lkebY7tbhDtnpFeGp9KtCekHw0hvEPEySX86k3hlepFAMRwZHh/fkMQI0YDwiH7xPcwp4KHtdm58nCpz8UW22u5xtb9yT+y27O79JXGAKSokvL1H3NTzLow1rYKUsYliOMoM0Bw/Jk8GiWbD5oqU+YH5xG1Fit2lF7jwmdtFCTC7QRL7RJlVPRv61yAOM0WCnKYB5g76cI0QRekxWQtOajl7aI5zN24X3HyC6SNFd4ulN6Sj3RSP2C+hR6/Ijh1qEKsj2MGi0UmHoPfVBsSIUUufEHyscYzJObmVVnL+9n3PQ53tGA8eMYkxk4yWSrGYlF8MJBoSZKUOJgvFKJA0a+MdZQgCBSs2yrVXC9xWm8fLLAAPk4lxNFke5XkdjPI0l6WJn9nQIlQMI7UADfyMQtQmijQxkXSowokNZ3hp4ZUbp++jVuad11b+LKpCjSrvmEAQaSVrF12cb4LkhSy8Y0kwemZWp2atoRpJm7/kX3x+69Kr+64c1Eo4HPvQW5skD3+IX0tddrTK0203Hmqb1L6bHjgoOXkVeX2SoQ7osmCIk3HmZfOt7GTW9UmCOmLgkjFD11MOpzOv+5ARfZOhLknt0n/SkmNJyQOhnnr+T34DnwO1l/mBsm0AAAAASUVORK5CYII=
name: Trend Micro Vision One
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: 'The type of object you would like to add to the block list: "file_sha1",
        "ip", "domain", "url" or "mailbox"'
      name: value_type
      predefined:
      - file_sha1
      - domain
      - ip
      - url
      - mailbox
      required: true
    - description: The object you would like to add that matches the value-type
      name: target_value
      required: true
    - description: Target product
      name: product_id
    - description: Optional description for reference
      name: description
    description: Adds a file SHA-1, IP address, domain, or URL object to the User-Defined
      Suspicious Objects List, which blocks the objects on subsequent detections
    name: trendmicro-visionone-add-to-block-list
    outputs:
    - contextPath: VisionOne.BlockList.actionId
      description: Action ID of task adding file SHA-1, IP address, domain, or URL
        to the User-Defined Suspicious Objects List
      type: string
    - contextPath: VisionOne.BlockList.taskStatus
      description: Task status of adding file SHA-1, IP address, domain, or URL object
        to the User-Defined Suspicious Objects List
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of object you would like to remove from the block list:
        "file_sha1", "ip", "domain", "url" or "mailbox"'
      name: value_type
      predefined:
      - file_sha1
      - domain
      - ip
      - url
      - mailbox
      required: true
    - description: The object you would like to add that matches the value-type
      name: target_value
      required: true
    - description: Target product
      name: product_id
    - description: Optional description for reference
      name: description
    description: Removes a file SHA-1, IP address, domain, or URL from the User-Defined
      Suspicious Objects List
    name: trendmicro-visionone-remove-from-block-list
    outputs:
    - contextPath: VisionOne.BlockList.actionId
      description: Action ID of task removing file SHA-1, IP address, domain, or URL
        object from the User-Defined Suspicious Objects List
      type: string
    - contextPath: VisionOne.BlockList.taskStatus
      description: Task Status of removing file SHA-1, IP address, domain, or URL
        object that was added to the User-Defined Suspicious Objects List from block
        list
      type: string
  - arguments:
    - description: Email Message ID from Trend Micro Vision One message activity data
      name: message_id
      required: true
    - description: Email mailbox where the message will be quarantined from
      name: mailbox
      required: true
    - description: Email message's original delivery time
      name: message_delivery_time
      required: true
    - default: true
      defaultValue: sca
      description: Target product
      name: product_id
    - description: Optional description for reference
      name: description
    description: Moves a message from a mailbox to the quarantine folder
    name: trendmicro-visionone-quarantine-email-message
    outputs:
    - contextPath: VisionOne.Email.actionId
      description: The Action Id of moving a message from a mailbox to the quarantine
        folder
      type: string
    - contextPath: VisionOne.Email.taskStatus
      description: The status of moving a message from a mailbox to the quarantine
        folder
      type: string
  - arguments:
    - description: Email Message ID from Trend Micro Vision One message activity data
      name: message_id
      required: true
    - description: Email mailbox where the message will be quarantined from
      name: mailbox
      required: true
    - description: Email message's delivery time
      name: message_delivery_time
      required: true
    - default: true
      defaultValue: sca
      description: Target product
      name: product_id
    - description: Optional description for reference
      name: description
    description: Deletes a message from a mailbox
    name: trendmicro-visionone-delete-email-message
    outputs:
    - contextPath: VisionOne.Email.actionId
      description: The action id of deleting a message from a mailbox
      type: string
    - contextPath: VisionOne.Email.taskStatus
      description: The task status of deleting a message from a mailbox
      type: string
  - arguments:
    - description: '"hostname", "macaddr" or "ip" of the endpoint to isolate'
      name: endpoint
      required: true
    - auto: PREDEFINED
      default: true
      defaultValue: sao
      description: 'Target product: "sao", "sds", or "xes"'
      name: product_id
      predefined:
      - sao
      - sds
      - xes
      required: true
    - description: Description
      name: description
    description: Disconnects an endpoint from the network (but allows communication
      with the managing Trend Micro product)
    name: trendmicro-visionone-isolate-endpoint
    outputs:
    - contextPath: VisionOne.Endpoint_Connection.actionId
      description: The action ID of isolate endpoint task
      type: string
    - contextPath: VisionOne.Endpoint_Connection.taskStatus
      description: 'The task status of isolate endpoint '
      type: string
  - arguments:
    - description: '"hostname", "macaddr" or "ip" of the endpoint to restore'
      name: endpoint
      required: true
    - auto: PREDEFINED
      default: true
      defaultValue: sao
      description: 'Target product: "sao", "sds", or "xes"'
      name: product_id
      predefined:
      - sao
      - sds
      - xes
      required: true
    - description: Description
      name: description
    description: Restores network connectivity to an endpoint that applied the "isolate
      endpoint" action
    name: trendmicro-visionone-restore-endpoint-connection
    outputs:
    - contextPath: VisionOne.Endpoint_Connection.actionId
      description: The action ID of the restore endpoint connection
      type: string
    - contextPath: VisionOne.Endpoint_Connection.taskStatus
      description: The task status of restore endpoint connection
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'Object type: "domain", "ip", "sha1", or "url".'
      name: type
      predefined:
      - domain
      - ip
      - sha1
      - url
      required: true
    - description: The object value. Full and partial matches supported. Domain partial
        match, (with a wildcard as the subdomain, example, .example.com) IP partial
        match, (IP range example, 192.168.35.1-192.168.35.254, cidr example, 192.168.35.1/24)
        URL Partial match, (Supports wildcards 'http://.'', 'https://.'' at beginning,
        or ''' at the end. Multiple wild cards also supported, such as , https://.example.com/path1/)
        SHA1 Only full match"
      name: value
      required: true
    - description: Exception description.
      name: description
    description: Adds domains, file SHA-1 values, IP addresses, or URLs to the Exception
      List and prevents these objects from being added to the Suspicious Object List
    name: trendmicro-visionone-add-objects-to-exception-list
    outputs:
    - contextPath: VisionOne.Exception_List.message
      description: status message success after task completion
      type: string
    - contextPath: VisionOne.Exception_List.status_code
      description: status code of response
      type: string
    - contextPath: VisionOne.Exception_List.total_items
      description: count of item present in exception list
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'Object type: "domain", "ip", "sha1", or "url".'
      name: type
      predefined:
      - domain
      - ip
      - sha1
      - url
      required: true
    - description: The object value.
      name: value
      required: true
    description: Deletes domains, file SHA-1 values, IP addresses, or URLs from the
      Exception List.
    name: trendmicro-visionone-delete-objects-from-exception-list
    outputs:
    - contextPath: VisionOne.Exception_List.message
      description: status message success after task completion
      type: string
    - contextPath: VisionOne.Exception_List.status_code
      description: status code of response
      type: number
    - contextPath: VisionOne.Exception_List.total_items
      description: count of item present in exception list
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'Object type: "domain", "ip", "sha1", or "url".'
      name: type
      predefined:
      - domain
      - ip
      - sha1
      - url
      required: true
    - description: The object value.
      name: value
      required: true
    - description: Description
      name: description
    - auto: PREDEFINED
      description: The action to take if object is found. If you don't use this parameter,
        the scan action specified in default_settings.riskLevel.type will be used
        instead. "block" or "log".
      name: scan_action
      predefined:
      - block
      - log
    - auto: PREDEFINED
      description: The Suspicious Object risk level. If you don't use this parameter,
        high will be used instead. "high", "medium" or "low".
      name: risk_level
      predefined:
      - high
      - medium
      - low
    - description: The number of days to keep the object in the Suspicious Object
        List. If you don't use this parameter, the default_settings.expiredDay scan
        action will be used instead.
      name: expiry_days
    description: Adds domains, file SHA-1 values, IP addresses, or URLs to the Suspicious
      Object List.
    name: trendmicro-visionone-add-objects-to-suspicious-list
    outputs:
    - contextPath: VisionOne.Suspicious_List.message
      description: Status message of adding item to suspicious object list
      type: string
    - contextPath: VisionOne.Suspicious_List.status_code
      description: Response code of adding item to suspicious object list
      type: number
    - contextPath: VisionOne.Suspicious_List.total_items
      description: Number of items present in suspicious object list
      type: number
  - arguments:
    - auto: PREDEFINED
      description: 'Object type: "domain", "ip", "sha1", or "url".'
      name: type
      predefined:
      - domain
      - ip
      - sha1
      - url
      required: true
    - description: The object value.
      name: value
      required: true
    description: Deletes domains, file SHA-1 values, IP addresses, or URLs from the
      Suspicious Object List
    name: trendmicro-visionone-delete-objects-from-suspicious-list
    outputs:
    - contextPath: VisionOne.Suspicious_List.message
      description: Status message of removing item from suspicious object list
      type: string
    - contextPath: VisionOne.Suspicious_List.status_code
      description: Response code of removing item from suspicious object list
      type: number
    - contextPath: VisionOne.Suspicious_List.total_items
      description: Number of items present in suspicious object list
      type: number
  - arguments:
    - description: '"hostname", "macaddr" or "ip" of the endpoint to query'
      name: endpoint
      required: true
    description: Retrieves information about a specific endpoint
    name: trendmicro-visionone-get-endpoint-info
    outputs:
    - contextPath: VisionOne.Endpoint_Info.message
      description: Message information from the request
      type: string
    - contextPath: VisionOne.Endpoint_Info.errorCode
      description: Error code
      type: integer
    - contextPath: VisionOne.Endpoint_Info.status
      description: Status of the request
      type: string
    - contextPath: VisionOne.Endpoint_Info.logonAccount
      description: Account currently logged on to the endpoint
      type: string
    - contextPath: VisionOne.Endpoint_Info.hostname
      description: Hostname
      type: string
    - contextPath: VisionOne.Endpoint_Info.macAddr
      description: MAC address
      type: string
    - contextPath: VisionOne.Endpoint_Info.ip
      description: IP address
      type: string
    - contextPath: VisionOne.Endpoint_Info.osName
      description: Operating System name
      type: string
    - contextPath: VisionOne.Endpoint_Info.osVersion
      description: Operating System nersion
      type: string
    - contextPath: VisionOne.Endpoint_Info.osDescription
      description: Description of the Operating System
      type: string
    - contextPath: VisionOne.Endpoint_Info.productCode
      description: Product code of the Trend Micro product running on the endpoint
      type: string
  - arguments:
    - description: '"hostname", "macaddr" or "ip" of the endpoint to terminate process
        on'
      name: endpoint
      required: true
    - description: SHA1 hash of the process to terminate
      name: file_sha1
      required: true
    - auto: PREDEFINED
      default: true
      defaultValue: sao
      description: Target product
      name: product_id
      predefined:
      - sao
    - description: Description
      name: description
    - description: Optional file name list for log
      name: filename
    description: Terminates a process that is running on an endpoint
    name: trendmicro-visionone-terminate-process
    outputs:
    - contextPath: VisionOne.Terminate_Process.actionId
      description: Action Id of the current running task
      type: string
    - contextPath: VisionOne.Terminate_Process.taskStatus
      description: Status of current running task
      type: string
  - arguments:
    - description: task_id from the trendmicro-visionone-submit-file-to-sandbox command
        output
      name: task_id
      required: true
    description: Retrieves the status of a sandbox analysis submission
    name: trendmicro-visionone-get-file-analysis-status
    outputs:
    - contextPath: VisionOne.File_Analysis_Status.message
      description: Status of the sandbox analysis
      type: string
    - contextPath: VisionOne.File_Analysis_Status.code
      description: Response code
      type: string
    - contextPath: VisionOne.File_Analysis_Status.task_id
      description: task_id of the task queried
      type: string
    - contextPath: VisionOne.File_Analysis_Status.taskStatus
      description: Sandbox analysis status
      type: string
    - contextPath: VisionOne.File_Analysis_Status.digest
      description: The hash values of file analyzed
      type: string
    - contextPath: VisionOne.File_Analysis_Status.analysis_completion_time
      description: Sample analysis completed time.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.risk_level
      description: Risk Level of the analyzed file.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.descritption
      description: Scan result description for NotAnalyzed.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.detection_name_list
      description: Detection name of this sample, if applicable.
      type: unknown
    - contextPath: VisionOne.File_Analysis_Status.threat_type_list
      description: Threat type of this sample.
    - contextPath: VisionOne.File_Analysis_Status.file_type
      description: File type of this sample.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.report_id
      description: ID used to get the report and suspicious object. Empty means no
        report.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.DBotScore.Score
      description: The DBot score.
      type: number
    - contextPath: VisionOne.File_Analysis_Status.DBotScore.Vendor
      description: The Vendor name.
      type: string
    - contextPath: VisionOne.File_Analysis_Status.DBotScore.Reliability
      description: The Reliability level.
      type: string
  - arguments:
    - description: report_id of the sandbox submission retrieved from the trendmicro-visionone-get-file-analysis-status
        command
      name: report_id
      required: true
    - auto: PREDEFINED
      description: 'Type of report to retrieve: "vaReport", "investigationPackage",
        or "suspiciousObject"'
      name: type
      predefined:
      - vaReport
      - investigationPackage
      - suspiciousObject
      required: true
    description: Retrieves the analysis report, investigation package, or Suspicious
      Object List of a submitted file
    name: trendmicro-visionone-get-file-analysis-report
    outputs:
    - contextPath: VisionOne.File_Analysis_Report.message
      description: Status message of file report
      type: string
    - contextPath: VisionOne.File_Analysis_Report.code
      description: status code of file report
      type: string
    - contextPath: VisionOne.File_Analysis_Report.type
      description: Suspicious object type
      type: string
    - contextPath: VisionOne.File_Analysis_Report.value
      description: Suspicious object value
      type: string
    - contextPath: VisionOne.File_Analysis_Report.risk_level
      description: Risk Level of suspicious object
      type: string
    - contextPath: VisionOne.File_Analysis_Report.analysis_completion_time
      description: Analyze time of suspicious object
      type: string
    - contextPath: VisionOne.File_Analysis_Report.expired_time
      description: Expire time of suspicious object
      type: string
    - contextPath: VisionOne.File_Analysis_Report.root_file_sha1
      description: Sample sha1 generate this suspicious object
      type: string
  - arguments:
    - description: '"hostname", "macaddr" or "ip" of the endpoint to collect file
        from'
      name: endpoint
      required: true
    - auto: PREDEFINED
      description: 'Product: "sao", "sds" or "xes"'
      name: product_id
      predefined:
      - sao
      - xes
      - sds
      required: true
    - description: Path to the file to collect.
      name: file_path
      required: true
    - description: Type of OS. "windows", "mac" or "linux"
      name: os
      required: true
    - description: Description of the file.
      name: description
    description: Compresses a file on an endpoint in a password-protected archive
      and then sends the archive to the XDR service platform
    name: trendmicro-visionone-collect-forensic-file
    outputs:
    - contextPath: VisionOne.Collect_Forensic_File.actionId
      description: Action ID of the particular file.
      type: string
    - contextPath: VisionOne.Collect_Forensic_File.taskStatus
      description: Task status of collected file
      type: string
  - arguments:
    - description: actionId output from the collect command used to collect the file.
      name: actionId
      required: true
    description: Retrieves a URL and other information required to download a collected
      file via the trendmicro-visionone-collect-forensic-file command
    name: trendmicro-visionone-download-information-for-collected-forensic-file
    outputs:
    - contextPath: VisionOne.Download_Information_For_Collected_Forensic_File.url
      description: URL of the collected file
      type: string
    - contextPath: VisionOne.Download_Information_For_Collected_Forensic_File.expires
      description: URL expiration date
      type: string
    - contextPath: VisionOne.Download_Information_For_Collected_Forensic_File.password
      description: Archive password for the protected forensic file
      type: string
    - contextPath: VisionOne.Download_Information_For_Collected_Forensic_File.filename
      description: Name of the collected file
      type: string
  - arguments:
    - description: URL pointing to the location of the file to be submitted.
      name: file_url
      required: true
    - description: Name of the file to be analyzed
      name: filename
      required: true
    - description: The Base64 encoded password for decrypting the submitted document.
        sample.
      name: document_password
    - description: The Base64 encoded password for decrypting the submitted archive.
      name: archive_password
    description: Submits a file to the sandbox for analysis (Note. For more information
      about the supported file types, see the Trend Micro Vision One Online Help.
      Submissions require credits. Does not require credits in regions where Sandbox
      Analysis has not been officially released.)
    name: trendmicro-visionone-submit-file-to-sandbox
    outputs:
    - contextPath: VisionOne.Submit_File_to_Sandbox.message
      description: Status message of the file submitted to sandbox.
      type: string
    - contextPath: VisionOne.Submit_File_to_Sandbox.code
      description: status code of the file submitted to sandbox
      type: string
    - contextPath: VisionOne.Submit_File_to_Sandbox.task_id
      description: Task ID of the submitted file
      type: string
    - contextPath: VisionOne.Submit_File_to_Sandbox.digest
      description: The hash value of the file
  - arguments:
    - description: Entry ID of the file to be submitted.
      name: entry_id
      required: true
    - description: The Base64 encoded password for decrypting the submitted document.
        sample.
      name: document_password
    - description: The Base64 encoded password for decrypting the submitted archive.
      name: archive_password
    description: Submits the file corresponding to EntryID to the sandbox for analysis
      (Note. For more information about the supported file types, see the Trend Micro
      Vision One Online Help. Submissions require credits. Does not require credits
      in regions where Sandbox Analysis has not been officially released.)
    name: trendmicro-visionone-submit-file-entry-to-sandbox
    outputs:
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.message
      description: Status message of the file submitted to sandbox.
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.code
      description: status code of the file submitted to sandbox
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.task_id
      description: Task ID of the submitted file
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.digest
      description: The hash value of the file
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.filename
      description: The name of the file submitted
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.file_path
      description: The path to the file associated to incident
      type: string
    - contextPath: VisionOne.Submit_File_Entry_to_Sandbox.entryId
      description: The Entry ID for the file
      type: string
  - arguments:
    - default: true
      defaultValue: "true"
      description: polling the task for 30 seconds interval.
      name: polling
    - description: task_id from the trendmicro-visionone-submit-file-to-sandbox or
        trendmicro-visionone-submit-file-entry-to-sandbox command output
      name: task_id
      required: true
    description: Runs a polling command to retrieve the status of a sandbox analysis
      submission
    name: trendmicro-visionone-run-sandbox-submission-polling
    outputs:
    - contextPath: VisionOne.Sandbox_Submission_Polling.message
      description: Status of the sandbox analysis
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.code
      description: Response code
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.task_id
      description: task_id of the task queried
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.taskStatus
      description: Sandbox analysis status
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.digest
      description: The hash values of file analyzed
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.analysis_completion_time
      description: Sample analysis completed time.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.risk_level
      description: Risk Level of the analyzed file.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.description
      description: Scan result description for NotAnalyzed.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.detection_name_list
      description: Detection name of this sample, if applicable.
      type: unknown
    - contextPath: VisionOne.Sandbox_Submission_Polling.threat_type_list
      description: Threat type of this sample.
      type: unknown
    - contextPath: VisionOne.Sandbox_Submission_Polling.file_type
      description: File type of this sample.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.report_id
      description: ID used to get the report and suspicious object. Empty means no
        report.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.DBotScore.Score
      description: The DBot score.
      type: number
    - contextPath: VisionOne.Sandbox_Submission_Polling.DBotScore.Vendor
      description: The Vendor name.
      type: string
    - contextPath: VisionOne.Sandbox_Submission_Polling.DBotScore.Reliability
      description: The Reliability level.
      type: string
    polling: true
  - arguments:
    - default: true
      defaultValue: "true"
      description: polling the task for 30 seconds interval.
      name: polling
    - description: Action id of the task you would like to check.
      name: actionId
      required: true
    description: Command gives the status of the running task based on the action
      id.
    name: trendmicro-visionone-check-task-status
    outputs:
    - contextPath: VisionOne.Task_Status.actionId
      description: Action ID of the task queried.
    - contextPath: VisionOne.Task_Status.taskStatus
      description: Status of the task.
    polling: true
  - arguments:
    - description: ID of the workbench you would like to attach the note to.
      name: workbench_id
      required: true
    - description: Contents of the note to be attached
      name: content
      required: true
    description: Attaches a note to a workbench alert
    name: trendmicro-visionone-add-note
    outputs:
    - contextPath: VisionOne.Add_Note.Workbench_Id
      description: The ID of the workbench that the note was added to.
      type: string
    - contextPath: VisionOne.Add_Note.Note_Id
      description: The ID of the note that was added.
      type: string
    - contextPath: VisionOne.Add_Note.Response_Code
      description: The response code from the command
      type: string
    - contextPath: VisionOne.Add_Note.Response_Msg
      description: The response message from the command
      type: string
  - arguments:
    - description: ID of the workbench you would like to update the status for.
      name: workbench_id
      required: true
    - auto: PREDEFINED
      description: Status to assign to the workbench alert
      name: status
      predefined:
      - new
      - in_progress
      - resolved_true_positive
      - resolved_false_positive
      required: true
    description: Updates the status of a workbench alert
    name: trendmicro-visionone-update-status
    outputs:
    - contextPath: VisionOne.Update_Status.Workbench_Id
      description: The ID of the workbench that had the status updated.
      type: string
    - contextPath: VisionOne.Update_Status.Response_Code
      description: The response code from the command
      type: string
    - contextPath: VisionOne.Update_Status.Response_Msg
      description: The response message from the command
      type: string
  dockerimage: demisto/python3:3.10.14.90585
  isFetchSamples: true
  isfetch: true
  runonce: false
  script: |
    register_module_line('Trend Micro Vision One', 'start', __line__())
    demisto.debug('pack name = Trend Micro Vision One, pack version = 4.1.4')


    """IMPORTS"""


    import base64
    import json
    import requests
    import urllib3
    import re
    from datetime import datetime, timezone, timedelta
    from typing import Any, Dict, Union
    from requests.models import HTTPError

    """CONSTANTS"""
    USER_AGENT = "TMV1CortexXSOARApp/1.1"
    VENDOR_NAME = "TrendMicroVisionOne"
    URL = "url"
    POST = "post"
    GET = "get"
    PUT = "put"
    AUTHORIZATION = "Authorization"
    BEARER = "Bearer "
    CONTENT_TYPE_JSON = "application/json"
    EMPTY_STRING = ""
    ASCII = "ascii"
    API_TOKEN = "apikey"
    VALUE_TYPE = "value_type"
    TARGET_VALUE = "target_value"
    PRODUCT_ID = "product_id"
    DESCRIPTION = "description"
    MESSAGE_ID = "message_id"
    MAILBOX = "mailbox"
    MESSAGE_DELIVERY_TIME = "message_delivery_time"
    COMPUTER_ID = "computer_id"
    FIELD = "field"
    ENDPOINT = "endpoint"
    DATA = "data"
    TYPE = "type"
    VALUE = "value"
    FILESHA = "file_sha1"
    FILENAME = "filename"
    CRITERIA = "criteria"
    EXCEPTION_LIST = "exceptionList"
    SUSPICIOUS_LIST = "suspiciousObjectList"
    LAST_MODIFIED = "lastModified"
    SCAN_ACTION = "scan_action"
    RISK_LEVEL = "risk_level"
    EXPIRYDAY = "expiry_days"
    TASKID = "task_id"
    REPORT_ID = "report_id"
    ENTRY_ID = "entry_id"
    TASKSTATUS = "taskStatus"
    OS_TYPE = "os"
    FILE_PATH = "file_path"
    FILE_URL = "file_url"
    FILE_NAME = "filename"
    DOCUMENT_PASSWORD = "document_password"
    ARCHIVE_PASSWORD = "archive_password"
    ACTION_ID = "actionId"
    WORKBENCH_ID = "workbench_id"
    CONTENT = "content"
    STATUS = "status"
    # End Points
    ADD_BLOCKLIST_ENDPOINT = "/v2.0/xdr/response/block"
    REMOVE_BLOCKLIST_ENDPOINT = "/v2.0/xdr/response/restoreBlock"
    QUARANTINE_EMAIL_ENDPOINT = "/v2.0/xdr/response/quarantineMessage"
    DELETE_EMAIL_ENDPOINT = "/v2.0/xdr/response/deleteMessage"
    ISOLATE_CONNECTION_ENDPOINT = "/v2.0/xdr/response/isolate"
    TERMINATE_PROCESS_ENDPOINT = "/v2.0/xdr/response/terminateProcess"
    RESTORE_CONNECTION_ENDPOINT = "/v2.0/xdr/response/restoreIsolate"
    ADD_OBJECT_TO_EXCEPTION_LIST = "/v2.0/xdr/threatintel/suspiciousObjects/exceptions"
    DELETE_OBJECT_FROM_EXCEPTION_LIST = (
        "/v2.0/xdr/threatintel/suspiciousObjects/exceptions/delete"
    )
    ADD_OBJECT_TO_SUSPICIOUS_LIST = "/v2.0/xdr/threatintel/suspiciousObjects"
    DELETE_OBJECT_FROM_SUSPICIOUS_LIST = "/v2.0/xdr/threatintel/suspiciousObjects/delete"
    TASK_DETAIL_ENDPOINT = "/v2.0/xdr/response/getTask"
    GET_COMPUTER_ID_ENDPOINT = "/v2.0/xdr/eiqs/query/agentInfo"
    GET_ENDPOINT_INFO_ENDPOINT = "/v2.0/xdr/eiqs/query/endpointInfo"
    GET_FILE_STATUS = "/v2.0/xdr/sandbox/tasks/{taskId}"
    GET_FILE_REPORT = "/v2.0/xdr/sandbox/reports/{reportId}"
    ADD_NOTE_ENDPOINT = "/v2.0/xdr/workbench/workbenches/{workbenchId}/notes"
    UPDATE_STATUS_ENDPOINT = "/v2.0/xdr/workbench/workbenches/{workbenchId}"
    COLLECT_FORENSIC_FILE = "/v2.0/xdr/response/collectFile"
    DOWNLOAD_INFORMATION_COLLECTED_FILE = "/v2.0/xdr/response/downloadInfo"
    SUBMIT_FILE_TO_SANDBOX = "/v2.0/xdr/sandbox/file"
    WORKBENCH_HISTORIES = "/v2.0/xdr/workbench/workbenchHistories"
    # Error Messages
    RESPONSE_ERROR = "Error in API call: [%d] - %s"
    RETRY_ERROR = "The max tries exceeded [%d] - %s"
    COMMAND_CALLED = "Command being called is {command}"
    COMMAND_EXECUTION_ERROR = "Failed to execute {error} command. Error"
    AUTHORIZATION_ERROR = (
        "Authorization Error: make sure URL/API Key is correctly set. Error - {error}"
    )
    PARAMETER_ISSUE = "{param} is not a valid parameter. Kindly provide valid parameter"
    FILE_TYPE_ERROR = "Kindly provide valid file 'type'"
    FILE_NOT_FOUND = "No such file present in {filepath}"
    # General Messages:
    RAW_RESPONSE = "The raw response data - {raw_response}"
    SUCCESS_RESPONSE = "success with url {url} and response status {status}"
    EXCEPTION_MESSAGE = "Successfully {task} object to exception list with response {code}, Total items in exception list - {length}"
    SUCCESS_TEST = "Successfully connected to the vision one API."
    POLLING_MESSAGE = "The task has not completed, will check status again in 30 seconds"
    # Workbench Statuses
    NEW = 0
    IN_PROGRESS = 1
    RESOLVED_TRUE_POSITIVE = 2
    RESOLVED_FALSE_POSITIVE = 3
    # Table Heading
    TABLE_ADD_TO_BLOCKLIST = "Add to block list "
    TABLE_REMOVE_FROM_BLOCKLIST = "Remove from block list "
    TABLE_QUARANTINE_EMAIL_MESSAGE = "Quarantine email message "
    TABLE_DELETE_EMAIL_MESSAGE = "Delete email message "
    TABLE_ISOLATE_ENDPOINT_MESSAGE = "Isolate endpoint connection "
    TABLE_RESTORE_ENDPOINT_MESSAGE = "Restore endpoint connection "
    TABLE_TERMINATE_PROCESS = "Terminate process "
    TABLE_ADD_EXCEPTION_LIST = "Add object to exception list "
    TABLE_DELETE_EXCEPTION_LIST = "Delete object from exception list "
    TABLE_ADD_SUSPICIOUS_LIST = "Add object to suspicious list "
    TABLE_ENDPOINT_INFO = "Endpoint info "
    TABLE_DELETE_SUSPICIOUS_LIST = "Delete object from suspicious list "
    TABLE_GET_FILE_ANALYSIS_STATUS = "File analysis status "
    TABLE_GET_FILE_ANALYSIS_REPORT = "File analysis report "
    TABLE_COLLECT_FILE = "Collect forensic file "
    TABLE_COLLECTED_FORENSIC_FILE_DOWNLOAD_INFORMATION = (
        "The download information for collected forensic file "
    )
    TABLE_SUBMIT_FILE_TO_SANDBOX = "Submit file to sandbox "
    TABLE_SUBMIT_FILE_ENTRY_TO_SANDBOX = "Submit file entry to sandbox "
    TABLE_SANDBOX_SUBMISSION_POLLING = "Sandbox submission polling status "
    TABLE_ADD_NOTE = "Add note to workbench alert "
    TABLE_UPDATE_STATUS = "Update workbench alert status"
    # COMMAND NAMES
    ADD_BLOCKLIST_COMMAND = "trendmicro-visionone-add-to-block-list"
    REMOVE_BLOCKLIST_COMMAND = "trendmicro-visionone-remove-from-block-list"
    QUARANTINE_EMAIL_COMMAND = "trendmicro-visionone-quarantine-email-message"
    DELETE_EMAIL_COMMAND = "trendmicro-visionone-delete-email-message"
    ISOLATE_ENDPOINT_COMMAND = "trendmicro-visionone-isolate-endpoint"
    RESTORE_ENDPOINT_COMMAND = "trendmicro-visionone-restore-endpoint-connection"
    TERMINATE_PROCESS_COMMAND = "trendmicro-visionone-terminate-process"
    ADD_EXCEPTION_LIST_COMMAND = "trendmicro-visionone-add-objects-to-exception-list"
    DELETE_EXCEPTION_LIST_COMMAND = (
        "trendmicro-visionone-delete-objects-from-exception-list"
    )
    ADD_SUSPICIOUS_LIST_COMMAND = "trendmicro-visionone-add-objects-to-suspicious-list"
    DELETE_SUSPICIOUS_LIST_COMMAND = (
        "trendmicro-visionone-delete-objects-from-suspicious-list"
    )
    GET_FILE_ANALYSIS_STATUS = "trendmicro-visionone-get-file-analysis-status"
    GET_FILE_ANALYSIS_REPORT = "trendmicro-visionone-get-file-analysis-report"
    COLLECT_FILE = "trendmicro-visionone-collect-forensic-file"
    DOWNLOAD_COLLECTED_FILE = (
        "trendmicro-visionone-download-information-for-collected-forensic-file"
    )
    FILE_TO_SANDBOX = "trendmicro-visionone-submit-file-to-sandbox"
    FILE_ENTRY_TO_SANDBOX = "trendmicro-visionone-submit-file-entry-to-sandbox"
    SANDBOX_SUBMISSION_POLLING = "trendmicro-visionone-run-sandbox-submission-polling"
    CHECK_TASK_STATUS = "trendmicro-visionone-check-task-status"
    GET_ENDPOINT_INFO_COMMAND = "trendmicro-visionone-get-endpoint-info"
    UPDATE_STATUS = "trendmicro-visionone-update-status"
    ADD_NOTE = "trendmicro-visionone-add-note"
    FETCH_INCIDENTS = "fetch-incidents"

    table_name = {
        ADD_BLOCKLIST_COMMAND: TABLE_ADD_TO_BLOCKLIST,
        REMOVE_BLOCKLIST_COMMAND: TABLE_REMOVE_FROM_BLOCKLIST,
        QUARANTINE_EMAIL_COMMAND: TABLE_QUARANTINE_EMAIL_MESSAGE,
        DELETE_EMAIL_COMMAND: TABLE_DELETE_EMAIL_MESSAGE,
        ISOLATE_ENDPOINT_COMMAND: TABLE_ISOLATE_ENDPOINT_MESSAGE,
        RESTORE_ENDPOINT_COMMAND: TABLE_RESTORE_ENDPOINT_MESSAGE,
        ADD_EXCEPTION_LIST_COMMAND: TABLE_ADD_EXCEPTION_LIST,
        DELETE_EXCEPTION_LIST_COMMAND: TABLE_DELETE_EXCEPTION_LIST,
        ADD_SUSPICIOUS_LIST_COMMAND: TABLE_ADD_SUSPICIOUS_LIST,
        GET_ENDPOINT_INFO_COMMAND: TABLE_ENDPOINT_INFO,
        DELETE_SUSPICIOUS_LIST_COMMAND: TABLE_DELETE_SUSPICIOUS_LIST,
    }
    # disable insecure warnings
    urllib3.disable_warnings()


    def check_datetime_aware(d):
        return (d.tzinfo is not None) and (d.tzinfo.utcoffset(d) is not None)


    class Client(BaseClient):
        def __init__(self, base_url: str, api_key: str, proxy: bool, verify: bool) -> None:
            """
            Inherit the BaseClient class from the demistomock.
            :type base_url: ``str``
            :param base_url: Base server address with suffix, for example: https://example.com/api/v2/.
            :type api_key: ``str``
            :param api_key: api token to access the api data.
            :type proxy: ``bool``
            :param proxy: Whether the request should use the system proxy settings.
            :type verify: ``bool``
            :param verify: Whether the request should verify the SSL certificate.
            :return: returns None
            :rtype: ``None``
            """
            self.base_url = base_url
            self.api_key = api_key
            self.status = None

            super().__init__(base_url=base_url, proxy=proxy, verify=verify)

        def http_request(
            self, method: str, url_suffix: str, json_data=None, params=None, data=None
        ) -> Any:
            """
            Override http_request method from BaseClient class. This method will print an error based on status code
            and exceptions.
            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.
            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.
            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.
            :type params: ``dict``
            :param params: URL parameters to specify the query.
            :type data: ``dict``
            :param data: The data to send in a 'POST' request.
            :return: response data
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """
            header = {
                "Authorization": "Bearer {token}".format(token=self.api_key),
                "Content-Type": f"{CONTENT_TYPE_JSON};charset=utf-8",
                "User-Agent": USER_AGENT,
            }
            try:
                response = self._http_request(
                    method=method,
                    full_url=f"{self.base_url}{url_suffix}",
                    retries=3,
                    json_data=json_data,
                    params=params,
                    headers=header,
                    resp_type="response",
                    ok_codes=(200, 201),
                    data=data,
                )
            except DemistoException as error:
                demisto.error(error.message)
                return_error(error.message)
            if response.ok:
                demisto.info(
                    SUCCESS_RESPONSE.format(
                        url=f"{self.base_url}{url_suffix}", status=response.status_code
                    )
                )
                self.status = response.status_code
                content_type = response.headers.get("Content-Type", "")
                if content_type.__contains__(CONTENT_TYPE_JSON):
                    # Handle empty response
                    if response.text == EMPTY_STRING:
                        return response
                    else:
                        return response.json()
                else:
                    return response

        def status_check(self, data: Dict[str, Any]) -> Any:
            """
            Check the status of particular task.
            :type data: ``dict``
            :param method: Response data to received from the end point.
            :return: task status response data.
            :rtype: ``Any``
            """
            action_id = data.get(ACTION_ID)
            params = {"actionId": action_id}
            response = self.http_request(GET, TASK_DETAIL_ENDPOINT, params=params)
            message = {
                "actionId": action_id,
                "taskStatus": response.get("data").get("taskStatus"),
            }
            return CommandResults(
                readable_output=tableToMarkdown(
                    "Status of task ", message, removeNull=True
                ),
                outputs_prefix=("VisionOne.Task_Status"),
                outputs_key_field="actionId",
                outputs=message,
            )

        def sandbox_submission_polling(self, data: Dict[str, Any]) -> Any:
            """
            Check the status of sandbox submission
            :type data: ``dict``
            :param method: Response data received from sandbox.
            :return: Sandbox submission response data.
            :rtype: ``Any``
            """
            task_id = data.get(TASKID)
            result = self.http_request(GET, GET_FILE_STATUS.format(taskId=task_id))
            risk = result.get("data", {}).get("analysisSummary", {}).get("riskLevel", "")
            risk_score = self.incident_severity_to_dbot_score(risk)
            sha256 = result.get("data", {}).get("digest", {}).get("sha256")
            md5 = result.get("data", {}).get("digest", {}).get("md5")
            sha1 = result.get("data", {}).get("digest", {}).get("sha1")
            reliability = demisto.params().get("integrationReliability")
            dbot_score = Common.DBotScore(
                indicator=sha256,
                indicator_type=DBotScoreType.FILE,
                integration_name=VENDOR_NAME,
                score=risk_score,
                reliability=reliability,
            )
            file_entry = Common.File(
                sha256=sha256, md5=md5, sha1=sha1, dbot_score=dbot_score
            )
            message = {
                "message": result.get("message", ""),
                "code": result.get("code", ""),
                "task_id": result.get("data", {}).get("taskId", ""),
                "taskStatus": result.get("data", {}).get("taskStatus", ""),
                "digest": result.get("data", {}).get("digest", ""),
                "analysis_completion_time": result.get("data", {})
                .get("analysisSummary", "")
                .get("analysisCompletionTime", ""),
                "risk_level": result.get("data", {})
                .get("analysisSummary", "")
                .get("riskLevel", ""),
                "description": result.get("data", {})
                .get("analysisSummary", "")
                .get("description", ""),
                "detection_name_list": result.get("data", {})
                .get("analysisSummary", "")
                .get("detectionNameList", ""),
                "threat_type_list": result.get("data", {})
                .get("analysisSummary", "")
                .get("threatTypeList", ""),
                "file_type": result.get("data", {})
                .get("analysisSummary", "")
                .get("trueFileType", ""),
                "report_id": result.get("data", {}).get("reportId", ""),
                "DBotScore": {
                    "Score": dbot_score.score,
                    "Vendor": dbot_score.integration_name,
                    "Reliability": dbot_score.reliability,
                },
            }
            return CommandResults(
                readable_output=tableToMarkdown(
                    TABLE_SANDBOX_SUBMISSION_POLLING, message, removeNull=True
                ),
                outputs_prefix="VisionOne.Sandbox_Submission_Polling",
                outputs_key_field="report_id",
                outputs=message,
                indicator=file_entry,
            )

        def lookup_type(self, param: Any) -> str:

            # Regex expression for validating IPv4
            regex = (
                "(([0-9]|[1-9][0-9]|1[0-9][0-9]|"
                "2[0-4][0-9]|25[0-5])\\.){3}"
                "([0-9]|[1-9][0-9]|1[0-9][0-9]|"
                "2[0-4][0-9]|25[0-5])"
            )

            # Regex expression for validating IPv6
            regex1 = "((([0-9a-fA-F]){1,4})\\:){7}" "([0-9a-fA-F]){1,4}"

            # Regex expression for validating mac
            regex2 = "([0-9A-Fa-f]{2}[:-]){5}" "([0-9A-Fa-f]{2})"

            p = re.compile(regex)
            p1 = re.compile(regex1)
            p2 = re.compile(regex2)

            # Checking if it is a valid IPv4 addresses
            if re.search(p, param):
                return "ip"

            # Checking if it is a valid IPv6 addresses
            elif re.search(p1, param):
                return "ipv6"

            # Checking if it is a valid IPv6 addresses
            elif re.search(p2, param):
                return "macaddr"

            # Otherwise use hostname type
            return "hostname"

        def get_computer_id(self, field: Any, value: Any) -> str:
            """
            Fetch particular computer id using hostname, macaddress or ip.
            :type field: ``str``
            :param field: type of field to search hostname, macaddress or ip.
            :type value: ``str``
            :param value: value of the particular field.
            :return: value of computer id.
            :rtype: ``str``
            """
            body = {CRITERIA: {FIELD: field, VALUE: value}}
            response = self.http_request(
                POST, GET_COMPUTER_ID_ENDPOINT, data=json.dumps(body)
            )

            if response["status"] == "FAIL":
                return_error("kindly provide valid field value")
            computer_id = response.get("result").get("computerId")
            return computer_id

        def exception_list_count(self) -> int:
            """
            Gets the count of object present in exception list

            :return: number of exception object.
            :rtype: ``int``
            """
            response = self.http_request(GET, ADD_OBJECT_TO_EXCEPTION_LIST)
            list_of_exception = response.get(DATA).get(EXCEPTION_LIST)
            exception_count = len(list_of_exception)
            return exception_count

        def suspicious_list_count(self) -> int:
            """
            Gets the count of object present in suspicious list
            :return: number of suspicious object.
            :rtype: ``int``
            """
            response = self.http_request(GET, ADD_OBJECT_TO_SUSPICIOUS_LIST)
            list_of_exception = response.get(DATA).get(SUSPICIOUS_LIST)
            exception_count = len(list_of_exception)
            return exception_count

        def get_workbench_histories(self, start, end, offset=None, size=None) -> str:
            if not check_datetime_aware(start):
                start = start.astimezone()
            if not check_datetime_aware(end):
                end = end.astimezone()
            start = start.astimezone(timezone.utc)
            end = end.astimezone(timezone.utc)
            start = start.isoformat(timespec="milliseconds").replace("+00:00", "Z")
            end = end.isoformat(timespec="milliseconds").replace("+00:00", "Z")

            params = dict(
                [("startTime", start), ("endTime", end), ("sortBy", "createdTime")]
                + ([("offset", offset)] if offset is not None else [])
                + ([("limit", size)] if size is not None else [])
            )

            response = self.http_request(GET, WORKBENCH_HISTORIES, params=params)["data"][
                "workbenchRecords"
            ]
            return response

        def incident_severity_to_dbot_score(self, severity: str):
            """
            Converts an priority string to DBot score representation
                alert severity. Can be one of:
                Unknown -> 0
                No Risk -> 1
                Low or Medium -> 2
                Critical or High -> 3
            Args:
                severity: String representation of severity.
            Returns:
                Dbot representation of severity
            """
            if not isinstance(severity, str):
                return 0

            if severity == "noRisk":
                return 1
            if severity in ["low", "medium"]:
                return 2
            if severity in ["high", "critical"]:
                return 3
            return 0


    def run_polling_command(
        args: Dict[str, Any], cmd: str, client: Client
    ) -> Union[str, CommandResults]:
        """
        Performs polling interval to check status of task or sandbox submission result.
        :type args: ``args``
        :param client: argument required for polling.

        :type client: ``cmd``
        :param client: The command that polled for an interval.

        :type client: ``Client``
        :param client: client object to use http_request.
        """
        ScheduledCommand.raise_error_if_not_supported()
        interval_in_secs = int(args.get("interval_in_seconds", 30))
        action_id = args.get(ACTION_ID)
        task_id = args.get(TASKID)
        if cmd == CHECK_TASK_STATUS:
            command_results = client.status_check(args)
            value = ACTION_ID
        else:
            command_results = client.sandbox_submission_polling(args)
            value = TASKID
        if command_results.outputs.get("taskStatus") not in (
            "success",
            "failed",
            "timeout",
            "skipped",
            "finished",
        ):
            # schedule next poll
            polling_args = {
                f"{value}": action_id if action_id else task_id,
                "interval_in_seconds": interval_in_secs,
                "polling": True,
                **args,
            }
            scheduled_command = ScheduledCommand(
                command=cmd,
                next_run_in_seconds=interval_in_secs,
                args=polling_args,
                timeout_in_seconds=1500,
            )  # The timeout interval set for 25 minutes.
            command_results = CommandResults(scheduled_command=scheduled_command)
        return command_results


    def get_task_status(args: Dict[str, Any], client: Client) -> Union[str, CommandResults]:
        """
        check status of task.

        :type args: ``args``
        :param client: argument required for polling.

        :type client: ``Client``
        :param client: client object to use http_request.
        """
        return run_polling_command(args, CHECK_TASK_STATUS, client)


    def get_sandbox_submission_status(
        args: Dict[str, Any], client: Client
    ) -> Union[str, CommandResults]:
        """
        call polling command to check status of sandbox submission.

        :type args: ``args``
        :param client: argument required for polling.

        :type client: ``Client``
        :param client: client object to use http_request.
        """
        return run_polling_command(args, SANDBOX_SUBMISSION_POLLING, client)


    def test_module(client: Client) -> Any:
        """
        Performs basic get request to get item samples.
        :type client: ``Client``
        :param client: client object to use http_request.
        """
        client.http_request("GET", "/v2.0/xdr/threatintel/suspiciousObjects/exceptions")
        return "ok"


    def get_endpoint_info(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve information abouut the endpoint queried and
        sends the result to demisto war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """

        value = args.get(ENDPOINT)
        field = client.lookup_type(value)

        computer_id = client.get_computer_id(field, value)
        body = {"computerId": computer_id}
        response = client.http_request(
            POST, GET_ENDPOINT_INFO_ENDPOINT, data=json.dumps(body)
        )

        message = {
            "message": response.get("message", ""),
            "errorCode": response.get("errorCodecode", ""),
            "status": response.get("status", ""),
            "logonAccount": response.get("result", {})
            .get("logonAccount", "")
            .get("value", ""),
            "hostname": response.get("result", {}).get("hostname", "").get("value", ""),
            "macAddr": response.get("result", {}).get("macAddr", "").get("value", ""),
            "ip": response.get("result", {}).get("ip", "").get("value", ""),
            "osName": response.get("result", {}).get("osName", ""),
            "osVersion": response.get("result", {}).get("osVersion", ""),
            "osDescription": response.get("result", {}).get("osDescription", ""),
            "productCode": response.get("result", {}).get("productCode", ""),
        }

        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[GET_ENDPOINT_INFO_COMMAND], message, removeNull=True
            ),
            outputs_prefix="VisionOne.Endpoint_Info",
            outputs_key_field="message",
            outputs=message,
        )
        return results


    def add_delete_block_list_mapping(data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Mapping add to block list response data.

        :type data: ``dict``
        :param data: Response data to received from the end point.

        :return: mapped response data.
        :rtype: ``dict``
        """
        action_id = data.get("actionId", {})
        task_status = data.get("taskStatus", {})
        return {"actionId": action_id, "taskStatus": task_status}


    def add_or_remove_from_block_list(
        client: Client, command: str, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve data from the add or remove from block list and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type command: ``str``
        :param command: type of command either
        trendmicro-visionone-add-to-block-list or
        trendmicro-visionone-remove-from-block-list.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        value_type = args.get(VALUE_TYPE)
        target_value = args.get(TARGET_VALUE)
        product_id = args.get(PRODUCT_ID)
        if not product_id:
            product_id = EMPTY_STRING
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        body = {
            "valueType": value_type,
            "targetValue": target_value,
            "productId": product_id,
            "description": description,
        }
        if command == ADD_BLOCKLIST_COMMAND:
            response = client.http_request(
                POST, ADD_BLOCKLIST_ENDPOINT, data=json.dumps(body)
            )
        elif command == REMOVE_BLOCKLIST_COMMAND:
            response = client.http_request(
                POST, REMOVE_BLOCKLIST_ENDPOINT, data=json.dumps(body)
            )

        mapping_data = add_delete_block_list_mapping(response)
        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[command], mapping_data, removeNull=True
            ),
            outputs_prefix="VisionOne.BlockList",
            outputs_key_field="actionId",
            outputs=mapping_data,
        )
        return results


    def fetch_incidents(client: Client):
        """
        This function do the loop to get all workbench alerts by changing
        the parameters of both 'offset' and 'size'.
        """
        offset = 0
        size = demisto.params().get("max_fetch")
        end = datetime.now(timezone.utc)
        days = int(demisto.params().get("first_fetch"))

        last_run = demisto.getLastRun()
        if last_run and "start_time" in last_run:
            start = datetime.fromisoformat(last_run.get("start_time"))
        else:
            start = end + timedelta(days=-days)

        alerts: List[Any] = []
        alerts.extend(client.get_workbench_histories(start, end, offset, size))

        incidents = []
        if alerts:
            for record in alerts:
                incident = {
                    "name": record["workbenchName"],
                    "occurred": record["createdTime"],
                    "severity": client.incident_severity_to_dbot_score(record["severity"]),
                    "rawJSON": json.dumps(record),
                }
                incidents.append(incident)
                last_event = datetime.strptime(record["createdTime"], "%Y-%m-%dT%H:%M:%SZ")

            next_search = last_event + timedelta(0, 1)

            demisto.setLastRun({"start_time": next_search.isoformat()})

        if incidents:
            demisto.incidents(incidents)
        else:
            demisto.incidents([])

        return incidents


    def quarantine_delete_email_mapping(data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Mapping quarantine email message response data.

        :type data: ``dict``
        :param method: Response data to received from the end point.

        :return: mapped response data.
        :rtype: ``dict``
        """
        action_id = data.get("actionId", {})
        task_status = data.get("taskStatus", {})
        return {"actionId": action_id, "taskStatus": task_status}


    def quarantine_or_delete_email_message(
        client: Client, command: str, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve data from the quarantine or delete email message and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type command: ``str``
        :param command: type of command either
        trendmicro-visionone-quarantine-email-message or
        trendmicro-visionone-delete-email-message

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        message_id = args.get(MESSAGE_ID)
        mailbox = args.get(MAILBOX)
        message_delivery_time = args.get(MESSAGE_DELIVERY_TIME)
        product_id = args.get(PRODUCT_ID)
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        body = {
            "messageId": message_id,
            "mailBox": mailbox,
            "messageDeliveryTime": message_delivery_time,
            "productId": product_id,
            "description": description,
        }
        if command == QUARANTINE_EMAIL_COMMAND:
            response = client.http_request(
                POST, QUARANTINE_EMAIL_ENDPOINT, data=json.dumps(body)
            )

        elif command == DELETE_EMAIL_COMMAND:
            response = client.http_request(
                POST, DELETE_EMAIL_ENDPOINT, data=json.dumps(body)
            )

        mapping_data = quarantine_delete_email_mapping(response)
        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[command], mapping_data, removeNull=True
            ),
            outputs_prefix="VisionOne.Email",
            outputs_key_field="actionId",
            outputs=mapping_data,
        )
        return results


    def isolate_restore_endpoint_mapping(data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Mapping isolate endpoint and restore endpoint response data.

        :type data: ``dict``
        :param method: Response data to received from the end point.

        :return: mapped response data.
        :rtype: ``dict``
        """
        action_id = data.get("actionId", {})
        task_status = data.get("taskStatus", {})
        return {"actionId": action_id, "taskStatus": task_status}


    def isolate_or_restore_connection(
        client: Client, command: str, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Retrieve data from the isolate or restore endpoint connection and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type command: ``str``
        :param command: type of command either
        trendmicro-visionone-isolate-endpoint or
        trendmicro-visionone-restore-endpoint-connection

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        value = args.get(ENDPOINT)
        field = client.lookup_type(value)
        product_id = args.get(PRODUCT_ID)
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        computer_id = client.get_computer_id(field, value)
        body = {
            "computerId": computer_id,
            "productId": product_id,
            "description": description,
        }
        if command == ISOLATE_ENDPOINT_COMMAND:
            response = client.http_request(
                POST, ISOLATE_CONNECTION_ENDPOINT, data=json.dumps(body)
            )

        elif command == RESTORE_ENDPOINT_COMMAND:
            response = client.http_request(
                POST, RESTORE_CONNECTION_ENDPOINT, data=json.dumps(body)
            )

        mapping_data = isolate_restore_endpoint_mapping(response)

        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[command], mapping_data, removeNull=True
            ),
            outputs_prefix="VisionOne.Endpoint_Connection",
            outputs_key_field="actionId",
            outputs=mapping_data,
        )
        return results


    def terminate_process(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Terminate the process running on the end point and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        file_list = []
        value = args.get(ENDPOINT)
        field = client.lookup_type(value)
        product_id = args.get(PRODUCT_ID)
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        computer_id = client.get_computer_id(field, value)
        file_sha1 = args.get(FILESHA)
        filename = args.get(FILENAME)
        if filename:
            file_list.append(filename)
        body = {
            "computerId": computer_id,
            "fileSha1": file_sha1,
            "productId": product_id,
            "description": description,
            "filename": file_list,
        }
        response = client.http_request(
            POST, TERMINATE_PROCESS_ENDPOINT, data=json.dumps(body)
        )

        action_id = response.get("actionId", {})
        task_status = response.get("taskStatus", {})
        message = {"actionId": action_id, "taskStatus": task_status}
        results = CommandResults(
            readable_output=tableToMarkdown(
                TABLE_TERMINATE_PROCESS, message, removeNull=True
            ),
            outputs_prefix="VisionOne.Terminate_Process",
            outputs_key_field="actionId",
            outputs=message,
        )
        return results


    def add_or_delete_from_exception_list(
        client: Client, command: str, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Add or Delete the exception object to exception list and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type command: ``str``
        :param command: type of command either
        trendmicro-visionone-add-objects-to-exception-list or
        trendmicro-visionone-delete-objects-from-exception-list

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        types = args.get(TYPE)
        value = args.get(VALUE)
        body = {DATA: [{"type": types, "value": value}]}
        if command == ADD_EXCEPTION_LIST_COMMAND:
            description = args.get(DESCRIPTION)
            if not description:
                description = EMPTY_STRING
            body[DATA][0][DESCRIPTION] = description
            client.http_request(POST, ADD_OBJECT_TO_EXCEPTION_LIST, data=json.dumps(body))

        elif command == DELETE_EXCEPTION_LIST_COMMAND:
            client.http_request(
                POST, DELETE_OBJECT_FROM_EXCEPTION_LIST, data=json.dumps(body)
            )

        exception_list = client.exception_list_count()

        message = {
            "message": "success",
            "status_code": client.status,
            "total_items": exception_list,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(table_name[command], message, removeNull=True),
            outputs_prefix="VisionOne.Exception_List",
            outputs_key_field="message",
            outputs=message,
        )
        return results


    def add_to_suspicious_list(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Add suspicious object to suspicious list and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        types = args.get(TYPE)
        value = args.get(VALUE)
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        scan_action = args.get(SCAN_ACTION)
        if scan_action and scan_action not in ("log", "block"):
            return_error(PARAMETER_ISSUE.format(param=SCAN_ACTION))
        risk_level = args.get(RISK_LEVEL)
        if risk_level and risk_level not in ("high", "medium", "low"):
            return_error(PARAMETER_ISSUE.format(param=RISK_LEVEL))
        expiry = args.get(EXPIRYDAY)
        if not expiry:
            expiry = 0
        body = {
            DATA: [
                {
                    "type": types,
                    "value": value,
                    "description": description,
                    "scanAction": scan_action,
                    "riskLevel": risk_level,
                    "expiredDay": expiry,
                }
            ]
        }
        client.http_request(POST, ADD_OBJECT_TO_SUSPICIOUS_LIST, data=json.dumps(body))
        suspicious_list = client.suspicious_list_count()

        message = {
            "message": "success",
            "status_code": client.status,
            "total_items": suspicious_list,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[ADD_SUSPICIOUS_LIST_COMMAND], message, removeNull=True
            ),
            outputs_prefix="VisionOne.Suspicious_List",
            outputs_key_field="message",
            outputs=message,
        )
        return results


    def delete_from_suspicious_list(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Delete the suspicious object from suspicious list and
        sends the result to demist war room.

        :type client: ``Client``
        :param client: client object to use http_request.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        types = args.get(TYPE)
        value = args.get(VALUE)
        body = {DATA: [{"type": types, "value": value}]}
        client.http_request(POST, DELETE_OBJECT_FROM_SUSPICIOUS_LIST, data=json.dumps(body))

        exception_list = client.suspicious_list_count()

        message = {
            "message": "success",
            "status_code": client.status,
            "total_items": exception_list,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                table_name[DELETE_SUSPICIOUS_LIST_COMMAND], message, removeNull=True
            ),
            outputs_prefix="VisionOne.Suspicious_List",
            outputs_key_field="message",
            outputs=message,
        )
        return results


    def get_file_analysis_status(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Get the status of file based on task id and
        sends the result to demist war room

        :type client: ``Client``
        :param client: client object to use http_request.

        :type args: ``dict``
        :param args: args object to fetch the argument data.

        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        task_id = args.get(TASKID)
        response = client.http_request(GET, GET_FILE_STATUS.format(taskId=task_id))
        risk = response.get("data", {}).get("analysisSummary", {}).get("riskLevel", "")
        risk_score = client.incident_severity_to_dbot_score(risk)
        sha256 = response.get("data", {}).get("digest", {}).get("sha256")
        md5 = response.get("data", {}).get("digest", {}).get("md5")
        sha1 = response.get("data", {}).get("digest", {}).get("sha1")
        reliability = demisto.params().get("integrationReliability")
        dbot_score = Common.DBotScore(
            indicator=sha256,
            indicator_type=DBotScoreType.FILE,
            integration_name=VENDOR_NAME,
            score=risk_score,
            reliability=reliability,
        )

        file_entry = Common.File(sha256=sha256, md5=md5, sha1=sha1, dbot_score=dbot_score)

        message = {
            "message": response.get("message", ""),
            "code": response.get("code", ""),
            "task_id": response.get("data", {}).get("taskId", ""),
            "taskStatus": response.get("data", {}).get("taskStatus", ""),
            "digest": response.get("data", {}).get("digest", ""),
            "analysis_completion_time": response.get("data", {})
            .get("analysisSummary", "")
            .get("analysisCompletionTime", ""),
            "risk_level": response.get("data", {})
            .get("analysisSummary", "")
            .get("riskLevel", ""),
            "description": response.get("data", {})
            .get("analysisSummary", "")
            .get("description", ""),
            "detection_name_list": response.get("data", {})
            .get("analysisSummary", "")
            .get("detectionNameList", ""),
            "threat_type_list": response.get("data", {})
            .get("analysisSummary", "")
            .get("threatTypeList", ""),
            "file_type": response.get("data", {})
            .get("analysisSummary", "")
            .get("trueFileType", ""),
            "report_id": response.get("data", {}).get("reportId", ""),
            "DBotScore": {
                "Score": dbot_score.score,
                "Vendor": dbot_score.integration_name,
                "Reliability": dbot_score.reliability,
            },
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                TABLE_GET_FILE_ANALYSIS_STATUS, message, removeNull=True
            ),
            outputs_prefix="VisionOne.File_Analysis_Status",
            outputs_key_field="message",
            outputs=message,
            indicator=file_entry,
        )
        return results


    def get_file_analysis_report(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Get the report of file based on report id and sends the result to demist war room
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        report_id = args.get(REPORT_ID)
        types = args.get(TYPE)
        if types not in ("vaReport", "investigationPackage", "suspiciousObject"):
            return_error(FILE_TYPE_ERROR)
        params = {TYPE: types}
        response = client.http_request(
            GET, GET_FILE_REPORT.format(reportId=report_id), params=params
        )
        if isinstance(response, dict):

            message = {
                "message": response.get("message", ""),
                "code": response.get("code", ""),
                "data": [],
            }
            if len(response.get("data", [])) > 0:
                for data in response.get("data", {}):
                    data_value = {
                        "type": data.get("type", ""),
                        "value": data.get("value", ""),
                        "risk_level": data.get("riskLevel", ""),
                        "analysis_completion_time": data.get("analysisCompletionTime", ""),
                        "expired_time": data.get("expiredTime", ""),
                        "root_file_sha1": data.get("rootFileSha1", ""),
                    }
                    message.get("data", {}).append(data_value)
            results = CommandResults(
                readable_output=tableToMarkdown(
                    TABLE_GET_FILE_ANALYSIS_REPORT, message, removeNull=True
                ),
                outputs_prefix="VisionOne.File_Analysis_Report",
                outputs_key_field="message",
                outputs=message,
            )
        elif response.headers.get("Content-Type", "") == "binary/octet-stream":
            data = response.content
            if types == "vaReport":
                results = fileResult(
                    "Sandbox_Analysis_Report.pdf", data, file_type=EntryType.ENTRY_INFO_FILE
                )
            else:
                results = fileResult(
                    "Sandbox_Investigation_Package.zip",
                    data,
                    file_type=EntryType.ENTRY_INFO_FILE,
                )
        return results


    def collect_file(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Collect forensic file and sends the result to demist war room
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        value = args.get(ENDPOINT)
        field = client.lookup_type(value)
        product_id = args.get(PRODUCT_ID)
        description = args.get(DESCRIPTION)
        if not description:
            description = EMPTY_STRING
        computer_id = client.get_computer_id(field, value)  # type: ignore
        file_path = args.get(FILE_PATH)
        os = args.get(OS_TYPE)
        body = {
            "description": description,
            "productId": product_id,
            "computerId": computer_id,
            "filePath": file_path,
            "os": os,
        }
        response = client.http_request(POST, COLLECT_FORENSIC_FILE, data=json.dumps(body))

        task_status = response.get("taskStatus", {})
        action_id = response.get("actionId", {})
        message = {"actionId": action_id, "taskStatus": task_status}
        results = CommandResults(
            readable_output=tableToMarkdown(TABLE_COLLECT_FILE, message, removeNull=True),
            outputs_prefix="VisionOne.Collect_Forensic_File",
            outputs_key_field="actionId",
            outputs=message,
        )
        return results


    def download_information_collected_file(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        Gets the download information for collected forensic file and sends the result to demist war room
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        action_id = args.get(ACTION_ID)
        params = {"actionId": action_id}
        response = client.http_request(
            GET, DOWNLOAD_INFORMATION_COLLECTED_FILE, params=params
        )

        file_url = response.get("data", "").get("url", "")
        expires = response.get("data", "").get("expires", "")
        password = response.get("data", "").get("password", "")
        filename = response.get("data", "").get("filename", "")
        message = {
            "url": file_url,
            "expires": expires,
            "password": password,
            "filename": filename,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                TABLE_COLLECTED_FORENSIC_FILE_DOWNLOAD_INFORMATION, message, removeNull=True
            ),
            outputs_prefix="VisionOne.Download_Information_For_Collected_Forensic_File",
            outputs_key_field="url",
            outputs=message,
        )
        return results


    def submit_file_to_sandbox(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        """
        submit file to sandbox and sends the result to demist war room
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        data = {}
        params: Dict[Any, Any] = {}
        file_url = args.get(FILE_URL)
        file_name = args.get(FILE_NAME)
        document_pass = args.get(DOCUMENT_PASSWORD)
        if document_pass:
            data["documentPassword"] = base64.b64encode(document_pass.encode(ASCII)).decode(
                ASCII
            )
        archive_pass = args.get(ARCHIVE_PASSWORD)
        if archive_pass:
            data["archivePassword"] = base64.b64encode(archive_pass.encode(ASCII)).decode(
                ASCII
            )
        headers = {AUTHORIZATION: f"{BEARER}{client.api_key}"}
        try:
            file_content = requests.get(file_url, allow_redirects=True)  # type: ignore
            files = {
                "file": (file_name, file_content.content, "application/x-zip-compressed")
            }
            result = requests.post(
                f"{client.base_url}{SUBMIT_FILE_TO_SANDBOX}",
                params=params,
                headers=headers,
                data=data,
                files=files,
            )
            result.raise_for_status()
        except HTTPError as http_err:
            demisto.error(http_err)
            return_error(http_err)
        except Exception as err:
            demisto.error(err)
            return_error(err)
        else:
            response = result.json()

        message = {
            "message": response.get("message", ""),
            "code": response.get("code", ""),
            "task_id": response.get("data", "").get("taskId", ""),
            "digest": response.get("data", "").get("digest", ""),
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                TABLE_SUBMIT_FILE_TO_SANDBOX, message, removeNull=True
            ),
            outputs_prefix="VisionOne.Submit_File_to_Sandbox",
            outputs_key_field="message",
            outputs=message,
        )
        return results


    def submit_file_entry_to_sandbox(
        client: Client, args: Dict[str, Any]
    ) -> Union[str, CommandResults]:
        entry = args.get(ENTRY_ID)
        file_ = demisto.getFilePath(entry)
        file_name = file_.get("name")
        file_path = file_.get("path")
        archive_pass = args.get(ARCHIVE_PASSWORD)
        document_pass = args.get(DOCUMENT_PASSWORD)
        query_params: Dict[Any, Any] = {}
        headers = {AUTHORIZATION: f"{BEARER} {client.api_key}"}
        with open(file_path, "rb") as f:
            contents = f.read()
        data = {}
        if document_pass:
            data["documentPassword"] = base64.b64encode(document_pass.encode(ASCII)).decode(
                ASCII
            )
        if archive_pass:
            data["archivePassword"] = base64.b64encode(archive_pass.encode(ASCII)).decode(
                ASCII
            )
        files = {"file": (f"{file_name}", contents, "application/octet-stream")}
        try:
            result = requests.post(
                f"{client.base_url}{SUBMIT_FILE_TO_SANDBOX}",
                params=query_params,
                headers=headers,
                data=data,
                files=files,
            )
        except HTTPError as http_err:
            demisto.error(http_err)
            return_error(http_err)
        response = result.json()
        message = {
            "filename": file_name,
            "entryId": entry,
            "file_path": file_.get("path", ""),
            "message": response.get("message"),
            "task_id": response.get("data", {}).get("taskId", ""),
            "code": response.get("code", ""),
            "digest": response.get("data", {}).get("digest", {}),
        }
        results = CommandResults(
            readable_output=tableToMarkdown(
                TABLE_SUBMIT_FILE_ENTRY_TO_SANDBOX, message, removeNull=True
            ),
            outputs_prefix="VisionOne.Submit_File_Entry_to_Sandbox",
            outputs_key_field="entryId",
            outputs=message,
        )
        return results


    def add_note(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Adds a note to an existing workbench alert
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        workbench_id = args.get(WORKBENCH_ID)
        content = args.get(CONTENT)

        body = {"content": content}
        response = client.http_request(
            POST, ADD_NOTE_ENDPOINT.format(workbenchId=workbench_id), data=json.dumps(body)
        )

        note_id = response.get("data").get("id")
        response_code = response.get("info").get("code")
        response_msg = response.get("info").get("msg")
        message = {
            "Workbench_Id": workbench_id,
            "noteId": note_id,
            "response_code": response_code,
            "response_msg": response_msg,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(TABLE_ADD_NOTE, message, removeNull=True),
            outputs_prefix="VisionOne.Add_Note",
            outputs_key_field="noteId",
            outputs=message,
        )
        return results


    def update_status(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Updates the status of an existing workbench alert
        :type client: ``Client``
        :param client: client object to use http_request.
        :type args: ``dict``
        :param args: args object to fetch the argument data.
        :return: sends data to demisto war room.
        :rtype: ``dict`
        """
        workbench_id = args.get(WORKBENCH_ID)
        status = args.get(STATUS)

        if status == "new":
            update_status = NEW
        elif status == "in_progress":
            update_status = IN_PROGRESS
        elif status == "resolved_true_positive":
            update_status = RESOLVED_TRUE_POSITIVE
        elif status == "resolved_false_positive":
            update_status = RESOLVED_FALSE_POSITIVE

        body = {"investigationStatus": update_status}
        response = client.http_request(
            PUT,
            UPDATE_STATUS_ENDPOINT.format(workbenchId=workbench_id),
            data=json.dumps(body),
        )

        response_code = response.get("info").get("code")
        response_msg = response.get("info").get("msg")
        message = {
            "Workbench_Id": workbench_id,
            "response_code": response_code,
            "response_msg": response_msg,
        }
        results = CommandResults(
            readable_output=tableToMarkdown(TABLE_UPDATE_STATUS, message, removeNull=True),
            outputs_prefix="VisionOne.Update_Status",
            outputs_key_field="Workbench_Id",
            outputs=message,
        )
        return results


    def main():
        try:
            """GLOBAL VARS"""
            params = demisto.params()

            base_url = params.get(URL)
            api_key = params.get(API_TOKEN).get("password")
            proxy = params.get("proxy", False)
            verify = not params.get("insecure", False)

            client = Client(base_url, api_key, proxy, verify)

            command = demisto.command()
            demisto.debug(COMMAND_CALLED.format(command=command))
            args = demisto.args()

            if command == "test-module":
                return_results(test_module(client))

            elif command == "fetch-incidents":
                return_results(fetch_incidents(client))

            elif command in (ADD_BLOCKLIST_COMMAND, REMOVE_BLOCKLIST_COMMAND):
                return_results(add_or_remove_from_block_list(client, command, args))

            elif command in (QUARANTINE_EMAIL_COMMAND, DELETE_EMAIL_COMMAND):
                return_results(quarantine_or_delete_email_message(client, command, args))

            elif command in (ISOLATE_ENDPOINT_COMMAND, RESTORE_ENDPOINT_COMMAND):
                return_results(isolate_or_restore_connection(client, command, args))

            elif command == TERMINATE_PROCESS_COMMAND:
                return_results(terminate_process(client, args))

            elif command in (ADD_EXCEPTION_LIST_COMMAND, DELETE_EXCEPTION_LIST_COMMAND):
                return_results(add_or_delete_from_exception_list(client, command, args))

            elif command == ADD_SUSPICIOUS_LIST_COMMAND:
                return_results(add_to_suspicious_list(client, args))

            elif command == DELETE_SUSPICIOUS_LIST_COMMAND:
                return_results(delete_from_suspicious_list(client, args))

            elif command == GET_FILE_ANALYSIS_STATUS:
                return_results(get_file_analysis_status(client, args))

            elif command == GET_FILE_ANALYSIS_REPORT:
                return_results(get_file_analysis_report(client, args))

            elif command == GET_ENDPOINT_INFO_COMMAND:
                return_results(get_endpoint_info(client, args))

            elif command == COLLECT_FILE:
                return_results(collect_file(client, args))

            elif command == DOWNLOAD_COLLECTED_FILE:
                return_results(download_information_collected_file(client, args))

            elif command == FILE_TO_SANDBOX:
                return_results(submit_file_to_sandbox(client, args))

            elif command == FILE_ENTRY_TO_SANDBOX:
                return_results(submit_file_entry_to_sandbox(client, args))

            elif command == SANDBOX_SUBMISSION_POLLING:
                if args.get("polling") == "true":
                    cmd_res = get_sandbox_submission_status(args, client)
                    if cmd_res is not None:
                        return_results(cmd_res)
                else:
                    return_results(client.sandbox_submission_polling(args))

            elif command == UPDATE_STATUS:
                return_results(update_status(client, args))

            elif command == ADD_NOTE:
                return_results(add_note(client, args))

            elif command == CHECK_TASK_STATUS:
                if args.get("polling") == "true":
                    cmd_res = get_task_status(args, client)
                    if cmd_res is not None:
                        return_results(cmd_res)
                else:
                    return_results(client.status_check(args))

            else:
                demisto.error(f"{command} command is not implemented.")
                raise NotImplementedError(f"{command} command is not implemented.")

        except Exception as error:
            demisto.error(COMMAND_EXECUTION_ERROR.format(error=error))


    if __name__ in ["__main__", "builtin", "builtins"]:
        main()

    register_module_line('Trend Micro Vision One', 'end', __line__())
  subtype: python3
  type: python
system: true
