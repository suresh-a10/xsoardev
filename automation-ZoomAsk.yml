args:
- description: The Zoom user ID, JID or email to whom to send the message. You must
    provide this parameter or the channel_id parameter.
  name: user
- description: The ID or the JID of the channel where you intend to send the message.
    You must provide this parameter or the user parameter.
  name: channel_id
- description: The channel name can be provided only if the channel is part of a mirroring
    incident, instead of the channel JID.
  name: channel_name
- description: The message to send to the user or channel.
  name: message
  required: true
- defaultValue: Yes#blue
  description: The first reply option. The default is "Yes" with a blue button. To
    change the color of the button, add the pound sign (#) followed by the name of
    the new color (blue, red, or black). The default color is "blue". For example,
    "Yes#blue".
  name: option1
- defaultValue: No#red
  description: The second reply option. The default is "No" with a red button. To
    change the button color, add the pound sign (#) followed by the name of the new
    color (blue, red, or black). The default color is "red". For example, "No#red".
  name: option2
- description: The task to close with the reply. If empty, then no playbook tasks
    will be closed.
  name: task
- auto: PREDEFINED
  defaultValue: "false"
  description: Indicates whether to use one-time entitlement or persistent entitlement.
  name: persistent
  predefined:
  - "true"
  - "false"
- auto: PREDEFINED
  defaultValue: button
  description: How the user should respond to the question.
  name: responseType
  predefined:
  - button
  - dropdown
- description: A comma-separated list of additional options in the format of "option#color",
    for example, "maybe#black". The default color is "black".
  name: additionalOptions
- defaultValue: Thank you {user}. you have answered {response} .
  description: The reply to send to the user. Use the templates {user} and {response}
    to incorporate these in the reply. (i.e., "Thank you {user}. You have answered
    {response}.").
  name: reply
- defaultValue: 1 day
  description: Time until the question expires. For example - 1 day. When it expires,
    a default response is sent.
  name: lifetime
- defaultValue: NoResponse
  description: Default response in case the question expires.
  name: defaultResponse
comment: Sends a message (question) to either user (in a direct message) or to a channel.
  The message includes predefined reply options. The response can also close a task
  (might be conditional) in a playbook.
commonfields:
  id: ZoomAsk
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.6.10
    packID: Zoom
    packName: Zoom
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
dependson:
  must:
  - Zoom|||send-notification
dockerimage: demisto/fastapi:1.0.0.79757
enabled: true
engineinfo: {}
mainengineinfo: {}
name: ZoomAsk
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('ZoomAsk', 'start', __line__())
  ### pack version: 1.6.10



  import dateparser

  STYLES_DICT = {
      'white': 'Default',
      'blue': 'Primary',
      'red': 'Danger',
      'gray': 'Disabled',
  }

  DATE_FORMAT = '%Y-%m-%d %H:%M:%S'


  def parse_option_text(option_text):
      # Function to parse the option text with color information and extract the text and style
      # Format of the option text: "<text>#<color>"
      parts = option_text.split("#", 1)
      if len(parts) == 2:
          text, color = parts
          style = STYLES_DICT.get(color.lower(), 'Default')
      else:
          text = option_text
          style = 'Default'
      return text, style


  def generate_json(text, options, response_type):
      if response_type == "button":
          # Generate JSON for button type response
          button_items = []
          for _i, option in enumerate(options):
              option_text, option_style = parse_option_text(option)
              button_item = {
                  "value": option_text,
                  "style": option_style,
                  "text": option_text
              }
              button_items.append(button_item)

          json_data = {
              "head": {
                  "type": "message",
                  "text": text
              },
              "body": [
                  {
                      "type": "actions",
                      "items": button_items
                  }
              ]
          }

      elif response_type == "dropdown":
          # Generate JSON for dropdown type response
          select_items = []
          for _i, option in enumerate(options):
              option_text, _ = parse_option_text(option)
              select_item = {
                  "value": option_text,
                  "text": option_text
              }
              select_items.append(select_item)

          json_data = {
              "body": [
                  {
                      "select_items": select_items,
                      "text": text,
                      "selected_item": {
                          "value": select_items[0].get('value')
                      },
                      "type": "select"
                  }
              ]
          }

      else:
          raise ValueError("Invalid responseType. should be 'button' or 'dropdown'.")
      return json_data


  def main():
      demisto_args = demisto.args()
      res = demisto.executeCommand('addEntitlement', {'persistent': demisto_args.get('persistent')})
      if isError(res[0]):
          return_results(res)
      entitlement = demisto.get(res[0], 'Contents')
      option1 = demisto_args.get('option1')
      option2 = demisto_args.get('option2')
      extra_options = argToList(demisto_args.get('additionalOptions', ''))
      reply = demisto_args.get('reply')
      response_type = demisto_args.get('responseType', 'buttons')
      lifetime = demisto_args.get('lifetime', '1 day')
      try:
          parsed_date = dateparser.parse('in ' + lifetime, settings={'TIMEZONE': 'UTC'})
          assert parsed_date is not None, f'Could not parse in {lifetime}'
          expiry = datetime.strftime(parsed_date,
                                     DATE_FORMAT)
      except Exception:
          parsed_date = dateparser.parse('in 1 day', settings={'TIMEZONE': 'UTC'})
          assert parsed_date is not None
          expiry = datetime.strftime(parsed_date,
                                     DATE_FORMAT)
      default_response = demisto_args.get('defaultResponse')

      entitlement_string = entitlement + '@' + demisto.investigation()['id']
      if demisto_args.get('task'):
          entitlement_string += '|' + demisto_args.get('task')

      args = {
          'ignoreAddURL': 'true',
      }

      user_options = [option1, option2]
      if extra_options:
          user_options += extra_options
      blocks = json.dumps(generate_json(demisto.args()['message'], user_options, response_type))
      args['message'] = json.dumps({
          'blocks': blocks,
          'entitlement': entitlement_string,
          'reply': reply,
          'expiry': expiry,
          'default_response': default_response
      })
      to = demisto_args.get('user')
      channel_name = demisto_args.get('channel_name')
      channel = demisto_args.get('channel_id')

      if to:
          args['to'] = to
      elif channel:
          args['channel_id'] = channel
      elif channel_name:
          args['channel'] = channel_name
      else:
          return_error('Either a user or a channel_id or channel_name must be specified')

      args['zoom_ask'] = 'true'
      try:
          return_results(demisto.executeCommand('send-notification', args))
      except ValueError as e:
          if 'Unsupported Command' in str(e):
              return_error(f'The command is unsupported by this script. {e}')
          else:
              return_error('An error has occurred while executing the send-notification command',
                           error=e)


  if __name__ in ('__builtin__', 'builtins', '__main__'):
      main()

  register_module_line('ZoomAsk', 'end', __line__())
scripttarget: 0
subtype: python3
system: true
tags:
- zoom
type: python
