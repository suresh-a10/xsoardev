category: Data Enrichment & Threat Intelligence
commonfields:
  id: GoogleCloudSCC_Main
  version: -1
configuration:
- additionalinfo: Service Account JSON
  display: Service Account JSON
  name: service_account_json
  required: true
  type: 4
- additionalinfo: Organization ID defines from which organization incidents need to
    be fetched.
  display: Organization ID
  name: organization_id
  required: true
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- additionalinfo: ID of the project to use for fetching incidents. If ID is not provided
    it will be taken from the provided service account JSON.
  display: Project ID
  name: project_id
  required: false
  type: 0
- additionalinfo: ID of subscription from which to fetch incidents.
  display: Subscription ID
  name: subscription_id
  required: false
  type: 0
- additionalinfo: The maximum number of incidents to fetch every time.
  defaultvalue: "50"
  display: Max Incidents
  name: max_fetch
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- additionalinfo: Enables to trust on all certificates
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- additionalinfo: Enables system proxy settings
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Security Command Center is a security and risk management platform for
  Google Cloud. Security Command Center enables you to understand your security and
  data attack surface by providing asset inventory and discovery, identifying vulnerabilities
  and threats, and helping you mitigate and remediate risks across an organization.
  This integration helps you to perform tasks related to findings and assets.
detaileddescription: "Security Command Center is a security and risk management platform
  for Google Cloud. This integration uses Pub/Sub to fetch the incidents. To set up
  the initial parameters of Google SCC in Cortex XSOAR, please follow the below instructions
  -\n\n### Scope\nWe need to provide the below mentioned OAuth scope to execute the
  commands: https://urldefense.com/v3/__https://www.googleapis.com/auth/cloud-platform.*5Cn__;JQ!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8hqczK56Q$
  \ \n### Create a Service Account\n1. Go to the [Google documentation](https://urldefense.com/v3/__https://developers.google.com/identity/protocols/OAuth2ServiceAccount*creatinganaccount__;Iw!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jGdY1D0A$
  ) and follow the procedure mentioned in the _Creating a Service Account_ section.
  After you create a service account, a Service Account Private Key file is downloaded.
  You will need this file when configuring an instance of the integration.\n2. Grant
  the Security Command Center admin permission to the Service Account to enable the
  Service Account to perform certain Google Cloud API commands.\n3. In Cortex XSOAR,
  configure an instance of the Google Cloud Security Command Center integration. For
  the Service Account Private Key parameter, add the Service Account Private Key file
  contents (JSON).\n\n### Getting your Organization ID\nThe Organization ID is a unique
  identifier for an organization and is automatically created when your organization
  resource is created.\n1. To get the Organization ID for your organization, follow
  the steps mentioned in Google documentation provided [here](https://urldefense.com/v3/__https://cloud.google.com/resource-manager/docs/creating-managing-organization*retrieving_your_organization_id).*5Cn2__;IyU!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jJrfgrkw$
  . To get your Organization ID using the Cloud Console, [Go to the Cloud Console](https://urldefense.com/v3/__https://console.cloud.google.com/__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8gB-sB_3A$
  ) and at the top of the page, click the project selection drop-down list and __from
  the Select__ window that appears, click the organization drop-down list and select
  the organization you want.\n3. On the right side, click __More__, then click __Settings__.
  The __Settings__ page displays your organization's ID.\n\n### Getting your Project
  ID\nWhen we create a new project or for an existing project, Project ID generates
  for that project. To get the Project ID and the Project number, you can follow the
  same instructions provided above for getting Organization ID. For more details,
  You can follow the instructions provided in Google documentation [here](https://urldefense.com/v3/__https://cloud.google.com/resource-manager/docs/creating-managing-projects).*5Cn*5Cn**B__;JSUjIyM!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8hYG40ASA$
  Getting Subscription ID from Pub/Sub\nTo fetch incidents using Google Pub/Sub, we
  need to configure Pub/Sub first. This [Google documentation](https://urldefense.com/v3/__https://cloud.google.com/pubsub/docs/quickstart-console__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jGsvgmWQ$
  ) will help setting up Pub/Sub prerequisites for creating a subscription.\n1. To
  add a subscription, we need to have a topic first. So after you create a topic,
  go to the menu for the topic and click on __Create subscription__ and it will take
  you to the _Add new subscription_ page.\n2. Type a name for the subscription and
  leave the delivery type as __Pull__.\n3. Set the Message retention duration to retain
  unacknowledged messages for a specified duration. If the checkbox of _Retain acknowledged
  messages_ is enabled, acknowledged messages are retained for the same duration.
  It is recommended to keep maximum possible value for Message retention so messages
  can be retained inside subscription until they are pulled.\n4. Set the Acknowledgement
  deadline for pub/sub to wait for the subscriber to acknowledge receipt before resending
  the message. Minimum recommended value for Acknowledgement deadline is 300 seconds
  for this integration.\n5. Apply the other settings as required and click on the
  CREATE button.\n6. Once the subscription is created, it will take you to the Subscriptions
  page, where you can see the Subscription ID for the subscription you just created.
  \n\n### Setting up finding notifications\n* Enable the Security Command Center API
  notifications feature. Notifications send information to a Pub/Sub topic to provide
  findings updates and new findings within minutes. Set up the notifications as per
  [Google Documentation](https://urldefense.com/v3/__https://cloud.google.com/security-command-center/docs/how-to-notifications__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jzcFDbbg$
  ) available and get SCC data in Cortex XSOAR. \n* The basic parameters required
  for setting up pub/sub notifications are ORGANIZATION_ID, PUBSUB_TOPIC, DESCRIPTION
  and FILTER.\n* Before creating a pub/sub notification, make sure to check the filter
  parameters using __google-cloud-scc-finding-list__ command provided in this integration.
  The total size applicable for the filter provided can be checked using _Total retrieved
  findings_ available inside the command results section. A maximum of 200 findings
  per minute is recommended.\n\n---\n[View Integration Documentation](https://urldefense.com/v3/__https://xsoar.pan.dev/docs/reference/integrations/google-cloud-scc__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jj2o3EjQ$
  )"
display: GoogleCloudSCC_Main
image: data:image/png;base64,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
name: GoogleCloudSCC_Main
script:
  commands:
  - arguments:
    - description: |-
        The filter expression is a list of one or more restrictions combined via logical operators AND and OR.
        Parentheses are supported, and OR has higher precedence than AND.Examples include:
        1) name
        2) securityCenterProperties.resource_name
        3) resourceProperties.name
        4) securityMarks.marks.marka

        The supported operators are:
        1) = for all value types.
        2) >, <, >=, <= for integer values.
        3) :, meaning substring matching, for strings.

        The following field and operator combinations are supported:
        1) name: =
        2) updateTime: =, >, <, >=, <

        Example: resourceProperties.displayName="test.com" OR resourceProperties.projectNumber="455757558851"
        Use a negated partial match on the empty string to filter based on a property not existing: "-resourceProperties.project=45".
      name: filter
    - description: |-
        This parameter defines what fields and order to use for sorting.
        The string value should be a comma-separated list of fields.
        The default sorting order is ascending. To specify descending order for a field, a suffix "desc" should be appended to the field name.
        For example: "name desc,resourceProperties.owner".
        The following fields are supported for orderBy:
        name, updateTime, resourceProperties,  securityMarks.marks,  securityCenterProperties.resource_name,
        securityCenterProperties.resource_display_name,  securityCenterProperties.resource_parent, securityCenterProperties.resource_parent_display_name,  securityCenterProperties.resource_project,
        securityCenterProperties.resource_project_display_name,  securityCenterProperties.resource_type.
      name: orderBy
    - description: |-
        Time is used as a reference point when filtering assets. The filter is limited to assets existing at the supplied time and their values are those at that specific time. If not provided, it will take current time. Format: YYYY-MM-ddTHH:mm:ss.sssZ
        Example:  2020-07-22T07:10:02.782Z.
      name: readTime
    - description: "When compareDuration is set, the \"stateChange\" attribute is
        updated to indicate whether the asset was added, removed, or remained present
        during the compareDuration period of time that precedes the readTime. \nPossible
        \"stateChange\" values when compareDuration is specified:\n1) ADDED\n2) REMOVED\n3)
        ACTIVE\n\nIf compareDuration is not specified, then the only possible stateChange
        is \"UNUSED\", \nExample value: 3.5s."
      name: compareDuration
    - description: |-
        A field mask is used to specify the specific response fields to be listed in the response.
        An empty field mask will list all fields. Comma-separated values are supported in this parameter.
        Example: "asset.resourceProperties.owner,asset.securityCenterProperties.resourceName".
      name: fieldMask
    - description: The value returned by the last response of the google-cloud-scc-asset-list
        command indicates that this is a continuation of prior assets.list call, and
        that the system should return the next page of data.
      name: pageToken
    - defaultValue: "10"
      description: The maximum number of results to return in a single response. The
        minimum value is 1 and maximum value is 1000.
      name: pageSize
    - description: ' This parameter is used to filter assets by resource types by
        providing a single value or a comma-separated value of resource types. If
        any resource type is not provided, by default all resource types will be considered
        for listing assets.The value provided inside resourceType would be applied
        in the query as a filter parameter for filtering results. Example: cloudfunction,
        bucket.'
      name: resourceType
    - description: 'This parameter is used to filter assets by the project by providing
        a single value or a comma-separated value of projects. If any project is not
        provided, by default all projects will be considered for listing assets. Value
        provided inside the project would be applied in the query as a filter parameter
        for filtering results. Example: Automeet, Backstory.'
      name: project
    - auto: PREDEFINED
      defaultValue: "False"
      description: This parameter is used to filter assets by their lifeCycleState
        value by selecting an option from the dropdown. If 'True' is selected the
        assets having lifeCycleState as 'ACTIVE' will be fetched and if 'False' or
        no option selected from the dropdown, then assets with all states will be
        considered for listing assets. The value selected in activeAssetsOnly would
        be applied in the query as a filter parameter for filtering results.
      name: activeAssetsOnly
      predefined:
      - "True"
      - "False"
    deprecated: true
    description: Lists an organization's assets.
    name: google-cloud-scc-asset-list
    outputs:
    - contextPath: GoogleCloudSCC.Asset.name
      description: The relative resource name of the asset.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceName
      description: The full resource name of the Google Cloud resource this asset
        represents.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceType
      description: The type of the Google Cloud resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceParent
      description: The full resource name of the immediate parent of the resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceProject
      description: The full resource name of the project the resource belongs to.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceOwners
      description: Owners of the Google Cloud resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceDisplayName
      description: The user defined display name for this resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceParentDisplayName
      description: The user defined display name for the parent of this resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.resourceProjectDisplayName
      description: The user defined display name for the project of this resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.folders.resourceFolder
      description: Full resource name of this folder.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityCenterProperties.folders.resourceFolderDisplayName
      description: The user defined display name for this folder.
      type: String
    - contextPath: GoogleCloudSCC.Asset.resourceProperties
      description: Resource managed properties. These properties are managed and defined
        by the Google Cloud resource and cannot be modified by the user. Properties
        are varying from assets to assets.
      type: Unknown
    - contextPath: GoogleCloudSCC.Asset.securityMarks.name
      description: The relative resource name of the SecurityMarks.
      type: String
    - contextPath: GoogleCloudSCC.Asset.securityMarks.marks
      description: Mutable user specified security marks belonging to the parent resource.
      type: String
    - contextPath: GoogleCloudSCC.Asset.createTime
      description: The time at which the asset was created in the Security Command
        Center.
      type: String
    - contextPath: GoogleCloudSCC.Asset.updateTime
      description: The time at which the asset was last updated, added, or deleted
        in Security Command Center.
      type: String
    - contextPath: GoogleCloudSCC.Asset.iamPolicy.policyBlob
      description: Cloud IAM Policy information associated with the Google Cloud resource
        described by the Security Command Center asset.
      type: String
    - contextPath: GoogleCloudSCC.Asset.stateChange
      description: State change of the asset between the points in time.
      type: String
    - contextPath: GoogleCloudSCC.Asset.readTime
      description: Time used for executing the list request.
      type: String
    - contextPath: GoogleCloudSCC.Token.nextPageToken
      description: Token to retrieve the next page of results, or empty if there are
        no more results.
      type: String
    - contextPath: GoogleCloudSCC.Token.name
      description: Name of the command.
      type: String
  - arguments:
    - description: Filter findings by their severity (LOW, MEDIUM, HIGH, CRITICAL).
        Comma-separated values are supported and if any severity value is not provided,
        by default all the severities will be considered for listing of findings.
        Value provided inside severity would be applied in the query as a filter parameter
        for filtering results.
      name: severity
    - description: |-
        Filter findings by providing comma-separated values of categories or a single category.
        If any category value is not provided, by default all the categories will be considered for listing findings.
        Value provided inside the category would be applied in the query as a filter parameter for filtering results.
        For Example: anomaly,application.
      name: category
    - defaultValue: '-'
      description: Filter findings by providing the value of a single source type.
        If any source type Id value  is not provided, by default all source types
        will be considered for list findings.
      name: sourceTypeId
    - defaultValue: "10"
      description: The maximum number of results to return in a single response. The
        minimum value is 1 and maximum value is 1000.
      name: pageSize
    - defaultValue: ACTIVE
      description: Filter the findings by their state. Can be 'ACTIVE', 'INACTIVE'.
        Comma-separated values are supported and if any state value is not provided,
        by default 'ACTIVE' state will be considered for listing of findings. Value
        provided inside the state would be applied in the query as a filter parameter
        for filtering results.
      name: state
    - description: |
        The filter  expression is a list of one or more restrictions combined via logical operators AND and OR.
        Parentheses are supported, and OR has higher precedence than AND.Examples include:
        1) name
        2) sourceProperties.a_property
        3) securityMarks.marks.marka

        The supported operators are:
        1) = for all value types.
        2) >, <, >=, <= for integer values.
        3) :, meaning substring matching, for strings.

        The following field and operator combinations are supported:
        1) name: =
        2) parent: =, :
        3) resourceName: =, :
        4) state: =, :
        5) category: =, :
        6) externalUri: =, :
        7) eventTime: =, >, <, >=, <=
        8) severity: =, :

        Examples: "sourceProperties.browser="chrome" AND sourceProperties.event_type="proximity""
        Use a negated partial match on the empty string to filter based on a property not existing: "-severity=LOW".
      name: filter
    - description: |-
        This parameter defines what fields and order to use for sorting.
        The string value should be a comma separated list of fields. The default sorting order is ascending.
        To specify descending order for a field, a suffix " desc" should be appended to the field name.
        For example: "name desc,sourceProperties.browser".
        Supported fields: name, parent, state, category, resourceName, eventTime, sourceProperties, securityMarks.marks.
      name: orderBy
    - description: |-
        When compareDuration is set, the "stateChange" attribute is updated to indicate whether the finding had its state changed, the finding's state remained unchanged, or if the finding was added in any state during the compareDuration period of time that precedes the readTime. This is the time between (readTime - compareDuration) and readTime.
        The results aren't affected if the finding is made inactive and then active again.

        Possible "stateChange" values when compareDuration is specified:
        1) CHANGED
        2) UNCHANGED
        3) ADDED
        4) REMOVED

        If compareDuration is not specified, then the only possible stateChange is "UNUSED".
        Example value: "3.5s".
      name: compareDuration
    - description: "Time used as a reference point when filtering findings. The filter
        is limited to findings existing at the supplied time and their values are
        those at that specific time. If not provided, it will take current time. \nFormat:
        YYYY-MM-ddTHH:mm:ss.sssZ\nExample: 2020-07-22T07:10:02.782Z."
      name: readTime
    - description: |-
        A field mask is used to specify the specific response fields to be listed in the response.
        An empty field mask will list all fields. Comma-separated values are supported in this parameter.
        Example: "user.displayName,sourceProperties.browser".
      name: fieldMask
    - description: The value returned by the last response of a google-cloud-scc-finding-list
        command indicates that this is a continuation of a prior findings.list call,
        and that the system should return the next page of data.
      name: pageToken
    description: Lists an organization or source's findings.
    name: google-cloud-scc-finding-list
    outputs:
    - contextPath: GoogleCloudSCC.Finding.name
      description: The relative resource name of this finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.parent
      description: The relative resource name of the source the finding belongs to.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resourceName
      description: For findings on Google Cloud resources, the full resource name
        of the Google Cloud resource this finding is for.
      type: String
    - contextPath: GoogleCloudSCC.Finding.state
      description: The state of the finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.category
      description: The additional taxonomy group within findings from a given source.
      type: String
    - contextPath: GoogleCloudSCC.Finding.externalUri
      description: The URI that, if available, points to a web page outside of Security
        Command Center where additional information about the finding can be found.
      type: String
    - contextPath: GoogleCloudSCC.Finding.createTime
      description: The time at which the finding was created in Security Command Center.
      type: String
    - contextPath: GoogleCloudSCC.Finding.eventTime
      description: The time at which the event took place, or when an update to the
        finding occurred.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.name
      description: The full resource name of the resource.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.parentDisplayName
      description: The human readable name of resource's parent.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.parentName
      description: The full resource name of resource's parent.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.projectDisplayName
      description: The human readable name of project that the resource belongs to.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.projectName
      description: The full resource name of the project that the resource belongs
        to.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.folders.resourceFolder
      description: Full resource name of this folder.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resource.folders.resourceFolderDisplayName
      description: The user defined display name for this folder.
      type: String
    - contextPath: GoogleCloudSCC.Finding.stateChange
      description: State change of the finding between the points in time.
      type: String
    - contextPath: GoogleCloudSCC.Finding.sourceProperties
      description: Source specific properties. These properties are managed by the
        source that writes the finding. Properties are varying from finding to finding.
      type: Unknown
    - contextPath: GoogleCloudSCC.Finding.severity
      description: Severity of the finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.securityMarks.name
      description: The relative resource name of the SecurityMarks.
      type: String
    - contextPath: GoogleCloudSCC.Finding.securityMarks.marks
      description: Mutable user specified security marks belonging to the parent resource.
      type: String
    - contextPath: GoogleCloudSCC.Finding.readTime
      description: Time used for executing the list request.
      type: String
    - contextPath: GoogleCloudSCC.Token.nextPageToken
      description: Token to retrieve the next page of results, or empty if there are
        no more results.
      type: String
    - contextPath: GoogleCloudSCC.Token.name
      description: Name of the command.
      type: String
  - arguments:
    - description: |-
        The relative resource name of the finding.
        Format: organizations/{organization_id}/sources/{source_id}/finding/{findingId}
        Example: organizations/595779152576/sources/14801394649435054450/findings/bc5a86da657611ebb979005056a5924e.
      name: name
      required: true
    - description: |-
        Time at which the event took place. By default UTC current time will be taken if no value is provided in eventTime.
        Format: YYYY-MM-ddTHH:mm:ss.sssZ
        Example: 2020-07-22T07:10:02.782Z, 2014-10-02T15:01:23.045123456Z.
      name: eventTime
    - auto: PREDEFINED
      description: Related severity of the finding.
      name: severity
      predefined:
      - LOW
      - MEDIUM
      - HIGH
      - CRITICAL
    - description: URI that points to a web page outside of Cloud SCC (Security Command
        Center) where additional information about the finding can be found.
      name: externalUri
    - description: Source specific properties. These properties are managed by the
        source that writes the finding. For example "key1=val1,key2=val2".
      name: sourceProperties
    - description: A updateMask argument supports single or comma-separated fields
        that need to be updated/deleted. A updateMask is automatically generated in
        the backend for the specific arguments provided in the command and only those
        values will be updated. To delete attributes/properties, add those keys in
        updateMask without specifying those fields individually in the command arguments.
      name: updateMask
    description: Update an organization's or source's finding.
    name: google-cloud-scc-finding-update
    outputs:
    - contextPath: GoogleCloudSCC.Finding.name
      description: The relative resource name of this finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.parent
      description: The relative resource name of the source the finding belongs to.
      type: String
    - contextPath: GoogleCloudSCC.Finding.resourceName
      description: For findings on Google Cloud resources, the full resource name
        of the Google Cloud resource this finding is for.
      type: String
    - contextPath: GoogleCloudSCC.Finding.state
      description: The state of the finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.category
      description: The additional taxonomy group within findings from a given source.
      type: String
    - contextPath: GoogleCloudSCC.Finding.externalUri
      description: The URI that, if available, points to a web page outside of Security
        Command Center where additional information about the finding can be found.
      type: String
    - contextPath: GoogleCloudSCC.Finding.createTime
      description: The time at which the finding was created in Security Command Center.
      type: String
    - contextPath: GoogleCloudSCC.Finding.eventTime
      description: The time at which the event took place, or when an update to the
        finding occurred.
      type: String
    - contextPath: GoogleCloudSCC.Finding.sourceProperties
      description: Source specific properties. These properties are managed by the
        source that writes the finding. Properties are varying from finding to finding.
      type: Unknown
    - contextPath: GoogleCloudSCC.Finding.severity
      description: Severity of the finding.
      type: String
    - contextPath: GoogleCloudSCC.Finding.securityMarks.name
      description: The relative resource name of the SecurityMarks.
      type: String
    - contextPath: GoogleCloudSCC.Finding.securityMarks.marks
      description: Mutable user specified security marks belonging to the parent resource.
      type: String
  - arguments:
    - description: |-
        Name of the organization or project the assets belong to. Organization Id provided in the Integration Configuration will be taken by default, if no value is provided to the parent.

        Format: "organizations/[organization-number]" (such as "organizations/123"), "projects/[project-id]" (such as "projects/my-project-id"), or "projects/[project-number]" (such as "projects/12345").
      name: parent
    - description: "This parameter is used to filter assets by asset types by providing
        a single value or a comma-separated value of asset types.\nFor example: \"compute.googleapis.com/Disk\".\n\nRegular
        expression is also supported. \nFor example:\n1) \"compute.googleapis.com.*\"
        resources whose asset type starts with \"compute.googleapis.com\".\n2) \".*Instance\"
        resources whose asset type ends with \"Instance\".\n3) \".*Instance.*\" resources
        whose asset type contains \"Instance\"."
      name: assetTypes
    - defaultValue: "10"
      description: The maximum number of results to return in a single response. The
        minimum value is 1 and maximum value is 1000.
      name: pageSize
    - description: The nextPageToken returned from the previous scc-asset-resource-list
        command response, or unspecified for the first  scc-asset-resource-list command.
        It is a continuation of a prior scc-asset-resource-list call, and the API
        should return the next page of assets.
      name: pageToken
    - description: "Time used as a reference point when filtering assets. This can
        only be set to a timestamp between the current time and the current time minus
        35 days (inclusive). If not provided, it will take current time. \n\nFormat:\n(<number>
        <time unit>, e.g., \"12 hours ago\", \"7 days ago\", \"1 week\", \"1 month\")
        or (<date> <time>, e.g. \"yyyy-mm-ddTHH-MM-SS\") or ( \"YYYY-MM-ddTHH:mm:ss.sssZ\",
        e.g. 2020-07-22T07:10:02.782Z) or (<date>, e.g. \"2020-07-22\")."
      name: readTime
    description: Lists cloud asset's resources.
    name: google-cloud-scc-asset-resource-list
    outputs:
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.name
      description: The full name of the asset.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.assetType
      description: The type of the asset.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.updateTime
      description: The last update timestamp of an asset. The updateTime is updated
        when create/update/delete operation is performed.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.readTime
      description: Time used for executing the list request.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.ancestors
      description: The ancestry path of an asset in Google Cloud resource hierarchy,
        represented as a list of relative resource names. An ancestry path starts
        with the closest ancestor in the hierarchy and ends at root. If the asset
        is a project, folder, or organization, the ancestry path starts from the asset
        itself.
      type: Unknown
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.version
      description: The API version.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.discoveryDocumentUri
      description: The URL of the discovery document containing the resource's JSON
        schema. This value is unspecified for resources that do not have an API based
        on a discovery document, such as Cloud Bigtable.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.discoveryName
      description: The JSON schema name listed in the discovery document. This value
        is unspecified for resources that do not have an API based on a discovery
        document, such as Cloud Bigtable.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.resourceUrl
      description: The REST URL for accessing the resource. An HTTP GET request using
        this URL returns the resource itself.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.parent
      description: The full name of the immediate parent of this resource. For third-party
        assets, this field may be set differently.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.data
      description: The content of the resource, in which some sensitive fields are
        removed and may not be present.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.Resource.resource.location
      description: The location of the resource in Google Cloud, such as its zone
        and region.
      type: String
    - contextPath: GoogleCloudSCC.Token.name
      description: Name of the command.
      type: String
    - contextPath: GoogleCloudSCC.Token.nextPageToken
      description: Token to retrieve the next page of results, or empty if there are
        no more results.
      type: String
  - arguments:
    - description: |-
        Name of the project. Supports comma separated values.

        Format: "projects/[project-number]" or for multiple projects "projects/[first-project-number], projects/[second-project-number]"
      name: projectName
      required: true
    - defaultValue: "2"
      description: Number of iterations to search the owner information. Each iteration
        retrieves 1000 records. The minimum value is 1 and maximum value is 10.
      name: maxIteration
    description: Gets the owner information for the provided projects.
    name: google-cloud-scc-asset-owner-get
    outputs:
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.name
      description: The full name of the asset.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.owners
      description: List of owners of the asset.
      type: Unknown
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.assetType
      description: The type of the asset.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.updateTime
      description: The last update timestamp of an asset. The updateTime is updated
        when create/update/delete operation is performed.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.readTime
      description: Time used for executing the list request.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.ancestors
      description: The ancestry path of an asset in Google Cloud resource hierarchy,
        represented as a list of relative resource names. An ancestry path starts
        with the closest ancestor in the hierarchy and ends at root. If the asset
        is a project, folder, or organization, the ancestry path starts from the asset
        itself.
      type: Unknown
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.version
      description: Specifies the format of the policy.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.etag
      description: 'The etag is used for optimistic concurrency control as a way to
        help prevent simultaneous updates of a policy from overwriting each other.
        It is strongly suggested that systems make use of the etag in the read-modify-write
        cycle to perform policy updates in order to avoid race conditions: An etag
        is returned in the response to getIamPolicy, and systems are expected to put
        that etag in the request to setIamPolicy to ensure that their change will
        be applied to the same version of the policy.'
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.bindings.role
      description: A role is a named collection of permissions that provide the ability
        to perform actions on Google Cloud resources.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.bindings.members
      description: A member, also known as an identity or principal, which can be
        a user account, service account, Google group, or domain.
      type: Unknown
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.bindings.condition
      description: A condition, which is an optional logic expression that further
        constrains the role binding based on attributes about the request, such as
        its origin, the target resource, and so on. Conditions are typically used
        to control whether access is granted based on the context for a request.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.auditConfigs.service
      description: Specifies a service that will be enabled for audit logging.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.auditConfigs.auditLogConfigs.logType
      description: The log type that this config enables.
      type: String
    - contextPath: GoogleCloudSCC.CloudAsset.IamPolicy.auditConfigs.auditLogConfigs.exemptedMembers
      description: Specifies the identities that do not cause logging for this type
        of permission.
      type: String
  dockerimage: demisto/google-api-py3:1.0.0.24037
  isfetch: true
  runonce: false
  script: |2


    """ IMPORTS """
    import json
    from typing import Any, Dict, List, Optional, Tuple, Callable, Union

    import urllib.parse
    import dateparser
    import httplib2
    import traceback
    from copy import deepcopy
    from google.auth import exceptions
    from google.oauth2 import service_account
    from googleapiclient import discovery
    from googleapiclient.errors import HttpError
    from google_auth_httplib2 import AuthorizedHttp

    """ CONSTANTS """
    SCOPES = ["https://urldefense.com/v3/__https://www.googleapis.com/auth/cloud-platform__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jGodseIQ$ "]
    SERVICE_NAME = "securitycenter"
    PUBSUB_SERVICE_NAME = "pubsub"
    CLOUD_ASSET_SERVICE_NAME = "cloudasset"
    SERVICE_VERSION = "v1"
    PUBSUB_SERVICE_VERSION = "v1"
    CLOUD_ASSET_SERVICE_VERSION = "v1"
    DEFAULT_MAX_FETCH_VALUE = "50"
    MAX_FETCH_VALUE = "200"
    DEFAULT_PAGE_SIZE = 10
    MAX_PAGE_SIZE = 1000
    INCIDENT_NAME_PREFIX = "GoogleCloudSCC"
    STATE_LIST = ["ACTIVE", "INACTIVE"]  # List of state mentioned in API doc
    SEVERITY_LIST = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]  # List of severity mentioned in API doc
    ALLOWED_DATE_UNIT = ["minute", "minutes", "hour", "hours", "day", "days", "month", "months", "year", "years"]
    DATE_FORMAT = "%B %d, %Y at %I:%M:%S %p"
    ISO_DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"
    MARKDOWN_LINK = "[{}]({})"
    TIMEOUT_TIME = 60  # in second

    # The maximum number of results to return in a single response.
    # (ref: https://urldefense.com/v3/__https://cloud.google.com/security-command-center/docs/reference/rest/v1/organizations.sources.findings/list__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8h8w9keKQ$ )
    MAX_ITERATION = 10
    DEFAULT_MAX_ITERATION = 2

    ERROR_MESSAGES: Dict[str, str] = {
        "JSON_PARSE_ERROR": "Unable to parse json. Please check the {} parameter.",
        "INVALID_ORGANIZATION_ID": "Invalid Organization ID.",
        "INVALID_ORGANIZATION_OR_PERMISSION_DENIED_ERROR": "Organization Id is not valid or permission denied.",
        "INVALID_SERVICE_ACCOUNT": "Invalid service account credentials.",
        "BAD_REQUEST_ERROR": "An error occurred while fetching/submitting the data. Reason: {}",
        "AUTHENTICATION_ERROR": "Unauthenticated. Check the configured Service Account JSON. Reason: {}",
        "AUTHORIZATION_ERROR": "Request has insufficient privileges. Reason: {}",
        "NOT_FOUND_ERROR": "Not found. Reason: {}",
        "TOO_MANY_REQUESTS_ERROR": "Too many requests please try after sometime. Reason: {}",
        "INTERNAL_SERVER_ERROR": "The server encountered an internal error. Reason: {}",
        "CONFLICT_ERROR": "Conflict. Reason: {}",
        "TIMEOUT_ERROR": "Connection Timeout Error - potential reasons might be that the Server is not accessible "
                         "from your host. Reason: {}",
        "PROXY_ERROR": "Proxy Error - if the 'Use system proxy' checkbox in the integration configuration is"
                       " selected, try clearing the checkbox.",
        "UNKNOWN_ERROR": "An error occurred. Status: {}. Reason: {}",
        "NO_RECORDS_FOUND": "No {} record(s) found for the given argument(s).",
        "MAX_INCIDENT_ERROR": "The parameter Max Incidents must be a positive integer."
                              " Accepted values can be in the range of 1-{}.".format(MAX_FETCH_VALUE),
        "INVALID_STATE_ERROR": "The state value must be ACTIVE or INACTIVE.",
        "INVALID_SEVERITY_ERROR": "The severity value must be LOW, MEDIUM, HIGH or CRITICAL.",
        "INVALID_PAGE_SIZE_ERROR": "Page size should be an integer between 1 to 1000.",
        "INVALID_SOURCE_PROPERTIES": "Invalid format provided in sourceProperties. Supported format: key1=value1,key2="
                                     "value2. if the value contains ',' or '=' character then escape with extra '\\'.",
        "REQUIRED_PROJECT_ID": "Project ID is required for fetch incidents.",
        "REQUIRED_SUBSCRIPTION_ID": "Subscription ID is required for fetch incidents.",
        "INVALID_INCIDENT": "Error while parsing pub/sub message. Reason: {}",
        "INVALID_DATE_TIME": "{} should be in following format: (<number> <time unit>, e.g., \"12 hours ago\","
                             " \"7 days ago\", \"1 week\", \"1 month\") or (<date> <time>, e.g. "
                             "\"yyyy-mm-ddTHH-MM-SS\") or ( \"YYYY-MM-ddTHH:mm:ss.sssZ\", "
                             "e.g. 2020-07-22T07:10:02.782Z) or (<date>, e.g. \"2020-07-22\").",
        "INVALID_PROJECT_NAME_ERROR": "projectName should be in following format: "
                                      "\"projects/[project-number]\" or \"projects/[first-project-number], "
                                      "projects/[second-project-number]\".",
        "INVALID_MAX_ITERATION_ERROR": "maxIteration should be an integer between 1 to {}.".format(MAX_ITERATION)
    }

    OUTPUT_PREFIX: Dict[str, Any] = {
        "LIST_ASSET": "GoogleCloudSCC.Asset(val.name && val.name == obj.name)",
        "LIST_FINDING": "GoogleCloudSCC.Finding(val.name && val.name == obj.name)",
        "TOKEN": "GoogleCloudSCC.Token(val.name && val.name == obj.name)",
        "FINDING": "GoogleCloudSCC.Finding",
        "LIST_RESOURCE": "GoogleCloudSCC.CloudAsset.Resource(val.name && val.name == obj.name)",
        "GET_OWNER": "GoogleCloudSCC.CloudAsset.IamPolicy"
    }

    GET_OUTPUT_MESSAGE: Dict[str, Any] = {
        "HEADER_MESSAGE": "Total retrieved {0}: {1}"
    }

    COMMON_STRING: Dict[str, str] = {
        "RESOURCE_NAME": "Resource Name",
        "SECURITY_MARKS": "Security Marks",
        "SET_STATE_HR_STR": "The state of the finding has been updated successfully.",
        "EVENT_TIME": "Event Time (In UTC)",
        "CREATE_TIME": "Create Time (In UTC)"
    }

    """ HELPER CLASSES """


    class GoogleNameParser:
        """
        Used to easily transform Google Cloud SCC names
        """
        # Google SCC helpers
        ORGANIZATION_PATH = "organizations/{}"
        SOURCE_PATH = "/sources/{}"
        FINDING_PATH = "/findings/{}"
        SCC_URL = "https://urldefense.com/v3/__https://console.cloud.google.com/security/command-center/*7B*7D?organizationId=*7B*7D&resourceId=*7B*7D__;JSUlJSUl!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8iEmLK-uA$ "

        # Google Pub/Sub helpers
        PROJECT_PATH = "projects/{}"
        SUBSCRIPTION_PATH = "/subscriptions/{}"

        @staticmethod
        def get_organization_id():
            """
            Return a fully-qualified organizations string.

            :return: fully-qualified organizations string.
            """
            return demisto.params().get("organization_id", "")

        @staticmethod
        def get_organization_path():
            """
            Return a fully-qualified organizations string.

            :return: fully-qualified organizations string.
            """
            return GoogleNameParser.ORGANIZATION_PATH.format(GoogleNameParser.get_organization_id())

        @staticmethod
        def get_source_path(source: str) -> str:
            """
            Return a fully-qualified source string.

            :param source: source id param.
            :return: fully-qualified source string.
            """
            return GoogleNameParser.get_organization_path() + GoogleNameParser.SOURCE_PATH.format(source)

        @staticmethod
        def get_finding_path(source, finding):
            """
            fully-qualified finding string.

            :param source: source name or source id
            :param finding: finding id
            :return: fully-qualified finding string.
            """
            return GoogleNameParser.get_source_path(source) + GoogleNameParser.FINDING_PATH.format(finding)

        @staticmethod
        def get_finding_url(name: str):
            """
            Get a finding url which redirect UI

            :param name: resource name
            :return: finding url
            """
            return GoogleNameParser.SCC_URL.format("findings", GoogleNameParser.get_organization_id(), name)

        @staticmethod
        def get_asset_url(name: str):
            """
            Get a asset url which redirect UI

            :param name: resource name
            :return: asset url
            """
            return GoogleNameParser.SCC_URL.format("assets", GoogleNameParser.get_organization_id(), name)

        @staticmethod
        def get_project_path(project_id):
            """
            Get a fully-qualified project path.

            :param project_id: project id of project
            :return: fully-qualified project path
            """
            return GoogleNameParser.PROJECT_PATH.format(project_id)

        @staticmethod
        def get_subscription_path(project_id, subscription_id):
            """
            Get a fully-qualified subscription path.

            :param project_id: project id of project
            :param subscription_id: subscription id of the topic
            :return:
            """
            return GoogleNameParser.get_project_path(project_id) + GoogleNameParser.SUBSCRIPTION_PATH.format(
                subscription_id)


    class BaseGoogleClient:
        """
        A Client class to wrap the google cloud api library as a service.
        """

        def __init__(self, service_name: str, service_version: str, service_account_json: str, scopes: list, proxy: bool,
                     **kwargs):
            """
            :param service_name: The name of the service. You can find this and the service  here
             https://urldefense.com/v3/__https://github.com/googleapis/google-api-python-client/blob/master/docs/dyn/index.md__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8hsAkwozw$
            :param service_version: The version of the API.
            :param service_account_json: A string of the generated credentials.json
            :param scopes: The scope needed for the project. (i.e. ['https://urldefense.com/v3/__https://www.googleapis.com/auth/cloud-platform__;!!Mt_FR42WkD9csi9Y!ZMqJMtMjUStaTsH0dLjwamzy4CuCP40l4h0MliMFeHGAYa-1pCGSsHvZbJ1VXAZRnMk76XrMxjLrk8jGodseIQ$ '])
            :param proxy: Proxy flag
            :param kwargs: Potential arguments dict
            """
            service_account_json = safe_load_non_strict_json(service_account_json)  # type: ignore
            try:
                credentials = service_account.Credentials.from_service_account_info(info=service_account_json,
                                                                                    scopes=scopes)
                http_client = AuthorizedHttp(credentials=credentials, http=self.get_http_client_with_proxy(proxy))
                self.service = discovery.build(service_name, service_version, http=http_client, cache_discovery=False)
            except httplib2.ServerNotFoundError as e:
                raise ValueError(ERROR_MESSAGES["TIMEOUT_ERROR"].format(str(e)))
            except (httplib2.socks.HTTPError, IndexError) as e:
                # library not able to handle Proxy error and throws Index Error
                demisto.debug(f"Failed to execute {demisto.command()} command. Error: {str(e)} , "
                              f"traceback: {traceback.format_exc()}")
                raise ValueError(ERROR_MESSAGES["PROXY_ERROR"])
            except exceptions.RefreshError as error:
                error_message = ERROR_MESSAGES["INVALID_SERVICE_ACCOUNT"]
                if error.args:
                    error_message += " Reason: {}".format(error.args[0])
                raise ValueError(error_message)

        @staticmethod
        def get_http_client_with_proxy(proxy: bool) -> httplib2.Http:
            """
            Create an http client with proxy with whom to use when using a proxy.
            :param proxy: Whether to use a proxy.

            :return: ProxyInfo object.
            """
            proxy_info = {}
            if proxy:
                proxies = handle_proxy()
                https_proxy = proxies.get("https")
                http_proxy = proxies.get("http")
                proxy_conf = https_proxy if https_proxy else http_proxy

                if proxy_conf:
                    if not proxy_conf.startswith("https") and not proxy_conf.startswith("http"):
                        proxy_conf = "https://" + proxy_conf
                    parsed_proxy = urllib.parse.urlparse(proxy_conf)
                    proxy_info = httplib2.ProxyInfo(
                        proxy_type=httplib2.socks.PROXY_TYPE_HTTP,
                        proxy_host=parsed_proxy.hostname,
                        proxy_port=parsed_proxy.port,
                        proxy_user=parsed_proxy.username,
                        proxy_pass=parsed_proxy.password,
                    )
            return httplib2.Http(proxy_info=proxy_info, timeout=TIMEOUT_TIME)

        @staticmethod
        def execute_request(request) -> Dict[str, Any]:
            """
            Execute the request and handle error scenario.

            :param request: request object
            :return: dictionary of json response
            """
            try:
                return request.execute()
            except HttpError as e:
                status = e.resp.status
                reason = e._get_reason()

                status_code_message_map = {
                    400: ERROR_MESSAGES["BAD_REQUEST_ERROR"],
                    401: ERROR_MESSAGES["AUTHENTICATION_ERROR"],
                    403: ERROR_MESSAGES["AUTHORIZATION_ERROR"],
                    404: ERROR_MESSAGES["NOT_FOUND_ERROR"],
                    409: ERROR_MESSAGES["CONFLICT_ERROR"],
                    429: ERROR_MESSAGES["TOO_MANY_REQUESTS_ERROR"],
                    500: ERROR_MESSAGES["INTERNAL_SERVER_ERROR"],
                }

                if status in status_code_message_map:
                    raise ValueError(status_code_message_map[status].format(reason))
                else:
                    raise ValueError(ERROR_MESSAGES["UNKNOWN_ERROR"].format(status, reason))
            except httplib2.socks.HTTPError as e:
                demisto.debug(f"Failed to execute {demisto.command()} command. Error: {str(e)} , "
                              f"traceback: {traceback.format_exc()}")
                raise ValueError(ERROR_MESSAGES["PROXY_ERROR"])
            except httplib2.ServerNotFoundError as e:
                raise ValueError(ERROR_MESSAGES["TIMEOUT_ERROR"].format(str(e)))


    class GoogleSccClient(BaseGoogleClient):
        """
        A Client class to wrap the google cloud security center api library as a service.
        """

        def __init__(self, organization_id: str, **kwargs):
            """Constructor for GoogleSccClient class."""
            super().__init__(**kwargs)
            self.organization_id = organization_id

        def get_findings(self, parent: str, compare_duration: Optional[str] = None, field_mask: Optional[str] = None,
                         filter_string: Optional[str] = None, order_by: Optional[str] = None,
                         page_size: Optional[Union[str, int]] = DEFAULT_PAGE_SIZE, page_token: Optional[str] = None,
                         read_time: Optional[str] = None) -> Dict[str, Any]:
            """
            Get an organization or source's findings.

            :param parent: Name of the source the findings belong to.
            :param compare_duration: A duration in seconds that is used to derived stateChange of finding.
            :param field_mask: A field mask to specify the Finding fields to be listed in the response.
            :param filter_string: Expression that defines the filter to apply across findings.
            :param order_by: Expression that defines what fields and order to use for sorting.
            :param page_size: The maximum number of results to return in a single response.
            :param page_token: The value returned by the last call; indicates that this is a continuation of a prior call.
            :param read_time: The Time used as a reference point when filtering findings.

            :return: list of findings
            """
            request = self.service.organizations().sources().findings().list(  # pylint: disable=E1101
                parent=parent, compareDuration=compare_duration, fieldMask=field_mask, filter=filter_string,
                orderBy=order_by, pageSize=page_size, pageToken=page_token, readTime=read_time)
            result = self.execute_request(request)
            return result

        def get_assets(self, parent: str, compare_duration: str, field_mask: str, filter_string: str, order_by: str,
                       page_size: Union[str, int], page_token: str, read_time: str) -> Dict[str, Any]:
            """
            Get an organization's assets.

            :param parent: Name of the organization assets should belong to.
            :param compare_duration: A duration in seconds that is used to derived stateChange of finding.
            :param field_mask: A field mask to specify the Finding fields to be listed in the response.
            :param filter_string: Expression that defines the filter to apply across findings.
            :param order_by: Expression that defines what fields and order to use for sorting.
            :param page_size: The maximum number of results to return in a single response.
            :param page_token: The value returned by the last call; indicates that this is a continuation of a prior call.
            :param read_time: The Time used as a reference point when filtering findings.
            :return: list of assets
            """
            request = self.service.organizations().assets().list(  # pylint: disable=E1101
                parent=parent, compareDuration=compare_duration, fieldMask=field_mask, filter=filter_string,
                orderBy=order_by, pageSize=page_size, pageToken=page_token, readTime=read_time)

            result = self.execute_request(request)
            return result

        def get_source(self, name: str) -> Dict[str, Any]:
            """
            Gets a source.

            :param name: A Relative resource name of the source.
            :return:
            """
            request = self.service.organizations().sources().get(name=name)  # pylint: disable=E1101
            result = self.execute_request(request)
            return result

        def update_finding(self, name: str, event_time: Optional[str], severity: Optional[str],
                           external_uri: Optional[str], source_properties: Optional[str],
                           update_mask: List) -> Dict[str, Any]:
            """
            Updates a finding. The corresponding source must exist for a finding update to succeed.

            :param name: The resource name of this finding.
            :param event_time: event time of finding
            :param severity: severity of finding
            :param external_uri: external_uri of finding
            :param source_properties: source_properties of finding
            :param update_mask: which field you want to update

            :return: updated finding response
            """
            body = assign_params(eventTime=event_time, severity=severity, externalUri=external_uri,
                                 sourceProperties=source_properties)
            update_mask = get_update_mask_for_update_finding(body, update_mask)  # type: ignore
            request = self.service.organizations().sources().findings().patch(  # pylint: disable=E1101
                name=name, updateMask=update_mask, body=body)
            result = self.execute_request(request)
            return result


    class GooglePubSubClient(BaseGoogleClient):
        """
            A Client class to wrap the google cloud pub/sub api library as a service.
        """

        def __init__(self, project_id, subscription_id, service_account_json, **kwargs):
            """Constructor for GooglePubSubClient class."""
            super().__init__(service_account_json=service_account_json, **kwargs)
            self.project_id = project_id or extract_project_id_from_service_account(service_account_json)
            self.subscription_id = subscription_id

        def pull_messages(self, max_messages, ret_immediately=True) -> Dict[str, Any]:
            """
            Pull messages for the subscription

            :param max_messages: The maximum number of messages to return for this request. Must be a positive integer
            :param ret_immediately: when set to true will return immediately, otherwise will be async
            :return: Messages
            """
            subscription = GoogleNameParser.get_subscription_path(self.project_id, self.subscription_id)
            body = assign_params(returnImmediately=ret_immediately, maxMessages=max_messages)
            request = self.service.projects().subscriptions().pull(  # pylint: disable=E1101
                subscription=subscription, body=body)
            result = self.execute_request(request)
            return result

        def acknowledge_messages(self, acks_list: List) -> Dict[str, Any]:
            """
            Pull messages for the subscription

            :param acks_list: The maximum number of messages to return for this request. Must be a positive integer
            :return:
            """
            subscription = GoogleNameParser.get_subscription_path(self.project_id, self.subscription_id)
            body = assign_params(ackIds=acks_list)
            request = self.service.projects().subscriptions().acknowledge(  # pylint: disable=E1101
                subscription=subscription, body=body)
            result = self.execute_request(request)
            return result


    class GoogleCloudAssetClient(BaseGoogleClient):
        """
            A Client class to wrap the google cloud assets api library as a service.
        """

        def __init__(self, organization_id: str, **kwargs):
            """Constructor for GoogleCloudAssetClient class."""
            super().__init__(**kwargs)
            self.organization_id = organization_id

        def get_assets(self, parent: str, asset_types: list, content_type: str, page_size: Union[str, int],
                       page_token: str, read_time: Optional[str]) -> Dict[str, Any]:
            """
            Get a assets based on asset type and content type.

            :param parent: Name of the organization or project the assets belong to.
            :param asset_types: A list of asset types to take a snapshot for.
            :param content_type: A field mask to specify the Finding fields to be listed in the response.
            :param page_size: The maximum number of results to return in a single response.
            :param page_token: The value returned by the last call; indicates that this is a continuation of a prior call.
            :param read_time: Timestamp to take an asset snapshot.
            :return: list of assets
            """
            request = self.service.assets().list(  # pylint: disable=E1101
                parent=parent, assetTypes=asset_types, contentType=content_type,
                pageSize=int(page_size), pageToken=page_token, readTime=read_time)

            result = self.execute_request(request)
            return result


    """ HELPER FUNCTIONS """


    def init_google_scc_client(**kwargs) -> GoogleSccClient:
        """
        Initializes google scc client
        :param kwargs: keyword arguments
        :return: SCC Client object
        """
        client = GoogleSccClient(service_name=SERVICE_NAME, service_version=SERVICE_VERSION, scopes=SCOPES, **kwargs)
        return client


    def init_google_pubsub_client(**kwargs) -> GooglePubSubClient:
        """
        Initializes google pubsub client
        :param kwargs: keyword arguments
        :return: Pubsub Client object
        """
        client = GooglePubSubClient(service_name=PUBSUB_SERVICE_NAME, service_version=PUBSUB_SERVICE_VERSION,
                                    scopes=SCOPES, **kwargs)
        return client


    def init_google_cloud_assets_client(**kwargs) -> GoogleCloudAssetClient:
        """
        Initializes google google cloud assets client
        :param kwargs: keyword arguments
        :return: Google cloud assets client object
        """
        client = GoogleCloudAssetClient(service_name=CLOUD_ASSET_SERVICE_NAME, service_version=CLOUD_ASSET_SERVICE_VERSION,
                                        scopes=SCOPES, **kwargs)
        return client


    def safe_load_non_strict_json(json_string: str) -> Dict[str, Any]:
        """
        Loads the JSON with non-strict mode.

        :param json_string: json string to parse.

        :return: Parsed dictionary.
        :raises ValueError: If there is any other issues while parsing json.
        """
        try:
            if json_string:
                return json.loads(json_string, strict=False)
            return {}
        except ValueError:
            raise ValueError(ERROR_MESSAGES["JSON_PARSE_ERROR"].format("Service Account JSON"))


    def validate_get_int(max_results: Optional[str], message: str, limit: Union[int, str] = 0) -> Optional[int]:
        """
        Validate and convert string max_results to integer.

        :param max_results: max results in string.
        :param message: Message to display when exception raised.
        :param limit: If max_results > limit raise the exception.

        :return: int max_results
        :raises ValueError: if max_results is not a integer and < 0.
        """
        if max_results:
            try:
                max_results_int = int(max_results)
                if max_results_int <= 0:
                    raise ValueError(message)
                if limit and max_results_int > int(limit):
                    raise ValueError(message)
                return max_results_int
            except ValueError:
                raise ValueError(message)
        return None


    def validate_project_and_subscription_id(params: Dict[str, Any]) -> None:
        """
        Validates parameters for fetch-incidents command.

        :param params: parameters dictionary.

        :return: None
        """
        pubsub_client = init_google_pubsub_client(**params)
        pubsub_client.pull_messages(1)


    def validate_service_account_and_organization_name(params: Dict[str, str]) -> None:
        """
        Validate Service Account JSON and Organization ID

        :param params: configuration parameter
        :return:
        """
        service_account_json = safe_load_non_strict_json(params.get("service_account_json", ""))

        if not isinstance(service_account_json, dict) or not service_account_json:
            raise ValueError(ERROR_MESSAGES["INVALID_SERVICE_ACCOUNT"])

        client = init_google_scc_client(**params)
        parent = GoogleNameParser.get_source_path("-")
        client.get_findings(parent, page_size=1)


    def validate_state_and_severity_list(state_list: List, severity_list: List) -> None:
        """
        Validate severity and state list values

        :param state_list: state list
        :param severity_list: severity list

        :return:
        """
        for state in state_list:
            if state and state.strip().upper() not in STATE_LIST:
                raise ValueError(ERROR_MESSAGES["INVALID_STATE_ERROR"])

        # Validate Severity param
        for severity in severity_list:
            if severity and severity.strip().upper() not in SEVERITY_LIST:
                raise ValueError(ERROR_MESSAGES["INVALID_SEVERITY_ERROR"])


    def validate_configuration_param(params: Dict[str, Any]) -> None:
        """
        validate configuration parameter through API call.

        :param params: parameter dictionary
        :return: None
        """
        # Validate parameter by hitting finding endpoint
        organization_id: str = params.get("organization_id", "")
        if not organization_id:
            raise ValueError(ERROR_MESSAGES["INVALID_ORGANIZATION_ID"])

        max_fetch = params.get("max_fetch") or DEFAULT_MAX_FETCH_VALUE
        validate_get_int(max_fetch, ERROR_MESSAGES["MAX_INCIDENT_ERROR"], MAX_FETCH_VALUE)
        service_account_json = params.get("service_account_json", "")
        project_id = params.get("project_id", "") or extract_project_id_from_service_account(service_account_json)
        subscription_id = params.get("subscription_id", "")
        is_fetch = params.get("isFetch", False)
        if is_fetch and not project_id:
            raise ValueError(ERROR_MESSAGES["REQUIRED_PROJECT_ID"])

        if is_fetch and not subscription_id:
            raise ValueError(ERROR_MESSAGES["REQUIRED_SUBSCRIPTION_ID"])


    def create_filter_list_findings(category: str, filter_string: str, severity: list, state: list) -> str:
        """
        creating common filter query string for "list findings" API based on various filter parameter.

        :param category: category filter
        :param filter_string: filter string
        :param severity: severity filter
        :param state: state filter
        :return: filter query string
        """
        if severity:
            filter_string = add_filter("Severity", filter_string, severity)
        if state:
            filter_string = add_filter("State", filter_string, state)
        if category:
            category_list: list = category.split(",")
            filter_string = add_filter("Category", filter_string, category_list)

        return filter_string


    def add_filter(label, filter_string, values) -> str:
        """
        adding filter in filter parameter string.

        :param label: label of the filter. i.e Severity, Category etc
        :param filter_string: filter param string
        :param values: list of values
        :return: filter params string
        """
        if filter_string:
            filter_string = filter_string + " AND "

        filter_string += "({})".format(" OR ".join(['{}="{}"'.format(label, value.strip()) for value in values]))
        return filter_string


    def prepare_markdown_fields_for_fetch_incidents(fields: Dict[str, Any]) -> Dict[str, str]:
        """
        Prepares markdown fields for incident.

        :param fields: fields received in response of incident.
        :returns: None
        """
        security_marks = dict_safe_get(fields, ["finding", "securityMarks", "marks"], {})
        mfa_details = dict_safe_get(fields, ["finding", "sourceProperties", "MfaDetails"], {})
        security_marks_hr = tableToMarkdown("", security_marks)
        mfa_details_hr = tableToMarkdown("", mfa_details)
        return {"securityMarks": security_marks_hr, "MfaDetails": mfa_details_hr}


    def strip_dict(args: Dict[str, str]) -> Dict[str, str]:
        """
        Remove leading and trailing white spaces from dictionary values and remove empty entries.
        :param args: Arguments dict.
        :return: Dictionary with whitespaces and empty entries removed.
        """
        return {key: value.strip() for (key, value) in args.items() if value and value.strip()}


    def create_filter_list_assets(asset_type: str, project: str, filter_string: str, active_assets_only: str) -> str:
        """
        creating common filter query string for "list findings" API based on various filter parameter.
        :param asset_type: type filter
        :param filter_string: filter dict
        :param project: project filter
        :param  active_assets_only: lifeCycleState filter
        :return: filter query string
        """
        if filter_string is None:
            filter_string = ""
        if project:
            project_list: list = project.split(",")
            filter_string = add_filter("resourceProperties.name", filter_string, project_list)
        if asset_type:
            type_list: list = asset_type.split(",")
            filter_string = add_filter("securityCenterProperties.resourceType", filter_string, type_list)
        if active_assets_only.lower() == "true":
            filter_string = add_filter('resourceProperties.lifecycleState', filter_string, ['ACTIVE'])
        return filter_string


    def prepare_human_readable_dict_for_list_asset(asset: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepare human-readable dictionary for list asset command.
        :param asset: asset information
        :return: human-readable dict
        """
        asset_url = GoogleNameParser.get_asset_url(asset.get("name", ""))

        return {
            COMMON_STRING["RESOURCE_NAME"]: asset.get("securityCenterProperties", {}).get("resourceName", ""),
            "Resource Type": asset.get("securityCenterProperties", {}).get("resourceType", ""),
            "Resource Owners": asset.get("securityCenterProperties", {}).get("resourceOwners", {}),
            "Project": asset.get("resourceProperties", {}).get("name", ""),
            "Name": get_markdown_link(asset.get("name", ""), asset_url),
            COMMON_STRING["SECURITY_MARKS"]: asset.get("securityMarks", {}).get("marks", {})
        }


    def prepare_outputs_for_list_assets(result) -> Tuple[Dict[str, Any], str]:
        """
        Preparing context output and human-readable for list-assets command.

        :param result: result dictionary
        :return:
        """
        hr_asset_list = []
        ec_asset_list = []

        list_assets = result.get("listAssetsResults", [])
        if len(list_assets) <= 0:
            return {}, ERROR_MESSAGES["NO_RECORDS_FOUND"].format("asset")

        read_time = result.get("readTime", "")
        total_size = result.get("totalSize")

        for asset in list_assets:
            flatten_keys_to_root(asset, ["asset"], {"readTime": read_time, "stateChange": asset.get("stateChange", None)})
            ec_asset_list.append(asset)
            hr_asset_dict = prepare_human_readable_dict_for_list_asset(asset)
            hr_asset_list.append(hr_asset_dict)

        # Preparing headers
        headers = ["Name", "Project", COMMON_STRING["RESOURCE_NAME"], "Resource Type", "Resource Owners",
                   COMMON_STRING["SECURITY_MARKS"]]
        readable_output = tableToMarkdown(GET_OUTPUT_MESSAGE["HEADER_MESSAGE"].format("asset(s)", total_size),
                                          t=hr_asset_list, headers=headers, removeNull=True)

        # preparing context
        ec_asset_dict: Dict[str, Any] = {
            OUTPUT_PREFIX["LIST_ASSET"]: ec_asset_list
        }

        next_page_token = result.get("nextPageToken", "")
        if next_page_token:
            token_ec = {"name": "google-cloud-scc-asset-list", "nextPageToken": next_page_token}
            ec_asset_dict.update({OUTPUT_PREFIX["TOKEN"]: token_ec})

        return remove_empty_elements(ec_asset_dict), readable_output


    def flatten_keys_to_root(data_dict: Dict[str, Any], keys: List, update_dict: Dict[str, Any]):
        """
        Add list of keys to root level in dict

        :param data_dict: dictionary
        :param keys: list of keys
        :param update_dict: dictionary that will be add in data dict
        :return: flatten dict for provided keys
        """
        for key in keys:
            value = data_dict.pop(key, None)
            if value and isinstance(value, dict):
                data_dict.update(value)
            else:
                data_dict[key] = value
        data_dict.update(update_dict)


    def convert_string_to_date_format(date: str, date_format: str = DATE_FORMAT) -> Optional[str]:
        """
        Convert date into given format

        :param date: date string
        :param date_format: output date format
        :return: human readable date
        """
        date_obj = dateparser.parse(date)

        if date_obj:
            return date_obj.strftime(date_format)
        return None


    def prepare_hr_and_ec_for_list_findings(result: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Prepare human readable output

        :param result: List findings API response
        :return: markdown string and context data  of list findings
        """
        # Preparing list of entry context and human readable
        hr_finding_list = []
        ec_finding_list = []

        findings = result.get("listFindingsResults", [])
        if not len(findings):
            return ERROR_MESSAGES["NO_RECORDS_FOUND"].format("finding"), {}

        read_time = result.get("readTime", "")
        total_size = result.get("totalSize")

        for finding in findings:
            flatten_keys_to_root(finding, ["finding"],
                                 {"readTime": read_time, "stateChange": finding.get("stateChange", None)})
            ec_finding_list.append(finding)
            finding_url = GoogleNameParser.get_finding_url(finding.get("name", ""))
            hr_finding_list.append({
                "Name": get_markdown_link(finding.get("name", ""), finding_url),
                "Category": finding.get("category", ""),
                COMMON_STRING["RESOURCE_NAME"]: finding.get("resourceName", ""),
                COMMON_STRING["EVENT_TIME"]: convert_string_to_date_format(finding.get("eventTime", "")),
                COMMON_STRING["CREATE_TIME"]: convert_string_to_date_format(finding.get("createTime", "")),
                COMMON_STRING["SECURITY_MARKS"]: finding.get("securityMarks", {}).get("marks", {})
            })

        headers = ["Name", "Category", COMMON_STRING["RESOURCE_NAME"], COMMON_STRING["EVENT_TIME"],
                   COMMON_STRING["CREATE_TIME"], COMMON_STRING["SECURITY_MARKS"]]
        readable_output = tableToMarkdown(GET_OUTPUT_MESSAGE["HEADER_MESSAGE"].format("finding(s)", total_size),
                                          t=hr_finding_list, headers=headers, removeNull=True)

        # preparing context
        ec_dict: Dict[str, Any] = {
            OUTPUT_PREFIX["LIST_FINDING"]: ec_finding_list
        }
        next_page_token = result.get("nextPageToken", "")
        if next_page_token:
            token_ec = {"name": "google-cloud-scc-finding-list", "nextPageToken": next_page_token}
            ec_dict[OUTPUT_PREFIX["TOKEN"]] = token_ec

        return readable_output, remove_empty_elements(ec_dict)


    def get_and_validate_args_finding_update(args: Dict[str, Any]) -> Tuple:
        """
        Get and validate arguments of finding update command.

        :param args: arguments of finding update command.
        :return: name, event_time, severity, external_uri, source_properties, update_mask
        """
        # Get command args
        name = args.get("name", None)
        event_time = args.get("eventTime") or datetime.now().strftime(ISO_DATE_FORMAT)
        severity = args.get("severity", "").upper()
        external_uri = args.get("externalUri", None)
        source_properties = args.get("sourceProperties", None)
        update_mask = [value for value in args.get("updateMask", "").split(",") if value.strip()]

        if severity and severity.strip().upper() not in SEVERITY_LIST:
            raise ValueError(ERROR_MESSAGES["INVALID_SEVERITY_ERROR"])

        try:
            if source_properties:
                source_properties = dict(split_and_escape(line, "=")  # type: ignore
                                         for line in split_and_escape(source_properties, ","))
        except ValueError:
            raise ValueError(ERROR_MESSAGES["INVALID_SOURCE_PROPERTIES"])

        return name, event_time, severity, external_uri, source_properties, update_mask


    def prepare_hr_and_ec_for_update_finding(result: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Prepare human readable output

        :param result: List findings API response
        :return: markdown string and context data  of list findings
        """
        # Preparing list of entry context and human readable
        finding_url = GoogleNameParser.get_finding_url(result.get("name", ""))

        hr_data = {
            "Name": get_markdown_link(result.get("name", ""), finding_url),
            "State": result.get("state", ""),
            "Severity": result.get("severity", ""),
            "Category": result.get("category", ""),
            COMMON_STRING["EVENT_TIME"]: convert_string_to_date_format(result.get("eventTime", "")),
            COMMON_STRING["CREATE_TIME"]: convert_string_to_date_format(result.get("createTime", "")),
            "External Uri": get_markdown_link(result.get("externalUri", ""), result.get("externalUri", "")),
            COMMON_STRING["RESOURCE_NAME"]: result.get("resourceName", "")
        }

        headers = ["Name", "State", "Severity", "Category", COMMON_STRING["EVENT_TIME"], COMMON_STRING["CREATE_TIME"],
                   "External Uri", COMMON_STRING["RESOURCE_NAME"]]
        readable_output = tableToMarkdown("The finding has been updated successfully.", t=hr_data, headers=headers,
                                          removeNull=True)

        return readable_output, remove_empty_elements(result)


    def validate_with_regex(validation_message: str, pattern: str, string: str, flags=0) -> None:
        """
        Match the string with regex pattern, if match is not found then raises ValueError with supplied validation message
        :param pattern: pattern to match with
        :param string: string to match on
        :param flags: flags used in re library
        :param validation_message: message to raise ValueError with
        """
        match = re.match(pattern, string, flags)
        if match is None:
            raise ValueError(validation_message)


    def prepare_hr_and_ec_for_cloud_asset_list(result: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Prepare human readable output

        :param result: List Cloud Asset API response
        :return: markdown string and context data of cloud assets
        """
        # Preparing list of entry context and human readable
        hr_asset_list = []
        ec_asset_list = []

        list_assets = result.get("assets", [])
        if len(list_assets) == 0:
            return ERROR_MESSAGES["NO_RECORDS_FOUND"].format("resource"), {}

        read_time = result.get("readTime", "")

        for asset in list_assets:
            asset["readTime"] = read_time
            ec_asset_list.append(asset)
            resource = asset.get("resource", {})
            hr_asset_dict = {
                "Asset Name": asset.get("name", ""),
                "Asset Type": asset.get("assetType", ""),
                "Parent": resource.get("parent", ""),
                "Discovery Name": resource.get("discoveryName", ""),
                "Ancestors": asset.get("ancestors", ""),
                "Update Time (In UTC)": convert_string_to_date_format(asset.get("updateTime", "")),
            }
            hr_asset_list.append(hr_asset_dict)

        headers = ["Asset Name", "Asset Type", "Parent", "Discovery Name", "Ancestors", "Update Time (In UTC)"]
        readable_output = tableToMarkdown("", t=hr_asset_list, headers=headers, removeNull=True)

        # preparing context
        ec_dict: Dict[str, Any] = {OUTPUT_PREFIX["LIST_RESOURCE"]: ec_asset_list}
        next_page_token = result.get("nextPageToken", "")
        if next_page_token:
            token_ec = {"name": "google-cloud-scc-asset-resource-list", "nextPageToken": next_page_token}
            ec_dict[OUTPUT_PREFIX["TOKEN"]] = token_ec

        return readable_output, remove_empty_elements(ec_dict)


    def prepare_hr_and_ec_for_cloud_asset_owners_get(assets: list, read_time: str) -> Tuple[str, list]:
        """
            Prepare human readable output

            :param assets: Cloud Assets
            :param read_time: readTime returned in API response
            :return: markdown string and context data of cloud assets
        """

        if len(assets) == 0:
            return ERROR_MESSAGES["NO_RECORDS_FOUND"].format("project"), []

        hr_asset_list = []

        for asset in assets:
            asset['owners'] = find_asset_owners(asset)
            asset['readTime'] = read_time

            hr_asset_dict = {
                "Project Name": asset.get("name", ""),
                "Project Owner": asset['owners'],
                "Ancestors": asset.get("ancestors", ""),
                "Update Time (In UTC)": convert_string_to_date_format(asset.get("updateTime", "")),
            }
            hr_asset_list.append(hr_asset_dict)

        headers = ["Project Name", "Project Owner", "Ancestors", "Update Time (In UTC)"]
        readable_output = tableToMarkdown("", t=hr_asset_list, headers=headers, removeNull=True)

        return readable_output, remove_empty_elements(assets)


    def find_asset_owners(asset: dict) -> list:
        """
        Retrieve owners from a cloud asset
        :param asset: asset from which to extract owners
        :return: a list of owners of provided asset
        """
        iam_policies = asset.get("iamPolicy", {})

        for binding in iam_policies.get('bindings', []):
            if binding['role'] == "roles/owner":
                return binding['members']
        return []


    def get_update_mask_for_update_finding(body: Dict[str, Any], update_mask: List) -> str:
        """
        Get updateMask for finding update API call.

        :param body: json body
        :param update_mask: list which contains which field should update
        :return: updateMask
        """
        for key, value in body.items():
            if key == "sourceProperties" and key not in update_mask:
                update_mask.extend(["sourceProperties." + inner_key for inner_key in value.keys()])
                continue
            if key not in update_mask:
                update_mask.append(key)
        return ",".join(update_mask)


    def split_and_escape(key: str, delimiter) -> List[str]:
        """
        Split key by delimiter with escape support.

        :param key: string which will be split
        :param delimiter: delimiter
        :return: a list of the extract keys
        """
        regex = r"(?<!\\)" + re.escape(delimiter)
        split_keys = map(lambda x: x.replace(r"\{}".format(delimiter), delimiter), re.split(regex, key))
        keys = [split_key.strip() for split_key in list(split_keys)]
        return keys


    def get_markdown_link(name: str, link: str) -> Optional[str]:
        """
        Prepare markdown supported link.

        :param name: display name of link
        :param link: link address
        :return: link in markdown format
        """
        if name and link:
            return MARKDOWN_LINK.format(name, link)
        return None


    def extract_project_id_from_service_account(service_account_json: str) -> str:
        """
        Extracts project name from a client secret json

        :param service_account_json: service account json string
        :return:
        """
        service_account_json = safe_load_non_strict_json(service_account_json)  # type: ignore
        project_id = ""
        if isinstance(service_account_json, dict):
            project_id = service_account_json.get("project_id")  # type: ignore
        if isinstance(project_id, list):
            project_id = project_id[0]
        return project_id


    def get_finding_id_from_path(finding_path: str) -> str:
        """
        Get finding ID from finding path

        :param finding_path: fully qualified path of finding
        :return: finding id
        """
        id_list = finding_path.split("findings/", 1)[-1:]
        if id_list:
            return id_list[0]
        return ""


    def convert_messages_to_incidents(messages: Dict[str, Any]) -> Tuple[List, List]:
        """
        convert pub/sub messages to incidents

        :param messages: pub/sdub message
        :return: list of incidents and list of ack ids
        """
        incidents = []
        acknowledges = []

        data_list = messages.get("receivedMessages", [])

        for data in data_list:
            acknowledges.append(data.get("ackId"))
            encoded_data = data.get("message", {}).get("data", "")
            try:
                data = base64.b64decode(encoded_data).decode()
                json_data = json.loads(data)

                finding = json_data.get("finding", {})
                finding_name = finding.get("name", "")
                # Support for only finding ingestion for Google Cloud SCC
                if not finding_name:
                    continue
                incident_name = get_finding_id_from_path(finding_name)
                create_time = finding.get("createTime")

                json_data["custom"] = prepare_markdown_fields_for_fetch_incidents(json_data)
                json_data["finding_url"] = GoogleNameParser.get_finding_url(finding_name)

                incidents.append({
                    "name": "{} - {}".format(INCIDENT_NAME_PREFIX, incident_name),
                    "occurred": create_time,
                    "rawJSON": json.dumps(json_data),
                    "details": json.dumps(json_data)
                })
            except Exception as e:
                demisto.error(ERROR_MESSAGES["INVALID_INCIDENT"].format(str(e)))

        acknowledges = [ack_id for ack_id in acknowledges if ack_id]
        return incidents, acknowledges


    """ COMMANDS """


    def test_module(params: Dict[str, Any]) -> None:
        """
        Test authentication using service json
        """
        # Basic validation on configuration parameter
        validate_configuration_param(params)

        # Validate Service Account JSON and Organization ID
        validate_service_account_and_organization_name(params)
        if params.get('isFetch', False):
            # Validate Project ID and Subscription ID.
            validate_project_and_subscription_id(params)
        demisto.results("ok")


    def fetch_incidents(client: GooglePubSubClient, params: Dict[str, Any]) -> Optional[list]:
        """
        Prepares incidents from past activity in Google Drive.

        :param client: GooglePubSubClient object
        :param params: arguments for fetch-incident.

        :return: incidents (``List[dict]``): List of incidents that will be created in XSOAR.
        """
        validate_configuration_param(params)
        max_messages = params.get("max_fetch") or DEFAULT_MAX_FETCH_VALUE

        messages = client.pull_messages(max_messages=max_messages)
        incidents, acks_id = convert_messages_to_incidents(messages)
        if acks_id:
            client.acknowledge_messages(acks_id)
        return incidents


    @logger
    def asset_list_command(client: GoogleSccClient, args: Dict) -> CommandResults:
        """
        Lists an organization's assets.
        :param client: SccClient Object.
        :param args: Command argument(s).
        :return: CommandResults object with context and human-readable.
        """
        # To validate arguments.
        page_size = validate_get_int(args.get("pageSize"), ERROR_MESSAGES["INVALID_PAGE_SIZE_ERROR"],
                                     MAX_PAGE_SIZE) or DEFAULT_PAGE_SIZE

        resource_type = args.get("resourceType", "")
        project = args.get("project", "")
        field_mask = args.get("fieldMask", None)
        order_by = args.get("orderBy", None)
        active_assets_only = args.get("activeAssetsOnly", "false")
        filter_string = args.get("filter", "")
        read_time = args.get("readTime", None)
        compare_duration = args.get("compareDuration", None)
        page_token = args.get("pageToken", None)

        # Creating filter
        filter_string = create_filter_list_assets(resource_type, project, filter_string, active_assets_only)
        demisto.debug(f"running command using the following filter: {filter_string}")

        # Build a request
        parent = GoogleNameParser.get_organization_path()
        raw_response = client.get_assets(parent, compare_duration, field_mask, filter_string, order_by, page_size,
                                         page_token, read_time)
        result = deepcopy(raw_response)  # To preserve original API response

        # Preparing list of entry context and human readable
        ec_asset_dict, readable_output = prepare_outputs_for_list_assets(result)

        return CommandResults(readable_output=readable_output, outputs=ec_asset_dict, raw_response=raw_response)


    @logger
    def finding_list_command(client: GoogleSccClient, args: Dict) -> CommandResults:
        """
        Lists an organization or source's findings.

        :param client: SccClient Object.
        :param args: Command argument(s).
        :return: CommandResults object with context and human-readable.
        """

        # Get command args
        severity = [value for value in args.get("severity", "").split(",") if value.strip()]
        category = args.get("category", "")
        source_type = args.get("sourceTypeId", "-")
        page_size = args.get("pageSize")
        state = [value for value in args.get("state", "").split(",") if value.strip()]
        filter_string = args.get("filter", "")
        order_by = args.get("orderBy", None)
        compare_duration = args.get("compareDuration", None)
        field_mask = args.get("fieldMask", None)
        read_time = args.get("readTime", None)
        page_token = args.get("pageToken", None)

        # Validates command args
        validate_state_and_severity_list(state, severity)
        page_size = validate_get_int(page_size, ERROR_MESSAGES["INVALID_PAGE_SIZE_ERROR"],
                                     MAX_PAGE_SIZE) or DEFAULT_PAGE_SIZE

        # Creating filter
        filter_string = create_filter_list_findings(category, filter_string, severity, state)
        demisto.debug(f"running command using the following filter: {filter_string}")

        parent = GoogleNameParser.get_source_path(source_type)
        raw_response = client.get_findings(parent, compare_duration, field_mask, filter_string, order_by, page_size,
                                           page_token, read_time)
        result = deepcopy(raw_response)  # To preserve original API response
        readable_output, context = prepare_hr_and_ec_for_list_findings(result)

        return CommandResults(readable_output=readable_output, outputs=context, raw_response=raw_response)


    @logger
    def finding_update_command(client: GoogleSccClient, args: Dict) -> CommandResults:
        """
        Lists an organization or source's findings.

        :param client: SccClient Object.
        :param args: Command argument(s).
        :return: CommandResults object with context and human-readable.
        """

        # Get validated command args
        arguments = get_and_validate_args_finding_update(args)

        # Get response
        result = client.update_finding(*arguments)

        readable_output, context = prepare_hr_and_ec_for_update_finding(result)

        return CommandResults(readable_output=readable_output, outputs_key_field="name",
                              outputs_prefix=OUTPUT_PREFIX['FINDING'], outputs=context, raw_response=result)


    @logger
    def cloud_asset_list_command(client: GoogleCloudAssetClient, args: Dict) -> CommandResults:
        """
        Lists assets with time and resource types.

        :param client: GoogleCloudAssetClient Object.
        :param args: Command argument(s).
        :return: CommandResults object with context and human-readable.
        """
        parent = args.get("parent", GoogleNameParser.get_organization_path())
        asset_types = argToList(args.get("assetTypes"))
        content_type = "RESOURCE"
        page_size = args.get("pageSize")
        page_token = args.get("pageToken")
        read_time = args.get("readTime")  # type: ignore

        # Validates command args
        page_size = validate_get_int(page_size, ERROR_MESSAGES["INVALID_PAGE_SIZE_ERROR"],
                                     MAX_PAGE_SIZE) or DEFAULT_PAGE_SIZE
        if read_time:
            read_time = convert_string_to_date_format(read_time, ISO_DATE_FORMAT)  # type: ignore

        if args.get("readTime") and not read_time:
            raise ValueError(ERROR_MESSAGES["INVALID_DATE_TIME"].format("readTime"))

        raw_response = client.get_assets(parent, asset_types, content_type, int(page_size), page_token,  # type:ignore
                                         read_time)  # type:ignore
        result = deepcopy(raw_response)  # To preserve original API response
        readable_output, context = prepare_hr_and_ec_for_cloud_asset_list(result)

        return CommandResults(readable_output=readable_output, outputs=context, raw_response=raw_response)


    @logger
    def cloud_asset_owner_get_command(client: GoogleCloudAssetClient, args: Dict) -> CommandResults:
        """
        Gets the owner information for the provided projects
        Lists assets with time and resource types.

        :param client: GoogleCloudAssetClient Object.
        :param args: Command argument(s).
        :return: CommandResults object with context and human-readable.
        """
        project_names = argToList(args.get("projectName"))
        max_iterations = args.get("maxIteration", "2")

        parent = GoogleNameParser.get_organization_path()
        asset_types = ["cloudresourcemanager.googleapis.com/Project"]
        content_type = "IAM_POLICY"

        # Validate command args.
        for project_name in project_names:
            validate_with_regex(ERROR_MESSAGES['INVALID_PROJECT_NAME_ERROR'], r"^projects\/\d{1,}$", project_name)
        max_iterations = validate_get_int(max_iterations, ERROR_MESSAGES["INVALID_MAX_ITERATION_ERROR"],
                                          MAX_ITERATION) or DEFAULT_MAX_ITERATION

        # Remove duplicate project names and extract id's.
        project_ids = list(map(lambda name: name.split('/')[-1], set(project_names)))
        page_token = ""
        matching_assets = []
        iteration = 0
        response = {}

        # Call API multiple times till we find all the projects or reach max iterations or run out of projects.
        while project_ids:
            response = client.get_assets(parent, asset_types, content_type, MAX_PAGE_SIZE, page_token, None)

            # search assets on project ids and append them to matching assets
            for asset in response['assets']:
                asset_id = asset['name'].split('/')[-1]
                if asset_id in project_ids:
                    matching_assets.append(asset)
                    project_ids.remove(asset_id)

            iteration += 1
            if iteration >= max_iterations or not response.get('nextPageToken'):
                break

            page_token = response['nextPageToken']

        readable_output, context = prepare_hr_and_ec_for_cloud_asset_owners_get(matching_assets,
                                                                                response.get('readTime', ""))
        return CommandResults(readable_output=readable_output, outputs=context, raw_response=context,
                              outputs_key_field="name", outputs_prefix=OUTPUT_PREFIX['GET_OWNER'])


    def main() -> None:
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # Commands dictionary
        commands: Dict[str, Callable] = {
            "google-cloud-scc-asset-list": asset_list_command,
            "google-cloud-scc-finding-list": finding_list_command,
            "google-cloud-scc-finding-update": finding_update_command
        }
        params = demisto.params()
        command = demisto.command()
        demisto.info(f"Command being called is {command}")
        try:
            # Trim the arguments
            args = strip_dict(demisto.args())
            client: Optional[Union[GoogleSccClient, GooglePubSubClient, GoogleCloudAssetClient]] = None
            if command == "test-module":
                # This is the call made when pressing the integration test button.
                test_module(params)
            elif command == "google-cloud-scc-asset-resource-list":
                client = init_google_cloud_assets_client(**params)
                return_results(cloud_asset_list_command(client, args))
            elif command == "google-cloud-scc-asset-owner-get":
                client = init_google_cloud_assets_client(**params)
                return_results(cloud_asset_owner_get_command(client, args))
            elif command == "fetch-incidents":
                client = init_google_pubsub_client(**params)
                incidents = fetch_incidents(client, params)
                demisto.incidents(incidents)
            elif command in commands:
                client = init_google_scc_client(**params)
                return_results(commands[command](client, args))
        # Log exceptions
        except Exception as e:
            return_error("Failed to execute {} command. Error: {}".format(demisto.command(), str(e)))


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()
  subtype: python3
  type: python
sourcemoduleid: GoogleCloudSCC
