category: Cloud Services
commonfields:
  id: AWS-EKS
  version: -1
configuration:
- display: AWS Default Region
  name: defaultRegion
  options:
  - us-east-1
  - us-east-2
  - us-west-1
  - us-west-2
  - ca-central-1
  - eu-west-1
  - eu-central-1
  - eu-west-2
  - ap-northeast-1
  - ap-northeast-2
  - ap-southeast-1
  - ap-southeast-2
  - ap-south-1
  - sa-east-1
  - eu-north-1
  - eu-west-3
  - us-gov-east-1
  - us-gov-west-1
  required: true
  section: Connect
  type: 15
- display: Access Key
  displaypassword: Secret Key
  name: credentials
  required: true
  section: Connect
  type: 9
- additionalinfo: The time in seconds till a timeout exception is reached. You can
    specify just the read timeout (for example 60) or also the connect timeout followed
    after a comma (for example 60,10). If a connect timeout is not specified, a default
    of 10 seconds will be used.
  defaultvalue: 60,10
  display: Timeout
  name: timeout
  required: false
  section: Connect
  type: 0
- additionalinfo: 'The maximum number of retry attempts when connection or throttling
    errors are encountered. Set to 0 to disable retries. The default value is 5 and
    the limit is 10. Note: Increasing the number of retries will increase the execution
    time.'
  display: Retries
  name: retries
  required: false
  section: Connect
  type: 0
- additionalinfo: Sets the AWS_STS_REGIONAL_ENDPOINTS environment variable to specify
    the AWS STS endpoint resolution logic. By default, this option is set to “legacy”
    in AWS. Leave empty if the environment variable is already set using server configuration.
  display: AWS STS Regional Endpoints
  name: sts_regional_endpoint
  options:
  - legacy
  - regional
  required: false
  section: Connect
  type: 15
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.9.0
    itemVersion: 1.0.3
    packID: AWS-EKS
    packName: AWS - EKS
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: The AWS EKS integration allows for the management and operation of Amazon
  Elastic Kubernetes Service (EKS) clusters.
detaileddescription: |-
  ### Configure AWS Settings
  - Create an IAM role with either of the following IAM policies:
    - AmazonEKSClusterPolicy
    - A custom IAM policy. For more information about creating a custom IAM policy see the [Amazon EKS cluster IAM role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html).
  - Create Amazon EKS clusters.

  For more information see the [Amazon EKS cluster IAM role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html).

  For detailed instructions, see the [AWS Integrations - Authentication](https://xsoar.pan.dev/docs/reference/articles/aws-integrations---authentication).

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/aws-eks)
display: AWS-EKS
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAAAmVBMVEUAAAAAAAAAAAAAAAAAAAA7U+AVfP8AAAAtbfIAAAAAAAAAAAA8VN8AAAAAAAAAAAAVfP8AAAAAAAAUfP87U90AAAAYgP8VfP9AWN8Vff86Ut48VNwAAAAWff8AAAAfdfkVff88VN86U90Uff8YfP84UN87VN4VfP88U987Ut08VN86Ut0VfP8Uff8Vff8AAAAVfP86Ut0AAAC5ZJFXAAAAMHRSTlMAv9+AIJ+gQBCvn2CAUBDPvzBwQL+QIH8g799A79+gMN/PYFtAIK+QkHDv78+vj1+YRpOWAAAB5klEQVRYw+3V646iQBCG4a+7WpoGAUFBRR1dR+ewR+z7v7gtRlEMmSz7w042y5uYdIjhSQpCYWhoaGjoX+0w2a7KBVzne1U1XZ1OI7e0P19WZ/j0bQx3HXbMnmGu3MNN2wmjN5h7cTFv/2fVNN1eYCeP+rVhN1NgX15lPDrvzC7nPureS7ew58Ov5QWOI5fwBMB4BP/LGMDsDlYUoW8hEf87A5CpmIJc9YRrtwOHVqJvQikVQwJEEBpp2g9+YbcLJ8ZqIAgDQZERKdJAGIVACBGBhAiZ4+vRGUadrF3I/qP+WvpdOLWpyAEpw9yaSBpoihKBKDRWkYwyG8ImkVnHH7DWWkFSDoCM7v2M30ZdOEhAfFcZQFuNJwHoTEhArTNIBoQB25FVHzARpZAmiQHopyTtCWP21oGl5bIWnEhiuL6ANQFG1LC2qj3q8HxQyd+91e8tOLSpUkK0YJshkCCp2EmUkhm6MHJC3AteFsBixb+9jy2OsyvMJpDZ+Abndp1IWI6UtNagDXMEWZ9+5SaQfxw15xXXvczHfTnCZ8Xx3fnTYgX0gPmbednL3LzAEY/ueVNd2j0fds1xisdXeFWnVx8uKn7cs5MtHNXMu9nLLptvbnvZbYV32cvuK75PphgaGhoa+r/7DdutSVNI6c4QAAAAAElFTkSuQmCC
name: AWS-EKS
script:
  commands:
  - arguments:
    - defaultValue: "50"
      description: The maximum number of clusters to return.
      name: limit
    - description: The nextToken value returned from a previous paginated request,
        where maxResults was used and the results exceeded the value of that parameter.
      name: next_token
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: Lists the Amazon EKS clusters in your Amazon Web Services account
      in the specified Amazon Web Services Region.
    name: aws-eks-list-clusters
    outputs:
    - contextPath: AWS.EKS.Cluster.ClustersNames
      description: A list of all of the clusters for your account in the specified
        Amazon Web Services Region.
      type: List
    - contextPath: AWS.EKS.Cluster.NextToken
      description: The nextToken value returned from a previous paginated request,
        where maxResults was used and the results exceeded the value of that parameter.
      type: List
  - arguments:
    - description: The name of the Amazon EKS cluster to update.
      name: cluster_name
      required: true
    - description: 'A JSON representation of the VPC configuration used by the cluster
        control plane. An example: "{''subnetIds'': [''string''], ''securityGroupIds'':
        [''string''], ''endpointPublicAccess'': True, ''endpointPrivateAccess'': True,
        ''publicAccessCidrs'': [''string'']}".'
      name: resources_vpc_config
    - description: 'A JSON representation of the logging configuration for the cluster.
        An example: "{''clusterLogging'': [{''types'': [''api'', ''audit'', ''authenticator'',
        ''controllerManager'', ''scheduler''], ''enabled'': true}]}".'
      name: logging
    - auto: PREDEFINED
      description: Whether to update the authentication mode to 'API_AND_CONFIG_MAP'
        or not.
      name: authentication_mode
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: 'Updates an Amazon EKS cluster configuration. Only one type of update
      is allowed. Potentially harmful: once the authentication mode is updated to
      ''API'' it is irreversible.'
    execution: true
    name: aws-eks-update-cluster-config
    outputs:
    - contextPath: AWS.EKS.UpdateCluster.clusterName
      description: The name of the cluster.
      type: String
    - contextPath: AWS.EKS.UpdateCluster.id
      description: The ID of the update.
      type: Integer
    - contextPath: AWS.EKS.UpdateCluster.status
      description: The status of the update.
      type: String
    - contextPath: AWS.EKS.UpdateCluster.type
      description: The type of the update.
      type: String
    - contextPath: AWS.EKS.UpdateCluster.params
      description: The parameters of the update.
      type: Object
    - contextPath: AWS.EKS.UpdateCluster.createdAt
      description: The creation date of the object.
      type: String
    - contextPath: AWS.EKS.UpdateCluster.errors
      description: Any errors associated with a failed update.
      type: Object
  - arguments:
    - description: The name of the cluster to describe.
      name: cluster_name
      required: true
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: Describes an Amazon EKS cluster.
    name: aws-eks-describe-cluster
    outputs:
    - contextPath: AWS.EKS.DescribeCluster.name
      description: The name of your cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.arn
      description: The Amazon Resource Name (ARN) of the cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.createdAt
      description: The creation date of the object.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.version
      description: The Kubernetes server version for the cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.endpoint
      description: The endpoint for your Kubernetes API server.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.roleArn
      description: The Amazon Resource Name (ARN) of the IAM role that provides permissions
        for the Kubernetes control plane to make calls to Amazon Web Services API
        operations on your behalf.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.subnetIds
      description: The subnets associated with your cluster.
      type: List
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.securityGroupIds
      description: The security groups associated with the cross-account elastic network
        interfaces that are used to allow communication between your nodes and the
        Kubernetes control plane.
      type: List
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.clusterSecurityGroupId
      description: The cluster security group that was created by Amazon EKS for the
        cluster. Managed node groups use this security group for control-plane-to-data-plane
        communication.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.vpcId
      description: The VPC associated with your cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.endpointPublicAccess
      description: Whether the public API server endpoint is enabled.
      type: Boolean
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.endpointPrivateAccess
      description: This parameter indicates whether the Amazon EKS private API server
        endpoint is enabled.
      type: Boolean
    - contextPath: AWS.EKS.DescribeCluster.resourcesVpcConfig.publicAccessCidrs
      description: The CIDR blocks that are allowed access to your cluster’s public
        Kubernetes API server endpoint.
      type: List
    - contextPath: AWS.EKS.DescribeCluster.kubernetesNetworkConfig.serviceIpv4Cidr
      description: The CIDR block that Kubernetes Pod and Service object IP addresses
        are assigned from.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.kubernetesNetworkConfig.serviceIpv6Cidr
      description: The CIDR block that Kubernetes Pod and Service IP addresses are
        assigned from if you created a 1.21 or later cluster with version 1.10.1 or
        later of the Amazon VPC CNI add-on and specified ipv6 for ipFamily when you
        created the cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.kubernetesNetworkConfig.ipFamily
      description: The IP family used to assign Kubernetes Pod and Service objects
        IP addresses.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.logging.clusterLogging
      description: The cluster control plane logging configuration for your cluster.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.identity
      description: The identity provider information for the cluster.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.status
      description: The current status of the cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.certificateAuthority.data
      description: The Base64-encoded certificate data required to communicate with
        your cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.clientRequestToken
      description: A unique, case-sensitive identifier that you provide to ensure
        the idempotency of the request.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.platformVersion
      description: The platform version of your Amazon EKS cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.tags
      description: A dictionary containing metadata for categorization and organization.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.encryptionConfig.resources
      description: Specifies the resources to be encrypted. The only supported value
        is secrets.
      type: List
    - contextPath: AWS.EKS.DescribeCluster.encryptionConfig.provider
      description: Key Management Service (KMS) key.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.connectorConfig.activationId
      description: A unique ID associated with the cluster for registration purposes.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.connectorConfig.activationCode
      description: A unique code associated with the cluster for registration purposes.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.connectorConfig.activationExpiry
      description: The expiration time of the connected cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.connectorConfig.provider
      description: The cluster’s cloud service provider.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.connectorConfig.roleArn
      description: The Amazon Resource Name (ARN) of the role to communicate with
        services from the connected Kubernetes cluster.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.id
      description: The ID of your local Amazon EKS cluster on an Amazon Web Services
        Outpost.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.health.issues
      description: An object representing the health issues of your local Amazon EKS
        cluster on an Amazon Web Services Outpost.
      type: List
    - contextPath: AWS.EKS.DescribeCluster.outpostConfig.outpostArns
      description: An object representing the configuration of your local Amazon EKS
        cluster on an Amazon Web Services Outpost.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.outpostConfig.controlPlaneInstanceType
      description: The Amazon EC2 instance type used for the control plane.
      type: String
    - contextPath: AWS.EKS.DescribeCluster.outpostConfig.controlPlanePlacement
      description: An object representing the placement configuration for all the
        control plane instances of your local Amazon EKS cluster on an Amazon Web
        Services Outpost.
      type: Object
    - contextPath: AWS.EKS.DescribeCluster.accessConfig.bootstrapClusterCreatorAdminPermissions
      description: Specifies whether or not the cluster creator IAM principal was
        set as a cluster admin access entry during cluster creation time.
      type: Boolean
    - contextPath: AWS.EKS.DescribeCluster.accessConfig.authenticationMode
      description: The current authentication mode of the cluster.
      type: String
  - arguments:
    - description: The name of the cluster for which to create an access entry.
      name: cluster_name
      required: true
    - description: ARN of the IAM principal for the AccessEntry.
      name: principal_arn
      required: true
    - description: A comma-separated list of names for Kubernetes groups in RoleBindings
        or ClusterRoleBindings.
      name: kubernetes_groups
    - description: A dictionary containing metadata for categorization and organization.
        Each tag consists of a key and an optional value.
      name: tags
    - description: Unique identifier for idempotency.
      name: client_request_token
    - description: Username for Kubernetes authentication.
      name: username
    - auto: PREDEFINED
      defaultValue: Standard
      description: The type of access entry to create.
      name: type
      predefined:
      - Standard
      - FARGATE_LINUX
      - EC2_LINUX
      - EC2_WINDOWS
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: Creates an access entry.
    name: aws-eks-create-access-entry
    outputs:
    - contextPath: AWS.EKS.CreateAccessEntry.clusterName
      description: The name of the cluster.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.principalArn
      description: The ARN of the IAM principal for the access entry.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.kubernetesGroups
      description: A list of names that you’ve specified in a Kubernetes RoleBinding
        or ClusterRoleBinding object so that Kubernetes authorizes the principalARN
        access to cluster objects.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.accessEntryArn
      description: The ARN of the access entry.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.createdAt
      description: The creation date of the object.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.modifiedAt
      description: The date and time for the last modification to the object.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.tags
      description: A dictionary containing metadata for categorization and organization.
      type: Object
    - contextPath: AWS.EKS.CreateAccessEntry.username
      description: The name of a user that can authenticate to the cluster.
      type: String
    - contextPath: AWS.EKS.CreateAccessEntry.type
      description: The type of the access entry.
      type: String
  - arguments:
    - description: The name of the cluster for which to create an access entry.
      name: cluster_name
      required: true
    - description: The Amazon Resource Name (ARN) of the IAM user or role for the
        AccessEntry that you’re associating the access policy to.
      name: principal_arn
      required: true
    - description: The ARN of the AccessPolicy that you’re associating.
      name: policy_arn
      required: true
    - auto: PREDEFINED
      description: The scope type of an access policy.
      name: type
      predefined:
      - cluster
      - namespace
      required: true
    - description: A comma-separated list of Kubernetes namespaces that an access
        policy is scoped to. A value is required if you specified namespace for type.
      name: namespaces
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: Associates an access policy and its scope to an access entry.
    name: aws-eks-associate-access-policy
    outputs:
    - contextPath: AWS.EKS.AssociatedAccessPolicy.clusterName
      description: The name of your cluster.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.principalArn
      description: The ARN of the IAM principal for the AccessEntry.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.policyArn
      description: The ARN of the AccessPolicy.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.accessScope.type
      description: The scope type of an access policy.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.accessScope.namespaces
      description: A Kubernetes namespace that an access policy is scoped to.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.associatedAt
      description: The date and time the AccessPolicy was associated with an AccessEntry.
      type: String
    - contextPath: AWS.EKS.AssociatedAccessPolicy.modifiedAt
      description: The date and time for the last modification to the object.
      type: String
  - arguments:
    - description: The name of the cluster.
      name: cluster_name
      required: true
    - description: ARN of the IAM principal for the AccessEntry.
      name: principal_arn
      required: true
    - description: A comma-separated list of names for Kubernetes groups in RoleBindings
        or ClusterRoleBindings.
      name: kubernetes_groups
    - description: Unique identifier for idempotency.
      name: client_request_token
    - description: Username for Kubernetes authentication.
      name: username
    - auto: PREDEFINED
      description: The AWS Region. If not specified, the configured region will be
        used.
      name: region
      predefined:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - ca-central-1
      - eu-west-1
      - eu-central-1
      - eu-west-2
      - ap-northeast-1
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-south-1
      - sa-east-1
      - eu-north-1
      - eu-west-3
    description: Updates an access entry.
    name: aws-eks-update-access-entry
    outputs:
    - contextPath: AWS.EKS.UpdateAccessEntry.clusterName
      description: The name of your cluster.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.principalArn
      description: The ARN of the IAM principal for the access entry.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.kubernetesGroups
      description: A list of names that you’ve specified in a Kubernetes RoleBinding
        or ClusterRoleBinding object so that Kubernetes authorizes the principalARN
        access to cluster objects.
      type: List
    - contextPath: AWS.EKS.UpdateAccessEntry.accessEntryArn
      description: The ARN of the access entry.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.createdAt
      description: The creation date of the object.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.modifiedAt
      description: The date and time for the last modification to the object.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.tags
      description: Metadata that assists with categorization and organization. Each
        tag consists of a key and an optional value.
      type: Object
    - contextPath: AWS.EKS.UpdateAccessEntry.username
      description: The name of a user that can authenticate to your cluster.
      type: String
    - contextPath: AWS.EKS.UpdateAccessEntry.type
      description: The type of the access entry.
      type: String
  dockerimage: demisto/boto3py3:1.0.0.98661
  runonce: false
  script: |
    register_module_line('AWS-EKS', 'start', __line__())
    ### pack version: 1.0.3
    import json




    ### GENERATED CODE ###: from AWSApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('AWSApiModule', 'start', __line__(), wrapper=-3)


    import boto3
    from botocore.config import Config


    def validate_params(aws_default_region, aws_role_arn, aws_role_session_name, aws_access_key_id, aws_secret_access_key):
        """
        Validates that the provided parameters are compatible with the appropriate authentication method.
        """
        if not aws_default_region:
            raise DemistoException('You must specify AWS default region.')

        if bool(aws_access_key_id) != bool(aws_secret_access_key):
            raise DemistoException('You must provide Access Key id and Secret key id to configure the instance with '
                                   'credentials.')
        if bool(aws_role_arn) != bool(aws_role_session_name):
            raise DemistoException('Role session name is required when using role ARN.')


    def extract_session_from_secret(secret_key, session_token):
        """
        Extract the session token from the secret_key field.
        """
        if secret_key and '@@@' in secret_key and not session_token:
            return secret_key.split('@@@')[0], secret_key.split('@@@')[1]
        else:
            return secret_key, session_token


    class AWSClient:

        def __init__(self, aws_default_region, aws_role_arn, aws_role_session_name, aws_role_session_duration,
                     aws_role_policy, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout, retries,
                     aws_session_token=None, sts_endpoint_url=None, endpoint_url=None):

            self.sts_endpoint_url = sts_endpoint_url
            self.endpoint_url = endpoint_url
            self.aws_default_region = aws_default_region
            self.aws_role_arn = aws_role_arn
            self.aws_role_session_name = aws_role_session_name
            # handle cases where aws_role_session_duration can be also empty string
            self.aws_role_session_duration = aws_role_session_duration if aws_role_session_duration else None
            self.aws_role_policy = aws_role_policy
            self.aws_access_key_id = aws_access_key_id
            self.aws_secret_access_key, self.aws_session_token = extract_session_from_secret(aws_secret_access_key, aws_session_token)
            self.verify_certificate = verify_certificate

            sts_regional_endpoint = demisto.params().get("sts_regional_endpoint") or None
            if sts_regional_endpoint:
                demisto.debug(f"Sets the environment variable AWS_STS_REGIONAL_ENDPOINTS={sts_regional_endpoint}")
                os.environ["AWS_STS_REGIONAL_ENDPOINTS"] = sts_regional_endpoint.lower()

            proxies = handle_proxy(proxy_param_name='proxy', checkbox_default_value=False)
            (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
            if int(retries) > 10:
                retries = 10
            self.config = Config(
                connect_timeout=connect_timeout,
                read_timeout=read_timeout,
                retries=dict(
                    max_attempts=int(retries)
                ),
                proxies=proxies
            )

        def update_config(self):
            command_config = {}
            retries = demisto.getArg('retries')  # Supports retries and timeout parameters on the command execution level
            if retries is not None:
                command_config['retries'] = dict(max_attempts=int(retries))
            timeout = demisto.getArg('timeout')
            if timeout is not None:
                (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
                command_config['read_timeout'] = read_timeout
                command_config['connect_timeout'] = connect_timeout
            if retries or timeout:
                demisto.debug('Merging client config settings: {}'.format(command_config))
                self.config = self.config.merge(Config(**command_config))  # type: ignore[arg-type]

        def aws_session(self, service, region=None, role_arn=None, role_session_name=None, role_session_duration=None,
                        role_policy=None):
            kwargs = {}

            self.update_config()

            if role_arn and role_session_name is not None:
                kwargs.update({
                    'RoleArn': role_arn,
                    'RoleSessionName': role_session_name,
                })
            elif self.aws_role_arn and self.aws_role_session_name is not None:
                kwargs.update({
                    'RoleArn': self.aws_role_arn,
                    'RoleSessionName': self.aws_role_session_name,
                })

            if role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(role_session_duration)})
            elif self.aws_role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(self.aws_role_session_duration)})

            if role_policy is not None:
                kwargs.update({'Policy': role_policy})
            elif self.aws_role_policy is not None:
                kwargs.update({'Policy': self.aws_role_policy})

            demisto.debug('{kwargs}='.format(kwargs=kwargs))

            if kwargs and not self.aws_access_key_id:  # login with Role ARN
                if not self.aws_access_key_id:
                    sts_client = boto3.client('sts', config=self.config, verify=self.verify_certificate,
                                              region_name=region if region else self.aws_default_region,
                                              endpoint_url=self.sts_endpoint_url)
                    sts_response = sts_client.assume_role(**kwargs)
                    client = boto3.client(
                        service_name=service,
                        region_name=region if region else self.aws_default_region,
                        aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                        aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                        aws_session_token=sts_response['Credentials']['SessionToken'],
                        verify=self.verify_certificate,
                        config=self.config,
                        endpoint_url=self.endpoint_url
                    )
            elif self.aws_access_key_id and (role_arn or self.aws_role_arn):  # login with Access Key ID and Role ARN
                sts_client = boto3.client(
                    service_name='sts',
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.sts_endpoint_url
                )
                kwargs.update({
                    'RoleArn': role_arn or self.aws_role_arn,
                    'RoleSessionName': role_session_name or self.aws_role_session_name,
                })
                sts_response = sts_client.assume_role(**kwargs)
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                    aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                    aws_session_token=sts_response['Credentials']['SessionToken'],
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_session_token and not self.aws_role_arn:  # login with session token
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    aws_session_token=self.aws_session_token,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_access_key_id and not self.aws_role_arn:  # login with access key id
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            else:  # login with default permissions, permissions pulled from the ec2 metadata
                client = boto3.client(service_name=service,
                                      region_name=region if region else self.aws_default_region,
                                      endpoint_url=self.endpoint_url)

            return client

        @staticmethod
        def get_timeout(timeout):
            if not timeout:
                timeout = "60,10"  # default values
            try:

                if isinstance(timeout, int):
                    read_timeout = timeout
                    connect_timeout = 10

                else:
                    timeout_vals = timeout.split(',')
                    read_timeout = int(timeout_vals[0])
                    # the default connect timeout is 10
                    connect_timeout = 10 if len(timeout_vals) == 1 else int(timeout_vals[1])

            except ValueError:
                raise DemistoException("You can specify just the read timeout (for example 60) or also the connect "
                                       "timeout followed after a comma (for example 60,10). If a connect timeout is not "
                                       "specified, a default of 10 second will be used.")
            return read_timeout, connect_timeout

    register_module_line('AWSApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()


    ''' CONSTANTS '''

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'  # ISO8601 format with UTC, default in XSOAR

    ''' HELPER FUNCTIONS '''


    def validate_args(resources_vpc_config: dict, logging_arg: dict, authentication_mode: bool):
        """
        Check that exactly one argument is passed, and if not raise a value error
        Args:
            resources_vpc_config: An object representing the VPC configuration to use for an Amazon EKS cluster.
            logging_arg: The cluster control plane logging configuration.
            authentication_mode: The desired authentication mode for the cluster.

        Returns:
            A Command Results object
        """
        arr = [resources_vpc_config, logging_arg, authentication_mode]
        arg_num = sum(bool(arg) for arg in arr)  # counts the number of non-empty args.
        if arg_num != 1:
            raise ValueError("Please provide exactly one of the following arguments: resources_vpc_config, logging or "
                             "authentication_mode.")


    def config_aws_session(args: dict, aws_client: AWSClient):
        """
        Configures an AWS session for the EKS service,
        Used in all the commands.

        Args:
            args (dict): A dictionary containing the configuration parameters for the session.
                         - 'region' (str): The AWS region.

            aws_client (AWSClient): The AWS client used to configure the session.

        Returns:
            AWS session (boto3 client): The configured AWS session.
        """
        return aws_client.aws_session(service='eks', region=args.get('region'))


    ''' COMMAND FUNCTIONS '''


    def list_clusters_command(aws_client, args: dict) -> CommandResults:
        """
        Lists the Amazon EKS clusters in the Amazon Web Services account in the specified Amazon Web Services Region.
        Args:
            aws_client (boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        limit = arg_to_number(args.get('limit')) or 50
        next_token = args.get('next_token', '')
        list_clusters = []
        flag = True  # Do we want to enter the while loop? -> in the first time, yes. After that only if next_token!=None & limit>0
        while limit > 0 and flag:
            if limit > 100:
                response = aws_client.list_clusters(maxResults=100,
                                                    nextToken=next_token)
                limit -= 100
            else:
                response = aws_client.list_clusters(maxResults=limit,
                                                    nextToken=next_token)
                limit = 0
            list_clusters.extend(response.get('clusters', []))
            next_token = response.get('nextToken')
            flag = bool(next_token)

        md_table = {
            'Clusters Names': list_clusters,
        }

        outputs = {
            'ClustersNames': list_clusters,
            'NextToken': next_token
        }

        if list_clusters:
            readable_output = tableToMarkdown(
                name='The list of clusters',
                t=md_table,
                removeNull=True,
            )
        else:
            readable_output = "No clusters found."

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AWS.EKS.Cluster',
            outputs=outputs,
            raw_response=outputs,
        )


    def update_cluster_config_command(aws_client, args: dict) -> CommandResults:
        """
        Updates an Amazon EKS cluster configuration.
        Args:
            aws_client(boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        cluster_name = args.get('cluster_name')
        resources_vpc_config = args.get('resources_vpc_config', '').replace('\'', '"')
        logging_arg = args.get('logging', '').replace('\'', '"')
        resources_vpc_config = json.loads(resources_vpc_config) if resources_vpc_config else {}
        logging_arg = json.loads(logging_arg) if logging_arg else {}
        authentication_mode = argToBoolean(args.get('authentication_mode', False))

        validate_args(resources_vpc_config, logging_arg, authentication_mode)

        access_config = {
            'authenticationMode': 'API_AND_CONFIG_MAP'
        } if authentication_mode else {}

        try:
            if resources_vpc_config:
                response = aws_client.update_cluster_config(
                    name=cluster_name,
                    resourcesVpcConfig=resources_vpc_config
                )
            elif logging_arg:
                response = aws_client.update_cluster_config(
                    name=cluster_name,
                    logging=logging_arg,
                )
            else:  # access_config
                response = aws_client.update_cluster_config(
                    name=cluster_name,
                    accessConfig=access_config
                )

            response_data = response.get('update', {})
            response_data['clusterName'] = cluster_name
            response_data['createdAt'] = datetime_to_string(response_data.get('createdAt'))

            headers = ['clusterName', 'id', 'status', 'type', 'params']
            readable_output = tableToMarkdown(
                name='Updated Cluster Config Information',
                t=response_data,
                removeNull=True,
                headers=headers,
                headerTransform=pascalToSpace
            )
            return CommandResults(
                readable_output=readable_output,
                outputs_prefix='AWS.EKS.UpdateCluster',
                outputs=response_data,
                raw_response=response_data,
                outputs_key_field='id'
            )
        except Exception as e:
            if 'No changes needed' in str(e):
                return CommandResults(readable_output='No changes needed for the required update.')
            else:
                raise e


    def describe_cluster_command(aws_client, args: dict) -> CommandResults:
        """
        Describes an Amazon EKS cluster.
        Args:
            aws_client(boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        cluster_name = args.get('cluster_name')

        response = aws_client.describe_cluster(name=cluster_name)
        response_data = response.get('cluster', {})
        response_data['createdAt'] = datetime_to_string(response_data.get('createdAt'))
        if response_data.get('connectorConfig', {}).get('activationExpiry'):
            response_data.get('connectorConfig', {})['activationExpiry'] = (
                datetime_to_string(response_data.get('connectorConfig', {}).get('activationExpiry')))

        headers = ['name', 'id', 'status', 'arn', 'createdAt', 'version']
        readable_output = tableToMarkdown(
            name='Describe Cluster Information',
            t=response_data,
            removeNull=True,
            headers=headers,
            headerTransform=pascalToSpace
        )
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AWS.EKS.DescribeCluster',
            outputs=response_data,
            raw_response=response_data,
            outputs_key_field='name'
        )


    def create_access_entry_command(aws_client, args: dict) -> CommandResults:
        """
        Creates an access entry.
        Args:
            aws_client(boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        cluster_name = args.get('cluster_name')
        principal_arn = args.get('principal_arn')
        kubernetes_groups = argToList(args.get('kubernetes_groups'))
        tags = args.get('tags', '').replace('\'', '"')
        tags = json.loads(tags) if tags else {}
        client_request_token = args.get('client_request_token', '')
        username = args.get('username', '')
        type_arg = args.get('type', '').upper()

        try:
            if username:
                response = aws_client.create_access_entry(
                    clusterName=cluster_name,
                    principalArn=principal_arn,
                    kubernetesGroups=kubernetes_groups,
                    tags=tags,
                    clientRequestToken=client_request_token,
                    username=username,
                    type=type_arg
                ).get('accessEntry')
            else:
                response = aws_client.create_access_entry(
                    clusterName=cluster_name,
                    principalArn=principal_arn,
                    kubernetesGroups=kubernetes_groups,
                    tags=tags,
                    clientRequestToken=client_request_token,
                    type=type_arg
                ).get('accessEntry')

            response['createdAt'] = datetime_to_string(response.get('createdAt'))
            response['modifiedAt'] = datetime_to_string(response.get('modifiedAt'))

            headers = ['clusterName', 'principalArn', 'username', 'type', 'createdAt']
            readable_output = tableToMarkdown(
                name='The newly created access entry',
                t=response,
                removeNull=True,
                headers=headers,
                headerTransform=pascalToSpace
            )

            return CommandResults(
                readable_output=readable_output,
                outputs_prefix='AWS.EKS.CreateAccessEntry',
                outputs=response,
                raw_response=response,
                outputs_key_field='ClusterName'
            )
        except Exception as e:
            if 'already in use' in str(e):
                return CommandResults(readable_output='The specified access entry resource is already in use on this cluster.')
            else:
                raise e


    def associate_access_policy_command(aws_client, args: dict) -> CommandResults:
        """
        Associates an access policy and its scope to an access entry.
        Args:
            aws_client(boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        cluster_name = args.get('cluster_name')
        principal_arn = args.get('principal_arn')
        policy_arn = args.get('policy_arn')
        type_arg = args.get('type')
        namespaces = argToList(args.get('namespaces'))
        if type_arg and type_arg == 'namespace' and not namespaces:
            raise Exception(f'When the {type_arg=}, you must enter a namespace.')

        access_scope = {
            'type': type_arg,
            'namespaces': namespaces
        }

        response = aws_client.associate_access_policy(
            clusterName=cluster_name,
            principalArn=principal_arn,
            policyArn=policy_arn,
            accessScope=access_scope
        )
        response_data = response.get('associatedAccessPolicy', {})
        response_data['clusterName'] = response.get('clusterName')
        response_data['principalArn'] = response.get('principalArn')

        response_data['associatedAt'] = datetime_to_string(response_data.get('associatedAt'))
        response_data['modifiedAt'] = datetime_to_string(response_data.get('modifiedAt'))

        headers = ['clusterName', 'principalArn', 'policyArn', 'associatedAt']
        readable_output = tableToMarkdown(
            name='The access policy was associated to the access entry successfully.',
            t=response_data,
            removeNull=True,
            headers=headers,
            headerTransform=pascalToSpace
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AWS.EKS.AssociatedAccessPolicy',
            outputs=response_data,
            raw_response=response_data,
            outputs_key_field='clusterName'
        )


    def update_access_entry_command(aws_client, args: dict) -> CommandResults:
        """
        Updates an access entry.
        Args:
            aws_client(boto3 client): The configured AWS session.
            args: command arguments

        Returns:
            A Command Results object
        """
        cluster_name = args.get('cluster_name')
        principal_arn = args.get('principal_arn')
        kubernetes_groups = argToList(args.get('kubernetes_groups'))
        client_request_token = args.get('client_request_token', '')
        username = args.get('username')

        if username:
            response = aws_client.update_access_entry(
                clusterName=cluster_name,
                principalArn=principal_arn,
                kubernetesGroups=kubernetes_groups,
                clientRequestToken=client_request_token,
                username=username
            ).get('accessEntry', {})
        else:
            response = aws_client.update_access_entry(
                clusterName=cluster_name,
                principalArn=principal_arn,
                kubernetesGroups=kubernetes_groups,
                clientRequestToken=client_request_token
            ).get('accessEntry', {})

        response['createdAt'] = datetime_to_string(response.get('createdAt'))
        response['modifiedAt'] = datetime_to_string(response.get('modifiedAt'))

        headers = ['clusterName', 'principalArn', 'username', 'type', 'modifiedAt']
        readable_output = tableToMarkdown(
            name='The updated access entry',
            t=response,
            removeNull=True,
            headers=headers,
            headerTransform=pascalToSpace
        )

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AWS.EKS.UpdateAccessEntry',
            outputs=response,
            raw_response=response,
            outputs_key_field='ClusterName'
        )


    def test_module(aws_client) -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type aws_client(boto3 client): The configured AWS session.
        :param AWSClient: client to use

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """

        message: str = ''
        try:
            aws_client.list_clusters(maxResults=1)
            message = 'ok'
        except DemistoException as e:
            if 'Forbidden' in str(e) or 'Authorization' in str(e):
                message = 'Authorization Error: make sure API Key is correctly set'
            else:
                raise e
        return message


    ''' MAIN FUNCTION '''


    def main():  # pragma: no cover
        params = demisto.params()
        aws_default_region = params.get('defaultRegion')
        aws_access_key_id = params.get('credentials', {}).get('identifier')
        aws_secret_access_key = params.get('credentials', {}).get('password')
        verify_certificate = not demisto.params().get('insecure', False)
        timeout = params.get('timeout')
        retries = params.get('retries') or 5

        demisto.debug(f'Command being called is {demisto.command()}')
        try:

            validate_params(aws_default_region, '', '', aws_access_key_id,
                            aws_secret_access_key)

            aws_client = AWSClient(aws_default_region, None, None, None,
                                   None, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout, retries)

            args = demisto.args()

            aws_client = config_aws_session(args, aws_client)

            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                return_results(test_module(aws_client))

            elif demisto.command() == 'aws-eks-list-clusters':
                return_results(list_clusters_command(aws_client, args))

            elif demisto.command() == 'aws-eks-update-cluster-config':
                return_results(update_cluster_config_command(aws_client, args))

            elif demisto.command() == 'aws-eks-describe-cluster':
                return_results(describe_cluster_command(aws_client, args))

            elif demisto.command() == 'aws-eks-create-access-entry':
                return_results(create_access_entry_command(aws_client, args))

            elif demisto.command() == 'aws-eks-associate-access-policy':
                return_results(associate_access_policy_command(aws_client, args))

            elif demisto.command() == 'aws-eks-update-access-entry':
                return_results(update_access_entry_command(aws_client, args))

            else:
                return_error(f"The command {demisto.command()} isn't implemented")

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('AWS-EKS', 'end', __line__())
  subtype: python3
  type: python
system: true
