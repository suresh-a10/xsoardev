category: IT Services
commonfields:
  id: Azure Compute v2
  version: -1
configuration:
- defaultvalue: https://management.azure.com
  display: Host URL (e.g. https://management.azure.com)
  name: host
  required: true
  section: Connect
  type: 0
- display: ID (received from the admin consent - see Detailed Instructions (?)
  hidden: true
  name: auth_id
  required: false
  type: 4
- display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  hidden: true
  name: tenant_id
  required: false
  type: 4
- display: Key (received from the admin consent - see Detailed Instructions (?)
  hidden: true
  name: enc_key
  required: false
  type: 4
- additionalinfo: Used for certificate authentication. As appears in the "Certificates
    & secrets" page of the app.
  display: Certificate Thumbprint
  hidden: true
  name: certificate_thumbprint
  required: false
  type: 4
- display: ""
  displaypassword: ID (received from the admin consent - see Detailed Instructions
    (?)
  hiddenusername: true
  name: cred_auth_id
  required: false
  section: Connect
  type: 9
- display: ""
  displaypassword: Token (received from the admin consent - see Detailed Instructions
    (?) section)
  hiddenusername: true
  name: cred_token
  required: false
  section: Connect
  type: 9
- display: ""
  displaypassword: Key (received from the admin consent - see Detailed Instructions
    (?)
  hiddenusername: true
  name: cred_enc_key
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication. As appears in the "Certificates
    & secrets" page of the app.
  display: ""
  displaypassword: Certificate Thumbprint
  hiddenusername: true
  name: cred_certificate_thumbprint
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication. The private key of the registered
    certificate.
  display: Private Key
  name: private_key
  required: false
  section: Connect
  type: 14
- display: Default Subscription ID
  hidden: true
  name: subscription_id
  required: false
  type: 4
- display: ""
  displaypassword: Default Subscription ID
  hiddenusername: true
  name: cred_subscription_id
  required: false
  section: Connect
  type: 9
- additionalinfo: This parameter can be overridden by the resource_group argument
    in any command.
  display: Default Resource Group Name
  name: resource_group
  required: false
  section: Connect
  type: 0
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  section: Connect
  type: 8
- additionalinfo: Select this checkbox if you are using a self-deployed Azure application.
  advanced: true
  display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  section: Connect
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.2.28
    packID: AzureCompute
    packName: Azure Compute
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Create and Manage Azure Virtual Machines.
detaileddescription: "Microsoft integrations (Graph and Azure) in Cortex XSOAR use
  Azure Active Directory applications to authenticate with Microsoft APIs. These integrations
  use OAuth 2.0 and OpenID Connect standard-compliant authentication services, which
  use an Application to sign-in or delegate authentication. For more information,
  see the Microsoft identity platform overview.\n\nThere are 2 application authentication
  methods available:\n\n * [Cortex XSOAR Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#cortex-xsoar-application)\n
  * [Self-Deployed Application](https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#self-deployed-application)\n\nDepending
  on the authentication method that you use, the integration parameters might change.\n\nTo
  allow us access to Azure Compute, an administrator has to approve the Demisto app
  using an admin consent flow, by clicking [here](https://oproxy.demisto.ninja/ms-azure-compute).\nAfter
  authorizing the Demisto app, you will receive an ID, Token, and Key, which needs
  to be added to the integration instance configuration's corresponding fields. After
  giving consent, the application must have a role assigned, so it can access the
  relevant resources per subscription. \nFor more information, see the integration
  documentation.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-compute-v2)"
display: Azure Compute v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAA0CAYAAAAjfRLqAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH4wMFBCEDPuWl6wAAEL5JREFUeNrt3Xu0JFV1BvBf9Z0XI8OAMg6IjshjkMEHGBUQUVCBOELQBIhGYhI1DyRRxMAMGjWiBnpwrayoy0QxyySoEURFAR+AUZDIQ1DRmQZ5RAQVhocwAvPwzu3KH7vqVt++fW9Xdd/HoP2tVeverj516tSpffbZ+9v7nE5sC6g38v92w8G42KoVW2a7WQM8/lCb7Qa0CPNy/DNSDIR5gJ6QzOrdC2E+BP+CTTgaG0bLNFPO2G9WmznA4wezp6FDmGs4Hudhf/w7Nli1AuZisdrsjrkBHl+YeWk5ex1JAgvwFrwLT8SNeCXuz0oegD/Nvt+UCfkAA0yKmdXQ9UYuzE/C2figEOYmztNM7g/BTeBI/BV+f7Y7aYDHD2ZOoAt7eQ98HH8ntDT8BF9US7OP6SKsxBPwDuzccv0AA0yImRHoQhgPxKfxRy33TvHf+LlVK/KyB2QHHCRMjwEG6IrpF+gQ0ASvFsJ8cFuJn+F8IdgkEsF0LMq+H8LJ2GegpQfohukT6DWNXJjnC4E8F3t1KPkF3D7q9KWW4Ki2MnvibzHHmoFQDzAxpkeg641c3+6I92MNdu5Q8l6htZuj1/Ei7NOh7J/gEKkBBpgQUy/QhVmwDP+KU7HdBKUvxtoWSm4IfyC0ejueKBzE7QemxwATYWoFuhC054lgyWuFkHbCQ/hPbAXnNODpOHySOxwpbPEBBuiIqRPoekPGH6/EZ/CSLldchhtGtXMYHYfjaZNcMx+n4CkDLT1AJ8yZklpCuOaS/rmwmZd2ueJRfMrYJKT5wtwY6nLtAXijCMpsexb1RANtEOmcEfSvoeMF7oD3iGy5bsIMV+Hq0TyNqOOZxlN6E7X5L/GsbVRL17BYOMQ7YeFsN+h3Cf0JdAjUjkKQV4vIXjdswX/gMaft29qKo3RmQjphGd6Geeo3z2yPde+Plwhz6n/wzaxvtuuj1gEqoD+BThMiivdnypsv1+PyMWlRTYvwKtWSpY7D4duY1VETjvALFdHOE/DsbXQ2+a1D7wJdb5CkecCjm92bY6vQzg87fUVRz9hQd1ksFjTe4m1CWKINy/CKtm92FL7BIA92BtCbQNd/QgjxW8RKk7L4ES5pO5cI7byoQj05DsMJWQbftoBXYPfs/y1y7iZC+UusWTfb7futR48aeoRINKqSNNTEp6WfvK/N4+8U6i6LuXirNF22DWjp7QRHns9W/4sHs//3xaGZiTbANKK6QIfgLBQRwCUVrrwVX5C8ub2ugwTD0Sv2w1+jNmtCHfd9loKlGRYZhHmD5uEPxQAcYBrRKw99tAiglEWKz+HuNu08Wai7LBL8Bb6EG6atp7rjGBGeh5/iq9gFL83OHYa91RuN32lOejQAl5LOZfXeJa9pR8KqfcedrSbQUfGT8XbVqKi7hUCnbXU9zeSh7rLYNWvTm9Qbm2dBYJaIQZ7jCtwj6LtTBR+9K1ZK03LTyFTNNqvGON8Tf1+1LZ2u61SuhpHUGD8n2Uo6RDJc5Z7zxAyXYjNpc7RMS1uqauhEUHQvqHjdF3Bbh044TORvTAWOxQX48hTVVw7RqYcgf7hNIukqxVp8T+SgJDhWkpyrdVX7xNhN2N79YK3IaJTd/7kKrv8B4aQ3S9Szk0j9zVSr2/Bwh3JDYrHzTtnn9fhxJsyL8HK8WDq0Ix7B5/HdCfqUUJ4vFdz+HlkdTfwS1+IyQ24Jxg2nr6gg0EU072+Up+nyhzqvQ8fNF9N0lbomwxOENrxavfHgDGrpOXiNwmxai+uz1Tcb8RXBftQENflC9cblJdp3hMhW7BVbRcrtxS3tfI9YiAzfEBz5b0rUdaigW4eEf3Aivt6h3HyxVvTF2efPu6L5Bi+rPUOkEB+tWHZHJKiNFegih/54sUzvAJ19j9fhTiPOxcekMcDKOYWRVD9HcM57VOzYS/DjDi9wD5H7PJV4EV4/YzRedP4exppNXyP5FXID6wqhUYhB9xrl+n1IvPxej6txTVudc1u+n1fhSecJ3n+H7O+cLmXze8zxstpSfFQEwhaMK31OC5UZ/bkIHxDrTl+oEOYRbBYDKsfuOBMfxpPUGyU1dLyYQ8WoqIKHtaaIjsWDuEk4TlOFOThZmn5VvXH7DGnpo4R5QGicr466CqtXUG/cgSvx+qzMkVhmTePO0eBSZ/yfcHQTRVCm9W/r+QWCYcnzRu4U2z880FZnP2HVtIc6EpwkCITN+L5gfpqCndo4WjKEeYGYRU5RDJo78UUxOH+F7bNn/WM8Qwz8E3Ef3tldoItRkzs3VXC5fPodj/tEpG9XPKePjm7HchHwOc05jRGnTatQby+451zjfs/42WirsOuPF9prd7xC6pNd6v62SOJKRuU2TXMxjhP5KkzepJjtNuH9mrXvq01qHs/ENLanEL5figF2kcTD0hTJYixo4+aPE8v1crm8HKdJ3NQ2jL4i/KWPZs+d98G3yvLQrxY2XRU8ZnyKaDvWiYHyy1I1lseJOKiUu9MripD987MzTVwsTTeOKbdxiJj+b8vODAmzoxtLlIppdivp1vg7egxLDYvp97lYldWXihnxs2rNTkxEPxq6lwGwv3BCV8tTHtLRqjZgvSTl7LXETN3Knl0v/LUQ5lUriiPwA5wmfDQixeDkyTV0vLSniCmgKlf8HVw1YTcUWxZ8E2eI0dZL+LsTlmSd8wP1mzd24iunAMFahF1J0HRXqLXpiPftQ71xr6Dw8k36DsZz1BvXTWgWdTOXou+WiLzwnCm6Hv+EzduAMBP279dw4aTPVL8Z6UoxOAkG5Exhdo2/rpCd64SP9qbsm8O6aehcle9f8UG2CO382KR2YtHQzwoveLhbxRWwEseUY6Uqon4LYSq9suXsd3CH0zsOnlSwDY9mn3fST8JSfdRJP1VQYcQWau8yPng1EVpt8OnCsHi3XbZyS9sXd1wt0m91GfAjwizJfbTtJtbQ0WnPFsn0VUPk38PlkhJKIUbbVpE3vAxvNjUdvR3eTvIt9cZ9U+sgNgl+NA9zDQs7ufOAjGe8ET9UUFpH48PqjfWV2vaBn8hyaY4VvkItu++H8K0uV890ru0vcF0J6dlVoTRTQQluQpkA063CvF3MRPTLmltIm/PwVpOv8euErcKOe8jpJbfBjRf+GN6Npxqr+frB80Ug6EOm9mXOE3ZwTindJhemiV/Ar3GRcGJqgtM/VD4dl8XcEdm1ZyrMna/g39DsMjha+6CK0uhVwfwU60s45rsr8oJSkfj2DyXvsVQLT91ZoNMmwa0e18NDrFWQ+eURQr1eTKO7qJ4f3QlDgja6RL1x85Ro6RDYfYxdBPxQ1l8jxtJbrYKQiFljS/Y3T1iaWLN3vvciIcz5w9wiqK5fV3y+mWA5fl3y2ZYqOOqaCAj1hPECHZ22WAjW4or1RYpoLVk/uryqCtIaSfMW4YSeJ0yQfvEMERA6xdnrhq3uc/P0uYsZ3rBShGVzHKzItJtoJsjDxq0T8GFYrt5YV9IJrAnP/9XZ2UfwXqmGtJRV2K6hp1uoWwf4ZJhvinYgGC/QNTQdLzq7Km7HhZo9zu6rnxkvbm7zKsO11fiYoGP6xetwoSTpZmN2x/CGxcY7dL2+jF2wkqRs5v/h+HsxxTbxCXxJkvXd5Ej1bnZVEfx0gv8nw1bFjDYsCIU7utTdsf6xAl1v0LRM2M5VQqN55Z/DXX1N7QUlc4Gw38/UX3opwSqcihvUG4/03L5o14HGsj53i6m1LBJhMy40Sv2lnzBZwlKRmfhBxcxwFc7BcIXnaaV8ZmLn2bIC/YgQ6nygXijYi8po19DFFgHV8XOR1N6/8xVCPYKPCLPjJP2/gCPwGpL/6qOOmpju8xDzQ2KPkJsq1rEGb8g+H4AD1RuXTZKSuUA4SQdmZ38hKLoqDEkeqMkxT5nEsCJZqBfzpKws3COYih2zdu2NMglc41AISTR8f/GCemn8F3HrlNFjUc8m/KNenMzxmI+3kfa261KhJVsjpjeIbLH7KxzrRdrk5qyOhSZKWFozuunliYrlbltwlsQ11VRH2lTw4ISm36Hkxc/Ru71dppV3C6GW3eclmKtefQ1maOhiFJ4iIoNVcZ/OKaL9ITT1A8Ju3FVkX/WD/UWg6AN6m0leLpxM2fWXYmPlQVxvXCPC/r+XnYmEpfq6O61qcVrDqnyB0M55SPgCfEoqtbrKfRO4q+XEbnimeuOeiSN4DaLfj+ylsyv08QMiypkzCYfjeSTXlezP0X9bTY5sSu4Jl+KmacluqyU009vFxjKfUT19dUxtwqT6snrjRxXbuyDrn3yaXi9SQ6sj9aDEpQqBfjqOIDl3tEy8pJ2NDW3fhPdhozThrG6b7KSckT1jKIebhNM1V6SyHo+r1BsjY/pizbp8z5V8eVvZjmp3PMsK9IiY4U8QA/fJIv/jjeqNh0bb34qz1mpLM9gd9+cLS3OnafseXs8GkXiytYdru6Og/64VySgP9l4ZwmyIXZfWlNx1afwiWMLUuK2nQRyT9yUiHZL2hKUitP0ORWj7QbxL6o7Q3Cm1Lsd4C/lGeX5E4HXZEXKQHyHMc4Sd/w4F5Tg9GNlChLpbHcFjRPR4j9E+aT0KYd4ta+O5WDIno+leK6JWveAKE6eITg0K5uMiEUk8W3/bax2Hz0vTr5crniI5Rvx6F6FRLlFutcdEz7NWDNJ8sfFBeK5649rsc2tom3CaXikZ3cimm4Btkfq4yCfO8QvBRL1HCOmO4gdPnyf8lHuy80/L+ui1QptfKsyOftmmznjnAdQbjwpGaz+RdjqkWO53vsiVuTd77u2FRn6RsCxWiJ82MUfTcvnPPVTHRsEZbu7h2moIIWiKlQzLhL3f6/KtHcSMdI16Y0P3wZjsLDbDyXEXvq02og9sElHCo7Ln2AnHMnItQ/saG9qWPfPJFerfLIT0zpZzqQiR54JArFR/u9gK4pGW/snTUT8ikoXK7p3Si8kR3lctvZHkLdk98w2MVsjNrHBqU2H+PcFYmX0YwzWhrpcLrVP1uBJXTuuvvbZOM4Etgvk4X39O6GE4IZLNu+IQY6nMK3GX057d+93jvlcY66i9iqElQjP2O+WNH20xcO8VNOgF8gSgwEIRgl4qhPkBnCXyax5TzBSTvex2G7q8YJwx+vuUl4nVKOcby+8vFLb1UmOXga0XuUMn4d45Qkt8o8LN80YnIo/g0Z7C3J0wOZ22ndAmuwmm4VFht1cNAOWIXZeS5BvqjW7BoLvEgs28j76rk8BUwer9qDd+JmbHp2Znt4i+/ZowD/rBsE7RtiQlTe4Q9OzLRCLYvlnfJsJWv1Es/7o2e861ilhAU6wWn+ieHxJmTZLdv7yWLkzLHwpn9CDxw6v7i+Sloaw9jwoT43oRYGpk95b0vf9DSjX6SCu/2glzxZS3i/Dul4vssr3EtPtkkaAzFZGuVK6FfjOv6d17dS5Vdl+KqpiJnZ46tbO1/5MaaXOhwifZpHWtXyFk3evtVC7bXqASxsvHgqx9+YD6TdbOlhl6iFX7THNySv1Wk5AfiTDulwgNtZcQ3OXC4N9VETmaTtwjcjNumMGtD7YNTKZYtpW+6Dbo29o5dQI9+Y0XCKfnKYKG2Sc79hQmxJOU2yx9uvAZsbBgNnZdGmAK0d9vrLQKcZqQpPOEubBUmAt7C8Hd21hzYao2l5kqHIsLJS6a7YYM0B/6/dGgeYKz3FeSPkswAXsLE+KJOm0ssm1ie5wk9U0FdTXA4xD/D/Hsm53QCsjKAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTAzLTA1VDA0OjMzOjAzLTA1OjAwbx74lgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wMy0wNVQwNDozMzowMy0wNTowMB5DQCoAAAAASUVORK5CYII=
name: Azure Compute v2
script:
  commands:
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group of the virtual machines.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    description: Lists the virtual machine instances in the given resource group.
    name: azure-vm-list-instances
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The location of the virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the virtual machine.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the virtual machine.
      type: string
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        Resource Group to which the virtual machine belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: Name of the virtual machine to power on. To see all virtual machines
        and their associated names for a specific resource group, run the `azure-vm-list-instances`
        command.
      name: virtual_machine_name
      required: true
    description: Powers on a given virtual machine.
    execution: true
    name: azure-vm-start-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: Name of the VM that was started.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: Resource group the VM resides in.
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the VM instance is powered on or off.
      type: string
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the virtual machine belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The name of the virtual machine to power off. To see all virtual
        machines with their associated names for a specific resource group, run the
        `azure-vm-list-instances` command.
      name: virtual_machine_name
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: Set to True to request non-graceful VM shutdown. Default value
        is False.
      name: skip_shutdown
      predefined:
      - "true"
      - "false"
    description: Powers off a given virtual machine.
    execution: true
    name: azure-vm-poweroff-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine that was powered off.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the virtual machine instance is powered on or off.
      type: string
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the virtual machine belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The name of the virtual machine you want to view the details of.
        To see all the virtual machines with their associated names for a specific
        resource group, run the `azure-vm-list-instances` command.
      name: virtual_machine_name
      required: true
    - auto: PREDEFINED
      defaultValue: instanceView
      description: The expand expression to apply on the operation. 'instanceView'
        retrieves a snapshot of the runtime properties of the virtual machine that
        is managed by the platform and can change outside of control plane operations.
        'userData' retrieves the UserData property as part of the VM model view that
        was provided by the user during the VM Create/Update operation. Default value
        is False.
      name: expand
      predefined:
      - instanceView
      - userData
    description: Gets the properties of a given virtual machine.
    name: azure-vm-get-instance-details
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine you want to get details of.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the given virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the deployed virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The region in which the virtual machine is hosted.
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the virtual machine instance is powered on or off.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group to which the virtual machine belongs.
      type: string
    - contextPath: Azure.Compute.NetworkInterfaces
      description: The list of network interfaces attached to this machine.
      type: string
    - contextPath: Azure.Compute.UserData
      description: UserData for the VM.
      type: string
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the new virtual machine will belong.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The name of the virtual machine to create.
      name: virtual_machine_name
      required: true
    - auto: PREDEFINED
      description: The location in which to create the virtual machine.
      name: virtual_machine_location
      predefined:
      - westus2
      - westus
      - westindia
      - westeurope
      - westcentralus
      - uksouth
      - ukwest
      - southeastasia
      - northcentralus
      - northeurope
      - southcentralus
      - southindia
      - francesouth
      - francecentral
      - japaneast
      - japanwest
      - koreacentral
      - koreasouth
      - brazilsouth
      - canadacentral
      - canadaeast
      - centralindia
      - eastus2
      - eastasia
      - westus
      - centralus
      - eastus
      - australiacentral
      - australiacentral2
      - australiaeast
      - australiasoutheast
      required: true
    - description: The name of the Network Interface to link the virtual machine with.
        Note that the virtual machine's location property must match that of the Network
        Interface you choose to link it to. To see a list of available Network Interfaces
        visit the Azure Web Portal, navigate to the search bar at the top of the page,
        type "network interfaces", and in the dynamic drop-down menu that appears,
        click the 'Network interfaces' option that appears under the 'Services' category.
        If none are present, you will need to create a new Network Interface.
      name: nic_name
      required: true
    - auto: PREDEFINED
      description: The name of a VirtualMachineSize, which determines the size of
        the deployed virtual machine. For more information, see the Azure documentation
        at https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/listavailablesizes#virtualmachinesize.
      name: vm_size
      predefined:
      - Standard_D1_v2
      - Standard_D2_v2
      - Standard_D2s_v3
      - Standard_B1ms
      - Standard_B1s
      - Standard_B2s
      - Standard_B4ms
      - Standard_D4s_v3
      - Standard_DS1_v2
      - Standard_DS2_v2
      - Standard_DS3_v2
      - Promo_DS2_v2
      - Promo_DS3_v2
      required: true
    - auto: PREDEFINED
      description: The base operating system image of the virtual machine.
      name: os_image
      predefined:
      - Ubuntu Server 14.04 LTS
      - Ubuntu Server 16.04 LTS
      - Ubuntu Server 18.04 LTS
      - Red Hat Enterprise Linux 7.6
      - CentOS-based 7.5
      - Windows Server 2012 R2 Datacenter
      - Windows Server 2016 Datacenter
      - Windows 10 Pro Version 1803
      - Windows 10 Pro Version 1809
    - defaultValue: 2016-Datacenter
      description: SKU of the OS image to be used. To see a list of available SKUs,
        visit your Azure Web Portal, click the symbol that looks similar to a '>'
        on the top bar of the page. This should open a cloud shell, make sure it is
        a bash shell. At the command prompt enter `az vm image list-skus` along with
        the appropriate arguments that it will prompt you with to display the list
        of VM image SKUs available in the Azure Marketplace.
      name: sku
    - defaultValue: MicrosoftWindowsServer
      description: Name of the publisher of the OS image. To see a list of available
        publishers, visit your Azure Web Portal, click the symbol that looks similar
        to a '>' on the top bar of the page which should open a cloud shell, make
        sure it is a bash shell. At the command prompt enter `az vm image list-publishers`
        along with the appropriate arguments that it will prompt you with to display
        the list of VM image publishers available in the Azure Marketplace.
      name: publisher
    - defaultValue: latest
      description: Version of the image to use. The supported formats are Major.Minor.Build
        or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest'
        to use the latest version of an image available at deploy time.
      name: version
    - defaultValue: WindowsServer
      description: Specifies the offer of the platform image or marketplace image
        used to create the virtual machine. To see a list of available offers, visit
        your Azure Web Portal, click the symbol that looks similar to a '>' on the
        top bar of the page which should open a cloud shell, make sure it is a bash
        shell. At the command prompt enter `az vm image list-offers` along with the
        appropriate arguments that it will prompt you with to display the list of
        VM image offers available in the Azure Marketplace.
      name: offer
    - defaultValue: DemistoUser
      description: The admin username to use when creating the virtual machine.
      name: admin_username
    - defaultValue: Passw0rd@123
      description: The admin password to use when creating the virtual machine.
      name: admin_password
    description: Creates a virtual machine instance with the specified OS image.
    execution: true
    name: azure-vm-create-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the created virtual machine instance.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the specified virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the deployed virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The region in which the virtual machine is hosted.
      type: string
  - arguments:
    - description: 'Subscription ID to use. Can be retrieved from the azure-sc-list-subscriptions
        command. Note: This argument will override the instance parameter ‘Default
        Subscription ID''.'
      name: subscription_id
    - description: A single tag in the form of '{"Tag Name":"Tag Value"}' to filter
        the list by.
      name: tag
    - defaultValue: "50"
      description: Limit on the number of resource-groups to return. Default value
        is 50.
      name: limit
    description: Lists all resource groups that belong to your Azure subscription.
    name: azure-list-resource-groups
    outputs:
    - contextPath: Azure.ResourceGroup.Name
      description: The name of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.ID
      description: The ID of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.Location
      description: The location of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.ProvisioningState
      description: The provisioning state of the resource group.
      type: string
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the virtual machine belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The name of the virtual machine to delete. To see all the virtual
        machines with their associated names for a specific resource group, run the
        `azure-vm-list-instances` command.
      name: virtual_machine_name
    description: Deletes a specified virtual machine.
    name: azure-vm-delete-instance
  - arguments: []
    description: Lists the subscriptions for this application.
    name: azure-list-subscriptions
    outputs:
    - contextPath: Azure.Subscription.ID
      description: The ID of the subscription.
      type: String
    - contextPath: Azure.Subscription.Name
      description: The name of the subscription.
      type: String
    - contextPath: Azure.Subscription.State
      description: The state of the subscription.
      type: String
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the network interface belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The name of the network interface you want to view the details
        of.
      name: nic_name
      required: true
    description: Gets the properties of a given network interface.
    name: azure-vm-get-nic-details
    outputs:
    - contextPath: Azure.Network.Interfaces.AttachedVirtualMachine
      description: The attached virtual machine to this interface.
      type: String
    - contextPath: Azure.Network.Interfaces.IsPrimaryInterface
      description: True if this interface is a primary interface of the attached virtual
        machine.
      type: String
    - contextPath: Azure.Network.Interfaces.NICType
      description: The interface type.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.ConfigID
      description: The interface IP configuration ID.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.ConfigName
      description: The interface IP configuration name.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.PrivateIPAddress
      description: The interface private IP address.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.PublicIPAddressID
      description: The interface public IP address ID.
      type: Unknown
    - contextPath: Azure.Network.Interfaces.MACAddress
      description: The interface MAC address.
      type: String
    - contextPath: Azure.Network.Interfaces.Name
      description: The interface name.
      type: String
    - contextPath: Azure.Network.Interfaces.ResourceGroup
      description: The interface resource group.
      type: String
    - contextPath: Azure.Network.Interfaces.NetworkSecurityGroup.id
      description: The interface network security group ID.
      type: String
    - contextPath: Azure.Network.Interfaces.Location
      description: The interface location.
      type: String
    - contextPath: Azure.Network.Interfaces.ID
      description: The interface ID.
      type: String
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the IP address belongs.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The IP address name.
      name: address_name
      required: true
    description: Gets the properties of a given public IP address.
    name: azure-vm-get-public-ip-details
    outputs:
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddress
      description: The public IP address.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressFQDN
      description: The address fully-qualified domain name (FQDN).
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressAllocationMethod
      description: The address allocation method.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicConfigID
      description: The address configuration ID.
      type: String
    - contextPath: Azure.Network.IPConfigurations.ResourceGroup
      description: The address resource group.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressDomainName
      description: The address domain name.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressVersion
      description: The address version.
      type: String
    - contextPath: Azure.Network.IPConfigurations.Location
      description: The address location.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicConfigName
      description: The address configuration name.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressID
      description: The address ID.
      type: String
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    - description: |
        The resource group to which the new network interface will belong.
        To see all the resource groups associated with your subscription, run the `azure-list-resource-groups` command. If none are present, navigate to the Azure Web Portal to create resource groups.
        Note: This argument will override the instance parameter ‘Default Resource Group Name'.
      name: resource_group
    - description: The network interface name.
      name: nic_name
      required: true
    - auto: PREDEFINED
      description: The location in which to create the network interface.
      name: nic_location
      predefined:
      - westus2
      - westus
      - westindia
      - westeurope
      - westcentralus
      - uksouth
      - ukwest
      - southeastasia
      - northcentralus
      - northeurope
      - southcentralus
      - southindia
      - francesouth
      - francecentral
      - japaneast
      - japanwest
      - koreacentral
      - koreasouth
      - brazilsouth
      - canadacentral
      - canadaeast
      - centralindia
      - eastus2
      - eastasia
      - westus
      - centralus
      - eastus
      - australiacentral
      - australiacentral2
      - australiaeast
      - australiasoutheast
      required: true
    - description: The virtual network name of the interface.
      name: vnet_name
      required: true
    - description: The subnet name of the interface.
      name: subnet_name
      required: true
    - auto: PREDEFINED
      defaultValue: Dynamic
      description: The address assignment method.
      name: address_assignment_method
      predefined:
      - Static
      - Dynamic
    - description: The private IP address of the interface if you chose the static
        assignment method.
      name: private_ip_address
    - description: The IP address configuration name.
      name: ip_config_name
      required: true
    - description: The network security group of the interface.
      name: network_security_group
    description: Creates a virtual machine network interface.
    name: azure-vm-create-nic
    outputs:
    - contextPath: Azure.Network.Interfaces.IPConfigurations.ConfigID
      description: The interface IP configuration ID.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.ConfigName
      description: The interface IP configuration name.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.PrivateIPAddress
      description: The interface private IP address.
      type: String
    - contextPath: Azure.Network.Interfaces.IPConfigurations.PublicIPAddressID
      description: The interface public IP address ID.
      type: Unknown
    - contextPath: Azure.Network.Interfaces.Name
      description: The interface name.
      type: String
    - contextPath: Azure.Network.Interfaces.ResourceGroup
      description: The interface resource group.
      type: String
    - contextPath: Azure.Network.Interfaces.NetworkSecurityGroup.id
      description: The interface network security group ID.
      type: String
    - contextPath: Azure.Network.Interfaces.Location
      description: The interface location.
      type: String
    - contextPath: Azure.Network.Interfaces.ID
      description: The interface ID.
      type: String
  - arguments:
    - description: 'The subscription ID. Note: This argument will override the instance
        parameter ‘Default Subscription ID''.'
      name: subscription_id
    description: Gets the properties of all public ip address in a subscription.
    name: azure-vm-get-all-public-ip-details
    outputs:
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddress
      description: The public IP address.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressFQDN
      description: The address fully-qualified domain name (FQDN).
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressAllocationMethod
      description: The address allocation method.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicConfigID
      description: The address configuration ID.
      type: String
    - contextPath: Azure.Network.IPConfigurations.ResourceGroup
      description: The address resource group.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressDomainName
      description: The address domain name.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressVersion
      description: The address version.
      type: String
    - contextPath: Azure.Network.IPConfigurations.Location
      description: The address location.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicConfigName
      description: The address configuration name.
      type: String
    - contextPath: Azure.Network.IPConfigurations.PublicIPAddressID
      description: The address ID.
      type: String
  - arguments: []
    description: Run this command if for some reason you need to rerun the authentication
      process.
    name: azure-vm-auth-reset
  dockerimage: demisto/crypto:1.0.0.83343
  runonce: false
  script: |
    register_module_line('Azure Compute v2', 'start', __line__())
    ### pack version: 1.2.28




    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)


    # pylint: disable=E9010, E9011
    import traceback


    import requests
    import re
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM


    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'  # resource_manager


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        security = 'https://api.security.microsoft.com/'
        management_azure = 'https://management.azure.com/'  # resource_manager
        manage_office = 'https://manage.office.com/'


    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line
    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'
    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'
    REGEX_SEARCH_ERROR_DESC = r"^.*?:\s(?P<desc>.*?\.)"
    SESSION_STATE = 'session_state'

    # Deprecated, prefer using AZURE_CLOUDS
    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.us',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"
    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"


    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris
    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api
    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'geo-us': 'https://login.microsoftonline.com',
        'geo-eu': 'https://login.microsoftonline.com',
        'geo-uk': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
    }

    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'geo-us': 'https://graph.microsoft.com',
        'geo-eu': 'https://graph.microsoft.com',
        'geo-uk': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        'com': 'https://securitycenter.onmicrosoft.com',
        'geo-us': 'https://securitycenter.onmicrosoft.com',
        'geo-eu': 'https://securitycenter.onmicrosoft.com',
        'geo-uk': 'https://securitycenter.onmicrosoft.com',
        'gcc': 'https://securitycenter.onmicrosoft.com',
        'gcc-high': 'https://securitycenter.onmicrosoft.us',
        'dod': 'https://securitycenter.onmicrosoft.us',
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
    }

    # Azure Managed Identities
    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'
    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'
    TOKEN_EXPIRED_ERROR_CODES = {50173, 700082, 70008, 54005, 7000222,
                                 }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism
    MAX_DELAY_REQUEST_COUNTER = 6


    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     management=None,
                     resource_manager=None,
                     sql_management=None,
                     batch_resource_id=None,
                     gallery=None,
                     active_directory=None,
                     active_directory_resource_id=None,
                     active_directory_graph_resource_id=None,
                     microsoft_graph_resource_id=None,
                     active_directory_data_lake_resource_id=None,
                     vm_image_alias_doc=None,
                     media_resource_id=None,
                     ossrdbms_resource_id=None,
                     log_analytics_resource_id=None,
                     app_insights_resource_id=None,
                     app_insights_telemetry_channel_resource_id=None,
                     synapse_analytics_resource_id=None,
                     attestation_resource_id=None,
                     portal=None,
                     keyvault=None,
                     exchange_online=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault
            self.exchange_online = exchange_online

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     storage_endpoint=None,
                     storage_sync_endpoint=None,
                     keyvault_dns=None,
                     mhsm_dns=None,
                     sql_server_hostname=None,
                     azure_datalake_store_file_system_endpoint=None,
                     azure_datalake_analytics_catalog_and_job_endpoint=None,
                     acr_login_server_endpoint=None,
                     mysql_server_endpoint=None,
                     postgresql_server_endpoint=None,
                     mariadb_server_endpoint=None,
                     synapse_analytics_endpoint=None,
                     attestation_endpoint=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """ Represents an Azure Cloud instance """

        def __init__(self,
                     origin,
                     name,
                     abbreviation,
                     endpoints=None,
                     suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        'Embedded',
        'AzureCloud',
        'com',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.windows.net/',
            resource_manager='https://management.azure.com/',
            sql_management='https://management.core.windows.net:8443/',
            batch_resource_id='https://batch.core.windows.net/',
            gallery='https://gallery.azure.com/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.windows.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.com/',
            active_directory_data_lake_resource_id='https://datalake.azure.net/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.azure.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.windows.net',
            app_insights_resource_id='https://api.applicationinsights.io',
            log_analytics_resource_id='https://api.loganalytics.io',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.com/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.net',
            attestation_resource_id='https://attest.azure.net',
            portal='https://portal.azure.com',
            keyvault='https://vault.azure.net',
            exchange_online='https://outlook.office365.com'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.windows.net',
            storage_sync_endpoint='afs.azure.net',
            keyvault_dns='.vault.azure.net',
            mhsm_dns='.managedhsm.azure.net',
            sql_server_hostname='.database.windows.net',
            mysql_server_endpoint='.mysql.database.azure.com',
            postgresql_server_endpoint='.postgres.database.azure.com',
            mariadb_server_endpoint='.mariadb.database.azure.com',
            azure_datalake_store_file_system_endpoint='azuredatalakestore.net',
            azure_datalake_analytics_catalog_and_job_endpoint='azuredatalakeanalytics.net',
            acr_login_server_endpoint='.azurecr.io',
            synapse_analytics_endpoint='.dev.azuresynapse.net',
            attestation_endpoint='.attest.azure.net'))

    AZURE_US_GCC_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook.office365.com'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc-high',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook.office365.us'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_DOD_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'dod',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://dod-graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook-dod.office365.us'

        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))


    AZURE_GERMAN_CLOUD = AzureCloud(
        'Embedded',
        'AzureGermanCloud',
        'de',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.cloudapi.de/',
            resource_manager='https://management.microsoftazure.de',
            sql_management='https://management.core.cloudapi.de:8443/',
            batch_resource_id='https://batch.cloudapi.de/',
            gallery='https://gallery.cloudapi.de/',
            active_directory='https://login.microsoftonline.de',
            active_directory_resource_id='https://management.core.cloudapi.de/',
            active_directory_graph_resource_id='https://graph.cloudapi.de/',
            microsoft_graph_resource_id='https://graph.microsoft.de',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.cloudapi.de',
            ossrdbms_resource_id='https://ossrdbms-aad.database.cloudapi.de',
            portal='https://portal.microsoftazure.de',
            keyvault='https://vault.microsoftazure.de',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.cloudapi.de',
            keyvault_dns='.vault.microsoftazure.de',
            mhsm_dns='.managedhsm.microsoftazure.de',
            sql_server_hostname='.database.cloudapi.de',
            mysql_server_endpoint='.mysql.database.cloudapi.de',
            postgresql_server_endpoint='.postgres.database.cloudapi.de',
            mariadb_server_endpoint='.mariadb.database.cloudapi.de'))

    AZURE_CHINA_CLOUD = AzureCloud(
        'Embedded',
        'AzureChinaCloud',
        'cn',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.chinacloudapi.cn/',
            resource_manager='https://management.chinacloudapi.cn',
            sql_management='https://management.core.chinacloudapi.cn:8443/',
            batch_resource_id='https://batch.chinacloudapi.cn/',
            gallery='https://gallery.chinacloudapi.cn/',
            active_directory='https://login.chinacloudapi.cn',
            active_directory_resource_id='https://management.core.chinacloudapi.cn/',
            active_directory_graph_resource_id='https://graph.chinacloudapi.cn/',
            microsoft_graph_resource_id='https://microsoftgraph.chinacloudapi.cn',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.chinacloudapi.cn',
            ossrdbms_resource_id='https://ossrdbms-aad.database.chinacloudapi.cn',
            app_insights_resource_id='https://api.applicationinsights.azure.cn',
            log_analytics_resource_id='https://api.loganalytics.azure.cn',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.cn/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.azure.cn',
            portal='https://portal.azure.cn',
            keyvault='https://vault.azure.cn',
            exchange_online='https://partner.outlook.cn'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.chinacloudapi.cn',
            keyvault_dns='.vault.azure.cn',
            mhsm_dns='.managedhsm.azure.cn',
            sql_server_hostname='.database.chinacloudapi.cn',
            mysql_server_endpoint='.mysql.database.chinacloudapi.cn',
            postgresql_server_endpoint='.postgres.database.chinacloudapi.cn',
            mariadb_server_endpoint='.mariadb.database.chinacloudapi.cn',
            acr_login_server_endpoint='.azurecr.cn',
            synapse_analytics_endpoint='.dev.azuresynapse.azure.cn'))


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    AZURE_CLOUD_NAME_CUSTOM = "Custom"

    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }


    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(origin: str,
                                  name: str | None = None,
                                  abbreviation: str | None = None,
                                  defaults: AzureCloud | None = None,
                                  endpoints: dict | None = None,
                                  suffixes: dict | None = None):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get('management', defaults.endpoints.management),
                resource_manager=endpoints.get('resource_manager', defaults.endpoints.resource_manager),
                sql_management=endpoints.get('sql_management', defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get('batch_resource_id', defaults.endpoints.batch_resource_id),
                gallery=endpoints.get('gallery', defaults.endpoints.gallery),
                active_directory=endpoints.get('active_directory', defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get('active_directory_resource_id',
                                                           defaults.endpoints.active_directory_resource_id),
                active_directory_graph_resource_id=endpoints.get(
                    'active_directory_graph_resource_id', defaults.endpoints.active_directory_graph_resource_id),
                microsoft_graph_resource_id=endpoints.get('microsoft_graph_resource_id',
                                                          defaults.endpoints.microsoft_graph_resource_id),
                active_directory_data_lake_resource_id=endpoints.get(
                    'active_directory_data_lake_resource_id', defaults.endpoints.active_directory_data_lake_resource_id),
                vm_image_alias_doc=endpoints.get('vm_image_alias_doc', defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get('media_resource_id', defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get('ossrdbms_resource_id', defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get('app_insights_resource_id', defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get('log_analytics_resource_id', defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    'app_insights_telemetry_channel_resource_id', defaults.endpoints.app_insights_telemetry_channel_resource_id),
                synapse_analytics_resource_id=endpoints.get(
                    'synapse_analytics_resource_id', defaults.endpoints.synapse_analytics_resource_id),
                attestation_resource_id=endpoints.get('attestation_resource_id', defaults.endpoints.attestation_resource_id),
                portal=endpoints.get('portal', defaults.endpoints.portal),
                keyvault=endpoints.get('keyvault', defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get('storage_endpoint', defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get('storage_sync_endpoint', defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get('keyvault_dns', defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get('mhsm_dns', defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get('sql_server_hostname', defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get('mysql_server_endpoint', defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get('postgresql_server_endpoint', defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get('mariadb_server_endpoint', defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    'azure_datalake_store_file_system_endpoint', defaults.suffixes.azure_datalake_store_file_system_endpoint),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    'azure_datalake_analytics_catalog_and_job_endpoint',
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint),
                acr_login_server_endpoint=suffixes.get('acr_login_server_endpoint', defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get('synapse_analytics_endpoint', defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get('attestation_endpoint', defaults.suffixes.attestation_endpoint),
            ))


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, 'com')
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get('azure_cloud')
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if 'server_url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'resource_manager': params.get('server_url')
                                                            or 'https://management.azure.com'})
            if 'azure_ad_endpoint' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={
                                                     'active_directory': params.get('azure_ad_endpoint')
                                                     or 'https://login.microsoftonline.com'
                                                 })
            # in multiple Graph integrations, the url is called 'url' instead of 'server_url' and the default url is different.
            if 'url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'microsoft_graph_resource_id': params.get('url')
                                                            or 'https://graph.microsoft.com'})

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str | None = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str | None = '',
                     multi_resource: bool = False,
                     resources: list[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: int | None = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
                     endpoint: str = "__NA__",  # Deprecated
                     certificate_thumbprint: str | None = None,
                     retry_on_rate_limit: bool = False,
                     private_key: str | None = None,
                     managed_identities_client_id: str | None = None,
                     managed_identities_resource_uri: str | None = None,
                     base_url: str | None = None,
                     command_prefix: str | None = "command_prefix",
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            demisto.debug(f'Initializing MicrosoftClient with: {endpoint=} | {azure_cloud.abbreviation}')
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=self.azure_cloud.endpoints.active_directory
                                                                      .rstrip("/"))
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(
                endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: str | None = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    try:
                        import defusedxml.ElementTree as defused_ET
                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug('defused_ET is not supported, using ET instead.')
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f'Failed to parse json object from response: {response.content}', exception)

        def get_access_token(self, resource: str = '', scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else \
                            min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug('Set integration context successfully.')

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in Microsoft authorization.'
            try:
                demisto.info(
                    f'Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} '
                    f'{oproxy_response.text}'
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r'{.*}', oproxy_response.text)
                microsoft_response = self.extract_microsoft_error(json.loads(search_microsoft_response.group())) \
                    if search_microsoft_response else ""
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f' body: {err_str}'
                err_response = oproxy_response.json()
                server_msg = err_response.get('message', '') or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f' Server message: {server_msg}'
            except Exception as ex:
                demisto.error(f'Failed parsing error response - Exception: {ex}')
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: dict[str, str], content: str,
                                            scope: str | None = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get('delay_request_counter', 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(next_request_time=next_request_time, delay_request_counter=delay_request_counter,
                                              context=context)
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: str | None = None,
                                     integration_context: dict | None = None
                                     ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                      resource)
                    self.resource_to_access_token[resource] = access_token

                return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: str | None = None,
                                                        resource: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope or self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')
            return None

        def _get_token_device_code(
            self, refresh_token: str = '', scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run, timeout_in_seconds=900))

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get('error', {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get('error_description', '')

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += f"\nYou can run the ***{self.command_prefix}-auth-reset*** command " \
                               f"to reset the authentication process."
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f'Failed getting integration info: {str(e)}')

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search['url'] if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
            Calculates the next request time based on the delay_request_counter.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2 ** delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
            Sets the next_request_time in the integration context.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context['next_request_time'] = next_request_time
        context['delay_request_counter'] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context['delay_request_counter'] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
            Checks if the request should be delayed based on context variables.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient,
                           login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException("Please make sure you entered the Authorization configuration correctly. "
                                   f"Missing:{','.join(missing)}")

        login_url = urljoin(login_url, f'{client.tenant_id}/oauth2/v2.0/authorize?'
                            f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
                            f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}')

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.
    You will be automatically redirected to a link with the following structure:
    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```
    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)
    and paste it in your instance configuration under the **Authorization code** parameter.
     """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f'No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.')


    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(readable_output='Authorization was reset successfully. Please regenerate the credentials, '
                                              'and then click **Test** to validate the credentials and connection.')

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###


    '''GLOBAL VARS'''
    API_VERSION = '2023-03-01'
    APP_NAME = 'ms-azure-compute'
    DEFAULT_LIMIT = 50

    # Image options to be used in the create_vm_command
    IMAGES = {
        'ubuntu server 14.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '14.04-LTS',
            'version': 'latest'
        },
        'ubuntu server 16.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '16.04-LTS',
            'version': 'latest'
        },
        'ubuntu server 18.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '18.04-LTS',
            'version': 'latest'
        },
        'red hat enterprise linux 7.6': {
            'publisher': 'RedHat',
            'offer': 'RHEL',
            'sku': '7-RAW',
            'version': 'latest'
        },
        'centos-based 7.5': {
            'publisher': 'OpenLogic',
            'offer': 'CentOS',
            'sku': '7.5',
            'version': 'latest'
        },
        'windows server 2012 r2 datacenter': {
            'publisher': 'MicrosoftWindowsServer',
            'offer': 'WindowsServer',
            'sku': '2012-R2-Datacenter',
            'version': 'latest'
        },
        'windows server 2016 datacenter': {
            'publisher': 'MicrosoftWindowsServer',
            'offer': 'WindowsServer',
            'sku': '2016-Datacenter',
            'version': 'latest'
        },
        'windows 10 pro version 1803': {
            'publisher': 'MicrosoftWindowsDesktop',
            'offer': 'Windows-10',
            'sku': 'rs4-pro',
            'version': 'latest'
        },
        'windows 10 pro version 1809': {
            'publisher': 'MicrosoftWindowsDesktop',
            'offer': 'Windows-10',
            'sku': 'rs5-pro',
            'version': 'latest'
        }
    }

    # Error messages for different provisioning states
    CREATING_OR_UPDATING_ERR = 'Please wait for the VM to finish being' \
                               ' {} before executing this command. To retrieve the ' \
                               'last known state of the VM, execute the ' \
                               '`azure-vm-get-instance-details` command. '
    DELETING_ERR = 'You cannot execute this command because the VM is being deleted.'
    FAILED_ERR = 'Unable to power-off or power-on \'{}\' virtual machine ' \
                 'because the following provisioning failure occurred during ' \
                 'the vm\'s creation.\ncode: "{}"\nmessage: "{}"\nVisit the ' \
                 'Azure Web Portal to take care of this issue.'

    # Error messages determined by the provisioning state of the VM
    PROVISIONING_STATE_TO_ERRORS = {
        'creating': CREATING_OR_UPDATING_ERR.format('created'),
        'updating': CREATING_OR_UPDATING_ERR.format('updated'),
        'deleting': DELETING_ERR,
        'failed': FAILED_ERR
    }

    '''HELPER FUNCTIONS'''


    def screen_errors(error_message, *args, **kwargs):
        """
        Make sure that the values passed as args and the keys in kwargs do not appear in error messages

        parameter: (string) error_message
            The error message that needs to be screened for the values in args and the keys
            in kwargs

        parameter: (list) *args
            Arguments that need to be screened from error outputs and that will be replaced
            by x's enclosed by a '<' symbol on the left, and a '>' symbol on the right

        parameter: (dict) **kwargs
            Key-value pairs for each of which the user wishes to screen the key identifier string
            from the error_message and replace it with its assigned value string. Useful for
            when the user wishes to replace sensitive data with a value of their choosing
            instead of the default x's enclosed by '<', and '>' symbols on the left and right respectively

        returns:
            The error message free of sensitive information as determined by the values of
            args and the keys of kwargs
        """
        if isinstance(error_message, Exception):
            # Format Exception object as String
            error_as_dict = vars(error_message)
            updated_error_message = ''
            for key, val in error_as_dict.items():
                if updated_error_message != '':
                    updated_error_message += '\n' + str(key) + ': ' + str(val)
                else:
                    updated_error_message += str(key) + ': ' + str(val)
        elif not isinstance(error_message, str):
            # If not an Exception or a String, try to cast to a string
            updated_error_message = str(error_message)
        else:
            updated_error_message = error_message

        for argument in args:
            if argument != '' and argument in updated_error_message:
                length = len(argument)
                placeholder = '<' + 'x' * length + '>'
                updated_error_message = updated_error_message.replace(argument, placeholder)

        for key, value in kwargs.items():
            if key != '' and key in updated_error_message:
                updated_error_message = updated_error_message.replace(key, value)

        return updated_error_message


    def assign_image_attributes(image):
        """
        Retrieve image properties determined by the chosen image

        returns:
            Image Properties Tuple (sku, publisher, offer, version)
        """
        image = image.lower()
        image_properties = IMAGES.get(image)
        if not image_properties:
            err_msg = 'Invalid value entered for the \'os_image\' argument. '
            err_msg += 'Only values from the provided options are accepted.'
            raise Exception(err_msg)
        sku = image_properties.get('sku')
        publisher = image_properties.get('publisher')
        offer = image_properties.get('offer')
        version = image_properties.get('version')
        return sku, publisher, offer, version


    def create_vm_parameters(args, subscription_id, resource_group):
        """
        Construct the VM object

        Use the actual parameters passed to the 'azure-vm-create-instance' command
        to build a vm object that will be sent in the body of the command's associated
        API call.

        parameter: (dict) args
            Dictionary that contains the actual parameters that were passed to the
            'azure-vm-create-instance' command

        returns:
            Virtual Machine Object
        """
        # Retrieve relevant command arguments
        location = args.get('virtual_machine_location')
        vm_size = args.get('vm_size')
        image = args.get('os_image')
        sku = args.get('sku')
        publisher = args.get('publisher')
        version = args.get('version')
        offer = args.get('offer')
        vm_name = args.get('virtual_machine_name')
        admin_username = args.get('admin_username')
        admin_password = args.get('admin_password')
        nic_name = args.get('nic_name')
        full_nic_id = f"/subscriptions/{subscription_id}/resourceGroups/"  # type: ignore
        full_nic_id += f"{resource_group}/providers/Microsoft.Network/networkInterfaces/{nic_name}"

        if not image and not (sku and publisher and version and offer):
            err_msg = 'You must enter a value for the \'os_image\' argument '
            err_msg += 'or the group of arguments, \'sku\', \'publisher\', \'version\', and \'offer\'.'
            raise Exception(err_msg)

        if image:
            sku, publisher, offer, version = assign_image_attributes(image)

        # Construct VM object
        vm = {
            'location': location,
            'properties': {
                'hardwareProfile': {
                    'vmSize': vm_size
                },
                'storageProfile': {
                    'imageReference': {
                        'sku': sku,
                        'publisher': publisher,
                        'version': version,
                        'offer': offer
                    },
                    'osDisk': {
                        'caching': 'ReadWrite',
                        'managedDisk': {
                            'storageAccountType': 'Standard_LRS'
                        },
                        'name': vm_name,
                        'createOption': 'FromImage'
                    }
                },
                'osProfile': {
                    'adminUsername': admin_username,
                    'computerName': vm_name,
                    'adminPassword': admin_password
                },
                'networkProfile': {
                    'networkInterfaces': [
                        {
                            'id': full_nic_id,
                            'properties': {
                                'primary': 'true'
                            }
                        }
                    ]
                }
            },
            'name': vm_name
        }

        return vm


    def create_nic_parameters(resource_group, subscription_id, args):
        """
        Construct the NIC object

        Use the actual parameters passed to the 'azure-vm-create-nic' command
        to build a nic object that will be sent in the body of the command's associated
        API call.

        parameter: (dict) args
            Dictionary that contains the actual parameters that were passed to the
            'azure-vm-create-nic' command

        returns:
            NIC Object
        """
        # Retrieve relevant command arguments
        location = args.get('nic_location')
        address_assignment_method = args.get('address_assignment_method')
        private_ip_address = args.get('private_ip_address')
        network_security_group = args.get('network_security_group')
        vnet_name = args.get('vnet_name')
        subnet_name = args.get('subnet_name')
        ip_config_name = args.get('ip_config_name')
        subnet_id = (f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers/Microsoft.Network/"
                     f"virtualNetworks/{vnet_name}/subnets/{subnet_name}")

        # Construct NIC object
        nic = {
            'location': location,
            'properties': {
                'ipConfigurations': [
                    {
                        'name': ip_config_name,
                        'properties': {
                            'privateIPAllocationMethod': address_assignment_method,
                            'subnet': {
                                'id': subnet_id
                            }
                        }
                    }
                ]
            }
        }

        if address_assignment_method == "Static":
            if not private_ip_address:
                err_msg = 'You have chosen to assign a "Static" IP address value to the interface, ' \
                          'so you must enter a value for the "private_ip_address" argument.'
                raise Exception(err_msg)
            nic['properties']['ipConfigurations'][0]['properties']['privateIPAddress'] = private_ip_address

        if network_security_group:
            network_security_group_id = (f"/subscriptions/{subscription_id}/resourceGroups/{resource_group}/providers"
                                         f"/Microsoft.Network/networkSecurityGroups/{network_security_group}")
            nic['properties']['networkSecurityGroup']['id'] = network_security_group_id

        return nic


    def get_single_ip_details_from_list_of_ip_details(list_of_ip_details: list, ip_address):
        """Finds the associated details of target IP Address from a list of PublicIPAddressListResult objects.

        Args:
            list_of_ip_details (list):  List of PublicIPAddressListResult objects.
            ip_address (list | dict): IP Address to search for in list of PublicIPAddressListResult objects.
        """
        def search_entry_for_ip(data, key, value):
            if isinstance(data, list):
                for item in data:
                    result = search_entry_for_ip(item, key, value)
                    if result:
                        return result
            elif isinstance(data, dict):
                if key in data and data[key] == value:
                    return True
                for val in data.values():
                    result = search_entry_for_ip(val, key, value)
                    if result:
                        return result
            return None

        for entry in list_of_ip_details:
            result = search_entry_for_ip(entry, "ipAddress", ip_address)
            if result:
                return entry
        return None


    class MsGraphClient:
        """
          Microsoft Graph Client enables authorized access to Create and Manage Azure Virtual Machines.
          """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy, self_deployed, ok_codes, server,
                     subscription_id, certificate_thumbprint, private_key):

            self.ms_client = MicrosoftClient(
                tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name, base_url=base_url, verify=verify,
                proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes, scope=Scopes.management_azure,
                certificate_thumbprint=certificate_thumbprint, private_key=private_key,
                command_prefix="azure-vm",
            )

            self.server = server
            self.subscription_id = subscription_id
            self.default_params = {"api-version": API_VERSION}

        def list_resource_groups(self, limit: int, tag: str = '', full_url: Optional[str] = ''):
            filter_by_tag = azure_tag_formatter(tag) if tag else None
            parameters = {'$filter': filter_by_tag, '$top': limit, 'api-version': '2021-04-01'} if not full_url else {}
            return self.ms_client.http_request(method='GET', params=parameters, url_suffix='', full_url=full_url)

        def list_subscriptions(self):
            parameters = {'api-version': '2020-01-01'}
            url = self.server + '/subscriptions'
            return self.ms_client.http_request(method='GET', full_url=url, params=parameters, url_suffix='')

        def list_vms(self, resource_group):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines"

            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params=self.default_params)

        def get_vm(self, resource_group, vm_name, expand='instanceView'):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"
            parameters = {'$expand': expand} | self.default_params
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params=parameters)

        def create_vm(self, args, resource_group):
            # Retrieve relevant command argument
            vm_name = args.get('virtual_machine_name')

            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"

            # Construct VM object utilizing parameters passed as command arguments
            payload = create_vm_parameters(args, self.subscription_id, resource_group)
            return self.ms_client.http_request(method='PUT', url_suffix=url_suffix, params=self.default_params, json_data=payload)

        def delete_vm(self, resource_group, vm_name):
            # Construct endpoint URI suffix (for de-allocation of compute resources)
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/deallocate"

            # Call API to deallocate compute resources
            self.ms_client.http_request(method='POST', url_suffix=url_suffix, params=self.default_params, resp_type="response")

            # Construct endpoint URI suffix (for deletion)
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"

            # Call API to delete
            return self.ms_client.http_request(
                method='DELETE', url_suffix=url_suffix, params=self.default_params, resp_type="response")

        def start_vm(self, resource_group, vm_name):
            # Retrieve relevant command arguments
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/start"

            # Call API
            return self.ms_client.http_request(
                method='POST', url_suffix=url_suffix, params=self.default_params, resp_type="response")

        def poweroff_vm(self, resource_group, vm_name, skip_shutdown):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/powerOff"
            parameters = {'skipShutdown': skip_shutdown} | self.default_params

            return self.ms_client.http_request(
                method='POST', url_suffix=url_suffix, params=parameters, resp_type="response")

        def get_all_public_ip_details(self):
            """
            List all public IPs belonging to your Azure subscription

            Returns:
                List of PublicIPAddressListResult Objects

            Docs:
                https://learn.microsoft.com/en-us/rest/api/virtualnetwork/public-ip-addresses/list-all?tabs=HTTP
            """
            url_suffix = "/providers/Microsoft.Network/publicIPAddresses"
            parameters = {'api-version': '2022-09-01'}
            base_url = f"{self.server}/subscriptions/{self.subscription_id}"
            self.ms_client._base_url = base_url
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params=parameters)

        def validate_provisioning_state(self, resource_group, vm_name):
            """
            Ensure that the provisioning state of a VM is 'Succeeded'

            For all provisioning states other than 'Succeeded', this method will raise an
            exception with an informative error message.

            parameter: (dict) args
                The command arguments passed to either the `azure-vm-start-instance` or
                `azure-vm-poweroff-instance` commands

            returns:
                None
            """
            response = self.get_vm(resource_group, vm_name)
            # Retrieve relevant properties for checking provisioning state and returning
            # informative error messages if necessary

            properties = response.get('properties')
            provisioning_state = properties.get('provisioningState')
            statuses = properties.get('instanceView', {}).get('statuses')

            # Check if the current ProvisioningState of the VM allows for executing this command
            if provisioning_state.lower() == 'failed':
                for status in statuses:
                    status_code = status.get('code')
                    if 'provisioningstate/failed' in status_code.lower():
                        message = status.get('message')
                        err_msg = PROVISIONING_STATE_TO_ERRORS.get('failed')
                        raise Exception(err_msg.format(vm_name, status_code, message))  # type: ignore
                # In the case that the microsoft API changes and the status code is no longer
                # relevant, preventing the above exception with its detailed error message from
                # being raised, then raise the below exception with a more general error message
                err_msg = 'Cannot execute this command because the ProvisioningState of the VM is \'Failed\'.'
                raise Exception(err_msg)
            elif provisioning_state.lower() in PROVISIONING_STATE_TO_ERRORS:
                err_msg = PROVISIONING_STATE_TO_ERRORS.get(provisioning_state.lower())
                raise Exception(err_msg)

        def get_network_interface(self, resource_group, interface_name):
            url_suffix = f"{resource_group}/providers/Microsoft.Network/networkInterfaces/{interface_name}"
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params={"api-version": '2023-05-01'})

        def get_public_ip_details(self, resource_group, address_name):
            url_suffix = f"{resource_group}/providers/Microsoft.Network/publicIPAddresses/{address_name}"
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params={"api-version": '2023-05-01'})

        def create_nic(self, resource_group, args):
            # Retrieve relevant command argument
            nic_name = args.get('nic_name')
            url_suffix = f"{resource_group}/providers/Microsoft.Network/networkInterfaces/{nic_name}"

            # Construct VM object utilizing parameters passed as command arguments
            payload = create_nic_parameters(resource_group, self.subscription_id, args)
            return self.ms_client.http_request(
                method='PUT',
                url_suffix=url_suffix,
                params={'api-version': '2023-05-01'},
                json_data=payload
            )


    def test_module(client: MsGraphClient):
        # Implicitly will test tenant, enc_token and subscription_id
        client.list_resource_groups(1)
        return 'ok'


    # <-------- Resource Groups --------> #

    def list_resource_groups_command(client: MsGraphClient, args: dict):
        """
        List all Resource Groups belonging to your Azure subscription

        returns:
            Resource-Group Objects
        """
        tag = args.get('tag', '')
        limit = arg_to_number(args.get('limit')) or DEFAULT_LIMIT

        resource_groups: List[dict] = []

        next_link = True
        while next_link and len(resource_groups) < limit:
            full_url = next_link if isinstance(next_link, str) else None
            response = client.list_resource_groups(limit, tag, full_url=full_url)
            # Retrieve relevant properties to return to context
            value = response.get('value')
            next_link = response.get('nextLink')

            for resource_group in value:
                resource_group_context = {
                    'Name': resource_group.get('name'),
                    'ID': resource_group.get('id'),
                    'Location': resource_group.get('location'),
                    'ProvisioningState': resource_group.get('properties', {}).get('provisioningState')
                }
                resource_groups.append(resource_group_context)

        resource_groups = resource_groups[:limit]
        title = 'List of Resource Groups'
        human_readable = tableToMarkdown(title, resource_groups, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.ResourceGroup',
            outputs_key_field='Name',
            outputs=resource_groups,
            readable_output=human_readable,
            raw_response=response
        )


    # <-------- Subscriptions --------> #

    def list_subscriptions_command(client: MsGraphClient):
        """
        List all subscriptions for this application

        returns:
            Subscription Objects
        """
        response = client.list_subscriptions()
        # Retrieve relevant properties to return to context
        value = response.get('value')
        subscriptions = []
        for subscription in value:
            subscription_context = {
                'Name': subscription.get('displayName'),
                'ID': subscription.get('id'),
                'State': subscription.get('state')
            }
            subscriptions.append(subscription_context)

        title = 'List of Subscriptions'
        human_readable = tableToMarkdown(title, subscriptions, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Subscription',
            outputs_key_field='ID',
            outputs=subscriptions,
            readable_output=human_readable,
            raw_response=response
        )


    # <-------- Virtual Machines --------> #

    def list_vms_command(client: MsGraphClient, args: dict, params: dict):
        """
        List the VM instances in the specified Resource Group

        demisto parameter: (string) resource_group
            Resource Group of the VMs

        returns:
            Virtual Machine Objects
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        response = client.list_vms(resource_group)

        vm_objects_list = response.get('value')

        vms = []
        for vm_object in vm_objects_list:
            vm_name = vm_object.get('name').lower()
            location = vm_object.get('location')
            properties = vm_object.get('properties')
            provisioning_state = properties.get('provisioningState')
            os_disk = properties.get('storageProfile', {}).get('osDisk')
            datadisk = os_disk.get('diskSizeGB', 'NA')
            vm_id = properties.get('vmId')
            os_type = os_disk.get('osType')
            vm = {
                'Name': vm_name,
                'ID': vm_id,
                'Size': datadisk,
                'OS': os_type,
                'Location': location,
                'ProvisioningState': provisioning_state,
                'ResourceGroup': resource_group
            }
            vms.append(vm)

        title = f'Microsoft Azure - List of Virtual Machines in Resource Group "{resource_group}"'
        table_headers = ['Name', 'ID', 'Size', 'OS', 'Location', 'ProvisioningState', 'ResourceGroup']
        human_readable = tableToMarkdown(title, vms, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Compute',
            outputs_key_field='Name',
            outputs=vms,
            readable_output=human_readable,
            raw_response=response
        )


    def get_vm_command(client: MsGraphClient, args: dict, params: dict):
        """
        Get the properties of a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine you wish to view the details of

        returns:
            Virtual Machine Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        vm_name = args.get('virtual_machine_name')
        expand = args.get('expand', '')
        response = client.get_vm(resource_group, vm_name, expand)
        # Retrieve relevant properties to return to context
        vm_name = vm_name.lower()  # type: ignore
        properties = response.get('properties')
        os_disk = properties.get('storageProfile', {}).get('osDisk')
        datadisk = os_disk.get('diskSizeGB', 'NA')
        vm_id = properties.get('vmId')
        os_type = os_disk.get('osType')
        provisioning_state = properties.get('provisioningState')
        location = response.get('location')
        user_data = properties.get('userData')
        network_interfaces = properties.get('networkProfile', {}).get('networkInterfaces')
        statuses = properties.get('instanceView', {}).get('statuses', [])
        power_state = None
        for status in statuses:
            status_code = status.get('code')
            status_code_prefix = status_code[:status_code.find('/')]
            if status_code_prefix == 'PowerState':
                power_state = status.get('displayStatus')

        vm = {
            'Name': vm_name,
            'ID': vm_id,
            'Size': datadisk,
            'OS': os_type,
            'ProvisioningState': provisioning_state,
            'Location': location,
            'PowerState': power_state,
            'ResourceGroup': resource_group,
            'NetworkInterfaces': network_interfaces,
            'UserData': user_data
        }

        title = f'Properties of VM "{vm_name}"'
        table_headers = ['Name', 'ID', 'Size', 'OS', 'ProvisioningState', 'Location', 'PowerState']
        human_readable = tableToMarkdown(title, vm, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Compute',
            outputs_key_field='Name',
            outputs=vm,
            readable_output=human_readable,
            raw_response=response
        )


    def create_vm_command(client: MsGraphClient, args: dict, params: dict):
        """
        Create a virtual machine instance with the specified OS image

        demisto parameter: (string) resource_group
            Resource group to which the new VM will belong

        demisto parameter: (string) virtual_machine_name
            Name to assign to the new virtual machine

        demisto parameter: (string) virtual_machine_location
            Region in which the vm will be hosted

        demisto parameter: (string) nic_name
            The name of the Network Interface to link the VM with. This must be created from the Azure Portal

        demisto parameter: (string) vm_size
            The name of a VirtualMachineSize which determines the size of the deployed vm

        demisto parameter: (string) os_image
            Choose the base operating system image of the vm

        demisto parameter: (string) sku
            SKU of the image to be used

        demisto parameter: (string) publisher
            Name of the publisher of the image

        demisto parameter: (string) version
            Version of the image to use

        demisto parameter: (string) offer
            Specifies the offer of the platform image or marketplace image used
            to create the virtual machine

        demisto parameter: (string) admin_username
            Admin Username to be used when creating the VM

        demisto parameter: (string) admin_password
            Admin Password to be used when creating the VM

        returns:
            Virtual Machine Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        response = client.create_vm(args, resource_group)

        # Retrieve relevant properties to return to context
        vm_name = response.get('name').lower()
        properties = response.get('properties')
        os_disk = properties.get('storageProfile', {}).get('osDisk')
        datadisk = os_disk.get('diskSizeGB', 'NA')
        vm_id = properties.get('vmId')
        os_type = os_disk.get('osType')
        provisioning_state = properties.get('provisioningState')
        location = response.get('location')

        vm = {
            'Name': vm_name,
            'ID': vm_id,
            'Size': datadisk,
            'OS': os_type,
            'ProvisioningState': provisioning_state,
            'Location': location,
            'ResourceGroup': resource_group
        }

        title = f'Created Virtual Machine "{vm_name}"'
        human_readable = tableToMarkdown(title, vm, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Compute',
            outputs_key_field='Name',
            outputs=vm,
            readable_output=human_readable,
            raw_response=response
        )


    def delete_vm_command(client: MsGraphClient, args: dict, params: dict):
        """
        Delete a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to delete

        returns:
            Success message to the war room
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        vm_name = args.get('virtual_machine_name')

        client.delete_vm(resource_group, vm_name)
        return f'"{vm_name}" VM Deletion Successfully Initiated'


    def start_vm_command(client: MsGraphClient, args: dict, params: dict):
        """
        Power-on a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to power-on

        returns:
            Virtual Machine Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        vm_name = args.get('virtual_machine_name')

        # Raise an exception if the VM isn't in the proper provisioning state
        client.validate_provisioning_state(resource_group, vm_name)

        client.start_vm(resource_group, vm_name)
        vm_name = vm_name.lower()   # type: ignore
        vm = {
            'Name': vm_name,
            'ResourceGroup': resource_group,
            'PowerState': 'VM starting'
        }

        title = f'Power-on of Virtual Machine "{vm_name}" Successfully Initiated'
        human_readable = tableToMarkdown(title, vm, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Compute',
            outputs_key_field='Name',
            outputs=vm,
            readable_output=human_readable,
            raw_response=vm
        )


    def poweroff_vm_command(client: MsGraphClient, args: dict, params: dict):
        """
        Power-off a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to power-off

        returns:
            Virtual Machine Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        vm_name = args.get('virtual_machine_name')
        skip_shutdown = argToBoolean(args.get('skip_shutdown', False))

        # Raise an exception if the VM isn't in the proper provisioning state
        client.validate_provisioning_state(resource_group, vm_name)

        client.poweroff_vm(resource_group, vm_name, skip_shutdown)

        vm_name = vm_name.lower()   # type: ignore
        vm = {
            'Name': vm_name,
            'ResourceGroup': resource_group,
            'PowerState': 'VM stopping'
        }

        title = f'Power-off of Virtual Machine "{vm_name}" Successfully Initiated'
        human_readable = tableToMarkdown(title, vm, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Compute',
            outputs_key_field='Name',
            outputs=vm,
            readable_output=human_readable,
            raw_response=vm
        )


    def get_network_interface_command(client: MsGraphClient, args: dict, params: dict):
        """
        Get the properties of a specified Network Interface

        demisto parameter: (string) resource_group
            Resource Group to which the network interface belongs

        demisto parameter: (string) nic_name
            Name of the network interface you wish to view the details of

        returns:
            Network Interface Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        interface_name = args.get('nic_name')
        response = client.get_network_interface(resource_group, interface_name)
        interface_name = interface_name.lower()  # type: ignore
        properties = response.get('properties')
        interface_id = response.get('id')
        mac_address = properties.get('macAddress', 'NA')
        network_security_group = properties.get('networkSecurityGroup', 'NA')
        is_primay_interface = properties.get('primary', 'NA')
        attached_virtual_machine = properties.get('virtualMachine', {}).get('id', 'NA')
        nic_type = properties.get('nicType', 'NA')
        location = response.get('location')
        dns_suffix = properties.get('dnsSettings', {}).get('internalDomainNameSuffix')

        ip_configurations = properties.get('ipConfigurations', [])

        ip_configs = []

        for ip_configuration in ip_configurations:
            ip_configs.append({
                "ConfigName": ip_configuration.get('name', "NA"),
                "ConfigID": ip_configuration.get('id', "NA"),
                "PrivateIPAddress": ip_configuration.get('properties', {}).get('privateIPAddress', "NA"),
                "PublicIPAddressID": ip_configuration.get('properties', {}).get('publicIPAddress', {}).get('id')
            })

        network_config = {
            'Name': interface_name,
            'ID': interface_id,
            'MACAddress': mac_address,
            'NetworkSecurityGroup': network_security_group,
            'IsPrimaryInterface': is_primay_interface,
            'Location': location,
            'AttachedVirtualMachine': attached_virtual_machine,
            'ResourceGroup': resource_group,
            'NICType': nic_type,
            'DNSSuffix': dns_suffix,
            'IPConfigurations': ip_configs
        }

        human_readable_network_config = {
            'Name': interface_name,
            'ID': interface_id,
            'MACAddress': mac_address,
            'PrivateIPAddresses': [ip.get("PrivateIPAddress") for ip in ip_configs],
            'NetworkSecurityGroup': network_security_group,
            'Location': location,
            'NICType': nic_type,
            'AttachedVirtualMachine': attached_virtual_machine
        }

        title = f'Properties of Network Interface "{interface_name}"'
        table_headers = ['Name', 'ID', 'MACAddress', 'PrivateIPAddresses', 'NetworkSecurityGroup',
                         'Location', 'NICType', 'AttachedVirtualMachine']
        human_readable = tableToMarkdown(title, human_readable_network_config, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Network.Interfaces',
            outputs_key_field='ID',
            outputs=network_config,
            readable_output=human_readable,
            raw_response=response
        )


    def get_public_ip_details_command(client: MsGraphClient, args: dict, params: dict):
        """
        Get the properties of a specified Public IP Address

        demisto parameter: (string) resource_group
            Resource Group to which the public IP address belongs

        demisto parameter: (string) address_name
            The IPv4 or Name of the public ip address you wish to view the details of.

        returns:
            Public IP Address Object
        """
        address_name = args.get('address_name')
        if resource_group := (args.get('resource_group') or params.get('resource_group')):
            response = client.get_public_ip_details(resource_group, address_name)
            address_id = response.get('id')
        else:
            response_for_all_ips = client.get_all_public_ip_details().get('value')
            response = get_single_ip_details_from_list_of_ip_details(response_for_all_ips, address_name)
            if not response:
                raise ValueError(f"'{address_name}' was not found. "
                                 "Please try specifying the resource group the IP would be associated with.")
            address_id = response.get('id')
            resource_group = address_id.split('resourceGroups/')[1].split('/providers')[0]

        # Retrieve relevant properties to return to context
        properties = response.get('properties')
        config_id = properties.get('ipConfiguration', {}).get('id')
        ip_address = properties.get('ipAddress', 'NA')
        ip_address_version = properties.get('publicIPAddressVersion', 'NA')
        ip_address_allocation_method = properties.get('publicIPAllocationMethod', 'NA')
        address_domain_name = properties.get('dnsSettings', {}).get('domainNameLabel', 'NA')
        address_fqdn = properties.get('dnsSettings', {}).get('fqdn', 'NA')
        config_name = response.get('name')
        location = response.get('location')

        ip_config = {
            'PublicIPAddressID': address_id,
            'PublicConfigName': config_name,
            'Location': location,
            'PublicConfigID': config_id,
            'ResourceGroup': resource_group,
            'PublicIPAddress': ip_address,
            'PublicIPAddressVersion': ip_address_version,
            'PublicIPAddressAllocationMethod': ip_address_allocation_method,
            'PublicIPAddressDomainName': address_domain_name,
            'PublicIPAddressFQDN': address_fqdn,
        }

        human_readable_ip_config = {
            'PublicConfigName': config_name,
            'Location': location,
            'PublicIPAddress': ip_address,
            'PublicIPAddressVersion': ip_address_version,
            'PublicIPAddressAllocationMethod': ip_address_allocation_method,
            "ResourceGroup": resource_group
        }

        title = f'Properties of Public Address "{address_name}"'
        table_headers = ['PublicConfigName', 'Location', 'PublicIPAddress', 'PublicIPAddressVersion',
                         'PublicIPAddressAllocationMethod', 'ResourceGroup']
        human_readable = tableToMarkdown(title, human_readable_ip_config, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Network.IPConfigurations',
            outputs_key_field='PublicIPAddressID',
            outputs=ip_config,
            readable_output=human_readable,
            raw_response=response
        )


    def get_all_public_ip_details_command(client: MsGraphClient):
        """
        Get the properties of all Public IP Addresses in the configured subscription

        returns:
            List of Public IP Address Objects
        """
        response = client.get_all_public_ip_details()

        ip_objects_list = response.get('value', [])

        ips = []

        for ip_object in ip_objects_list:
            # Retrieve relevant properties to return to context
            properties = ip_object.get('properties', {})
            address_id = ip_object.get('id', '')
            config_id = properties.get('ipConfiguration', {}).get('id', '')
            ip_address = properties.get('ipAddress', 'NA')
            ip_address_version = properties.get('publicIPAddressVersion', 'NA')
            ip_address_allocation_method = properties.get('publicIPAllocationMethod', 'NA')
            address_domain_name = properties.get('dnsSettings', {}).get('domainNameLabel', 'NA')
            address_fqdn = properties.get('dnsSettings', {}).get('fqdn', 'NA')
            config_name = ip_object.get('name')
            location = ip_object.get('location')
            resource_group = address_id.split('resourceGroups/')[1].split('/providers')[0]
            ip_config = {
                'PublicIPAddressID': address_id,
                'PublicConfigName': config_name,
                'Location': location,
                'PublicConfigID': config_id,
                'ResourceGroup': resource_group,
                'PublicIPAddress': ip_address,
                'PublicIPAddressVersion': ip_address_version,
                'PublicIPAddressAllocationMethod': ip_address_allocation_method,
                'PublicIPAddressDomainName': address_domain_name,
                'PublicIPAddressFQDN': address_fqdn,
            }
            ips.append(ip_config)

        title = f'Microsoft Azure - List of Virtual Machines in Subscription "{client.subscription_id}"'
        table_headers = ['PublicConfigName', 'Location', 'PublicIPAddress', 'PublicIPAddressVersion',
                         'PublicIPAddressAllocationMethod']
        human_readable = tableToMarkdown(title, ips, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Network.IPConfigurations',
            outputs_key_field='PublicIPAddressID',
            outputs=ips,
            readable_output=human_readable,
            raw_response=response
        )


    def create_nic_command(client: MsGraphClient, args: dict, params: dict):
        """
        Create a Network Interface with the specified interface parameters

        demisto parameter: (string) resource_group
            The resource group to which the new network interface will belong.

        demisto parameter: (string) nic_name
            The network interface name.

        demisto parameter: (string) nic_location
            The location in which to create the network interface.

        demisto parameter: (string) vnet_name
            The virtual network name of the inteface.

        demisto parameter: (string) subnet_name
            The subnet name of the inteface.

        demisto parameter: (string) address_assignment_method
             The address assignment method, the default is Dynamic.

        demisto parameter: (string) private_ip_address
            The private ip address of the interface incase you chose to use the static assignment method.

        demisto parameter: (string) ip_config_name
            The ip address config name.

        demisto parameter: (string) network_security_group
            The network security group of the interface.

        returns:
            Network Interface Object
        """
        resource_group = get_from_args_or_params(args=args, params=params, key='resource_group')
        response = client.create_nic(resource_group, args)

        # Retrieve relevant properties to return to context
        nic_name = response.get('name').lower()
        nic_id = response.get('id')
        location = response.get('location')
        properties = response.get('properties')
        network_security_group = properties.get('networkSecurityGroup', {}).get('id', 'NA')
        provisioning_state = properties.get('provisioningState', "NA")
        ip_configurations = properties.get('ipConfigurations', [])
        dns_suffix = properties.get('dnsSettings', {}).get('internalDomainNameSuffix')

        ip_configs = []
        for ip_configuration in ip_configurations:
            ip_configs.append({
                "ConfigName": ip_configuration.get('name', "NA"),
                "ConfigID": ip_configuration.get('id', "NA"),
                "PrivateIPAddress": ip_configuration.get('properties', {}).get('privateIPAddress', "NA"),
                "PublicIPAddressID": ip_configuration.get('properties', {}).get('publicIPAddress', {}).get('id', "NA"),
                "SubNet": ip_configuration.get('properties', {}).get('subnet', {}).get('id', "NA"),
            })

        nic = {
            'Name': nic_name,
            'ID': nic_id,
            'IPConfigurations': ip_configs,
            'ProvisioningState': provisioning_state,
            'Location': location,
            'ResourceGroup': resource_group,
            'NetworkSecurityGroup': network_security_group,
            'DNSSuffix': dns_suffix
        }

        human_readable_nic = {
            'Name': nic_name,
            'ID': nic_id,
            'PrivateIPAddresses': [ip.get("PrivateIPAddress") for ip in ip_configs],
            'NetworkSecurityGroup': network_security_group,
            'Location': location
        }

        title = f'Created Network Interface "{nic_name}"'
        table_headers = ['Name', 'ID', 'PrivateIPAddresses', 'NetworkSecurityGroup', 'Location']
        human_readable = tableToMarkdown(title, human_readable_nic, headers=table_headers, removeNull=True)

        return CommandResults(
            outputs_prefix='Azure.Network.Interfaces',
            outputs_key_field=['ID', 'Name'],
            outputs=nic,
            readable_output=human_readable,
            raw_response=response
        )


    def main():
        params: dict = demisto.params()
        args = demisto.args()
        server = params.get('host', 'https://management.azure.com').rstrip('/')
        tenant = params.get('cred_token', {}).get('password') or params.get('tenant_id')
        auth_and_token_url = params.get('cred_auth_id', {}).get('password') or params.get('auth_id')
        if not tenant or not auth_and_token_url:
            return_error('Token and ID must be provided.')
        enc_key = params.get('cred_enc_key', {}).get('password') or params.get('enc_key')
        certificate_thumbprint = params.get('cred_certificate_thumbprint', {}).get(
            'password') or params.get('certificate_thumbprint')
        private_key = params.get('private_key')
        verify = not params.get('unsecure', False)
        subscription_id = args.get('subscription_id') or params.get(
            'cred_subscription_id', {}).get('password') or params.get('subscription_id')
        proxy: bool = params.get('proxy', False)
        self_deployed: bool = params.get('self_deployed', False)
        if not self_deployed and not enc_key:
            raise DemistoException('Key must be provided. For further information see '
                                   'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')
        elif not enc_key and not (certificate_thumbprint and private_key):
            raise DemistoException('Key or Certificate Thumbprint and Private Key must be providedFor further information see '
                                   'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')
        ok_codes = (200, 201, 202, 204)

        commands_without_args = {
            'test-module': test_module,
            'azure-list-subscriptions': list_subscriptions_command,
            'azure-vm-get-all-public-ip-details': get_all_public_ip_details_command
        }

        commands_with_args = {
            'azure-list-resource-groups': list_resource_groups_command
        }

        commands_with_args_and_params = {
            'azure-vm-list-instances': list_vms_command,
            'azure-vm-get-instance-details': get_vm_command,
            'azure-vm-start-instance': start_vm_command,
            'azure-vm-poweroff-instance': poweroff_vm_command,
            'azure-vm-create-instance': create_vm_command,
            'azure-vm-delete-instance': delete_vm_command,
            'azure-vm-get-public-ip-details': get_public_ip_details_command,
            'azure-vm-create-nic': create_nic_command,
            'azure-vm-get-nic-details': get_network_interface_command
        }

        '''EXECUTION'''
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            # Initial setup
            if not subscription_id:
                return_error('A subscription ID must be provided.')
            base_url = f"{server}/subscriptions/{subscription_id}/resourceGroups/"

            client = MsGraphClient(
                base_url=base_url, tenant_id=tenant, auth_id=auth_and_token_url, enc_key=enc_key, app_name=APP_NAME,
                verify=verify, proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes, server=server,
                subscription_id=subscription_id, certificate_thumbprint=certificate_thumbprint,
                private_key=private_key)

            if command == 'azure-vm-auth-reset':
                return_results(reset_auth())

            elif command in commands_without_args:
                return_results(commands_without_args[command](client))

            elif command in commands_with_args:
                return_results(commands_with_args[command](client, args))

            elif command in commands_with_args_and_params:
                return_results(commands_with_args_and_params[command](client, args, params))

        except Exception as e:
            screened_error_message = screen_errors(str(e), tenant)
            return_error(screened_error_message)


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Azure Compute v2', 'end', __line__())
  subtype: python3
  type: python
system: true
