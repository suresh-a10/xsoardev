category: IT Services
commonfields:
  id: AWS - S3
  version: -1
configuration:
- display: Role Arn
  name: roleArn
  required: false
  section: Connect
  type: 0
- display: Role Session Name
  name: roleSessionName
  required: false
  section: Connect
  type: 0
- advanced: true
  display: AWS Default Region
  name: defaultRegion
  options:
  - us-east-1
  - us-east-2
  - us-west-1
  - us-west-2
  - ca-central-1
  - eu-west-1
  - eu-central-1
  - eu-west-2
  - ap-northeast-1
  - ap-northeast-2
  - ap-southeast-1
  - ap-southeast-2
  - ap-south-1
  - sa-east-1
  - eu-north-1
  - eu-west-3
  - us-gov-east-1
  - us-gov-west-1
  required: true
  section: Connect
  type: 15
- advanced: true
  display: Role Session Duration
  name: sessionDuration
  required: false
  section: Connect
  type: 0
- display: Access Key
  displaypassword: Secret Key
  name: credentials
  required: false
  section: Connect
  type: 9
- display: Access Key
  hidden: true
  name: access_key
  required: false
  section: Connect
  type: 0
- display: Secret Key
  hidden: true
  name: secret_key
  required: false
  section: Connect
  type: 4
- additionalinfo: The time in seconds till a timeout exception is reached. You can
    specify just the read timeout (for example 60) or also the connect timeout followed
    after a comma (for example 60,10). If a connect timeout is not specified, a default
    of 10 second will be used.
  advanced: true
  defaultvalue: 60,10
  display: Timeout
  name: timeout
  required: false
  section: Connect
  type: 0
- additionalinfo: 'The maximum number of retry attempts when connection or throttling
    errors are encountered. Set to 0 to disable retries. The default value is 5 and
    the limit is 10. Note: Increasing the number of retries will increase the execution
    time.'
  advanced: true
  defaultvalue: "5"
  display: Retries
  name: retries
  required: false
  section: Connect
  type: 0
- advanced: true
  display: PrivateLink service URL.
  name: endpoint_url
  required: false
  section: Connect
  type: 0
- advanced: true
  display: STS PrivateLink URL.
  name: sts_endpoint_url
  required: false
  section: Connect
  type: 0
- additionalinfo: Sets the AWS_STS_REGIONAL_ENDPOINTS environment variable to specify
    the AWS STS endpoint resolution logic. By default, this option is set to “legacy”
    in AWS. Leave empty if the environment variable is already set using server configuration.
  display: AWS STS Regional Endpoints
  name: sts_regional_endpoint
  options:
  - legacy
  - regional
  required: false
  section: Connect
  type: 15
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.2.25
    packID: AWS-S3
    packName: AWS - S3
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Amazon Web Services Simple Storage Service (S3).
detaileddescription: "Before you can use AWS S3, you need to perform several configuration
  steps in your AWS environment.\n\n### Prerequisites\n- Attach an instance profile
  with the required permissions to the Cortex XSOAR server or engine that is running
  \non your AWS environment.\n- Instance profile requires minimum permission: sts:AssumeRole.\n-
  Instance profile requires permission to assume the roles needed by the AWS integrations.\n\n###
  Configure AWS Settings\n- Create an IAM Role for the Instance Profile.\n- Attach
  a Role to the Instance Profile.\n- Configure the Necessary IAM Roles that the AWS
  Integration Can Assume.\n\nFor detailed instructions, see the [AWS Integrations
  - Authentication](https://xsoar.pan.dev/docs/reference/articles/aws-integrations---authentication).\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/aws---s3)"
display: AWS - S3
image: data:image/png;base64,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
name: AWS - S3
script:
  commands:
  - arguments:
    - description: The name of S3 bucket to create (in lowercase).
      name: bucket
      required: true
    - auto: PREDEFINED
      description: ACL for S3 bucket.
      name: acl
      predefined:
      - private
      - public-read
      - public-read-write
      - authenticated-read
    - description: Specifies the region where the bucket will be created. If you don't
        specify a region, the bucket will be created in US Standard.
      name: locationConstraint
    - description: Allows grantee the read, write, read ACP, and write ACP permissions
        on the bucket.
      name: grantFullControl
    - description: Allows grantee to list the objects in the bucket.
      name: grantRead
    - description: Allows grantee to read the bucket ACL.
      name: grantReadACP
    - description: Allows grantee to create, overwrite, and delete any object in the
        bucket.
      name: grantWrite
    - description: Allows grantee to write the ACL for the applicable bucket.
      name: grantWriteACP
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Create AWS S3 bucket.
    name: aws-s3-create-bucket
    outputs:
    - contextPath: AWS.S3.Buckets.BucketName
      description: The name of the bucket that was created.
      type: string
    - contextPath: AWS.S3.Buckets.Location
      description: The AWS Region the bucket was created.
      type: string
  - arguments:
    - description: Name of S3 bucket to delete.
      name: bucket
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Delete AWS S3 bucket.
    name: aws-s3-delete-bucket
  - arguments:
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: List all S3 buckets in AWS account.
    name: aws-s3-list-buckets
    outputs:
    - contextPath: AWS.S3.Buckets.BucketName
      description: The name of the bucket.
      type: string
    - contextPath: AWS.S3.Buckets.CreationDate
      description: Date the bucket was created.
      type: date
  - arguments:
    - description: Name of bucket.
      name: bucket
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Get AWS S3 Bucket Policy.
    name: aws-s3-get-bucket-policy
    outputs:
    - contextPath: AWS.S3.Buckets.Policy.Version
      description: S3 Bucket Policy Version.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.PolicyId
      description: S3 Bucket Policy ID.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Sid
      description: S3 Bucket Policy Statment ID.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Action
      description: S3 Bucket Policy Statment Action.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Principal
      description: S3 Bucket Policy Statment Principal.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Resource
      description: S3 Bucket Policy Statment Resource.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Effect
      description: S3 Bucket Policy Statment Effect.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.Json
      description: AWS S3 Policy Json output.
      type: string
    - contextPath: AWS.S3.Buckets.Policy.BucketName
      description: S3 Bucket Name.
      type: string
  - arguments:
    - description: Name of S3 bucket.
      name: bucket
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Deletes the policy from the bucket.
    name: aws-s3-delete-bucket-policy
  - arguments:
    - description: The name of S3 bucket.
      name: bucket
    - description: The S3 object key to download.
      name: key
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Download a file from S3 bucket to war room.
    name: aws-s3-download-file
  - arguments:
    - description: The name of S3 bucket.
      name: bucket
      required: true
    - description: A delimiter is a character you use to group keys.
      name: delimiter
    - description: Limits the response to keys that begin with the specified prefix.
      name: prefix
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: List object in S3 bucket.
    name: aws-s3-list-bucket-objects
    outputs:
    - contextPath: AWS.S3.Buckets.Objects.Key
      description: The name of S3 object.
      type: Unknown
    - contextPath: AWS.S3.Buckets.Objects.Size
      description: Object size.
      type: Unknown
    - contextPath: AWS.S3.Buckets.Objects.LastModified
      description: Last date object was modified.
      type: Unknown
  - arguments:
    - description: Name of S3 bucket.
      name: bucket
      required: true
    - description: The bucket policy to apply in json format.
      name: policy
      required: true
    - auto: PREDEFINED
      description: Set this parameter to true to confirm that you want to remove your
        permissions to change this bucket policy in the future.
      name: confirmRemoveSelfBucketAccess
      predefined:
      - "True"
      - "False"
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Replaces a policy on a bucket. If the bucket already has a policy,
      the one in this request completely replaces it.
    name: aws-s3-put-bucket-policy
  - arguments:
    - description: The name of the bucket from which the server-side encryption configuration
        is retrieved.
      name: bucket
      required: true
    - description: The account ID of the exepcted bucket owner.
      name: expectedBucketOwner
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Get AWS S3 Bucket Encryption.
    name: aws-s3-get-bucket-encryption
    outputs:
    - contextPath: AWS.S3.Buckets.BucketName.ServerSideEncryptionConfiguration.Rules.ApplyServerSideEncryptionByDefault.SSEAlgorithm
      description: S3 Bucket Encryption SSE Algorithm.
      type: string
    - contextPath: AWS.S3.Buckets.BucketName.ServerSideEncryptionConfiguration.Rules.ApplyServerSideEncryptionByDefault.KMSMasterKeyID
      description: S3 Bucket Encryption KMS Master Key ID.
      type: string
    - contextPath: AWS.S3.Buckets.BucketName.ServerSideEncryptionConfiguration.Rules.BucketKeyEnabled
      description: S3 Bucket Encryption Key Enabled.
      type: boolean
  - arguments:
    - description: Entry ID of the file to upload.
      name: entryID
      required: true
    - description: The name of the bucket to upload to.
      name: bucket
      required: true
    - description: The name of the key to upload to.
      name: key
      required: true
    - description: The AWS Region, if not specified the default region will be used.
      name: region
    - description: The Amazon Resource Name (ARN) of the role to assume.
      name: roleArn
    - description: An identifier for the assumed role session.
      name: roleSessionName
    - description: The duration, in seconds, of the role session. The value can range
        from 900 seconds (15 minutes) up to the maximum session duration setting for
        the role.
      name: roleSessionDuration
    description: Upload file to S3 bucket.
    name: aws-s3-upload-file
  - arguments:
    - description: The name of the Amazon S3 bucket whose PublicAccessBlock configuration
        you want to retrieve.
      name: bucket
      required: true
    description: Retrieves the PublicAccessBlock configuration for an Amazon S3 bucket.
    name: aws-s3-get-public-access-block
    outputs:
    - contextPath: AWS.S3.Buckets.BucketName.PublicAccessBlockConfiguration.BlockPublicAcls
      description: Specifies whether Amazon S3 should block public access control
        lists (ACLs) for this bucket and objects in this bucket.
      type: Boolean
    - contextPath: AWS.S3.Buckets.BucketName.PublicAccessBlockConfiguration.IgnorePublicAcls
      description: Specifies whether Amazon S3 should ignore public ACLs for this
        bucket and objects in this bucket.
      type: Boolean
    - contextPath: AWS.S3.Buckets.BucketName.PublicAccessBlockConfiguration.BlockPublicPolicy
      description: Specifies whether Amazon S3 should block public bucket policies
        for this bucket.
      type: Boolean
    - contextPath: AWS.S3.Buckets.BucketName.PublicAccessBlockConfiguration.RestrictPublicBuckets
      description: Specifies whether Amazon S3 should restrict public bucket policies
        for this bucket.
      type: Boolean
  - arguments:
    - description: The name of the Amazon S3 bucket whose PublicAccessBlock configuration
        you want to retrieve.
      name: bucket
      required: true
    - description: Specifies whether Amazon S3 should block public access control
        lists (ACLs) for this bucket and objects in this bucket.
      name: BlockPublicAcls
      required: true
    - description: Specifies whether Amazon S3 should ignore public ACLs for this
        bucket and objects in this bucket.
      name: IgnorePublicAcls
      required: true
    - description: Specifies whether Amazon S3 should block public bucket policies
        for this bucket.
      name: BlockPublicPolicy
      required: true
    - description: Specifies whether Amazon S3 should restrict public bucket policies
        for this bucket.
      name: RestrictPublicBuckets
      required: true
    description: Creates or modifies the PublicAccessBlock configuration for an Amazon
      S3 bucket.
    name: aws-s3-put-public-access-block
  dockerimage: demisto/boto3py3:1.0.0.100496
  runonce: false
  script: |
    register_module_line('AWS - S3', 'start', __line__())
    ### pack version: 1.2.25


    import io
    import math
    import json
    from datetime import datetime, date
    import urllib3.util

    ### GENERATED CODE ###: from AWSApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('AWSApiModule', 'start', __line__(), wrapper=-3)


    import boto3
    from botocore.config import Config


    def validate_params(aws_default_region, aws_role_arn, aws_role_session_name, aws_access_key_id, aws_secret_access_key):
        """
        Validates that the provided parameters are compatible with the appropriate authentication method.
        """
        if not aws_default_region:
            raise DemistoException('You must specify AWS default region.')

        if bool(aws_access_key_id) != bool(aws_secret_access_key):
            raise DemistoException('You must provide Access Key id and Secret key id to configure the instance with '
                                   'credentials.')
        if bool(aws_role_arn) != bool(aws_role_session_name):
            raise DemistoException('Role session name is required when using role ARN.')


    def extract_session_from_secret(secret_key, session_token):
        """
        Extract the session token from the secret_key field.
        """
        if secret_key and '@@@' in secret_key and not session_token:
            return secret_key.split('@@@')[0], secret_key.split('@@@')[1]
        else:
            return secret_key, session_token


    class AWSClient:

        def __init__(self, aws_default_region, aws_role_arn, aws_role_session_name, aws_role_session_duration,
                     aws_role_policy, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout, retries,
                     aws_session_token=None, sts_endpoint_url=None, endpoint_url=None):

            self.sts_endpoint_url = sts_endpoint_url
            self.endpoint_url = endpoint_url
            self.aws_default_region = aws_default_region
            self.aws_role_arn = aws_role_arn
            self.aws_role_session_name = aws_role_session_name
            # handle cases where aws_role_session_duration can be also empty string
            self.aws_role_session_duration = aws_role_session_duration if aws_role_session_duration else None
            self.aws_role_policy = aws_role_policy
            self.aws_access_key_id = aws_access_key_id
            self.aws_secret_access_key, self.aws_session_token = extract_session_from_secret(aws_secret_access_key, aws_session_token)
            self.verify_certificate = verify_certificate

            sts_regional_endpoint = demisto.params().get("sts_regional_endpoint") or None
            if sts_regional_endpoint:
                demisto.debug(f"Sets the environment variable AWS_STS_REGIONAL_ENDPOINTS={sts_regional_endpoint}")
                os.environ["AWS_STS_REGIONAL_ENDPOINTS"] = sts_regional_endpoint.lower()

            proxies = handle_proxy(proxy_param_name='proxy', checkbox_default_value=False)
            (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
            if int(retries) > 10:
                retries = 10
            self.config = Config(
                connect_timeout=connect_timeout,
                read_timeout=read_timeout,
                retries=dict(
                    max_attempts=int(retries)
                ),
                proxies=proxies
            )

        def update_config(self):
            command_config = {}
            retries = demisto.getArg('retries')  # Supports retries and timeout parameters on the command execution level
            if retries is not None:
                command_config['retries'] = dict(max_attempts=int(retries))
            timeout = demisto.getArg('timeout')
            if timeout is not None:
                (read_timeout, connect_timeout) = AWSClient.get_timeout(timeout)
                command_config['read_timeout'] = read_timeout
                command_config['connect_timeout'] = connect_timeout
            if retries or timeout:
                demisto.debug('Merging client config settings: {}'.format(command_config))
                self.config = self.config.merge(Config(**command_config))  # type: ignore[arg-type]

        def aws_session(self, service, region=None, role_arn=None, role_session_name=None, role_session_duration=None,
                        role_policy=None):
            kwargs = {}

            self.update_config()

            if role_arn and role_session_name is not None:
                kwargs.update({
                    'RoleArn': role_arn,
                    'RoleSessionName': role_session_name,
                })
            elif self.aws_role_arn and self.aws_role_session_name is not None:
                kwargs.update({
                    'RoleArn': self.aws_role_arn,
                    'RoleSessionName': self.aws_role_session_name,
                })

            if role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(role_session_duration)})
            elif self.aws_role_session_duration is not None:
                kwargs.update({'DurationSeconds': int(self.aws_role_session_duration)})

            if role_policy is not None:
                kwargs.update({'Policy': role_policy})
            elif self.aws_role_policy is not None:
                kwargs.update({'Policy': self.aws_role_policy})

            demisto.debug('{kwargs}='.format(kwargs=kwargs))

            if kwargs and not self.aws_access_key_id:  # login with Role ARN
                if not self.aws_access_key_id:
                    sts_client = boto3.client('sts', config=self.config, verify=self.verify_certificate,
                                              region_name=region if region else self.aws_default_region,
                                              endpoint_url=self.sts_endpoint_url)
                    sts_response = sts_client.assume_role(**kwargs)
                    client = boto3.client(
                        service_name=service,
                        region_name=region if region else self.aws_default_region,
                        aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                        aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                        aws_session_token=sts_response['Credentials']['SessionToken'],
                        verify=self.verify_certificate,
                        config=self.config,
                        endpoint_url=self.endpoint_url
                    )
            elif self.aws_access_key_id and (role_arn or self.aws_role_arn):  # login with Access Key ID and Role ARN
                sts_client = boto3.client(
                    service_name='sts',
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.sts_endpoint_url
                )
                kwargs.update({
                    'RoleArn': role_arn or self.aws_role_arn,
                    'RoleSessionName': role_session_name or self.aws_role_session_name,
                })
                sts_response = sts_client.assume_role(**kwargs)
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
                    aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
                    aws_session_token=sts_response['Credentials']['SessionToken'],
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_session_token and not self.aws_role_arn:  # login with session token
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    aws_session_token=self.aws_session_token,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            elif self.aws_access_key_id and not self.aws_role_arn:  # login with access key id
                client = boto3.client(
                    service_name=service,
                    region_name=region if region else self.aws_default_region,
                    aws_access_key_id=self.aws_access_key_id,
                    aws_secret_access_key=self.aws_secret_access_key,
                    verify=self.verify_certificate,
                    config=self.config,
                    endpoint_url=self.endpoint_url
                )
            else:  # login with default permissions, permissions pulled from the ec2 metadata
                client = boto3.client(service_name=service,
                                      region_name=region if region else self.aws_default_region,
                                      endpoint_url=self.endpoint_url)

            return client

        @staticmethod
        def get_timeout(timeout):
            if not timeout:
                timeout = "60,10"  # default values
            try:

                if isinstance(timeout, int):
                    read_timeout = timeout
                    connect_timeout = 10

                else:
                    timeout_vals = timeout.split(',')
                    read_timeout = int(timeout_vals[0])
                    # the default connect timeout is 10
                    connect_timeout = 10 if len(timeout_vals) == 1 else int(timeout_vals[1])

            except ValueError:
                raise DemistoException("You can specify just the read timeout (for example 60) or also the connect "
                                       "timeout followed after a comma (for example 60,10). If a connect timeout is not "
                                       "specified, a default of 10 second will be used.")
            return read_timeout, connect_timeout

    register_module_line('AWSApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###
    from http import HTTPStatus

    # Disable insecure warnings
    urllib3.disable_warnings()

    SERVICE = 's3'

    """HELPER FUNCTIONS"""


    def convert_size(size_bytes):
        if size_bytes == 0:
            return "0B"
        size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"


    class DatetimeEncoder(json.JSONEncoder):
        # pylint: disable=method-hidden
        def default(self, obj):
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%dT%H:%M:%S')
            elif isinstance(obj, date):
                return obj.strftime('%Y-%m-%d')
            # Let the base class default method raise the TypeError
            return json.JSONEncoder.default(self, obj)


    def create_bucket_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        data = []
        kwargs = {'Bucket': args.get('bucket', '').lower()}
        if args.get('acl') is not None:
            kwargs.update({'ACL': args.get('acl')})
        if args.get('locationConstraint') is not None:
            kwargs.update({'CreateBucketConfiguration': {'LocationConstraint': args.get('locationConstraint')}})
        if args.get('grantFullControl') is not None:
            kwargs.update({'GrantFullControl': args.get('grantFullControl')})
        if args.get('grantRead') is not None:
            kwargs.update({'GrantRead': args.get('grantRead')})
        if args.get('grantReadACP') is not None:
            kwargs.update({'GrantReadACP': args.get('grantReadACP')})
        if args.get('grantWrite') is not None:
            kwargs.update({'GrantWrite': args.get('grantWrite')})
        if args.get('grantWriteACP') is not None:
            kwargs.update({'GrantWriteACP': args.get('grantWriteACP')})

        response = client.create_bucket(**kwargs)

        data.append({'BucketName': args.get('bucket'), 'Location': response['Location']})
        human_readable = tableToMarkdown('AWS S3 Buckets', data)
        return CommandResults(readable_output=human_readable, outputs=data, outputs_prefix='AWS.S3.Buckets')


    def delete_bucket_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )

        response = client.delete_bucket(Bucket=args.get('bucket', '').lower())
        if response['ResponseMetadata']['HTTPStatusCode'] == HTTPStatus.NO_CONTENT:
            return CommandResults(readable_output=f"The requested bucket '{args.get('bucket')}' was deleted")
        return CommandResults(readable_output=f"The requested bucket '{args.get('bucket')}' was not found")


    def list_buckets_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        data = []
        response = client.list_buckets()
        for bucket in response['Buckets']:
            data.append({'BucketName': bucket['Name'],
                         'CreationDate': datetime.strftime(bucket['CreationDate'], '%Y-%m-%dT%H:%M:%S')})
        human_readable = tableToMarkdown('AWS S3 Buckets', data)
        return CommandResults(readable_output=human_readable, outputs_prefix='AWS.S3.Buckets',
                              outputs_key_field='BucketName', outputs=data)


    def get_bucket_policy_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        data = []
        response = client.get_bucket_policy(Bucket=args.get('bucket', '').lower())
        policy = json.loads(response['Policy'])
        statements = policy['Statement']
        for statement in statements:
            data.append(
                {'BucketName': args.get('bucket'), 'PolicyId': policy.get('Id'), 'PolicyVersion': policy.get('Version'),
                 'Sid': statement.get('Sid'), 'Action': statement.get('Action'), 'Principal': statement.get('Principal'),
                 'Resource': statement.get('Resource'), 'Effect': statement.get('Effect'), 'Json': response.get('Policy')})
        human_readable = tableToMarkdown('AWS S3 Bucket Policy', data)
        return CommandResults(readable_output=human_readable, outputs_prefix='AWS.S3.Buckets',
                              outputs_key_field='BucketName', outputs=data)


    def put_bucket_policy_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        kwargs = {'Bucket': args.get('bucket', '').lower(), 'Policy': args.get('policy')}
        if args.get('confirmRemoveSelfBucketAccess') is not None:
            kwargs.update(
                {'ConfirmRemoveSelfBucketAccess': True if args.get('confirmRemoveSelfBucketAccess') == 'True' else False})

        response = client.put_bucket_policy(**kwargs)
        if response['ResponseMetadata']['HTTPStatusCode'] == HTTPStatus.OK:
            return CommandResults(readable_output=f"Successfully applied bucket policy to {args.get('bucket')} bucket")
        return CommandResults(readable_output=f"Couldn't apply bucket policy to {args.get('bucket')} bucket")


    def delete_bucket_policy_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        client.delete_bucket_policy(Bucket=args.get('bucket', '').lower())
        return CommandResults(readable_output=f"Policy deleted from {args.get('bucket')}")


    def download_file_command(args: Dict[str, Any], aws_client: AWSClient):
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        data = io.BytesIO()
        client.download_fileobj(args.get('bucket', '').lower(), args.get('key'), data)

        demisto.results(fileResult(args.get('key'), data.getvalue()))


    def list_objects_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        data = []
        kwargs = {'Bucket': args.get('bucket')}
        if args.get('delimiter') is not None:
            kwargs.update({'Delimiter': args.get('delimiter')})
        if args.get('prefix') is not None:
            kwargs.update({'Prefix': args.get('prefix')})

        client.list_objects(**kwargs)
        paginator = client.get_paginator('list_objects')
        for response in paginator.paginate(**kwargs):
            if response.get('Contents', None):
                for key in response['Contents']:
                    data.append({'Key': key['Key'], 'Size': convert_size(key['Size']),
                                 'LastModified': datetime.strftime(key['LastModified'], '%Y-%m-%dT%H:%M:%S')})

        if len(data) > 0:
            human_readable = tableToMarkdown('AWS S3 Bucket Objects', data)
            return CommandResults(readable_output=human_readable, outputs_prefix='AWS.S3.Buckets',
                                  outputs_key_field='BucketName', outputs=data)
        return CommandResults(readable_output=f"The {args.get('bucket')} bucket contains no objects.")


    def get_file_path(file_id):
        filepath_result = demisto.getFilePath(file_id)
        return filepath_result


    def upload_file_command(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        path = get_file_path(args.get('entryID'))

        with open(path['path'], 'rb') as data:
            client.upload_fileobj(data, args.get('bucket'), args.get('key'))
            return CommandResults(
                readable_output=f"File {args.get('key')} was uploaded successfully to {args.get('bucket')}")


    def get_public_access_block(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        response = client.get_public_access_block(Bucket=args.get('bucket'))
        public_access_block_configuration = response.get('PublicAccessBlockConfiguration')
        data = {'BucketName': args.get('bucket'), 'PublicAccessBlockConfiguration': {
            'BlockPublicAcls': public_access_block_configuration.get('BlockPublicAcls'),
            'IgnorePublicAcls': public_access_block_configuration.get('IgnorePublicAcls'),
            'BlockPublicPolicy': public_access_block_configuration.get('BlockPublicPolicy'),
            'RestrictPublicBuckets': public_access_block_configuration.get('RestrictPublicBuckets'), }}
        human_readable = tableToMarkdown('AWS S3 Bucket Public Access Block', data)
        return CommandResults(outputs=data, readable_output=human_readable, outputs_prefix='AWS.S3.Buckets',
                              outputs_key_field='BucketName')


    def put_public_access_block(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        kwargs = {'Bucket': args.get('bucket'),
                  'PublicAccessBlockConfiguration': {'BlockPublicAcls': argToBoolean(args.get('BlockPublicAcls')),
                                                     'IgnorePublicAcls': argToBoolean(args.get('IgnorePublicAcls')),
                                                     'BlockPublicPolicy': argToBoolean(args.get('BlockPublicPolicy')),
                                                     'RestrictPublicBuckets': argToBoolean(
                                                         args.get('RestrictPublicBuckets'))}}
        response = client.put_public_access_block(**kwargs)

        if response['ResponseMetadata']['HTTPStatusCode'] == HTTPStatus.OK:
            return CommandResults(
                readable_output=f"Successfully applied public access block to the {args.get('bucket')} bucket")
        return CommandResults(readable_output=f"Couldn't apply public access block to the {args.get('bucket')} bucket")


    def get_bucket_encryption(args: Dict[str, Any], aws_client: AWSClient) -> CommandResults:
        client = aws_client.aws_session(service=SERVICE, region=args.get('region'), role_arn=args.get('roleArn'),
                                        role_session_name=args.get('roleSessionName'),
                                        role_session_duration=args.get('roleSessionDuration'), )
        kwargs = {'Bucket': args.get('bucket')}
        if args.get('expectedBucketOwner') is not None:
            kwargs.update({'ExpectedBucketOwner': args.get('expectedBucketOwner')})
        try:
            response = client.get_bucket_encryption(**kwargs)
        except client.exceptions.ClientError as ex:
            if ex.response.get('Error', {}).get('Code', '') != 'ServerSideEncryptionConfigurationNotFoundError':
                raise ex
            response = {}
        data = {'BucketName': args.get('bucket'),
                'ServerSideEncryptionConfiguration': response.get('ServerSideEncryptionConfiguration')}
        human_readable = tableToMarkdown('AWS S3 Bucket Encryption', data)
        return CommandResults(outputs=data, readable_output=human_readable, outputs_prefix='AWS.S3.Buckets',
                              outputs_key_field='BucketName')


    def main():  # pragma: no cover
        params = demisto.params()
        aws_default_region = params.get('defaultRegion')
        aws_role_arn = params.get('roleArn')
        aws_role_session_name = params.get('roleSessionName')
        aws_role_session_duration = params.get('sessionDuration')
        aws_role_policy = None
        aws_access_key_id = params.get('credentials', {}).get('identifier') or params.get('access_key')
        aws_secret_access_key = params.get('credentials', {}).get('password') or params.get('secret_key')
        verify_certificate = not params.get('insecure', True)
        timeout = params.get('timeout')
        retries = params.get('retries') or 5
        sts_endpoint_url = params.get('sts_endpoint_url') or None
        endpoint_url = params.get('endpoint_url') or None

        try:
            command = demisto.command()
            validate_params(aws_default_region, aws_role_arn, aws_role_session_name, aws_access_key_id,
                            aws_secret_access_key)

            aws_client = AWSClient(aws_default_region, aws_role_arn, aws_role_session_name, aws_role_session_duration,
                                   aws_role_policy, aws_access_key_id, aws_secret_access_key, verify_certificate, timeout,
                                   retries, sts_endpoint_url=sts_endpoint_url, endpoint_url=endpoint_url)

            args = demisto.args()

            demisto.info(f'Command being called is {demisto.command()}')
            if command == 'test-module':
                client = aws_client.aws_session(service=SERVICE)
                response = client.list_buckets()
                if response['ResponseMetadata']['HTTPStatusCode'] == HTTPStatus.OK:
                    demisto.results('ok')

            elif command == 'aws-s3-create-bucket':
                return_results(create_bucket_command(args, aws_client))

            elif command == 'aws-s3-delete-bucket':
                return_results(delete_bucket_command(args, aws_client))

            elif command == 'aws-s3-list-buckets':
                return_results(list_buckets_command(args, aws_client))

            elif command == 'aws-s3-get-bucket-policy':
                return_results(get_bucket_policy_command(args, aws_client))

            elif command == 'aws-s3-put-bucket-policy':
                return_results(put_bucket_policy_command(args, aws_client))

            elif command == 'aws-s3-delete-bucket-policy':
                return_results(delete_bucket_policy_command(args, aws_client))

            elif command == 'aws-s3-download-file':
                download_file_command(args, aws_client)

            elif command == 'aws-s3-list-bucket-objects':
                return_results(list_objects_command(args, aws_client))

            elif command == 'aws-s3-upload-file':
                return_results(upload_file_command(args, aws_client))

            elif command == 'aws-s3-get-public-access-block':
                return_results(get_public_access_block(args, aws_client))

            elif command == 'aws-s3-put-public-access-block':
                return_results(put_public_access_block(args, aws_client))

            elif command == 'aws-s3-get-bucket-encryption':
                return_results(get_bucket_encryption(args, aws_client))
            else:
                raise NotImplementedError(f'{command} command is not implemented.')

        except Exception as e:
            return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')


    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()

    register_module_line('AWS - S3', 'end', __line__())
  subtype: python3
  type: python
system: true
