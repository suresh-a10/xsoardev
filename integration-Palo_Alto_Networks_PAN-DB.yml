beta: true
category: Data Enrichment & Threat Intelligence
commonfields:
  id: Palo Alto Networks PAN-DB
  version: -1
configuration:
- defaultvalue: https://api.urlcloud.paloaltonetworks.com/service/publicapi/v1/
  display: Server URL
  name: url
  required: true
  type: 0
- display: API KEY
  name: api_key
  required: true
  type: 4
- defaultvalue: "true"
  display: Return PAN-DB History in results
  name: get_history
  required: false
  type: 8
- defaultvalue: "true"
  display: Return PAN-DB Evidence in results
  name: get_evidence
  required: false
  type: 8
- additionalinfo: If selected, when running the !url command, the command will execute
    using pan-os with PAN_DB (with applied filters). The URL filtering categories
    determine DBot score (malicious, suspicious, benign).
  defaultvalue: "false"
  display: Use URL Filtering for auto enrichment
  name: use_url_filtering
  required: false
  type: 8
- defaultvalue: B - Usually reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  type: 15
- display: URL Filtering Additional malicious categories. CSV list of categories that
    will be considered malicious.
  name: additional_malicious
  required: false
  type: 0
- display: URL Filtering Additional suspicious categories. CSV list of categories
    that will be considered suspicious.
  name: additional_suspicious
  required: false
  type: 0
- defaultvalue: "false"
  display: Trust any certificate
  name: insecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use system proxy
  name: proxy
  required: false
  type: 8
- display: Fetch indicators
  name: feed
  required: false
  type: 8
- defaultvalue: high-risk,medium-risk,hacking,proxy-avoidance-and-anonymizers
  display: Predefined Suspicious Categories
  name: predefined_suspicious
  options:
  - high-risk
  - medium-risk
  - hacking
  - proxy-avoidance-and-anonymizers
  required: false
  type: 16
- defaultvalue: phishing,command-and-control,malware,ransomware
  display: Predefined Malicious Categories
  name: predefined_malicious
  options:
  - phishing
  - command-and-control
  - malware
  - ransomware
  required: false
  type: 16
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Queries the Palo Alto Networks URL Filtering DB (PAN-DB API)
detaileddescription: |-
  Note: This is a beta Integration, which lets you implement and test pre-release software. Since the integration is beta, it might contain bugs. Updates to the integration during the beta phase might include non-backward compatible features. We appreciate your feedback on the quality and usability of the integration to help us identify issues, fix them, and continually improve.
  ---
  [View Integration Documentation](https://pan.dev/cdss/threat-vault/api)
display: Palo Alto Networks PAN-DB
image: data:image/png;base64,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
name: Palo Alto Networks PAN-DB
script:
  commands:
  - arguments:
    - description: URL to query verdict information for
      name: url
      required: true
    description: Query URL for PANDB verdict
    name: pan-url-get-category
    outputs:
    - contextPath: PAN-DB_API.URL.url
      description: URL queried
      type: String
    - contextPath: PAN-DB_API.URL.categories
      description: URL categories
      type: string
    - contextPath: PAN-DB_API.URL.evidences
      description: URL category evidence
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: string
  - arguments:
    - description: URL to query
      name: url
      required: true
    description: Query URL for PANDB Verdict
    name: url
    outputs:
    - contextPath: PAN-DB_API.URL.url
      description: URL queried
      type: string
    - contextPath: PAN-DB_API.URL.categories
      description: URL categories
      type: string
    - contextPath: PAN-DB_API.URL.evidences
      description: URL category evidence
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
  - arguments:
    - name: domain
      required: true
    description: Query Domain for PANDB Verdict (as a domain)
    name: domain
    outputs:
    - contextPath: PAN-DB_API.URL.url
      description: URL queried
      type: string
    - contextPath: PAN-DB_API.URL.categories
      description: URL categories
      type: string
    - contextPath: PAN-DB_API.URL.evidences
      description: URL category evidence
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: string
  - arguments:
    - description: IP to query PANDB
      name: ip
    description: Query IP for PANDB Verdict (as IP)
    name: ip
    outputs:
    - contextPath: PAN-DB_API.URL.url
      type: string
    - contextPath: PAN-DB_API.URL.categories
      type: string
    - contextPath: PAN-DB_API.URL.evidences
      type: string
    - contextPath: DBotScore.Type
      type: string
    - contextPath: DBotScore.Vendor
      type: string
    - contextPath: DBotScore.Score
      type: string
  dockerimage: demisto/python3:3.10.8.37233
  runonce: false
  script: |-
    #import demistomock as demisto
    #from CommonServerPython import *  # noqa # pylint: disable=unused-wildcard-import
    #from CommonServerUserPython import *  # noqa
    import requests
    import traceback
    from typing import Callable, Dict, cast
    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()  # pylint: disable=no-member
    ''' CONSTANTS '''
    INTEGRATION_NAME = 'PAN-DB_API'
    INTEGRATION_ENTRY_CONTEXT = "PAN-DB_API"
    ''' CLIENT CLASS '''
    class Client(BaseClient):
        def domain_request(self, method, url, body: dict = None, params: dict = None):
            response = self._http_request(
                method,
                url,
                json_data=body,
                params=params
            )
            return response
        def get_url(self, args):
            """
             Executes URL enrichment against PAN-DB API.
             Args:
                 client (Client): client.
                 args (Dict[str, str]): the arguments for the command.
             Returns:
                 dict: the results to return into Demisto's context.
            """
            url_suffix = 'url'
            #print(json.dumps(args, indent=4, sort_keys=True))
            #response = self._http_request('POST', url_suffix=url_suffix, json_data=args)
            _response = self._http_request('POST', url_suffix=url_suffix, json_data=args, resp_type='response')
            quota_limit_remaining = int(_response.headers.get('x-ratelimit-remaining', 99))
            quota_limit_total = int(_response.headers.get('x-ratelimit-rate', 99))
            #quota_limit_reset_after = int(_response.headers.get('x-ratelimit-resetafter', 60))
            #limit_action = _response.headers.get('X-Quota-Limit-Total', 'search')
            quota_limit_reset = int(_response.headers.get('x-ratelimit-period', 99))
            response = _response.json()
            response_code = int(_response.headers.get('status_code', 100))
            # append the api values to the returned json
            response['quota_limit_remaining']=quota_limit_remaining
            response['quota_limit_total']=quota_limit_total
            response['quota_limit_reset']=quota_limit_reset
            quota_limit_reset_mins = quota_limit_reset/60
            if quota_limit_remaining < 10:
                    return_warning('Your available rate limit remaining is {} and is about to be exhausted. '
                               'The rate limit will reset at {}'.format(str(quota_limit_remaining),
                                                                        quota_limit_reset_date))
            '''
                * We are completely uploaded and fine
                < HTTP/2 200
                < server: openresty/1.21.4.1
                < date: Wed, 14 Sep 2022 15:29:27 GMT
                < content-type: application/json; charset=UTF-8
                < content-length: 330
                < content-security-policy: default-src 'none'
                < strict-transport-security: max-age=7776000
                < vary: Origin
                < x-content-type-options: nosniff
                < x-ratelimit-burst: 10000
                < x-ratelimit-period: 86400
                < x-ratelimit-rate: 10000
                < x-ratelimit-remaining: 9999
                < x-ratelimit-resetafter: 8
                < x-ratelimit-retryafter: 0
                < via: 1.1 google
            '''
            return response
    ''' HELPER FUNCTIONS '''
    ''' provide explanation for risk categories '''
    def risk_category_explain(category: str):
        RISK_CAT_DICT = {
            'high-risk': '''High-risk sites include:
    Sites previously confirmed to be malware, phishing, or C2 sites. These sites will remain in this category for at least 30 days.
    Unknown domains are classified as high-risk until PAN-DB completes site analysis and categorization.
    Sites that are associated with confirmed malicious activity. For example, a page might be high-risk if there are malicious hosts on the same domain, even if the page itself does not contain malicious content.
    Bulletproof ISP-hosted sites.
    Domains classified as DDNS due to the presence of an active dynamic DNS configuration.
    Sites hosted on IPs from ASNs that are known to allow malicious content.
    Default and Recommended Policy Action: Alert
    ''',
            'medium-risk': '''Medium-risk sites include:
    All cloud storage sites (with the URL category online-storage-and-backup).
    Sites previously confirmed to be malware, phishing, or C2 sites that have displayed only benign activity for at least 30 days. These sites will remain in this category for an additional 60 days.
    Unknown IP addresses are categorized as medium-risk until PAN-DB completes site analysis and categorization.
    Default and Recommended Policy Action: Alert
    ''',
            'low-risk': '''Sites that are not medium or high risk are considered low risk. These sites have displayed benign activity for a minimum of 90 days.
    Default and Recommended Policy Action: Allow
    ''',
            'newly-registered-domain': '''Identifies sites that have been registered within the last 32 days. New domains are frequently used as tools in malicious campaigns.
    Default Policy Action: Alert
    Recommended Policy Action: Block
    ''',
        }
        markdown = ''
        if category in RISK_CAT_DICT:
            #risk_cat_desc = RISK_CAT_DICT.get(category)
            table = {
                    'Risk Category': category,
                    'Description': RISK_CAT_DICT.get(category)
                }
            markdown = tableToMarkdown(f'URL Filtering Risk Category Details:\n'
                                               , table, removeNull=True)
        return markdown
    ''' remove empty cateogory entries in list for context entry '''
    def pretty_context(response_data: list):
        #pretty_response_raw = []
        categories_raw = response_data[0]['categories']
        str_list = list(filter(None, categories_raw))
        response_data[0]['categories'] = str_list
        return response_data
    def calculate_dbot_score(category: str, additional_suspicious: list, additional_malicious: list):
        """translate a category to a dbot score. For more information:
        https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000Cm5hCAC
        Args:
            category: the URL category from URLFiltering
        Returns:
            dbot score.
        """
        #predefined_suspicious = ['high-risk', 'medium-risk', 'hacking', 'proxy-avoidance-and-anonymizers', 'grayware','not-resolved']
        predefined_malicious = ['phishing', 'command-and-control', 'malware', 'ransomware']
        predefined_malicious = PREDEFINED_MALICIOUS
        predefined_suspicious = PREDEFINED_SUSPICIOUS
        suspicious_categories = list((set(additional_suspicious)).union(set(predefined_suspicious)))
        malicious_categories = list((set(additional_malicious)).union(set(predefined_malicious)))
        malicious_categories = [element.lower() for element in malicious_categories] ; malicious_categories
        suspicious_categories = [element.lower() for element in suspicious_categories] ; suspicious_categories
        if category in malicious_categories:
            dbot_score = 3
        elif category in suspicious_categories:
            dbot_score = 2
        elif category == 'unknown':
            dbot_score = 0
        else:
            dbot_score = 1
        return dbot_score
    ''' COMMAND FUNCTIONS '''
    ''' Test module '''
    def test_command(client: Client, arg_url: str):
        query_list = {}
        # list of image_details
        query_list["urls"] = []
        # query for getting object
        query_list["urls"].append(arg_url)
        query_list["get_evidence"] = False
        query_list["get_history"] = False
        #print(query_list)
        response = client.get_url(query_list)
        response_data = response.get('success')
        if response_data:
            return_results('ok')
        else:
            print(json.dumps(response_data, indent=4, sort_keys=True))
    ''' query module for PAN-DB API - also performs enrichment of urls '''
    def get_category_command(client: Client, args: dict):
        table = {}
        execution_metrics = ExecutionMetrics()
        command_results: list = []
        if args.get('url') or args.get('domain') or args.get('ip'):
            try:
                # get the value to search for from either domain or url query
                query_value = ''
                if args.get('url'):
                    query_value = args.get('url')
                elif args.get('domain'):
                    query_value = args.get('domain')
                else:
                    query_value = args.get('ip')
                query_list = {}
                # list of image_details
                query_list["urls"] = []
                # query for getting object
                query_list["urls"].append(query_value)
                query_list["get_evidence"] = RETURN_EVIDENCE
                query_list["get_history"] = RETURN_HISTORY
                response = client.get_url(query_list)
                #print(json.dumps(response, indent=4, sort_keys=True))
                response_data = response.get('data')
                #append the api values to the returned json
                quota_limit_total = int(response.get('quota_limit_total', 99))
                quota_limit_remaining = int(response.get('quota_limit_remaining', 99))
                quota_limit_reset = int(response.get('quota_limit_reset', 99))
                quota_limit_reset_date = datetime.fromtimestamp(quota_limit_reset, tz=timezone.utc)
                #print(quota_limit_remaining)
                execution_metrics.success += 1
            except Exception as err:
                return_error(f"Error creating JSON format for query: {err}")
                execution_metrics.general_error += 1
        #print(json.dumps(response_data, indent=4, sort_keys=True))
        history_trimmed_str = ''
        evidence_trimmed_str = ''
        # extract the history of the url if they exist
        try:
            #response_data[0]['histories']
            #print(response_data[0]['histories'])
            history_trimmed = list(filter(None, response_data[0]['histories']))
            history_trimmed_str = '\n'.join(history_trimmed)
        except Exception:
            history_trimmed_str = ''
        # extract the evidence if they exist
        try:
            #response_data[0]['evidences']:
            #print(response_data[0]['evidences'])
            evidence_trimmed = list(filter(None, response_data[0]['evidences']))
            evidence_trimmed_str = '\n'.join(evidence_trimmed)
        except Exception:
            evidence_trimmed_str = ''
        # get the categories and strip out any blank entries
        categories_raw = response_data[0]['categories']
        category_list = list(filter(None, categories_raw))
        categories_trimmed = '\n'.join(category_list)
        url = response_data[0]['url']
        # if integration set to use PANDB to enrich URLS and domains to calculate dbot score
        max_url_dbot_score = 0
        url_dbot_score_category = ''
        risk_cat_md = ''
        if USE_URL_FILTERING:
            for category in category_list:
                #print("Category: "+ category)
                # returns list with 3 values [ dbotscore, malicious_cats, susp_cats ]
                current_dbot_score = calculate_dbot_score(
                            category.lower(), ADDITIONAL_SUSPICIOUS, ADDITIONAL_MALICIOUS
                        )
                # get the risk category description if it exists
                risk_cat_md += risk_category_explain(category)
                #print(risk_cat_md)
                #print("Score "+ str(current_dbot_score))
                if current_dbot_score > max_url_dbot_score:
                        max_url_dbot_score = current_dbot_score
                        url_dbot_score_category = category
                dbot_score = Common.DBotScore(
                    indicator=url,
                    indicator_type=DBotScoreType.URL,
                    integration_name=INTEGRATION_NAME,
                    score=max_url_dbot_score,
                    reliability=reliability
                )
                url_obj = Common.URL(
                    url=url,
                    dbot_score=dbot_score,
                    category=url_dbot_score_category
                )
            # create the table based on the response
            table = {
                        'URL': url,
                        'Categories': categories_trimmed,
                        'Evidence': evidence_trimmed_str,
                        'Raw_Response': response_data[0],
                        'DBot_Score': max_url_dbot_score,
                        'API Quota': str(quota_limit_remaining)+'/'+str(quota_limit_total)+' resets in '+str(quota_limit_reset_date)
                    }
            markdown = tableToMarkdown(f'PAN-DB Results for: {url}\n'
                                           , table, removeNull=True)
            # append the markdown from a risk cateogry seen if exists
            markdown = markdown + risk_cat_md
            command_results = CommandResults(
                outputs_prefix=f'{INTEGRATION_ENTRY_CONTEXT}.URL',
                outputs_key_field='id',
                indicator=url_obj,
                outputs=pretty_context(response_data),
                readable_output=markdown,
                raw_response=response_data
            )
        else:
            # not using url filtering for enrichment (unselected)
            # create the table based on the response
            table = {
                        'URL': url,
                        'Categories': categories_trimmed,
                        'Evidence': evidence_trimmedstr,
                        'Raw_Response': response_data[0],
                        'API Quota': str(quota_limit_remaining)+'/'+str(quota_limit_total)+' resets in '+str(quota_limit_reset_date)
                    }
            markdown = tableToMarkdown(f'PAN-DB Results for: {url}\n'
                                           , table, removeNull=True)
            command_results = CommandResults(
                outputs_prefix=f'{INTEGRATION_ENTRY_CONTEXT}.URL',
                outputs_key_field='id',
                outputs=pretty_context(response_data),
                readable_output=markdown
            )
        if execution_metrics.is_supported():
            command_results_list = [command_results]
            _metric_results = execution_metrics.metrics
            metric_results = cast(CommandResults, _metric_results)
            command_results_list.append(metric_results)
            return_results(command_results_list)
        else:
            return_results(command_results)
    ''' MAIN FUNCTION '''
    def main() -> None:
        global API_KEY, USE_SSL, USE_URL_FILTERING, RETURN_EVIDENCE, RETURN_HISTORY, ADDITIONAL_MALICIOUS, ADDITIONAL_SUSPICIOUS, reliability, PREDEFINED_SUSPICIOUS, PREDEFINED_MALICIOUS
        params = demisto.params()
        args = demisto.args()
        base_url = params.get('url')
        API_KEY = params.get('api_key')
        ADDITIONAL_MALICIOUS = argToList(params.get('additional_malicious'))
        ADDITIONAL_SUSPICIOUS = argToList(params.get('additional_suspicious'))
        PREDEFINED_SUSPICIOUS = argToList(params.get('predefined_suspicious'))
        PREDEFINED_MALICIOUS = argToList(params.get('predefined_malicious'))
        reliability = params.get('integrationReliability')
        USE_URL_FILTERING = params.get('use_url_filtering')
        RETURN_EVIDENCE = params.get('get_evidence')
        RETURN_HISTORY = params.get('get_history')
        #verify_certificate = not demisto.params().get('insecure', False)
        #proxy = demisto.params().get('proxy', False)
        exe_metrics = ExecutionMetrics()
        command = demisto.command()
        demisto.debug(f'Command being called is {command}')
        try:
            commands: Dict[str, Callable] = {
                'pan-url-get-category'      : get_category_command,
                'url'                       : get_category_command,
                'domain'                    : get_category_command,
                'ip'                        : get_category_command
            }
            headers: Dict = {
                'X-PANDB-API-KEY': API_KEY,
                'Content-Type': 'application/json'
            }
            client = Client(
                base_url=base_url,
                #verify=verify_certificate,
                headers=headers,
                #proxy=proxy
            )
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                result = test_command(client, 'paloaltonetworks.com')
                return_results(result)
            elif command in commands:
                commands[command](client, args)  # type: ignore[operator]
            else:
                raise NotImplementedError(f"command {command} is not implemented.")
        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')
    ''' ENTRY POINT '''
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
sourcemoduleid: Palo Alto Networks Security Advisories
