args:
- name: EmailNewRecipients
  required: true
- name: EmailSelectThread
  required: true
- name: EmailSubject
  required: true
- name: EmailBody
  required: true
comment: This script can be used to forward emails by rendering all email messages
  with the thread number specified in the "Email Selected Thread" field .
commonfields:
  id: 60a75cc9-469e-418b-89fc-c80e9be67520
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/python3:3.10.4.30607
enabled: true
engineinfo: {}
mainengineinfo: {}
name: ForwardEmailHtmlThread
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('DisplayEmailHtmlThread', 'start', __line__())


  import re


  no_entries_message = """<!DOCTYPE html>
  <html>
  <body>
  <h3>This Incident does not contain any email threads yet.</h3>
  </body>
  </html>
  """




  def set_email_reply(email_from, email_to, email_cc, email_subject, html_body):
      """Set the email reply from the given details.
      Args:
          email_from: The email author mail.
          email_to: The email recipients.
          email_cc: The email cc.
          email_subject: The email subject.
          html_body: The email HTML body.
          email_time: The time the email was received
          attachment_names: String of attachment names
      Returns:
          str. Email reply.
      """

      single_reply = f'<html><body><b>From:</b> {email_from}<br><b>To:</b> {email_to}<br><b>CC:</b> {email_cc}<br>' \
                     f'<b>Subject:</b> {email_subject}<br>'


      single_reply += f'\n{html_body}\n<hr style="width:98%;text-align:center;height:3px;border-width:0;' \
                      f'background-color:#cccccc">\n\n'

      return single_reply


  def html_cleanup(full_thread_html):
      """
          Moves various HTML tags so the final output is a single HTML document
      Args:
          full_thread_html (string): The concatenated string of all email HTML
      Returns:
          str. Full email thread HTML
      """
      # Remove HTML tags within the string that should only occur once
      full_thread_html = re.sub('(?i)<!DOCTYPE html>', '', full_thread_html)
      full_thread_html = re.sub('(?i)<.?html>', '', full_thread_html)
      full_thread_html = re.sub('(?i)<.?body>', '', full_thread_html)

      # Place needed HTML tags in their appropriate locations
      final_html_result = f'<!DOCTYPE html>\n<html>\n<body>\n{full_thread_html}\n</body>\n</html>'

      return final_html_result

  def get_attachment_entry_ids(email_threads, thread_number,files):


      file_names = []
      for thread in email_threads:
          if str(thread['EmailCommsThreadNumber']) == str(thread_number):

              file_names.append(thread.get('EmailAttachments', None))

      file_names=set(file_names)



      entry_ids=[]
      if len(files) == 0:
          entry_ids = None
      elif isinstance(files, dict):
          entry_ids.append(files['EntryID'])
      else:
          for i in range(len(files)):
              for file_name in file_names:
                  if file_name == files[i]['name']:
                      entry_ids.append(files[i]['entry_id'])

      return entry_ids

  def format_body(email_body):
      """
          Converts markdown included in the email body to HTML
      Args:
          new_email_body (str): Email body text with or without markdown formatting included
      Returns: (str) HTML email body
      """
      # Replace newlines with <br> element to preserve line breaks
      new_email_body= email_body.replace('\n', '<br>')

      res = demisto.executeCommand("mdToHtml", {"text": new_email_body})
      html_body = res[0]['Contents']

      return html_body


  def send_mail(final_html_result,email_recipients,email_subject,new_email_body,entry_ids):

      if entry_ids is None:
          mail_content = {
              "to": email_recipients,
              "htmlBody":new_email_body+final_html_result,
              "subject":email_subject
          }
      else:
          mail_content = {
              "to": email_recipients,
              "htmlBody":new_email_body+final_html_result,
              "subject":email_subject,
              "attachIDs":",".join(entry_ids)
          }

      email_result = demisto.executeCommand("send-mail", mail_content)




  def main():
      incident = demisto.incident()
      custom_fields = incident.get('CustomFields')
      thread_number = demisto.args().get('EmailSelectThread',0)
      email_recipients = demisto.args()['EmailNewRecipients']
      email_subject = demisto.args()['EmailSubject']
      email_body = demisto.args()['EmailBody']
      #thread_number = custom_fields.get('emailselectedthread', 0)
      incident_context = demisto.context()
      email_threads = incident_context.get('EmailThreads', {})
      files = incident_context.get('File',{})

      if len(email_threads) == 0:
          return_results({
              'ContentsFormat': EntryFormat.HTML,
              'Type': EntryType.NOTE,
              'Contents': no_entries_message
          })
          return None

      if isinstance(email_threads, dict):
          email_threads = [email_threads]

      thread_exists = False
      thread_items = []
      full_thread_html = str()

      for thread in email_threads:
          if str(thread['EmailCommsThreadNumber']) == str(thread_number):

              thread_exists = True
              thread_dict = {
                  'email_from': thread.get('EmailFrom', None),
                  'email_cc': thread.get('EmailCC', None),
                  'email_to': thread.get('EmailTo', None),
                  'email_subject': thread.get('EmailSubject', None),
                  'email_html': thread.get('EmailHTML', None),
                  'email_time': thread.get('MessageTime', None),
                  'email_attachments': thread.get('EmailAttachments', None),
              }
              thread_items.append(thread_dict)

      if thread_exists:
          # Append all messages together, with the most recent on top
          for thread in reversed(thread_items):
              email_reply = set_email_reply(thread.get('email_from', None), thread.get('email_to', None),
                                            thread.get('email_cc', None), thread.get('email_subject', None),
                                            thread.get('email_html', None))
              full_thread_html += email_reply

          final_html_result = html_cleanup(full_thread_html)

          ### Forward email Body to be formated in HTML ####
          new_email_body=format_body(email_body)

          #attachments
          entry_ids= get_attachment_entry_ids(email_threads,thread_number,files)

          html_mail_content = send_mail(final_html_result,email_recipients,email_subject,new_email_body,entry_ids)


          return_results({
              'ContentsFormat': EntryFormat.HTML,
              'Type': EntryType.NOTE,
              'Contents': final_html_result
          })
      else:
          return_error(f"An email thread of {thread_number} was not found. Please make sure this thread number is correct.")


  if __name__ in ('__builtin__', 'builtins', '__main__'):
      main()

  register_module_line('DisplayEmailHtmlThread', 'end', __line__())
scripttarget: 0
subtype: python3
tags:
- incident-action-button
- Utility
type: python
