category: Network Security
commonfields:
  id: rapid7_threat_command
  version: -1
configuration:
- additionalinfo: URL of the Rapid7 platform.
  defaultvalue: https://api.ti.insight.rapid7.com/
  display: Server URL
  name: base_url
  required: true
  type: 0
- display: Account ID
  displaypassword: API key
  name: credentials
  required: true
  type: 9
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- defaultvalue: "false"
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- additionalinfo: Timestamp in ISO format or <number> <time unit>, e.g., 2023-01-01T00:00:00.000Z,
    12 hours, 7 days, 3 months, now.
  defaultvalue: 1 day
  display: First fetch timestamp.
  name: first_fetch
  required: false
  type: 0
- additionalinfo: The maximum number of alerts to fetch each time. The default is
    50. If the value is greater than 200, it will be considered as 200.
  defaultvalue: "50"
  display: Maximum incidents per fetch
  name: max_fetch
  required: true
  type: 0
- additionalinfo: Alert types to fetch as incidents.
  display: Alert types to fetch as incidents
  name: alert_types
  options:
  - AttackIndication
  - DataLeakage
  - Phishing
  - BrandSecurity
  - ExploitableData
  - vip
  required: false
  type: 16
- additionalinfo: Network types to fetch as incidents.
  display: Network types to fetch as incidents
  name: network_types
  options:
  - Clear Web
  - Dark Web
  required: false
  type: 16
- additionalinfo: Alerts with the minimum level of severity to fetch.
  display: Minimum Alert Severity Level
  name: alert_severity
  options:
  - Low
  - Medium
  - High
  required: false
  type: 15
- additionalinfo: Source types to filter alerts by.
  display: Source types to filter alerts by
  name: source_types
  options:
  - ApplicationStores
  - BlackMarkets
  - HackingForums
  - SocialMedia
  - PasteSites
  - Others
  required: false
  type: 16
- additionalinfo: Fetch closed alerts from Rapid7 platform.
  defaultvalue: "false"
  display: Fetch closed alerts
  name: fetch_closed_incidents
  required: false
  type: 8
- defaultvalue: "false"
  display: Include CSV files of alerts
  name: fetch_csv
  required: false
  type: 8
- additionalinfo: MSSP accounts must provide a sub-account ID to perform this action.
  defaultvalue: "false"
  display: Include attachments of alerts
  name: fetch_attachments
  required: false
  type: 8
- display: Sub-account ID (for MSSP accounts).
  name: mssp_sub_account
  required: false
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.8.0
    itemVersion: 3.1.4
    packID: IntSight
    packName: Rapid7 - Threat Command (IntSights)
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Rapid7 Insight - Threat Command allows managing alerts, CVEs, IOCs, and
  assets by accounts and MSSP accounts.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: Rapid7
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [support@rapid7.com](mailto:support@rapid7.com)
  - **URL**: [https://www.rapid7.com/for-customers/](https://www.rapid7.com/for-customers/)
  ***
  ### Get a Threat Command API Key

  * Create an account in Threat Command.
  * Connect your account to Threat Command.
  * Generate your API account ID & API key (Settings -> Subscription -> Generate API Key).

  ### MSSP users:

  Insert your sub-account ID in order to perform MSSP actions.

  ### Instance Configuration:

  1. Configure an integration instance with a valid Server URL, Account ID and API key.
  2. Click Test to validate the connection.
  3. To fetch Threat Command Alerts as XSOAR Incidents, select the option Fetches incidents and follow the table to update configuration parameters.

  | **Parameter**                       | **Description**                                                                                                                                       |
  |-------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
  | Classifier                          | Select "N/A".                                                                                                                                         |
  | Incident type                       | Select "Rapid7 ThreatCommand Alert".                                                                                                                  |
  | Mapper (incoming)                   | Select "Rapid7 ThreatCommand - Incoming Mapper".                                                                                                      |
  | Server URL                          | URL of the Rapid7 platform.                                                                                                                           |
  | Account ID                          | Account ID of the Rapid7 platform.                                                                                                                    |
  | API key                             | API key of the Rapid7 platform.                                                                                                                       |
  | Source Reliability                  | Reliability of the source providing the intelligence data.                                                                                            |
  | First fetch timestamp.              | Timestamp in ISO format or &lt;number&gt; &lt;time unit&gt;, e.g., 2023-01-01T00:00:00.000Z, 12 hours, 7 days, 3 months, now. The default is "1 day". |
  | Maximum incidents per fetch         | The maximum number of alerts to fetch each time. The default is 50. If the value is greater than 200, it will be considered as 200.                   |
  | Alert types to fetch as incidents   | Alert types to fetch as incidents. The possible values are AttackIndication, DataLeakage, Phishing, BrandSecurity, ExploitableData, and vip.          |
  | Network types to fetch as incidents | Network types to fetch as incidents. The possible values are Clear Web and Dark Web.                                                                  |
  | Minimum Alert Severity Level        | Alerts with the minimum level of severity to fetch. The possible values are High, Medium, and Low.                                                    |
  | Source types to filter alerts by    | Source types to filter alerts by. The possible values are ApplicationStores, BlackMarkets, HackingForums, SocialMedia, PasteSites, and Others.        |
  | Fetch closed alerts                 | Boolean value indicating to fetch closed alerts from Rapid7 platform.                                                                                 |
  | Include CSV files of alerts         | Boolean value indicating to include CSV files of alerts.                                                                                              |
  | Include attachments of alerts       | Boolean value indicating to include attachments of alerts. MSSP accounts must provide a sub-account ID to perform this action.                        |
  | Sub-account ID (for MSSP accounts). | Sub-account ID for MSSP accounts.                                                                                                                     |
  | Use system proxy settings           | Indicates whether to use XSOAR's system proxy settings to connect to the API.                                                                         |
  | Trust any certificate (not secure)  | Indicates whether to allow connections without verifying the SSL certificate's validity.                                                              |
  | Incidents Fetch Interval            | The incident fetch interval. The default is "1 minute".                                                                                               |


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/rapid7-threat-command)
display: Rapid7 - Threat Command (IntSights) (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAnxQTFRFAAAA8ZNw7Gs97Gw97HJF74dh74Fb86aK9cSx86qS62g26Vgj6Vsn62g57nxR8ZJy/+fb9a2T62Qz6Vgi7n1U8Zp6749s6Vkk6Vom74BZ+une/7OZ7nRL7HFE85Jt75Jy6mAt62c37YZh7npR62Y186SG8J176lwo7n9X88Kq74Rd74Nc8ZV17XlO6mw762o76mMx9rei/8zM62c37n1S9aSI7npR7XlO7oli74Vf9rKa8Ytl9b2o+dXC7oJZ9rSf62k68Y1o62U098W1/+be6mEu7G9B/8zM7HJG6Vci8JFs7G9B74dg9ayT6mIw63FF7n1T86aI8IZf7HFE7nxS886262o762c2/87C6l8r7G5A7HVJ8ZFu6Vol6mIx8aOH7HJF7XRH74Fa6nhO7n9X8pVz/8+v62g47XNG972t8ZV19r2o74Vf7HFE9rSc+NHB86CE9aKJ6nFA8ZNw7XVJ74hi6mEv8ZyA74Ja7oJZ997O62k698697XZK6mMx8aqV8pRy7G0//9vO62Qy8Ipl7XFE86KE6l4r8p1962U1741p74dg7nJG/+bM8I5q+byq+ci28pBu7G9B74Nc8Ixo97Wl8pZy86mN7XNG8JNv8Idh7HlO8ph0+L2o85x776+P7G5B7XNF8p+A74BX741q8Z+A7XRH62o697Wc96WE62g4/8+/86qM6l0q8qaL7oFZ7n9W74pl8JNy8Ytm8ph07XRH7Gw98Zh16mAu85p77HJF9bGY85h562g58pt57XdM7Gs8749u/5lm7YZb62U062g576+f62c37HJG74Fa9cSx75x762s76l0p74lj85t87HFE7HBD8Ipl9bGWKV5EawAAANR0Uk5TAMvb29vbklMaKur///XGXhVO///vSYL//8EvCtvqKi/67yqx5So0/+8V0KFe/0n//1gK/6FJ4NVosVOhSSqxbf99/x8f/8sFy/9o/6w0/5z/bafb6hXv7xW2/21Y//8k1e/BJP+HEP//H5dt1eBYTj40JG3gof8krHgf+h/g9SRy2xX/u7to/zn/csHbCpwqKofvwYcfTlPlwbbqckk+EOrgjayCl9XgHx/1ECr/OeChklN9Of//Xv9oyzQq+mO7+nIFKuDqEPrqgjQf4P+xkv/LrE5we4fsAAACdklEQVR4nO3XZ1PUUBSH8WtXbizsqsSuoGIvoGLvoIi9iy52sYu9C2LB3nvvIrr23nvvfiFnNHtvck4yxpn/C8fhvNznzvmRzGaXFaJw/qEpUvRPU6x4iZKlSsPhMlHSxxhly5WvAJajA35kKYMVK4HlyjH+ZGlWqQqFq1X3CUtZoyZUrlXbt1wnFirH+YZl3XpIuH68f7lBQ6TcyLY56DGR3hgJN9Fu02Ye09w60KIlEE5IVHArjyOt1UPXBgiLJAW39TjRTp0w2gPhDpGtMR3dD3TS90R2BsJdIku7ehzoZnv7de+Bg3smW0tT3Huv3jY4tQ8OFmnW0r7uuV9/+7M8AAgPtHYOcs+D7a4cAoSHWg+p+/fPsOEOeMRIHDzq98r00bbR76ExIQecMRYHj4u8cfSM1/9yTHC4Mn4iDp4k2UxWcUqms5jROHgqcwPTVJxOkjkDBycyeKaOsyg8G+bOMahrZKk416RtHgyen0rhBToupG3RYhi8hN3ppaotS6Nt+QoYvJLuXpWtWg77o1bD3Nw1dPdaHdcxOA4Gr6er8zaolr2RxuAmGLyZ7t6yVbVt7IIztqPcHezn007VcncxeDfKFXvo6sy9qu1jT3hoP8pNOEB3H9TxELvgwyhXHKGfTOZRHdOpm3cM5R4/QXef1PEUu+DTKFecYb+Pz+p4jrbz+Sj3QgHdHXVRxUth0gouo1xxhd3MqzpeIylwHebeYG74pq63nOl2lveiv5w7dxmcpD+17jlC6P4DmPvwEXNDj3V+Yg9Pnz2HuS9eMle+eq1y/hv1qvH23XsYKz58/MTns+5fwr9eSf767fsPnFo4/8X8BIo3tfz5Rs3GAAAAAElFTkSuQmCC
name: rapid7_threat_command
script:
  commands:
  - arguments:
    - description: Filter by free text, which can be the cyber term name or ID.
      name: search
    - auto: PREDEFINED
      description: 'A comma-separated list of cyber term types by which to filter
        the results. For example: ThreatActor,Campaign.'
      isArray: true
      name: types
      predefined:
      - Threat Actor
      - Malware
      - Campaign
    - auto: PREDEFINED
      description: 'A comma-separated list of cyber term severities by which to filter
        the results. For example: High,Low.'
      isArray: true
      name: severities
      predefined:
      - High
      - Medium
      - Low
    - description: 'A comma-separated list of targeted sectors by which to filter
        the results. For example: Education,Government.'
      isArray: true
      name: sectors
    - description: 'A comma-separated list of targeted countries by which to filter
        the results. For example: Albania,Algeria.'
      isArray: true
      name: countries
    - description: 'A comma-separated list of nationalities by which to filter the
        results. For example: Egypt,Iraq.'
      isArray: true
      name: origins
    - description: 'A comma-separated list of TTPs by which to filter the results.
        For example: Malware,Backdoor.'
      isArray: true
      name: ttps
    - description: 'Filter for results whose last update date is greater than the
        given value (in ISO 8601 format). For example:  2022-12-25T08:38:06Z. Default
        value: Last year.'
      name: last_update_from
    - description: 'Filter for results whose last update date is less than the given
        value (in ISO 8601 format). For example:  2022-12-25T08:38:06Z.'
      name: last_update_to
    - defaultValue: "1"
      description: The page number of the results to retrieve (1-based).
      name: page
    - description: The number of objects per page.
      name: page_size
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    description: List cyber terms by filter.
    name: threat-command-cyber-term-list
    outputs:
    - contextPath: ThreatCommand.CyberTerm.id
      description: The ID of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.type
      description: The type of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.name
      description: Name of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.severity
      description: The severity of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.aliases
      description: Aliases of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.target_countries
      description: List of targeted countries.
      type: String
    - contextPath: ThreatCommand.CyberTerm.sectors
      description: List of targeted sectors.
      type: String
    - contextPath: ThreatCommand.CyberTerm.origins
      description: List of origin nationalities.
      type: String
    - contextPath: ThreatCommand.CyberTerm.created_date
      description: The date the cyber term was first reported.
      type: Date
    - contextPath: ThreatCommand.CyberTerm.updated_date
      description: The date the cyber term was last updated.
      type: Date
    - contextPath: ThreatCommand.CyberTerm.ttp
      description: List of TTPs.
      type: String
    - contextPath: ThreatCommand.CyberTerm.overview
      description: Overview of the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.additional_information
      description: Additional information about the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.related_malware
      description: Related malware names.
      type: String
    - contextPath: ThreatCommand.CyberTerm.related_threat_actor
      description: Related threat actor names.
      type: String
    - contextPath: ThreatCommand.CyberTerm.related_campaigns
      description: Related campaign names.
      type: String
    - contextPath: ThreatCommand.CyberTerm.MitreAttack.tactic
      description: MITRE ATT&CK tactic name related to the cyber term.
      type: String
    - contextPath: ThreatCommand.CyberTerm.MitreAttack.Techniques.name
      description: MITRE ATT&CK technique names.
      type: String
    - contextPath: ThreatCommand.CyberTerm.MitreAttack.Techniques.url
      description: MITRE ATT&CK technique URLs.
      type: String
  - arguments:
    - description: Cyber term unique ID (dependencies - use threat-command-cyber-term-list
        command to get all the cyber term IDs).
      name: cyber_term_id
      required: true
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: List cyber term CVEs by cyber term ID.
    name: threat-command-cyber-term-cve-list
    outputs:
    - contextPath: ThreatCommand.CVE.id
      description: CVE ID.
      type: String
    - contextPath: ThreatCommand.CVE.publish_date
      description: CVE publish date.
      type: String
    - contextPath: ThreatCommand.CVE.vendor_product
      description: CVE vendor product.
      type: Number
  - arguments:
    - description: Cyber term unique ID (dependencies - use threat-command-cyber-term-list
        command to get all the cyber term IDs).
      name: cyber_term_id
      required: true
    - auto: PREDEFINED
      description: IOC types to include.
      name: ioc_type
      predefined:
      - Ip Addresses
      - Urls
      - Domains
      - Hashes
      - Emails
    - defaultValue: "1"
      description: The page number of the results to retrieve (1-based).
      name: page
    - description: The number of objects per page.
      name: page_size
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    description: List cyber term IOCs by cyber term ID.
    name: threat-command-cyber-term-ioc-list
    outputs:
    - contextPath: ThreatCommand.IOC.value
      description: The value of the IOC.
      type: String
    - contextPath: ThreatCommand.IOC.type
      description: The type of the IOC.
      type: String
    - contextPath: ThreatCommand.IOC.updated_date
      description: The date the IOC was last updated.
      type: String
    - contextPath: ThreatCommand.IOC.status
      description: The status of the IOC.
      type: String
    - contextPath: ThreatCommand.IOC.is_whitelisted
      description: Whether the IOC is whitelisted.
      type: String
    - contextPath: ThreatCommand.IOC.severity
      description: The severity of the IOC.
      type: String
    - contextPath: ThreatCommand.IOC.reporting_feeds
      description: List of reporting feeds in which the value appears.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Gets lists of IOC document sources.
    name: threat-command-source-list
    outputs:
    - contextPath: ThreatCommand.Source.id
      description: Source ID.
      type: String
    - contextPath: ThreatCommand.Source.name
      description: Source name.
      type: String
    - contextPath: ThreatCommand.Source.confidence_level
      description: Source confidence level.
      type: Number
    - contextPath: ThreatCommand.Source.is_enable
      description: Whether the source is enabled.
      type: Boolean
    - contextPath: ThreatCommand.Source.type
      description: Source type.
      type: String
  - arguments:
    - description: Source name.
      name: name
      required: true
    - description: Source description.
      name: description
      required: true
    - auto: PREDEFINED
      description: Source confidence level.
      name: confidence_level
      predefined:
      - "1"
      - "2"
      - "3"
      required: true
    - auto: PREDEFINED
      description: Whether to share this source with all tenants (available for MSSP
        users only).
      name: share
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Source severity level.
      name: severity
      predefined:
      - High
      - Medium
      - Low
    - description: Comma-separated list of user tags for the document.
      isArray: true
      name: tags
    - description: 'Comma-separated list of domain IOC values to add. For example:
        securitywap.com,test.com'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to add. For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to add. For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to add. For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to add. For example:
        test@test.com.'
      isArray: true
      name: emails
    description: Adds a new IOC source document. At least one IOC is required.
    name: threat-command-source-document-create
    outputs:
    - contextPath: ThreatCommand.Source.Files.id
      description: Document source ID.
      type: String
    - contextPath: ThreatCommand.Source.Files.name
      description: Document source name.
      type: String
  - arguments:
    - description: The ID of the source document (dependencies - use threat-command-source-ioc-get
        command with  source_type="Files" to get all the document source IDs).
      name: source_id
      required: true
    description: Deletes an existing IOC source document.
    name: threat-command-source-document-delete
  - arguments:
    - description: The ID of the source document (dependencies - use threat-command-source-ioc-get
        command with  source_type="Files" to get all the document source IDs).
      name: source_id
      required: true
    - description: 'Comma-separated list of domain IOC values to create. For example:
        securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to create. For example:
        "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to create. For example:
        8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to create. For example:
        8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to create. For example:
        test@test.com.'
      isArray: true
      name: emails
    description: Create new IOCs to existing IOC source documents. At least one IOC
      is required.
    name: threat-command-source-document-ioc-create
  - arguments:
    - description: 'IOC value. Required when last_updated_from is not selected. Not
        supported for email addresses. While using this argument, all the other filtering
        arguments are not relevant. '
      name: ioc_value
    - defaultValue: "1"
      description: The page number of the results to retrieve (1-based).
      name: page
    - description: The number of objects per page.
      name: page_size
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: 'Enrichment flag. Use True to enrich the data about the IOC. Supported
        IOC types are: Domains, URLs, IP addresses and file hashes. While using this
        argument, all the other filtering arguments are not relevant (except ioc_value). '
      name: enrichment
      predefined:
      - "true"
      - "false"
    - defaultValue: "30"
      description: The interval in seconds between each poll. Relevant while enrichment=true.
      name: interval_in_seconds
    - defaultValue: "600"
      description: The timeout in seconds until polling ends. Relevant while enrichment=true.
      name: timeout_in_seconds
    - description: 'Filter by last update date (IOC update date is greater than).
        For example:  2022-12-25T08:38:06Z. Required when ioc_value is not selected.'
      name: last_updated_from
    - description: 'Filter by last update date (IOC update date is less than). For
        example:  2022-12-25T08:38:06Z.'
      name: last_updated_to
    - description: 'Filter by last seen date (IOC last seen date is greater than).
        For example:  2022-12-25T08:38:06Z.'
      name: last_seen_from
    - description: 'Filter by last seen date (IOC last seen date is less than). For
        example:  2022-12-25T08:38:06Z.'
      name: last_seen_to
    - description: 'Filter by first seen date (IOC first seen date is greater than).
        For example:  2022-12-25T08:38:06Z.'
      name: first_seen_from
    - description: 'Filter by first seen date (IOC first seen date is less than).
        For example:  2022-12-25T08:38:06Z.'
      name: first_seen_to
    - auto: PREDEFINED
      description: Filter by IOC status.
      name: status
      predefined:
      - Active
      - Retired
    - auto: PREDEFINED
      description: 'Comma-separated list of IOC types to filter. For example: Urls,Domains.'
      isArray: true
      name: type_list
      predefined:
      - Ip Addresses
      - Urls
      - Domains
      - Hashes
      - Emails
    - auto: PREDEFINED
      description: 'Comma-separated list of IOC severities to filter. For example:
        Low,Medium.'
      isArray: true
      name: severity_list
      predefined:
      - High
      - Medium
      - Low
    - auto: PREDEFINED
      description: Filter by whitelist status.
      name: whitelisted
      predefined:
      - "true"
      - "false"
    - description: Comma-separated list of source IDs (dependencies - use threat-command-source-document-ioc-get
        command to get all the document source IDs).
      isArray: true
      name: source_ids
    - auto: PREDEFINED
      description: 'Comma-separated list of the phase of the Lockheed-Martin kills
        chain. For example: Delivery,Exploitation.'
      isArray: true
      name: kill_chain_phases
      predefined:
      - Reconnaissance
      - Weaponization
      - Delivery
      - Exploitation
      - Installation
      - Command and Control
      - Actions on Objective
    description: Gets IOC details by value or IOC's full enrichment data. While using
      the enrichment flag, the command is scheduled and allows us to get full enrichment
      data. Note that enrichment has a quota. You can get the quota by using threat-command-quotas-usage-get.
    name: threat-command-ioc-search
    outputs:
    - contextPath: ThreatCommand.IOC.value
      description: IOC value.
      type: String
    - contextPath: ThreatCommand.IOC.type
      description: IOC type.
      type: String
    - contextPath: ThreatCommand.IOC.Source.name
      description: IOC source name (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.Source.confindece_level
      description: IOC source confidence level(Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.system_tags
      description: IOC system tags (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.tags
      description: IOC tags.
      type: String
    - contextPath: ThreatCommand.IOC.status
      description: IOC status is determined based on how recently the IOC was last
        seen. (Active/Retired).The domain is active for 3 months, the Email address
        for 2 months, the File hash for 1 year, the IP address for 2 weeks, and the
        URL for 2 months.
      type: String
    - contextPath: ThreatCommand.IOC.is_known_ioc
      description: Whether the IOC is known (Relevant to enrichment only).
      type: Boolean
    - contextPath: ThreatCommand.IOC.related_malware
      description: Malware related to the IOC (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedThreatActors.value
      description: Threat actors related to the IOC (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.related_campaign
      description: Related campaign (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.first_seen
      description: IOC first seen date.
      type: Date
    - contextPath: ThreatCommand.IOC.last_seen
      description: IOC last seen date.
      type: Date
    - contextPath: ThreatCommand.IOC.update_seen
      description: IOC updated seen date (Relevant to enrichment only).
      type: Date
    - contextPath: ThreatCommand.IOC.is_whitelisted
      description: Whether the IOC is whitelisted.
      type: Boolean
    - contextPath: ThreatCommand.IOC.Severity.value
      description: IOC severity value.
      type: String
    - contextPath: ThreatCommand.IOC.Severity.score
      description: IOC severity score.
      type: Number
    - contextPath: ThreatCommand.IOC.Severity.origin
      description: IOC severity origin (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.DnsRecord.value
      description: IOC DNS recorded value (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.DnsRecord.type
      description: IOC DNS recorded type (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.DnsRecord.first_resolved
      description: IOC DNS recorded first resolved (Relevant to enrichment only).
      type: Date
    - contextPath: ThreatCommand.IOC.DnsRecord.last_resolved
      description: IOC DNS recorded last resolved (Relevant to enrichment only).
      type: Date
    - contextPath: ThreatCommand.IOC.DnsRecord.count
      description: IOC DNS record count (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.subdomains
      description: IOC subdomain (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.History.status
      description: History statuses (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.History.name_servers
      description: History name servers (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.Current.status
      description: Current statuses (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.Current.name_servers
      description: Current name servers (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.Resolution.resolved_ip_address
      description: Resolved IP address (Relevant to domain IOC) (Relevant to enrichment
        only).
      type: String
    - contextPath: ThreatCommand.IOC.Resolution.resolved_domain
      description: Resolved domain (Relevant to IP IOC) (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.Resolution.reporting_sources
      description: Reporting sources (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedHash.downloaded
      description: Download hashes (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedHash.communicating
      description: Communicating hashes (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedHashes.referencing
      description: Referencing hashes (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.antivirus_scan_date
      description: Antivirus scan date (Relevant to enrichment only).
      type: Date
    - contextPath: ThreatCommand.IOC.file_name
      description: File name (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.file_type
      description: File type (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.file_author
      description: File author (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.file_description
      description: File description (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.file_size
      description: File size (the file size is shown in bytes) (Relevant to enrichment
        only).
      type: Number
    - contextPath: ThreatCommand.IOC.antivirus_detection_ratio
      description: Antivirus detection ratio (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.antivirus_detected_engines
      description: Antivirus-detected engines (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.AntivirusDetection.name
      description: Detection name (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.AntivirusDetection.version
      description: Detection version (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.AntivirusDetection.detected
      description: Whether the IOC is detected (Relevant to enrichment only).
      type: Boolean
    - contextPath: ThreatCommand.IOC.AntivirusDetection.result
      description: Detection result (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedHash.type
      description: Hash type (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.RelatedHash.value
      description: Hash value (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.ip_range
      description: IOC IP range (Relevant to enrichment only).
      type: String
    - contextPath: ThreatCommand.IOC.last_update_date
      description: IOC last update date (Relevant to search mode only).
      type: Date
    - contextPath: ThreatCommand.IOC.geo_location
      description: Geo location code (Relevant to search mode only).
      type: String
    - contextPath: ThreatCommand.IOC.reportedFeeds.id
      description: IOC reported feed ID (Relevant to search mode only).
      type: String
    - contextPath: ThreatCommand.IOC.reportedFeeds.name
      description: IOC reported feed name (Relevant to search mode only).
      type: String
    - contextPath: ThreatCommand.IOC.reportedFeeds.confidence_level
      description: IOC reported feed confidence level (Relevant to search mode only).
      type: Number
    polling: true
  - arguments:
    - description: The IOC value.
      isArray: true
      name: ioc_value
      required: true
    - description: 'Comma-separated list of tags to add (Tag can be any word). For
        example: "Example Tag","Regional Alert".'
      isArray: true
      name: tag_values
      required: true
    description: Adds user tags to IOCs. This enables you to classify IOCs and later
      search for all IOCs with a specific tag. There is no indication of success or
      failure for this command. The user has to choose a correct and existing IOC.
    name: threat-command-ioc-tags-add
  - arguments:
    - auto: PREDEFINED
      description: 'The whitelist status for the IOCs. Add to the user whitelist -
        The IOCs will not be passed to integrated devices. Do not whitelist - The
        IOCs will be passed to integrated devices, even if the IOCs are on the system
        whitelist. '
      name: is_whitelisted
      predefined:
      - Add to the user whitelist
      - Do not whitelist
      required: true
    - description: 'Comma-separated list of domain IOC values to apply is_whitelisted
        to. For example: securitywap.com,test.com.'
      name: domains
    - description: 'Comma-separated list of URL IOC values to apply is_whitelisted
        to. For example: "http://securitywap.com/path".'
      name: urls
    - description: 'Comma-separated list of IP IOC values to apply is_whitelisted
        to. For example: 8.8.8.8,1.2.3.4.'
      name: ips
    - description: 'Comma-separated list of hash IOC values to apply is_whitelisted
        to. For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      name: hashes
    - description: 'Comma-separated list of email IOC values to apply is_whitelisted
        to. For example: test@test.com.'
      name: emails
    description: 'You can add an IOC to your user whitelist (even if it is already
      on the system whitelist). If you change your mind, you can then revert that
      decision to rely again on the system designation using the threat-command-account-whitelist-remove
      command. When an IOC is whitelisted, it will not be sent to integrated security
      to block. When an IOC is not whitelisted, it will be sent to integrated security
      devices to block. There is no indication of success or failure for this command.
      The user has to choose a correct and existing IOC. At least one IOC is required. '
    name: threat-command-account-whitelist-update
  - arguments:
    - description: 'Comma-separated list of domain IOC values to be reverted back
        to the system whitelist default. For example: securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to be reverted back to
        the system whitelist default. For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of domain IOC values to be reverted back
        to the system whitelist default. For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of domain IOC values to be reverted back
        to the system whitelist default. For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of domain IOC values to be reverted back
        to the system whitelist default. For example: test@test.com.'
      isArray: true
      name: emails
    description: Reverts IOC values to the system-default whitelist status. The ETP
      Suite automatically whitelists certain IOCs, such as company assets. You can
      override this designation or ensure that certain IOCs will not be system whitelisted
      using the threat-command-account-whitelist-update command. There is no indication
      of success or failure for this command. The user has to choose a correct and
      existing IOC. At least one IOC is required.
    name: threat-command-account-whitelist-remove
  - arguments:
    - description: 'Comma-separated list of domain IOC values to add to the Remediation
        blocklist. For example: securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to add to the Remediation
        blocklist. For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC valuesto add to the Remediation
        blocklist. For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to add to the Remediation
        blocklist. For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to add to the Remediation
        blocklist. For example: test@test.com.'
      isArray: true
      name: emails
    description: Adds an IOC to an internal Remediation Blocklist. By sending the
      blocklist to security devices, you can block the IOCs. At least one IOC is required.
    name: threat-command-ioc-blocklist-add
  - arguments:
    - description: 'Comma-separated list of domain IOC values to remove from the Remediation
        blocklist. For example: securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to remove from the Remediation
        blocklist. For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to remove from the Remediation
        blocklist. For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to remove from the Remediation
        blocklist. For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to remove from the Remediation
        blocklist. For example: test@test.com.'
      isArray: true
      name: emails
    description: Removes IOC values from the Remediation blocklist. There is no indication
      of success or failure for this command. The user has to choose a correct and
      existing IOC. At least one IOC is required.
    name: threat-command-ioc-blocklist-remove
  - arguments:
    - auto: PREDEFINED
      description: The severity of the IOCs.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      required: true
    - description: 'Comma-separated list of domain IOC values to update the severity.
        For example: securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to update the severity.
        For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to update the severity.
        For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to update the severity.
        For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to update the severity.
        For example: test@test.com.'
      isArray: true
      name: emails
    description: Changes the severity of existing IOCs for the requester account (overrides
      the system severity). At least one IOC is required.
    name: threat-command-ioc-severity-update
  - arguments:
    - description: The comment to add.
      name: comment
      required: true
    - description: 'Comma-separated list of domain IOC values to add the comment to.
        For example: securitywap.com,test.com.'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to add the comment to.
        For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to add the comment to. For
        example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of hash IOC values to add the comment to.
        For example: 8100f3d2668f0f61e6c7ea0dfda59458111238dfeeb9bf47d9fa7543abfb6fb7.'
      isArray: true
      name: hashes
    - description: 'Comma-separated list of email IOC values to add the comment to.
        For example: test@test.com.'
      isArray: true
      name: emails
    description: Adds comments to IOCs. At least one IOC is required.
    name: threat-command-ioc-comment-add
  - arguments: []
    description: Gets the current API enrichment credits ("quota") usage for the requester
      account.
    name: threat-command-enrichment-quota-usage
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
    - defaultValue: "1"
      description: The page number of the results to retrieve (1-based).
      name: page
    - description: The number of objects per page.
      name: page_size
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Retrieve alert IDs only. Set to False in order to get the alerts
        with complete data details, and set to True in order to get a list of alerts.
      name: retrieve_ids_only
      predefined:
      - "true"
      - "false"
    - defaultValue: "1970-01-01T00:00:00.000Z"
      description: 'Start date to fetch from. For example:  2022-12-25T08:38:06Z.'
      name: last_updated_from
    - auto: PREDEFINED
      description: Alert's type.
      isArray: true
      name: alert_type
      predefined:
      - Attack Indication
      - Data Leakage
      - Phishing
      - Brand Security
      - Exploitable Data
      - vip
    - auto: PREDEFINED
      description: Comma-separated list of alert severities. For example:High,Medium.
      isArray: true
      name: severity
      predefined:
      - High
      - Medium
      - Low
    - auto: PREDEFINED
      description: Comma-separated list of alert source types. For example:Others,Markets.
      isArray: true
      name: source_type
      predefined:
      - Application Stores
      - Black Markets
      - Hacking Forums
      - Social Media
      - Paste Sites
      - Others
    - auto: PREDEFINED
      description: Comma-separated list of alert network types. For example:Clear
        Web,Dark Web.
      isArray: true
      name: network_type
      predefined:
      - Clear Web
      - Dark Web
    - description: Comma-separated list of alert matched assets.
      isArray: true
      name: matched_asset_value
    - description: 'End date to fetch to. For example:  2022-12-25T08:38:06Z.'
      name: last_updated_to
    - description: 'Start date to fetch from. For example:  2022-12-25T08:38:06Z.'
      name: source_date_from
    - description: 'End date to fetch to. For example:  2022-12-25T08:38:06Z.'
      name: source_date_to
    - description: 'Start date to fetch from. For example:  2022-12-25T08:38:06Z.'
      name: found_date_from
    - description: 'End date to fetch to. For example:  2022-12-25T08:38:06Z.'
      name: found_date_to
    - auto: PREDEFINED
      description: Show assigned/unassigned alerts.
      name: assigned
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Show flagged/unflagged alerts.
      name: is_flagged
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show closed/open alerts.
      name: is_closed
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Show alerts with IOC results.
      name: has_ioc
      predefined:
      - "true"
      - "false"
    description: Get a list of alerts with all details.
    name: threat-command-alert-list
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.assets.type
      description: Asset type.
      type: Date
    - contextPath: ThreatCommand.Alert.assets.value
      description: Asset value.
      type: String
    - contextPath: ThreatCommand.Alert.assignees
      description: Assignees list.
      type: String
    - contextPath: ThreatCommand.Alert.type
      description: Alert type list.
      type: String
    - contextPath: ThreatCommand.Alert.sub_type
      description: Alert sub type.
      type: String
    - contextPath: ThreatCommand.Alert.title
      description: Alert title.
      type: String
    - contextPath: ThreatCommand.Alert.description
      description: Alert description.
      type: String
    - contextPath: ThreatCommand.Alert.severity
      description: Alert severity.
      type: String
    - contextPath: ThreatCommand.Alert.images
      description: Alert images list.
      type: String
    - contextPath: ThreatCommand.Alert.source_type
      description: Alert type.
      type: String
    - contextPath: ThreatCommand.Alert.source_url
      description: Alert URL source.
      type: String
    - contextPath: ThreatCommand.Alert.source_email
      description: Alert email source.
      type: String
    - contextPath: ThreatCommand.Alert.source_network_type
      description: Alert network type.
      type: String
    - contextPath: ThreatCommand.Alert.source_date
      description: Alert date.
      type: Date
    - contextPath: ThreatCommand.Alert.Tags.created_by
      description: Alert tag creator.
      type: String
    - contextPath: ThreatCommand.Alert.Tags.name
      description: Alert tag name.
      type: String
    - contextPath: ThreatCommand.Alert.Tags.id
      description: Alert tag ID.
      type: String
    - contextPath: ThreatCommand.Alert.related_iocs
      description: Alert related IOC list.
      type: String
    - contextPath: ThreatCommand.Alert.found_date
      description: Alert found date.
      type: String
    - contextPath: ThreatCommand.Alert.update_date
      description: Alert update date.
      type: String
    - contextPath: ThreatCommand.Alert.takedown_status
      description: Alert remediation status.
      type: String
    - contextPath: ThreatCommand.Alert.is_closed
      description: Whether the alert is closed.
      type: Boolean
    - contextPath: ThreatCommand.Alert.is_flagged
      description: Whether the alert is flagged.
      type: Boolean
    - contextPath: ThreatCommand.Alert.related_threat_ids
      description: Alert-related threat IDs.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - auto: PREDEFINED
      defaultValue: Domain
      description: Takedown target. Available for phishing scenarios only. If you
        have evidence of malicious activity associated with this domain, select Domain.
      name: target
      predefined:
      - Domain
      - Website
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to close the alert after successful remediation.
      name: close_alert_after_success
      predefined:
      - "true"
      - "false"
    description: Send a takedown request for the selected alert (Request that Threat
      Command will contact the host to request a takedown of a malicious domain, website,
      or mobile application).
    name: threat-command-alert-takedown-request
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Get the alert's takedown status.
    name: threat-command-alert-takedown-request-status-get
    outputs:
    - contextPath: ThreatCommand.Alert.takedown_status
      description: Alert's takedown status.
      type: String
  - arguments:
    - description: 'Alert''s found date. For example:  2022-12-25T08:38:06Z. The defaut
        value is the current time.'
      name: found_date
    - description: Alert's title.
      name: title
      required: true
    - description: Alert's description.
      name: description
      required: true
    - auto: PREDEFINED
      description: Alert's type (dependencies - use threat-command-alert-type-list
        command to get all the alert types). Required while scenario not inserted.
      name: type
      predefined:
      - Attack Indication
      - Data Leakage
      - Phishing
      - Brand Security
      - Exploitable Data
      - vip
    - description: Alert subtype (dependencies - use threat-command-alert-type-list
        command to get all the alert subtypes). Required while scenario not inserted.
      name: sub_type
    - auto: PREDEFINED
      description: Alert's severity.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      required: true
    - description: Alert source type (dependencies - use threat-command-alert-source-type-list
        command to get all the alert source types).
      name: source_type
      required: true
    - auto: PREDEFINED
      description: Source network type.
      name: source_network_type
      predefined:
      - Clear Web
      - Dark Web
      required: true
    - description: 'The source URL of the alert. '
      name: source_url
    - description: 'Alert''s source date. For example:  2022-12-25T08:38:06Z.'
      name: source_date
    - description: 'Comma-separated list of image entry IDs to attach to the alert.
        Allowed image types: gif,jpeg.'
      isArray: true
      name: image_entry_ids
    - description: If provided, the related values will override any type and sub_type
        parameters (dependencies - use the threat-command-alert-scenario-list command
        to get all the alert scenarios).
      name: scenario
    description: Create a new alert. You have to insert scenario or type and sub_type.
    name: threat-command-alert-create
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: Alert's closed reason.
      name: reason
      predefined:
      - Problem Solved
      - Informational Only
      - Problem We Are Already Aware Of
      - Company Owned Domain
      - Legitimate Application/Profile
      - Not Related To My Company
      - False Positive
      - Other
      required: true
    - description: Alert's comments.
      name: comment
    - auto: PREDEFINED
      defaultValue: "false"
      description: Alerts' hidden status (Delete alert from the account instance only
        when reason is FalsePositive).
      name: is_hidden
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: 'Alert''s rate. Rate range: 0-5 (The range not officaly documented).'
      name: rate
      predefined:
      - "0"
      - "1"
      - "2"
      - "3"
      - "4"
      - "5"
    description: Close alert.
    name: threat-command-alert-close
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.is_closed
      description: Whether the alert is closed.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: The desired severity.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      required: true
    description: Change the alert's severity. Changing the severity level of alerts
      can help to prioritize alert management.
    name: threat-command-alert-severity-update
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.severity
      description: Alert severity.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Get alert's blocklist status.
    name: threat-command-alert-blocklist-get
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.BlockList.value
      description: Alert blocklist value.
      type: String
    - contextPath: ThreatCommand.Alert.BlockList.status
      description: Alert blocklist status.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: 'Comma-separated list of domain IOC values to add. For example:
        securitywap.com,test.com'
      isArray: true
      name: domains
    - description: 'Comma-separated list of URL IOC values to add. For example: "http://securitywap.com/path".'
      isArray: true
      name: urls
    - description: 'Comma-separated list of IP IOC values to add. For example: 8.8.8.8,1.2.3.4.'
      isArray: true
      name: ips
    - description: 'Comma-separated list of email IOC values to add. For example:
        test@test.com.'
      isArray: true
      name: emails
    - auto: PREDEFINED
      description: Blocklist status.
      name: blocklist_status
      predefined:
      - Sent
      - Not Sent
      required: true
    description: Change selected IOCs blocklist status.
    name: threat-command-alert-blocklist-update
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Comma-separated list of the desired source names (dependencies
        - use threat-command-source-ioc-get to get all the source names). For example:GoogleWebRisk,PhishTank.Since
        there are variety of sources that accept different types of IOCs, select only
        sources that accept the alert IOCs.
      isArray: true
      name: external_sources
      required: true
    description: Report IOCs to external sources (Report the URLs and domains that
      are included in an alert to external sources. This can warn others of the potential
      danger of those IOCs).
    name: threat-command-alert-ioc-report
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Assigned user ID (dependencies - use threat-command-mssp-user-list
        or threat-command-account-user-list to get user IDs).
      name: user_id
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: If the assigned user is an MSSP user or not.
      name: is_mssp
      predefined:
      - "true"
      - "false"
    description: Assign an alert to other ETP Suite users. When an alert is assigned,
      the assignee will receive a notification. Mainly used to assign alerts.
    name: threat-command-alert-assign
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.assignees
      description: Assignees list.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Unassign an alert from all users.
    name: threat-command-alert-unassign
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.assignees
      description: Assignees list.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Reopen alert.
    name: threat-command-alert-reopen
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: The new tag string.
      name: tag_name
      required: true
    description: Adds a tag to an alert. This enables you to classify alerts and later
      search for all alerts with a specific tag.
    name: threat-command-alert-tag-add
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Tag's unique ID to remove (dependencies - use threat-command-alert-list
        command to get all the tag IDs).
      name: tag_id
      required: true
    description: Removes a tag from the alert.
    name: threat-command-alert-tag-remove
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Comma-separated list of destinaions email addresses.
      isArray: true
      name: email_addresses
      required: true
    - description: Content added to the alert details.
      name: content
      required: true
    description: Send mail with the alert details and a question.
    name: threat-command-alert-send-mail
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Question added to the alert details.
      name: question
      required: true
    description: Send a question to an analyst about the requested alert. Questions
      can revolve around an alert explanation, a request for more context, recommended
      remediation steps, or requests for threat actor engagement. In order to get
      the conversation with the analyst, use the threat-command-alert-analyst-conversation-list
      command.
    name: threat-command-alert-analyst-ask
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Get alert's analyst response.
    name: threat-command-alert-analyst-conversation-list
    outputs:
    - contextPath: ThreatCommand.Alert.id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.Alert.Message.date
      description: Response date.
      type: String
    - contextPath: ThreatCommand.Alert.Message.initiator
      description: Response initiator.
      type: String
    - contextPath: ThreatCommand.Alert.Message.message
      description: Response message.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Get alert activity log.
    name: threat-command-alert-activity-log-get
    outputs:
    - contextPath: ThreatCommand.Alert.ActivityLog.rate
      description: Alert rate.
      type: Number
    - contextPath: ThreatCommand.Alert.ActivityLog.type
      description: Alert type.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.sub_types
      description: Alert subtypes.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.initiator
      description: Alert initiator.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.created_date
      description: Alert created date.
      type: Date
    - contextPath: ThreatCommand.Alert.ActivityLog.update_date
      description: Alert update date.
      type: Date
    - contextPath: ThreatCommand.Alert.ActivityLog.read_by
      description: Alert read by.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.id
      description: Alert created ID.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.tag_names
      description: Alert tag names.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.tag_ids
      description: Alert tag IDs.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.note_id
      description: Alert note ID.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.question
      description: Alert mail question.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.Replies.email
      description: Alert mail reply email.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.Replies.token
      description: Alert mail reply token.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.Replies.date
      description: Alert mail reply date.
      type: Date
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.Replies.read_by
      description: Alert mail read by.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Mail.Replies.is_token_valid
      description: Alert mail reply is token valid.
      type: Boolean
    - contextPath: ThreatCommand.Alert.ActivityLog.Messages.initiator_id
      description: Alert message ID.
      type: String
    - contextPath: ThreatCommand.Alert.ActivityLog.Messages.initiator_is_support
      description: Whether asking the analyst is supported.
      type: Boolean
    - contextPath: ThreatCommand.Alert.ActivityLog.Messages.date
      description: Alert message date.
      type: Date
    - contextPath: ThreatCommand.Alert.ActivityLog.Messages.content
      description: Alert message content.
      type: String
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: Get alert's CSV file in case of credentials leakage or leaked credit
      cards alerts.
    name: threat-command-alert-csv-get
    outputs:
    - contextPath: ThreatCommand.CSV.alert_id
      description: Alert ID.
      type: String
    - contextPath: ThreatCommand.CSV.content
      description: Content of CSV file.
      type: Unknown
    - contextPath: InfoFile.EntryID
      description: The EntryID of the CSV file.
      type: string
    - contextPath: InfoFile.Extension
      description: The extension of the CSV file.
      type: string
    - contextPath: InfoFile.Name
      description: The name of the CSV file.
      type: string
    - contextPath: InfoFile.Info
      description: The info of the CSV file.
      type: string
    - contextPath: InfoFile.Size
      description: The size of the CSV file.
      type: number
    - contextPath: InfoFile.Type
      description: The type of the CSV file.
      type: string
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    - description: Desired note.
      name: note
      required: true
    - description: 'Comma-separated list of file entry IDs. Allowed types: pdf,csv,doc,docx,png,txt,jpeg,jpg.'
      isArray: true
      name: entry_ids
    description: Add a note to the alert. You can add notes, as text or uploaded files,
      to an alert that can be seen by internal users. Each note is accompanied by
      the name of the note creator. Other users can reply to notes. Alert notes remain
      with the alert, even after it is closed or otherwise remediated.
    name: threat-command-alert-note-add
  - arguments:
    - description: Alert's unique ID (dependencies - use threat-command-alert-list
        command to get all the alert IDs).
      name: alert_id
      required: true
    description: List alert images by ID.
    name: threat-command-alert-image-list
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - description: This field is used for pagination. Each request is limited to 1000
        results. To get the next page, send the returned "nextOffset" parameter back
        to the sever as "offset".
      name: offset
    - description: 'CVE''s publish date minimum value. For example:  2022-12-25T08:38:06Z.'
      name: publish_date_from
    - description: 'CVE''s publish date maximum value. For example:  2022-12-25T08:38:06Z.'
      name: publish_date_to
    - description: 'CVE''s update date minimum value. For example:  2022-12-25T08:38:06Z.'
      name: update_date_from
    - description: 'CVE''s update date maximum value. For example:  2022-12-25T08:38:06Z.'
      name: update_date_to
    - auto: PREDEFINED
      description: Comma-separated list of CVE severities.
      isArray: true
      name: severity_list
      predefined:
      - Critical
      - High
      - Medium
      - Low
    - description: Comma-separated list of CPEs.
      isArray: true
      name: cpe_list
    - description: Comma-separated list of specific CVE IDs.
      isArray: true
      name: cve_ids
    description: Get CVE's list from account.
    name: threat-command-cve-list
    outputs:
    - contextPath: ThreatCommand.CVE.id
      description: CVE ID.
      type: String
    - contextPath: ThreatCommand.CVE.Cpe.value
      description: CVE CPE value.
      type: String
    - contextPath: ThreatCommand.CVE.Cpe.title
      description: CVE CPE title.
      type: String
    - contextPath: ThreatCommand.CVE.Cpe.vendor_product
      description: CVE CPE vendor.
      type: String
    - contextPath: ThreatCommand.CVE.published_date
      description: CVE CP publish date.
      type: Date
    - contextPath: ThreatCommand.CVE.update_date
      description: CVE update date.
      type: Date
    - contextPath: ThreatCommand.CVE.severity
      description: CVE severity.
      type: String
    - contextPath: ThreatCommand.CVE.intsights_score
      description: CVE insight score.
      type: Number
    - contextPath: ThreatCommand.CVE.cvss_score
      description: CVE CVSS score.
      type: Number
    - contextPath: ThreatCommand.CVE.mentions_amount
      description: CVE mentions amount.
      type: Number
    - contextPath: ThreatCommand.CVE.paste_site_mentions
      description: CVE paste site mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.hacking_forum_mentions
      description: CVE hacking forum mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.instant_message_mentions
      description: CVE instant message mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.dark_web_mentions
      description: CVE dark web mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.clear_web_cyber_blogs_mentions
      description: CVE clear web cyber blogs mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.code_repositories_mentions
      description: CVE code repositories mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.exploit_mentions
      description: CVE exploit mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.social_media_mentions
      description: CVE social media mentions.
      type: Number
    - contextPath: ThreatCommand.CVE.first_mention_date
      description: CVE first mention date.
      type: Date
    - contextPath: ThreatCommand.CVE.last_mention_date
      description: CVE last mention date.
      type: Date
    - contextPath: ThreatCommand.CVE.exploit_availability
      description: CVE exploit availability.
      type: Boolean
    - contextPath: ThreatCommand.CVE.vulnerability_origin
      description: CVE last vulnerability origin.
      type: String
    - contextPath: ThreatCommand.CVE.related_threat_actors
      description: Related threat actors.
      type: String
    - contextPath: ThreatCommand.CVE.related_malware
      description: Related malware.
      type: String
    - contextPath: ThreatCommand.CVE.related_campaigns
      description: Related campaigns.
      type: String
  - arguments:
    - description: Comma-separated list of CVEs unique IDs.
      isArray: true
      name: cve_ids
      required: true
    description: Add CVEs to account.
    name: threat-command-cve-add
  - arguments:
    - description: Comma-separated list of CVEs unique IDs (dependencies - use threat-command-cve-listto
        get all the CVE IDs).
      isArray: true
      name: cve_ids
      required: true
    description: Delete CVEs from account.
    name: threat-command-cve-delete
  - arguments:
    - description: 'The type of asset to add value. For example: asset_type="Domains"
        asset_value="example.com". (You can get the asset types with threat-command-asset-type-list
        command).'
      name: asset_type
      required: true
    - description: Asset value.
      name: asset_value
      required: true
    description: Add assets by type and value. Assets include any company resource
      that could lead to a potential security threat.
    name: threat-command-asset-add
    outputs:
    - contextPath: ThreatCommand.Asset.type
      description: The type of the asset.
      type: String
    - contextPath: ThreatCommand.Asset.value
      description: The value of the asset type.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_results
      predefined:
      - "true"
      - "false"
    - description: 'Comma-separated list of alert source types (dependencies - use
        threat-command-asset-type-list command to get all the asset types). For example:Domains,CompanyNames. '
      isArray: true
      name: asset_types
    description: Get account assets grouped by asset type.
    name: threat-command-asset-list
    outputs:
    - contextPath: ThreatCommand.Asset.type
      description: The type of the asset.
      type: String
    - contextPath: ThreatCommand.Asset.value
      description: The value of the asset type.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_results
      predefined:
      - "true"
      - "false"
    description: Get all asset types. Mainly used to add or delete assets.
    name: threat-command-asset-type-list
    outputs:
    - contextPath: ThreatCommand.AssetType
      description: Asset type.
      type: String
  - arguments:
    - description: 'The type of asset to add value. For example: asset_type="Domains"
        asset_value="example.com". (You can get the asset types with threat-command-asset-type-list
        command).'
      name: asset_type
      required: true
    - description: Asset value.
      name: asset_value
      required: true
    description: Delete asset by type and value.
    name: threat-command-asset-delete
  - arguments: []
    description: List the system modules of your account.
    name: threat-command-account-system-modules-list
    outputs:
    - contextPath: ThreatCommand.SystemModule.module_name
      description: Module name.
      type: String
    - contextPath: ThreatCommand.SystemModule.status
      description: Whether the module module is enabled.
      type: String
  - arguments:
    - description: 'Search using simple keywords (you can choose the search keywords
        by the outputs keywords), basic operators, search operators, and by document
        type. Basic operators: Use AND, OR, NOT, and (). For example: Searching for
        "bin_number: 1234 AND email_user_name: john_smith" returns all results that
        contain this BIN number and that username as the email user name, Searching
        for "comment_number: 17 AND author: gyber" returns all results with 17 comments
        and the author is Gyber. '
      name: search
      required: true
    - description: 'Supply time-frame. For example:  2022-12-25T08:38:06Z.'
      name: report_date
    - defaultValue: "0"
      description: Zero-based page number. 15 results per page.
      name: page_number
    - auto: PREDEFINED
      description: A comma-separated list of source types to filter.
      name: source_types
      predefined:
      - Social Media
      - Paste Site
      - Hacking Forum
      - Instant Message
      - Black Market
      - Cyber Security Blog
      - Web Page
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show only mentions from the dark web or not.
      name: only_dark_web
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "true"
      description: Show highlight tags (<em>) in the content or not.
      name: highlight_tags
      predefined:
      - "true"
      - "false"
    description: Search for strings in the scrapes database.
    name: threat-command-mention-search
    outputs:
    - contextPath: ThreatCommand.Mentions.author
      description: Mention author.
      type: String
    - contextPath: ThreatCommand.Mentions.comment_number
      description: Mentions comments number.
      type: Number
    - contextPath: ThreatCommand.Mentions.original_url
      description: Mentions original URL.
      type: String
    - contextPath: ThreatCommand.Mentions.source_date
      description: Mentions source date.
      type: Date
    - contextPath: ThreatCommand.Mentions.url
      description: Mention URL.
      type: String
    - contextPath: ThreatCommand.Mentions.insertion_date
      description: Mention insertion date.
      type: Date
    - contextPath: ThreatCommand.Mentions.type
      description: Mention type.
      type: String
    - contextPath: ThreatCommand.Mentions.Tags.is_product_for_sale
      description: Whether the product for sale.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.credit_cards
      description: Whether the mention includes credit cards.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.domains
      description: Whether the mention includes domains.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.emails
      description: Whether the mention includes emails.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.ips
      description: Whether the mention includes IPs.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.ssns
      description: Whether the mention includes SSNs (Switched Service Networks).
      type: Boolean
    - contextPath: ThreatCommand.Mentions.Tags.urls
      description: Whether the mention includes URLs.
      type: Boolean
    - contextPath: ThreatCommand.Mentions.id
      description: Mention ID.
      type: String
    - contextPath: ThreatCommand.Mentions.short_content
      description: Mention short content.
      type: String
    - contextPath: ThreatCommand.Mentions.title
      description: Mention title.
      type: String
    - contextPath: ThreatCommand.Mentions.date
      description: Mention date.
      type: Date
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    description: Get all Managed Security Service Provider's (MSSP) sub-accounts.
    name: threat-command-mssp-customer-list
    outputs:
    - contextPath: ThreatCommand.MsspCustomer.id
      description: Customer ID.
      type: String
    - contextPath: ThreatCommand.MsspCustomer.company_name
      description: Customer company name.
      type: String
    - contextPath: ThreatCommand.MsspCustomer.status
      description: Customer status.
      type: String
    - contextPath: ThreatCommand.MsspCustomer.note
      description: Customer note.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    description: Get the details of the MSSPs users (In case you are an MSSP account).
    name: threat-command-mssp-user-list
    outputs:
    - contextPath: ThreatCommand.MsspUser.id
      description: User ID.
      type: String
    - contextPath: ThreatCommand.MsspUser.email
      description: User email.
      type: String
    - contextPath: ThreatCommand.MsspUser.role
      description: User role.
      type: String
    - contextPath: ThreatCommand.MsspUser.is_deleted
      description: Whether the user was deleted.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: Type of the user.
      name: user_type
      predefined:
      - Admin
      - Analyst
    - description: Email of the user.
      name: user_email
    - description: The ID of the user.
      name: user_id
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    description: List the users in your account. Mainly used to assign alerts.
    name: threat-command-account-user-list
    outputs:
    - contextPath: ThreatCommand.AccountUser.id
      description: User ID.
      type: String
    - contextPath: ThreatCommand.AccountUser.email
      description: User email.
      type: String
    - contextPath: ThreatCommand.AccountUser.first_name
      description: User first name.
      type: String
    - contextPath: ThreatCommand.AccountUser.last_name
      description: User last name.
      type: String
    - contextPath: ThreatCommand.AccountUser.role
      description: User role.
      type: String
    - contextPath: ThreatCommand.AccountUser.is_deleted
      description: Whether the user was deleted.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    description: List alert types and sub-types. They are mainly used to add manual
      alerts.
    name: threat-command-alert-type-list
    outputs:
    - contextPath: ThreatCommand.AlertType.type
      description: Type.
      type: String
    - contextPath: ThreatCommand.AlertType.sub_type
      description: Sub-type of the type.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    description: List alert source types. They are mainly used to add manual alerts.
    name: threat-command-alert-source-type-list
    outputs:
    - contextPath: ThreatCommand.AlertSourceType
      description: List of source types.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of records to retrieve.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Show all results if True.
      name: all_result
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Alert type (dependencies - use threat-command-alert-type-list command
        to get all the alert types).
      name: type
      predefined:
      - Attack Indication
      - Data Leakage
      - Phishing
      - Brand Security
      - Exploitable Data
      - vip
    - description: Alert's sub-type (dependencies - use threat-command-alert-type-list
        command to get all the alert subtypes).
      name: sub_type
    description: List alert scenarios. They are mainly used to add manual alerts.
    name: threat-command-alert-scenario-list
    outputs:
    - contextPath: ThreatCommand.Scenario.type
      description: Alert type.
      type: String
    - contextPath: ThreatCommand.Scenario.subtype
      description: Alert sub-type.
      type: String
    - contextPath: ThreatCommand.Scenario.scenario
      description: Name of the scenario.
      type: String
    - contextPath: ThreatCommand.Scenario.description
      description: Short description of the scenario.
      type: String
  - arguments:
    - defaultValue: "-1"
      description: Unfinished IOCs number.
      hidden: true
      name: unfinished_enriches
      required: true
    - default: true
      description: Hash of the file to query. Supports MD5, SHA1, and SHA256.
      isArray: true
      name: file
      required: true
    - defaultValue: "30"
      description: The interval in seconds between each poll.
      name: interval_in_seconds
    - defaultValue: "600"
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Runs reputation on files.
    name: file
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.sha512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.name
      description: The full file name (including file extension).
      type: String
    - contextPath: File.description
      description: The description of the file.
      type: String
    - contextPath: File.size
      description: The size of the file.
      type: String
    - contextPath: File.file_type
      description: The type of the file.
      type: String
    - contextPath: File.tags
      description: The tags of the file.
      type: String
    - contextPath: File.actor
      description: Related threat actors to the file.
      type: String
    - contextPath: File.campaign
      description: Related threat campaigns to the file.
      type: String
    - contextPath: File.associated_file_names
      description: Assosiated file names to the file.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    polling: true
  - arguments:
    - defaultValue: "-1"
      description: Unfinished IOCs number.
      hidden: true
      name: unfinished_enriches
      required: true
    - default: true
      description: IP address to check.
      isArray: true
      name: ip
      required: true
    - defaultValue: "30"
      description: The interval in seconds between each poll.
      name: interval_in_seconds
    - defaultValue: "600"
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Checks the reputation of an IP address.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: IP.ASN
      description: IP ASN.
      type: String
    - contextPath: IP.Address
      description: IP address.
      type: String
    - contextPath: IP.Region
      description: IP region.
      type: String
    - contextPath: IP.UpdatedDate
      description: IP updated date.
      type: String
    - contextPath: ThreatCommand.IP.asn
      description: IP ASN.
      type: String
    - contextPath: ThreatCommand.IP.ip
      description: IP address.
      type: String
    - contextPath: ThreatCommand.IP.region
      description: IP region.
      type: String
    - contextPath: ThreatCommand.IP.updated_date
      description: IP updated date.
      type: String
    polling: true
  - arguments:
    - defaultValue: "-1"
      description: Unfinished IOCs number.
      hidden: true
      name: unfinished_enriches
      required: true
    - default: true
      description: A comma-separated list of URLs to check. This command will not
        work properly on URLs containing commas.
      isArray: true
      name: url
      required: true
    - defaultValue: "10"
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format.
      name: sampleSize
    - defaultValue: "30"
      description: The interval in seconds between each poll.
      name: interval_in_seconds
    - defaultValue: "600"
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Checks the reputation of a URL.
    name: url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: URL.Data
      description: The URL value.
      type: String
    - contextPath: URL.DetectionEngines
      description: URL detection engines.
      type: String
    - contextPath: URL.PositiveDetections
      description: Number of positive engines.
      type: Number
    - contextPath: URL.Tags
      description: URL tags.
      type: Number
    - contextPath: ThreatCommand.URL.detection_engines
      description: URL detection engines.
      type: String
    - contextPath: ThreatCommand.URL.positive_detections
      description: URL positive detection engines.
      type: String
    - contextPath: ThreatCommand.URL.tags
      description: URL tags.
      type: String
    - contextPath: ThreatCommand.URL.url
      description: The URL value.
      type: Number
    polling: true
  - arguments:
    - defaultValue: "-1"
      description: Unfinished IOCs number.
      hidden: true
      name: unfinished_enriches
      required: true
    - default: true
      description: Domain name to check.
      isArray: true
      name: domain
      required: true
    - defaultValue: "30"
      description: The interval in seconds between each poll.
      name: interval_in_seconds
    - defaultValue: "600"
      description: The timeout in seconds until polling ends.
      name: timeout_in_seconds
    description: Checks the reputation of a domain.
    name: domain
    outputs:
    - contextPath: Domain.domain
      description: Domain found.
      type: String
    - contextPath: Domain.Name
      description: The name of the domain that was checked.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: Domain.DNSRecords
      description: DNS records of the domain.
      type: String
    - contextPath: ThreatCommand.Domain.domain
      description: The domain value.
      type: String
    - contextPath: ThreatCommand.Domain.sub_domains
      description: Sub domains of the domain.
      type: Date
    - contextPath: ThreatCommand.Domain.tags
      description: Tags of the domain.
      type: String
    - contextPath: ThreatCommand.Domain.updated_date
      description: Domain updated date.
      type: String
    polling: true
  dockerimage: demisto/python3:3.11.9.103066
  isfetch: true
  runonce: false
  script: |
    register_module_line('rapid7_threat_command', 'start', __line__())
    ### pack version: 3.1.4


    from http import HTTPStatus
    from enum import Enum, StrEnum
    from typing import Any, cast
    from collections.abc import Callable
    import copy
    from requests import Response
    import pathlib
    import re
    import csv

    DEFAULT_INTERVAL = 30
    DEFAULT_TIMEOUT = 600
    ISO_8601_FORMAT = "%Y-%m-%dT%H:%M:%S.000Z"
    INTEGRATION_ENTRY_CONTEXT = "ThreatCommand"
    BACKOFF_FACTOR = 15  # Consider its double.
    RETRIES = 3  # One retry is completed right away, so it should be viewed as a minor attempt.
    STATUS_LIST_TO_RETRY = [429] + list(range(500, 600))


    class Headers(list, Enum):
        GET_ALERT = [
            "id",
            "type",
            "sub_type",
            "title",
            "description",
            "severity",
            "found_date",
            "is_closed",
            "Tags",
            "assignees",
        ]
        LIST_CYBER_TERM = [
            "id",
            "name",
            "severity",
            "overview",
            "target_countries",
            "sectors",
            "ttp",
            "related_malware",
            "related_campaigns",
        ]
        GET_IOC = [
            "value",
            "type",
            "status",
            "is_whitelisted",
            "score",
            "severity",
            "last_update_date",
        ]
        MENTION = [
            "author",
            "original_url",
            "url",
            "type",
            "id",
            "short_content",
            "title",
            "date",
        ]
        ENRICH_IOC = [
            "value",
            "Source",
            "status",
            "is_known_ioc",
            "update_seen",
            "is_whitelisted",
            "Severity",
        ]


    class ReadableOutputs(str, Enum):
        CYBER_TERM_CVES = "Related CVEs to Cyber term {0}"
        CYBER_TERM_IOCS = "Related IOCs to Cyber term {0}"
        CYBER_TERM = "Cyber terms"
        IOC_SOURCE = "IOC sources"
        SYSTEM_MODULES = "System modules"
        ASSET_TYPES = "Asset types."
        LIST_ASSET = "Asset list."
        CREATE_ASSET = 'Asset "{0}" successfully added to "{1}" asset list.'
        DELETE_ASSET = 'Asset "{0}" successfully deleted from "{1}" asset list.'
        CREATE_IOC = 'IOC "{0}" successfully added to "{1}" document source.'
        DOCUMENT_CREATE = "Source document successfully created."
        DOCUMENT_DELETE = 'Source document "{0}" successfully deleted.'
        CREATE_IOC_SUCCESS = 'IOCs "{0}" successfully added to "{1}" source document.'
        CREATE_IOC_FAIL = 'Failed to add IOCs "{0}" to "{1}" source document.'
        CVES = "CVE list."
        CVE_NEXT_OFFSET = "CVE next offset."
        ADD_CVE_SUCCESS = 'The "{0}" CVEs successfully added.'
        ADD_CVE_FAIL = 'Failed to add the "{0}" CVEs.'
        DELETE_CVE_SUCCESS = 'The "{0}" CVEs successfully deleted.'
        DELETE_CVE_FAIL = 'Failed to delete the "{0}" CVEs.'
        ALERT_LIST = "Alert list"
        ALERT_GET = 'Alert "{0}"'
        ALERT_CREATE = "Alert successfully created"
        ALERT_CLOSE = 'Alert "{0}" successfully closed'
        ALERT_SEVERITY = 'Alert "{0}" severity successfully updated to "{1}".'
        ALERT_ASSIGN = 'Alert "{0}" successfully assign to user "{1}".'
        ALERT_UNASSIGN = "Alert '{0}' successfully unassigned from any user."
        ALERT_REOPEN = 'Alert "{0}" successfully re-opened.'
        ALERT_TAG_ADD = 'The tag "{1}" successfully added to "{0}" Alert.'
        ALERT_TAG_REMOVE = 'The tag "{1}" successfully removed from "{0}" Alert.'
        ALERT_MAIL = 'The alert "{0}" successfully send to "{1}".'
        ALERT_ANALYST = 'The alert "{0}" successfully sent to the analyst.'
        ALERT_CONVERSATION_LIST = "Alert conversation with analyst:"
        ALERT_NO_CONVERSATION_LIST = "There is no conversation with analyst."
        ALERT_ADD_NOTE = 'Note successfully add to alert "{0}".'
        ALERT_BLOCKLIST_GET = 'Blocklist for alert "{0}".'
        ALERT_BLOCKLIST_UPDATE = 'IOC successfully updated to status "{0}".'
        ALERT_IMAGES = 'Alert "{0}" Images list.'
        ALERT_NO_IMAGES = 'Alert "{0}" does not contain images.'
        ALERT_CSV = 'Alert "{0}" CSV file.'
        ALERT_NO_CSV = 'Alert "{0}" does not have a CSV file.'
        ALERT_TAKEDOWN = 'Successfully sent takedown request for alert "{0}".'
        ALERT_TAKEDOWN_STATUS = 'Takedown status for alert "{0}".'
        ALERT_REPORT = 'Alert "{0}" successfully reported'
        ALERT_ACTIVITY = 'Alert "{0}" activity log'
        ALERT_TYPES = "Alert types"
        ALERT_SOURCE_TYPES = "Alert source types"
        IOC_LIST = "IOC list"
        IOC_GET = 'IOC "{0}"'
        ENRICH_GET = 'Enrichment data for IOC "{0}"'
        IOC_TAG_ADD = 'The tags "{1}" successfully added to "{0}" IOC.'
        UPDATE_IOC_SEVERITY = 'The severity "{1}" successfully updated to "{0}" IOCs.'
        ADD_IOC_COMMENT = 'The comment "{1}" successfully updated to "{0}" IOCs.'
        UPDATE_ACCOUNT_WHITELIST = (
            'The status "{1}" successfully updated to "{0}" IOCs in the account whitelist.'
        )
        REMOVE_ACCOUNT_WHITELIST = (
            'The IOCs "{0}" successfully removed from the account whitelist.'
        )
        ADD_IOC_BLOCKLIST = (
            'The IOCs "{0}" successfully added to the remediation blocklist.'
        )
        REMOVE_IOC_BLOCKLIST = (
            'The IOCs "{0}" successfully removed from the remediation blocklist.'
        )
        ACCOUNT_USER_LIST = "Account user list"
        MSSP_USER_LIST = "MSSP user list"
        MSSP_CUSTOMER_LIST = "MSSP customer list"
        SCENARIO_LIST = "Alert scenario list"
        MENTIONS = 'Mentions for "{0}" (page number {1}).'
        ENRICH_QUOTA = "Current API enrichment credits (quota)."


    class ReadableErrors(str, Enum):
        MISSING_IOCS = "Missing IOCs. Please insert."
        SOURCE_NOT_EXIST = "The source does not exist."
        GENERAL = "General error with the request."
        NOT_FOUND = "The object does not exist."
        WRONG_PARAMETERS = "Wrong parameters."
        NO_CONTENT = "No content - there is no data to show."
        UNAUTHORIZED = "Authorization Error: Make sure that the Account ID and API key are correctly set."
        ENRICH_FAIL = 'Enrichment failed. Status is "{0}"".'
        INSERT_VALUE = "Please insert {0}."
        NO_IOCS = "Please insert at least one IOC."
        WRONG_IOC = "Please insert correct IOC value."
        EMAIL = '"{0}" is not correct email, please insert correct email.'
        DOMAIN = '"{0}" is not correct domain, please insert correct domain.'
        URL = '"{0}" is not correct URL, please insert correct URL.'
        IP = '"{0}" is not correct IP, please insert correct IP.'
        HASH = '"{0}" is not correct hash, please insert correct hash.'
        SOURCE_ALREADY_EXIST = "The source already exist."
        CONFIDENCE_LEVEL = "confidence_level is a number in range 1-3"
        RATE = "rate is a number in range 0-5"
        ALERT_LIST = "You can't choose alert_id and retrieve_ids_only."
        SCENARIO_TYPES = "You have to insert scenario or type and sub-type."
        ALERT_TYPE = "You have to insert type or remove the sub_type and insert scenario."
        ALERT_SUB_TYPE = (
            "You have to insert sub_type or remove the type and insert scenario."
        )
        ARGUMENT = "{0} argument should be {1}"
        NUMBER = "Please insert a valid number."
        LIMIT = "Limit has to be positive number."
        MODULE_NOT_AVAILABLE = "The module is not available."
        ACCOUNT_ID_HEADER = "Missing Account ID."
        IS_HIDDEN = 'You can use is_hidden=True only in case the reason is "False Positive"'
        USER_EMAIL = "The user email is invalid."
        USER_ID = "The user ID is invalid."
        SOURCE_TYPE = "The source type is invalid."
        SUB_TYPE = "The sub-type is invalid."
        EXTERNAL_SOURCE = "The external source is invalid."
        ASSET_TYPE = "The asset type is invalid."
        TAG_ID = "The tag ID is invalid."
        ASSET_COUNTRY = "The country is invalid."
        ASSET_SECTOR = "The sector is invalid."
        ASSET_DOMAIN = "The domain is invalid."
        TAG_EXIST = "The tag is already exist."
        INVALID_EMAIL = "The email is invalid."
        IOC_NOT_EXIST = "The IOC does not exist."
        FIRST_FETCH_NOT_EXIST = "Failed to get first fetch time."
        MAX_FETCH_INVALID = "Maximum incidents per fetch must be a positive integer ranging from 1 to 200."


    ERROR_RESPONSE_MAPPER: dict[str, str] = {
        "MissingIocs": ReadableErrors.MISSING_IOCS.value,
        "SourceDoesNotExist": ReadableErrors.SOURCE_NOT_EXIST.value,
        "SourceNameAlreadyExists": ReadableErrors.SOURCE_ALREADY_EXIST.value,
        "InvaliduserEmail": ReadableErrors.USER_EMAIL.value,
        "InvaliduserId": ReadableErrors.USER_ID.value,
        "InvalidAssigneeID": ReadableErrors.USER_ID.value,
        "InvalidSourceType": ReadableErrors.SOURCE_TYPE.value,
        "InvalidSubAlertType": ReadableErrors.SUB_TYPE.value,
        "InvalidExternalSources": ReadableErrors.EXTERNAL_SOURCE.value,
        "InvalidAssetType": ReadableErrors.ASSET_TYPE.value,
        "InvalidTagID": ReadableErrors.TAG_ID.value,
        "InvalidCountryOfActivityAsset": ReadableErrors.ASSET_COUNTRY.value,
        "InvalidSectorAsset": ReadableErrors.ASSET_SECTOR.value,
        "InvalidDomainAsset": ReadableErrors.ASSET_DOMAIN.value,
        "MissingAccountIdHeader": ReadableErrors.ACCOUNT_ID_HEADER.value,
        "ModuleNotAvailable": ReadableErrors.MODULE_NOT_AVAILABLE.value,
        "TagExist": ReadableErrors.TAG_EXIST.value,
        "InvalidEmails": ReadableErrors.INVALID_EMAIL.value,
        "IocDoesNotExist": ReadableErrors.IOC_NOT_EXIST.value,
    }


    ERROR_CODE_MAPPER: dict[int, str] = {
        HTTPStatus.NOT_FOUND: ReadableErrors.NOT_FOUND.value,
        HTTPStatus.UNPROCESSABLE_ENTITY: ReadableErrors.WRONG_PARAMETERS.value,
        HTTPStatus.INTERNAL_SERVER_ERROR: ReadableErrors.GENERAL.value,
        HTTPStatus.UNAUTHORIZED: ReadableErrors.UNAUTHORIZED.value,
        HTTPStatus.NO_CONTENT: ReadableErrors.NO_CONTENT.value,
    }


    class IOCType(str, Enum):
        FILE = "FILE"
        URL = "URL"
        IP = "IP"
        HASH = "HASH"
        EMAIL = "EMAIL"
        DOMAIN = "DOMAIN"


    pattern_and_readable_error_by_ioc_type = {
        IOCType.URL: (urlRegex, ReadableErrors.URL),
        IOCType.IP: (ipv4Regex, ReadableErrors.IP),
        IOCType.HASH: (hashRegex, ReadableErrors.HASH),
        IOCType.EMAIL: (emailRegex, ReadableErrors.EMAIL),
    }

    WHITELIST_ADD = "Add to the user whitelist"
    WHITELIST_DO_NOT = "Do not whitelist"


    class ArgumentValues(list, Enum):
        WHITELIST_STATUS = [WHITELIST_ADD, WHITELIST_DO_NOT]
        BOOLEAN = ["true", "false"]
        ALERT_TYPE = [
            "Attack Indication",
            "Data Leakage",
            "Phishing",
            "Brand Security",
            "Exploitable Data",
            "vip",
        ]
        ALERT_IOC_AND_DOCUMENT_SEVERITY = ["High", "Medium", "Low"]
        ALERT_SOURCE_NETWORK = ["Clear Web", "Dark Web"]
        ALERT_CLOSE_REASON = [
            "Problem Solved",
            "Informational Only",
            "Problem We Are Already Aware Of",
            "Company Owned Domain",
            "Legitimate Application/Profile",
            "Not Related To My Company",
            "False Positive",
            "Other",
        ]
        ALERT_BLOCKLIST = ["Sent", "Not Sent"]
        CVE_SEVERITY = ["High", "Medium", "Low", "Critical"]
        USER_TYPE = ["Admin", "Analyst"]
        MENTION_SOURCE_TYPE = [
            "Social Media",
            "Paste Site",
            "Hacking Forum",
            "Instant Message",
            "Black Market",
            "Cyber Security Blog",
            "Web Page",
        ]
        SOURCE_TYPE = [
            "Application Stores",
            "Black Market",
            "Hacking Forum",
            "Others",
            "Paste Site",
            "Social Media",
        ]


    V1_PREFIX = "v1"
    V2_PREFIX = "v2"
    V3_PREFIX = "v3"
    API_MAX_LIMIT = 1000
    FETCH_LIMIT = 50
    XSOAR_SEVERITY = {
        "Low": IncidentSeverity.LOW,
        "Medium": IncidentSeverity.MEDIUM,
        "High": IncidentSeverity.HIGH,
    }
    ALERT_WHITELIST = {
        WHITELIST_ADD: True,
        WHITELIST_DO_NOT: False,
    }


    class UrlPrefix(StrEnum):
        CYBER_TERM = "threat-library/cyber-terms"
        IOC_SOURCE = "iocs"
        ACCOUNT = "account"
        ASSET = "data/assets"
        CVE = "cves"
        ALERT = "data/alerts"
        IOC = "iocs"
        MSSP = "mssp"


    class Parser:
        """
        This class will handle the objects input arguments API response outputs.
        """

        def cyber_term_cve_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse Cyber-term CVE response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Cyber-term CVE response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "id": obj.get("CveId"),
                "publish_date": obj.get("PublishedDate"),
                "vendor_product": obj.get("VendorProducts"),
            }

        def cyber_term_ioc_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse Cyber-term IOC response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Cyber-term IOC response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "value": obj.get("Value"),
                "type": obj.get("Type"),
                "updated_date": obj.get("UpdateDate"),
                "status": obj.get("Status"),
                "is_whitelisted": obj.get("Whitelisted"),
                "severity": obj.get("Severity"),
                "reporting_feeds": obj.get("ReportingFeeds"),
            }

        def cyber_term_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse Cyber-term response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Cyber-term response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "id": obj.get("ID"),
                "name": obj.get("Value"),
                "type": obj.get("Type"),
                "severity": obj.get("Severity"),
                "aliases": obj.get("Aliases"),
                "origins": obj.get("Origins"),
                "target_countries": obj.get("TargetCountries"),
                "sectors": obj.get("TargetSectors"),
                "created_date": obj.get("CreatedDate"),
                "updated_date": obj.get("UpdatedDate"),
                "ttp": obj.get("TTPs"),
                "overview": obj.get("Overview"),
                "additional_information": obj.get("AdditionalInformation"),
                "related_malware": obj.get("RelatedMalware"),
                "related_threat_actor": obj.get("RelatedThreatActors"),
                "related_campaigns": obj.get("RelatedCampaigns"),
                "MitreAttack": [
                    {
                        "tactic": attack.get("ReportingFeeds"),
                        "Techniques": [
                            {
                                "name": tech.get("ReportingFeeds"),
                                "url": tech.get("ReportingFeeds"),
                            }
                            for tech in attack.get("Techniques", [])
                        ],
                    }
                    for attack in obj.get("MitreAttack", [])
                ],
            }

        def cve_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse CVE response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): CVE response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "id": obj.get("cveId"),
                "cpe": [
                    {
                        "value": cpe.get("Value"),
                        "title": cpe.get("Title"),
                        "vendor_product": cpe.get("VendorProduct"),
                    }
                    for cpe in obj.get("cpe", [])
                ],
                "published_date": obj.get("publishedDate"),
                "update_date": obj.get("updateDate"),
                "severity": obj.get("severity"),
                "intsights_score": obj.get("intsightsScore"),
                "cvss_score": obj.get("cvssScore"),
                "social_media_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "SocialMedia"]
                ),
                "paste_site_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "PasteSite"]
                ),
                "hacking_forum_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "HackingForum"]
                ),
                "instant_message_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "InstantMessage"]
                ),
                "dark_web_mentions": dict_safe_get(obj, ["mentionsPerSource", "DarkWeb"]),
                "code_repositories_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "CodeRepositories"]
                ),
                "exploit_mentions": dict_safe_get(obj, ["mentionsPerSource", "Exploit"]),
                "clear_web_cyber_blogs_mentions": dict_safe_get(
                    obj, ["mentionsPerSource", "ClearWebCyberBlogs"]
                ),
                "poc_mentions": dict_safe_get(obj, ["mentionsPerSource", "POC"]),
                "first_mention_date": obj.get("firstMentionDate"),
                "last_mention_date": obj.get("lastMentionDate"),
                "exploit_availability": obj.get("exploitAvailability"),
                "vulnerability_origin": obj.get("vulnerabilityOrigin"),
                "related_threat_actors": obj.get("relatedThreatActors"),
                "related_malware": obj.get("relatedMalware"),
                "related_campaigns": obj.get("relatedCampaigns"),
            }

        def alert_get_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse complete Alert response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Alert response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "id": obj.get("_id"),
                "assets": [
                    {
                        "type": asset.get("Type"),
                        "value": asset.get("Value"),
                    }
                    for asset in obj.get("Assets", [])
                ],
                "assignees": obj.get("Assignees"),
                "type": dict_safe_get(obj, ["Details", "Type"]),
                "sub_type": dict_safe_get(obj, ["Details", "SubType"]),
                "title": dict_safe_get(obj, ["Details", "Title"]),
                "description": dict_safe_get(obj, ["Details", "Description"]),
                "severity": dict_safe_get(obj, ["Details", "Severity"]),
                "images": dict_safe_get(obj, ["Details", "Images"]),
                "source_type": dict_safe_get(obj, ["Details", "Source", "Type"]),
                "source_url": str(dict_safe_get(obj, ["Details", "Source", "URL"], "")),
                "source_email": "",
                "source_network_type": dict_safe_get(
                    obj, ["Details", "Source", "NetworkType"]
                ),
                "source_date": str(dict_safe_get(obj, ["Details", "Source", "Date"], "")),
                "Tags": [
                    {
                        "created_by": tag.get("CreatedBy"),
                        "name": tag.get("Name"),
                        "id": tag.get("_id"),
                    }
                    for tag in dict_safe_get(obj, ["Details", "Tags"], [])
                ],
                "related_iocs": obj.get("RelatedIocs"),
                "found_date": obj.get("FoundDate"),
                "update_date": obj.get("UpdateDate"),
                "takedown_status": obj.get("TakedownStatus"),
                "is_closed": dict_safe_get(obj, ["Closed", "IsClosed"]),
                "is_flagged": obj.get("IsFlagged"),
                "related_threat_ids": obj.get("RelatedThreatIDs"),
            }

        def alert_fetch_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse complete Alert response from the API to fetch XSOAR outputs.

            Args:
                obj (dict[str, Any]): Alert response from the API.

            Returns:
                dict[str, Any]: fetch XSOAR outputs.
            """
            return remove_empty_elements(
                {
                    "id": obj.get("_id"),
                    "found_date": obj.get("FoundDate"),
                    "type": dict_safe_get(obj, ["Details", "Type"]),
                    "severity": XSOAR_SEVERITY[dict_safe_get(obj, ["Details", "Severity"])],
                    "title": dict_safe_get(obj, ["Details", "Title"]),
                    "description": dict_safe_get(obj, ["Details", "Description"]),
                    "update_date": obj.get("UpdateDate"),
                    "Source": {
                        "type": dict_safe_get(obj, ["Details", "Source", "Type"]),
                        "network_type": dict_safe_get(
                            obj, ["Details", "Source", "NetworkType"]
                        ),
                        "email": "",
                        "url": dict_safe_get(obj, ["Details", "Source", "URL"]),
                        "date": dict_safe_get(obj, ["Details", "Source", "Date"]),
                    },
                    "related_iocs": obj.get("RelatedIocs"),
                    "takedown_status": obj.get("TakedownStatus"),
                    "Assets": [
                        {
                            "type": asset.get("Type"),
                            "value": asset.get("Value"),
                        }
                        for asset in obj.get("Assets", [])
                    ],
                    "related_threat_ids": obj.get("RelatedThreatIDs"),
                    "Tags": [
                        {
                            "created_by": tag.get("CreatedBy"),
                            "name": tag.get("Name"),
                            "id": tag.get("_id"),
                        }
                        for tag in dict_safe_get(obj, ["Details", "Tags"], [])
                    ],
                    "is_closed": dict_safe_get(obj, ["Closed", "IsClosed"]),
                    "sub_type": dict_safe_get(obj, ["Details", "SubType"]),
                }
            )

        def parse_incident(self, alert: dict) -> dict:
            """
            Parse alert to XSOAR Incident.
            Args:
                alert (dict): alert item.
            Returns:
                dict: XSOAR Incident.
            """
            incident = {
                "name": alert.get("id"),
                "occurred": alert.get("found_date"),
                "rawJSON": json.dumps(alert),
            }
            return incident

        def alert_activity_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse complete Alert activity response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Alert activity response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return remove_empty_elements(
                {
                    "rate": dict_safe_get(obj, ["AdditionalInformation", "Status", "Rate"]),
                    "type": obj.get("Type"),
                    "sub_types": obj.get("SubTypes"),
                    "initiator": obj.get("Initiator"),
                    "created_date": obj.get("CreatedDate"),
                    "update_date": obj.get("UpdateDate"),
                    "read_by": obj.get("ReadBy"),
                    "id": obj.get("_id"),
                    "tag_names": dict_safe_get(obj, ["AdditionalInformation", "TagNames"]),
                    "tag_ids": dict_safe_get(obj, ["AdditionalInformation", "TagIDs"]),
                    "Mail": {
                        "note_id": dict_safe_get(
                            obj, ["AdditionalInformation", "Mail", "NoteId"]
                        ),
                        "question": dict_safe_get(
                            obj, ["AdditionalInformation", "Mail", "Question"]
                        ),
                        "Replies": [
                            {
                                "email": reply.get("Email"),
                                "token": reply.get("Token"),
                                "date": reply.get("Date"),
                                "read_by": reply.get("ReadBy"),
                                "is_token_valid": reply.get("IsTokenValid"),
                            }
                            for reply in dict_safe_get(
                                obj, ["AdditionalInformation", "Mail", "Replies"], []
                            )
                        ],
                    },
                    "Messages": [
                        {
                            "initiator_id": dict_safe_get(msg, ["Initiator", "_id"]),
                            "initiator_is_support": dict_safe_get(
                                msg, ["Initiator", "IsSupport"]
                            ),
                            "date": msg.get("Date"),
                            "content": msg.get("Content"),
                        }
                        for msg in dict_safe_get(
                            obj, ["AdditionalInformation", "AskTheAnalyst", "Messages"], []
                        )
                    ],
                }
            )

        def ioc_get_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse IOC response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): IOC response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return {
                "value": obj.get("value"),
                "type": obj.get("type"),
                "status": obj.get("status"),
                "severity": obj.get("severity"),
                "score": obj.get("score"),
                "last_update_date": obj.get("lastUpdateDate"),
                "last_seen": obj.get("lastSeen"),
                "first_seen": obj.get("firstSeen"),
                "related_malware": obj.get("relatedMalware"),
                "related_campaigns": obj.get("relatedCampaigns"),
                "related_threat_actors": obj.get("relatedThreatActors"),
                "ReportedFeeds": [
                    {
                        "id": feed.get("id"),
                        "name": feed.get("name"),
                        "confidence_level": feed.get("confidenceLevel"),
                    }
                    for feed in obj.get("reportedFeeds", [])
                ],
                "is_whitelisted": obj.get("whitelisted"),
                "tags": obj.get("tags"),
            }

        def ioc_enrich_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse IOC enrich response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): IOC enrich response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return remove_empty_elements(
                {
                    "value": obj.get("Value"),
                    "type": obj.get("Type"),
                    "Sources": [
                        {
                            "name": source.get("Name"),
                            "confidence_level": source.get("ConfidenceLevel"),
                        }
                        for source in obj.get("Sources", [])
                    ],
                    "system_tags": obj.get("SystemTags"),
                    "tags": obj.get("Tags"),
                    "status": obj.get("Status"),
                    "is_known_ioc": obj.get("IsKnownIoc"),
                    "related_threat_actors": obj.get("RelatedThreatActors"),
                    "related_campaign": obj.get("RelatedCampaigns"),
                    "first_seen": obj.get("FirstSeen"),
                    "last_seen": obj.get("LastSeen"),
                    "update_seen": obj.get("UpdateDate"),
                    "is_whitelisted": obj.get("Whitelisted"),
                    "Severity": {
                        "value": dict_safe_get(obj, ["Severity", "Value"]),
                        "score": dict_safe_get(obj, ["Severity", "Score"]),
                        "origin": dict_safe_get(obj, ["Severity", "Origin"]),
                    },
                    "DnsRecord": [
                        {
                            "value": record.get("Value"),
                            "type": record.get("Type"),
                            "first_resolved": record.get("FirstResolved"),
                            "last_resolved": record.get("LastResolved"),
                            "count": record.get("Count"),
                        }
                        for record in obj.get("DnsRecords", [])
                    ],
                    "subdomains": obj.get("Subdomains"),
                    "History": [
                        {
                            "status": source.get("Statuses"),
                            "name_servers": source.get("NameServers"),
                        }
                        for source in dict_safe_get(obj, ["Whois", "History"], [])
                    ],
                    "Current": {
                        "status": dict_safe_get(obj, ["Whois", "Current", "Statuses"]),
                        "name_servers": dict_safe_get(
                            obj, ["Whois", "Current", "NameServers"]
                        ),
                    },
                    "Resolution": [
                        {
                            "resolved_ip_address": res.get("ResolvedIpAddress"),
                            "resolved_domain": res.get("ResolvedDomain"),
                            "reporting_sources": res.get("ReportingSources"),
                        }
                        for res in obj.get("Resolutions", [])
                    ],
                    "RelatedHash": {
                        "downloaded": dict_safe_get(obj, ["RelatedHashes", "downloaded"]),
                        "communicating": dict_safe_get(
                            obj, ["RelatedHashes", "communicating"]
                        ),
                        "referencing": dict_safe_get(obj, ["RelatedHashes", "referencing"]),
                        "Hashes": [
                            {
                                "type": res.get("Type"),
                                "value": res.get("Value"),
                            }
                            for res in obj["RelatedHashes"]
                        ]
                        if isinstance(obj["RelatedHashes"], list)
                        else None,
                    },
                    "antivirus_scan_date": obj.get("AntivirusScanDate"),
                    "file_name": obj.get("FileName"),
                    "file_type": obj.get("FileType"),
                    "file_author": obj.get("FileAuthor"),
                    "file_description": obj.get("FileDescription"),
                    "file_size": obj.get("FileSize"),
                    "antivirus_detection_ratio": obj.get("AntivirusDetectionRatio"),
                    "antivirus_detected_engines": obj.get("AntivirusDetectedEngines"),
                    "ip_range": dict_safe_get(obj, ["Whois", "NetworkDetails", "IPRange"]),
                    "AntivirusDetection": [
                        {
                            "name": res.get("Name"),
                            "version": res.get("Version"),
                            "detected": res.get("Detected"),
                            "result": res.get("Result"),
                        }
                        for res in obj.get("AntivirusDetections", [])
                    ],
                }
            )

        def mention_parser(self, obj: dict[str, Any]) -> dict[str, Any]:
            """
            Parse mention response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Mention response from the API.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            return remove_empty_elements(
                {
                    "author": obj.get("Author"),
                    "comment_number": obj.get("CommentNumber"),
                    "original_url": obj.get("OriginalUrl"),
                    "source_date": obj.get("SourceDate"),
                    "url": obj.get("Url"),
                    "insertion_date": obj.get("InsertionDate"),
                    "type": obj.get("Type"),
                    "Tags": obj.get("Tags"),
                    "id": obj.get("id"),
                    "short_content": obj.get("ShortContent"),
                    "title": obj.get("Title"),
                    "date": obj.get("Date"),
                }
            )

        def file_reputation_parser(
            self, obj: dict[str, Any], reliability, hash_
        ) -> dict[str, Any]:
            """
            Parse hash enrichment response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Hash enrichment response from the API.
                reliability (_type_): Reliability of the source providing the intelligence data.
                hash_ (bool): Hash value.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            related_hashes = get_enrich_hashes(obj)
            is_known_ioc = dict_safe_get(obj, ["Data", "IsKnownIoc"])
            dbot_score = get_dbotscore(reliability, hash_, is_known_ioc)
            tags = dict_safe_get(obj, ["Data", "Tags"], []) + dict_safe_get(
                obj, ["Data", "SystemTags"], []
            )
            return remove_empty_elements(
                {
                    "md5": related_hashes.get("md5"),
                    "sha1": related_hashes.get("SHA1"),
                    "sha256": related_hashes.get("SHA256"),
                    "sha512": related_hashes.get("SHA512"),
                    "name": dict_safe_get(obj, ["Data", "FileName"]),
                    "description": dict_safe_get(obj, ["Data", "FileDescription"]),
                    "size": dict_safe_get(obj, ["Data", "FileSize"]),
                    "file_type": dict_safe_get(obj, ["Data", "FileType"]),
                    "tags": tags,
                    "actor": dict_safe_get(obj, ["Data", "RelatedThreatActors"]),
                    "campaign": dict_safe_get(obj, ["Data", "RelatedCampaigns"]),
                    "associated_file_names": get_enrich_file_nams(obj),
                    "dbot_score": dbot_score,
                }
            )

        def ip_reputation_parser(
            self, obj: dict[str, Any], reliability, ip
        ) -> dict[str, Any]:
            """
            Parse IP enrichment response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): IP enrichment response from the API.
                reliability (_type_): Reliability of the source providing the intelligence data.
                ip (bool): IP value.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            is_known_ioc = dict_safe_get(obj, ["Data", "IsKnownIoc"])
            dbot_score = get_dbotscore(reliability, ip, is_known_ioc)
            tags = dict_safe_get(obj, ["Data", "Tags"], []) + dict_safe_get(
                obj, ["Data", "SystemTags"], []
            )
            return remove_empty_elements(
                {
                    "ip": ip,
                    "asn": dict_safe_get(obj, ["Data", "IpDetails", "ASN"]),
                    "region": dict_safe_get(obj, ["Data", "IpDetails", "Country"]),
                    "updated_date": dict_safe_get(obj, ["Data", "UpdateDate"]),
                    "campaign": dict_safe_get(obj, ["Data", "RelatedCampaigns"]),
                    "tags": tags,
                    # "whois_records": dict_safe_get(
                    #     obj, ["Data", "Whois", "RegistrantDetails"]
                    # ),
                    "dbot_score": dbot_score,
                }
            )

        def url_reputation_parser(
            self, obj: dict[str, Any], reliability, url
        ) -> dict[str, Any]:
            """
            Parse url enrichment response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Url enrichment response from the API.
                reliability (_type_): Reliability of the source providing the intelligence data.
                url (bool): url value.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            is_known_ioc = dict_safe_get(obj, ["Data", "IsKnownIoc"])
            dbot_score = get_dbotscore(reliability, url, is_known_ioc)
            antivirus_detected_engines: str = dict_safe_get(
                obj, ["Data", "AntivirusDetectedEngines"]
            )
            if len(antivirus_detected_engines.split("/")) == 2:
                detection_engines = antivirus_detected_engines.split("/")[1]
                positive_detections = antivirus_detected_engines.split("/")[0]
            else:
                detection_engines = None
                positive_detections = None

            tags = dict_safe_get(obj, ["Data", "Tags"], []) + dict_safe_get(
                obj, ["Data", "SystemTags"], []
            )
            return remove_empty_elements(
                {
                    "url": url,
                    "detection_engines": detection_engines,
                    "positive_detections": positive_detections,
                    "campaign": dict_safe_get(obj, ["Data", "RelatedCampaigns"]),
                    "tags": tags,
                    "dbot_score": dbot_score,
                }
            )

        def domain_reputation_parser(
            self, obj: dict[str, Any], reliability, domain
        ) -> dict[str, Any]:
            """
            Parse domain enrichment response from the API to XSOAR outputs.

            Args:
                obj (dict[str, Any]): Domain enrichment response from the API.
                reliability (_type_): Reliability of the source providing the intelligence data.
                domain (bool): domain value.

            Returns:
                dict[str, Any]: XSOAR outputs.
            """
            is_known_ioc = dict_safe_get(obj, ["Data", "IsKnownIoc"])
            dbot_score = get_dbotscore(reliability, domain, is_known_ioc)
            tags = dict_safe_get(obj, ["Data", "Tags"], []) + dict_safe_get(
                obj, ["Data", "SystemTags"], []
            )
            dns_records: List[Common.DNSRecord] = []
            for dns in dict_safe_get(obj, ["Data", "DnsRecords"], []):
                dns_records.append(
                    Common.DNSRecord(
                        dns_record_type=dns["Type"], dns_record_data=dns["Value"]
                    )
                )
            return remove_empty_elements(
                {
                    "domain": domain,
                    # "whois_records": dict_safe_get(obj, ["Data", "Whois"]),
                    "dns_records": dns_records,
                    "updated_date": dict_safe_get(obj, ["Data", "UpdateDate"]),
                    "tags": tags,
                    "sub_domains": dict_safe_get(obj, ["Data", "Subdomains"]),
                    "campaign": dict_safe_get(obj, ["Data", "RelatedCampaigns"]),
                    "dbot_score": dbot_score,
                }
            )
            # ) | {"dns_records": dns_records}


    class Client(BaseClient):
        """Client class to interact with Threat Command API."""

        def __init__(
            self,
            base_url: str,
            account_id: str,
            api_key: str,
            mssp_sub_account: str | None,
            reliability: str,
            verify: bool,
            proxy: bool,
        ):
            self.reliability = reliability
            base_url = urljoin(base_url, "public")
            self.parser = Parser()
            super().__init__(
                base_url=base_url,
                headers=remove_empty_elements({"Account-Id": mssp_sub_account}),
                verify=verify,
                proxy=proxy,
                auth=(account_id, api_key),
            )

        def _http_request(self, *args, **kwargs):
            """
            Warp to _http_request command. I use it because sometimes the API response code is 200
            but there is an error with the request. The error flag located in the response body.

            Raises:
                DemistoException: Error response.
                DemistoException: Error response.

            Returns:
                Response | dict[str,Any]: API response from Threat Command API.
            """
            kwargs["error_handler"] = self.error_handler
            demisto.debug(f'Making API request at {kwargs.get("method")} {kwargs.get("url_suffix")} '
                          f'with params:{kwargs.get("params")} and body:{kwargs.get("json_data")}')
            res = super()._http_request(backoff_factor=BACKOFF_FACTOR, retries=RETRIES,  # type: ignore
                                        status_list_to_retry=STATUS_LIST_TO_RETRY, raise_on_status=True,  # type: ignore
                                        *args, **kwargs)  # type: ignore
            if isinstance(res, dict):
                if (
                    res.get("Success") is False
                    and (data := res.get("Data"))
                    and ERROR_RESPONSE_MAPPER.get(data)
                ):
                    raise DemistoException(message=ERROR_RESPONSE_MAPPER.get(data))
                if dict_safe_get(res, ["content", "success"]) is False:
                    raise DemistoException(message=res)
            return res

        def error_handler(self, res: Response):
            """
            Handling with request errors.

            Args:
                res (Response): API response from Threat Command API.

            Raises:
                DemistoException: Error response.
                DemistoException: Error response.
                DemistoException: Error response.
                DemistoException: Error response.
            """
            error_str = f"Status Code: {res.status_code}, Message: {res.text}"
            if isinstance(res, Response):
                if ERROR_RESPONSE_MAPPER.get(res.content.decode()):
                    raise DemistoException(ERROR_RESPONSE_MAPPER.get(res.content.decode()))
                if ERROR_CODE_MAPPER.get(res.status_code):
                    raise DemistoException(f"Status Code: {res.status_code}, {ERROR_CODE_MAPPER.get(res.status_code)}")
            raise DemistoException(message=error_str)

        def list_cyber_term_cve(self, cyber_term_id: str) -> dict[str, Any]:
            """
            List the Cyber-term CVEs.

            Args:
                cyber_term_id (str): The ID of the cyber-term.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CYBER_TERM}/{cyber_term_id}/cves"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def list_cyber_term_ioc(
            self,
            cyber_term_id: str,
            limit: int,
            ioc_type: str | None,
            offset: str | None,
        ) -> dict[str, Any]:
            """
            List the Cyber-term IOCs.

            Args:
                cyber_term_id (str | None): The ID of the cyber-term.
                limit (int): The maximum number of records to retrieve.
                ioc_type (str | None): IOC type to filter.
                offset (str | None): Offset for pagination.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """

            params = remove_empty_elements(
                {
                    "iocType": remove_whitespaces(ioc_type),
                    "limit": limit,
                    "offset": offset,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CYBER_TERM}/{cyber_term_id}/iocs"
            return self._http_request(method="GET", url_suffix=url_suffix, params=params)

        def list_cyber_term(
            self,
            search: str | None,
            types_: List[str] | None,
            severities: List[str] | None,
            sectors: List[str] | None,
            countries: List[str] | None,
            origin: List[str] | None,
            ttp: List[str] | None,
            last_update_from: str | None,
            last_update_to: str | None,
            limit: int,
            offset: str | None,
        ) -> dict[str, Any]:
            """List Cyber terms.

            Args:
                search (str | None): Filter by free text, which can be the cyber term name or ID.
                types_ (str | None): Filter by one or more cyber term types.
                severities (str | None): Filter by one or more cyber term severities.
                sectors (List[str] | None): Filter by one or more targeted sectors.
                countries (List[str] | None): Filter by one or more targeted countries.
                origin (List[str] | None): Filter by one or more nationalities.
                ttp (List[str] | None): Filter by one or more TTPs.
                last_update_from (str | None): Filter by last update date is greater than (in ISO 8601 format).
                last_update_to (str | None): Filter by last update date is less than (in ISO 8601 format).
                limit (int): The maximum number of records to retrieve.
                offset (str | None): Offset for pagination.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {
                    "search": search,
                    "type": [remove_whitespaces(type_) for type_ in types_]
                    if types_
                    else None,
                    "severity": severities,
                    "target-sector": sectors,
                    "target-country": countries,
                    "origin": origin,
                    "ttp": ttp,
                    "last-update-from": last_update_from,
                    "last-update-to": last_update_to,
                    "limit": limit,
                    "offset": offset,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CYBER_TERM}"
            return self._http_request(method="GET", url_suffix=url_suffix, params=params)

        def list_source(self) -> dict[str, Any]:
            """
            List the IOC sources.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/sources"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def create_document_source(
            self,
            name: str,
            description: str,
            confidence_level: int,
            share: bool | None,
            severity: str | None,
            tags: List[str],
            domains: List[str],
            urls: List[str],
            ips: List[str],
            hashes: List[str],
            emails: List[str],
        ) -> dict[str, Any]:
            """
            Create document source.

            Args:
                name (str): Source name.
                description (str): Source description.
                confidence_level (int): Source confidence level.
                share (bool | None): Share this source with all tenants (available for MSSP users only).
                severity (str | None): Source severity level.
                tags (List[str]): A list of user tags for the document.
                domains (List[str]): A list of domain IOC values to add.
                urls (str): A list of URL IOC values to add.
                ips (List[str]): A list of IP IOC values to add.
                hashes (List[str]): A list hash domain IOC values to add.
                emails (List[str]): A list of email IOC values to add.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = remove_empty_elements(
                {
                    "DocumentDetails": {
                        "Name": name,
                        "Description": description,
                        "ConfidenceLevel": confidence_level,
                        "Share": share,
                        "Severity": severity.lower() if severity else None,
                        "Tags": tags,
                    },
                    "Iocs": map_ioc_list(
                        domains=domains, urls=urls, ips=ips, hashes=hashes, emails=emails
                    ),
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/add-source"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
            )

        def delete_document_source(self, source_id: str) -> Response:
            """
            Delete document source.

            Args:
                source_id (str): The ID of the document source.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/delete-source/{source_id}"
            return self._http_request(
                method="DELETE",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                resp_type="response",
            )

        def create_document_source_ioc(
            self,
            source_id: str,
            domains: List[str],
            urls: List[str],
            ips: List[str],
            hashes: List[str],
            emails: List[str],
        ) -> Response:
            """
            Create new IOCs to existing IOC source documents.

            Args:
                source_id (str): The ID of the document source.
                domains (List[str]): A list of domain IOC values to add.
                urls (str): A list of URL IOC values to add.
                ips (List[str]): A list of IP IOC values to add.
                hashes (List[str]): A list hash domain IOC values to add.
                emails (List[str]): A list of email IOC values to add.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = remove_empty_elements(
                {
                    "Iocs": map_ioc_list(
                        domains=domains,
                        urls=urls,
                        ips=ips,
                        hashes=hashes,
                        emails=emails,
                    )
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/add-iocs-to-source/{source_id}"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                ok_codes=[HTTPStatus.OK],
                resp_type="response",
            )

        def list_system_modules(self) -> dict[str, Any]:
            """
            List the system modules.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ACCOUNT}/system-modules"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def add_asset(self, asset_type: str, asset_value: str) -> Response:
            """
            Add a new asset to asset list.

            Args:
                asset_type (str): The type of the asset.
                asset_value (str): The asset value.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"AssetType": asset_type, "AssetValue": asset_value}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ASSET}/add-asset"
            return self._http_request(
                method="PUT",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                json_data=payload,
                resp_type="response",
            )

        def delete_asset(self, asset_type: str, asset_value: str) -> Response:
            """
            Delete an asset to asset list.

            Args:
                asset_type (str): The type of the asset.
                asset_value (str): The asset value.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"AssetType": asset_type, "AssetValue": asset_value}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ASSET}/delete-asset"
            return self._http_request(
                method="DELETE",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                json_data=payload,
                resp_type="response",
            )

        def list_assets(self, asset_types: List[str] | None) -> dict[str, Any]:
            """
            List assets.

            Args:
                asset_types (List[str] | None): Type for filter.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {"assetTypes": asset_types if asset_types else None}
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ASSET}/account-assets"
            return self._http_request(
                method="GET", url_suffix=url_suffix, ok_codes=[HTTPStatus.OK], params=params
            )

        def list_asset_types(self) -> List[str]:
            """
            List asset types.

            Returns:
                List[str]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ASSET}/assets-types"
            return self._http_request(
                method="GET", url_suffix=url_suffix, ok_codes=[HTTPStatus.OK]
            )

        def list_cve(
            self,
            offset: str | None,
            publish_date_from: str | None,
            publish_date_to: str | None,
            update_date_from: str | None,
            update_date_to: str | None,
            severity_list: List[str] | None,
            cpe_list: List[str] | None,
            cve_ids: List[str] | None,
        ) -> dict[str, Any]:
            """
            List of CVEs.

            Args:
                offset (str | None): Offset for pagination.
                publish_date_from (str | None): Publish date from.
                publish_date_to (str | None): Publish date to.
                update_date_from (str | None): Update date from.
                update_date_to (str | None): Update date to.
                severity_list (List[str] | None): Severity list.
                cpe_list (List[str] | None): CPE list.
                cve_ids (List[str] | None): CVE IDs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {
                    "publishDateFrom": publish_date_from,
                    "publishDateTo": publish_date_to,
                    "updateDateFrom": update_date_from,
                    "updateDateTo": update_date_to,
                    "severity": severity_list if severity_list else None,
                    "cpe": cpe_list if cpe_list else None,
                    "cveId": cve_ids if cve_ids else None,
                    "offset": offset,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CVE}/get-cves-list"
            return self._http_request(method="GET", url_suffix=url_suffix, params=params)

        def add_cve(self, cve_ids: List[str]) -> dict[str, Any]:
            """
            Add CVEs to account.

            Args:
                cve_ids (List[str]): List of CVE IDs to add.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = {"cveIds": cve_ids}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CVE}/add-cves"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                json_data=payload,
            )

        def delete_cve(self, cve_ids: List[str]) -> dict[str, Any]:
            """
            Delete CVEs from account.

            Args:
                cve_ids (List[str]): List of CVE IDs to delete.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = {"cveIds": cve_ids}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.CVE}/delete-cves"
            return self._http_request(
                method="DELETE",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                json_data=payload,
            )

        def list_alert(
            self,
            limit: int,
            is_closed: bool,
            offset: str | None = None,
            last_updated_from: str | None = None,
            last_updated_to: str | None = None,
            alert_type: List[str] | None = None,
            severity: List[str] | None = None,
            source_type: List[str] | None = None,
            network_type: List[str] | None = None,
            matched_asset_value: List[str] | None = None,
            source_date_from: str | None = None,
            source_date_to: str | None = None,
            found_date_from: str | None = None,
            found_date_to: str | None = None,
            assigned: bool | None = None,
            is_flagged: bool | None = None,
            has_ioc: bool | None = None,
        ) -> dict[str, Any]:
            """
            List alerts with updated date.

            Args:
                limit (int): Limit for pagination.
                is_closed (bool): Whether the alert is closed.
                offset (str | None): Offset for pagination.
                last_updated_from (str | None): Last updated from date for filter.
                last_updated_to (str | None): Last updated to date for filter.
                alert_type (List[str] | None): Alert types for filter.
                severity (List[str] | None): Alert severities for filter.
                source_type (List[str] | None): Alert source types for filter.
                network_type (List[str] | None): Alert network types for filter.
                matched_asset_value (List[str] | None): Alert matched asset values for filter.
                source_date_from (str | None): Source date from for filter.
                source_date_to (str | None): Source date to for filter.
                found_date_from (str | None): Found date from for filter.
                found_date_to (str | None): Found date from for filter.
                assigned (bool | None): Assigned user for filter.
                is_flagged (bool | None): Whether the alert is flagged.
                has_ioc (bool | None): Whether the alert has IOCs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {
                    "lastUpdatedFrom": last_updated_from,
                    "lastUpdatedTo": last_updated_to,
                    "alertType": [remove_whitespaces(_type) for _type in alert_type]
                    if alert_type
                    else None,
                    "severity": severity if severity else None,
                    "sourceType": [remove_whitespaces(_type) for _type in source_type]
                    if source_type
                    else None,
                    "networkType": [remove_whitespaces(_type) for _type in network_type]
                    if network_type
                    else None,
                    "matchedAssetValue": matched_asset_value
                    if matched_asset_value
                    else None,
                    "sourceDateFrom": source_date_from,
                    "sourceDateTo": source_date_to,
                    "foundDateFrom": found_date_from,
                    "foundDateTo": found_date_to,
                    "assigned": str(assigned).lower() if assigned else None,
                    "isFlagged": str(is_flagged).lower() if is_flagged else None,
                    "isClosed": str(is_closed).lower() if is_closed else None,
                    "hasIoc": str(has_ioc).lower() if has_ioc else None,
                    "limit": limit,
                    "offset": offset,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/update-alerts"
            return self._http_request(
                method="GET", url_suffix=url_suffix, params=params, ok_codes=[HTTPStatus.OK]
            )

        def get_alert(self, alert_id: str) -> dict[str, Any]:
            """
            Get alert with complete details.

            Args:
                alert_id (str): Alert ID.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/get-complete-alert/{alert_id}"
            return self._http_request(
                method="GET", url_suffix=url_suffix, ok_codes=[HTTPStatus.OK]
            )

        def create_alert(
            self,
            title: str,
            description: str,
            type_: str | None,
            sub_type: str | None,
            severity: str,
            source_type: str,
            source_network_type: str,
            source_date: str | None,
            found_date: str | None,
            image_entry_ids: List[str],
            scenario: str | None,
            source_url: str | None,
        ) -> Response:
            """
            Create a new alert.

            Args:
                title (str): Title for the alert.
                description (str): Description for the alert.
                type_ (str | None): Type for the alert.
                sub_type (str | None): Sub-type for the alert.
                severity (str): Severity.
                source_type (str): Source type.
                source_network_type (str): Source network.
                source_date (str | None): Source date.
                found_date (str | None): Found date.
                image_entry_ids (List[str]]): Images data.
                scenario (str | None): Scenario.
                source_url (str | None): Source URL.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = remove_empty_elements(
                {
                    "FoundDate": found_date,
                    "Details": {
                        "Title": title,
                        "Description": description,
                        "Type": remove_whitespaces(type_),
                        "SubType": sub_type,
                        "Severity": severity,
                        "Source": {
                            "Type": source_type,
                            "NetworkType": remove_whitespaces(source_network_type),
                            "URL": source_url,
                            "Date": source_date if source_date else "",
                        },
                        "Images": files_handler(file_ids=image_entry_ids, is_image=True),
                    },
                    "Scenario": scenario,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/add-alert"

            return self._http_request(
                method="PUT",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK],
                json_data=payload,
                resp_type="response",
            )

        def close_alert(
            self,
            alert_id: str,
            reason: str,
            comment: str | None,
            is_hidden: bool,
            rate: int | None,
        ) -> Response:
            """
            Close alert.

            Args:
                alert_id (str): Alert ID.
                reason (str): Close reason.
                comment (str | None): Close comment.
                is_hidden (bool): Alerts' hidden status.
                rate (int | None): Alert's rate

            Returns:
                Response: API response from Threat Command API.
            """
            payload = remove_empty_elements(
                {
                    "Reason": remove_whitespaces(reason),
                    "FreeText": comment,
                    "IsHidden": is_hidden,
                    "Rate": rate,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/close-alert/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def update_alert_severity(self, alert_id: str, severity: str) -> Response:
            """
            Update alert severity.

            Args:
                alert_id (str): Alert ID.
                severity (str): Alert severity.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"Severity": severity}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/change-severity/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def assign_alert(self, alert_id: str, user_id: str, is_mssp: bool) -> Response:
            """
            Assign alert to user.

            Args:
                alert_id (str): Alert ID.
                user_id (str): User ID.
                is_mssp (bool): Whether to user is MSSP.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {
                "AssigneeID": user_id,
                "IsMssp": is_mssp,
            }
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/assign-alert/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def unassign_alert(self, alert_id: str) -> Response:
            """
            Unassign alert.

            Args:
                alert_id (str): Alert ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/unassign-alert/{alert_id}"
            return self._http_request(
                method="PATCH", url_suffix=url_suffix, resp_type="response"
            )

        def reopen_alert(self, alert_id: str) -> Response:
            """
            Re-open alert.

            Args:
                alert_id (str): Alert ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/reopen-alert/{alert_id}"
            return self._http_request(
                method="PATCH", url_suffix=url_suffix, resp_type="response"
            )

        def tag_alert(self, alert_id: str, tag_name: str) -> Response:
            """
            Add a tag to alert.

            Args:
                alert_id (str): Alert ID.
                tag_name (str): Tag to add.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {
                "TagName": tag_name,
            }
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/add-tag/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def untag_alert(self, alert_id: str, tag_id: str) -> Response:
            """
            Remove a tag to alert.

            Args:
                alert_id (str): Alert ID.
                tag_id (str): Tag ID to remove.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {
                "TagID": tag_id,
            }
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/remove-tag/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def send_mail_alert(
            self, alert_id: str, email_addresses: List[str], content: str
        ) -> Response:
            """
            Send mail with the alert details and a question.


            Args:
                alert_id (str): Alert ID.
                email_addresses (List[str]): List of mails to send.
                content (str): Content.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"Emails": email_addresses, "Content": content}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/send-mail/{alert_id}"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def analyst_ask_alert(self, alert_id: str, question: str) -> Response:
            """
            Send a question to an analyst about the requested alert.

            Args:
                alert_id (str): Alert ID.
                question (str): Question to ask.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"Question": question}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/ask-the-analyst/{alert_id}"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def list_alert_conversation(self, alert_id: str) -> Response:
            """
            List alert's analyst response.

            Args:
                alert_id (str): Alert ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/ask-the-analyst-conversation/{alert_id}"
            return self._http_request(
                method="GET",
                url_suffix=url_suffix,
                ok_codes=[HTTPStatus.OK, HTTPStatus.NO_CONTENT],
                resp_type="response",
            )

        def list_alert_activity(self, alert_id: str) -> List[dict[str, Any]]:
            """
            Get alert activity log.

            Args:
                alert_id (str): Alert ID.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/activity-log/{alert_id}"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def add_alert_note(
            self, alert_id: str, note: str, file_entry_ids: List[str]
        ) -> Response:
            """
            Add note to alert.

            Args:
                alert_id (str): Alert ID.
                note (str): Note text to add.
                file_entry_ids (List[str]): File entry ids.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"Note": note, "Files": files_handler(file_ids=file_entry_ids)}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/add-note/{alert_id}"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def get_alert_blocklist(self, alert_id: str) -> List[dict[str, Any]]:
            """
            Get alert blocklist.

            Args:
                alert_id (str): Alert ID.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/blocklist-status/{alert_id}"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def update_alert_blocklist(
            self,
            alert_id: str,
            domains: List[str],
            urls: List[str],
            ips: List[str],
            emails: List[str],
            blocklist_status: str,
        ) -> Response:
            """
            Update alert blocklist.

            Args:
                alert_id (str): Alert ID.
                domains (List[str]): Domains IOCs.
                urls (List[str]): URL IOCs.
                ips (List[str]): IP IOCs.
                emails (List[str]): Email IOCs.
                blocklist_status (str): Blocklist status.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = remove_empty_elements(
                {
                    "Iocs": map_ioc_list(
                        domains=domains,
                        urls=urls,
                        ips=ips,
                        emails=emails,
                        blocklist_status=remove_whitespaces(blocklist_status),
                    )
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/change-iocs-blocklist-status/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                ok_codes=[HTTPStatus.OK],
                resp_type="response",
            )

        def get_alert_image(self, image_id: str) -> Response:
            """
            Get alert image.

            Args:
                image_id (str): Image ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/alert-image/{image_id}"
            return self._http_request(
                method="GET", url_suffix=url_suffix, resp_type="response"
            )

        def takedown_alert(
            self, alert_id: str, target: str, close_alert_after_success: bool
        ) -> Response:
            """
            Takedown alert.

            Args:
                alert_id (str): Alert ID.
                target (str): Target.
                close_alert_after_success (bool): Whether to close after success.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {
                "Target": target,
                "ShouldCloseAlertAfterSuccess": close_alert_after_success,
            }
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/takedown-request/{alert_id}"
            return self._http_request(
                method="PATCH",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def get_takedown_alert(self, alert_id: str) -> Response:
            """
            Get takedown status.

            Args:
                alert_id (str): Alert ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/takedown-status/{alert_id}"
            return self._http_request(
                method="GET", url_suffix=url_suffix, resp_type="response"
            )

        def list_alert_type(self) -> dict[str, Any]:
            """
            List alert types.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/types-subtypes-relations"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def list_alert_source_type(self) -> List[dict[str, Any]]:
            """
            List alert sub-types.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/source-types"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def list_alert_scenario(
            self, type_: str | None, sub_type: str | None
        ) -> List[dict[str, Any]]:
            """
            List alert scenarios.

            Args:
                type_ (str | None): Filter by type.
                sub_type (str | None): Filter by sub-type.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {"type": remove_whitespaces(type_), "subType": sub_type}
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/scenario-relations"
            return self._http_request(method="GET", url_suffix=url_suffix, params=params)

        def report_alert_ioc(self, alert_id: str, external_sources: List[str]) -> Response:
            """
            List alert scenarios.

            Args:
                alert_id (str): Alert ID.
                external_sources (List[str]): External sources to report.

            Returns:
                Response: API response from Threat Command API.
            """
            payload = {"ExternalSources": external_sources}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/report-iocs/{alert_id}"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                resp_type="response",
            )

        def list_account_user(
            self, user_type: str | None, user_email: str | None, user_id: str | None
        ) -> List[dict[str, Any]]:
            """List account users.

            Args:
                user_type (str | None): User type for filter.
                user_email (str | None): User Emails for filter.
                user_id (str | None): User ID for filter.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {
                    "userType": user_type,
                    "userEmail": user_email,
                    "userId": user_id,
                }
            )
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ACCOUNT}/users-details"
            return self._http_request(
                method="GET", url_suffix=url_suffix, params=params, ok_codes=[HTTPStatus.OK]
            )

        def get_ioc(self, ioc_value: str) -> dict[str, Any]:
            """
            Get IOC.

            Args:
                ioc_value (str): IOC value.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = {
                "iocValue": ioc_value,
            }
            url_suffix = f"{V3_PREFIX}/{UrlPrefix.IOC}/ioc-by-value"
            return self._http_request(
                method="GET", url_suffix=url_suffix, params=params, ok_codes=[HTTPStatus.OK]
            )

        def list_ioc(
            self,
            last_updated_from: str | None,
            last_updated_to: str | None,
            last_seen_from: str | None,
            last_seen_to: str | None,
            first_seen_from: str | None,
            first_seen_to: str | None,
            status: str | None,
            type_list: List[str] | None,
            severity_list: List[str] | None,
            whitelisted: bool | None,
            source_ids: List[str] | None,
            kill_chain_phases: List[str] | None,
            limit: str,
            offset: str | None,
        ) -> dict[str, Any]:
            """
            List IOCs.

            Args:
                last_updated_from (str | None): Last updated from filter.
                last_updated_to (str | None): Last updated to filter.
                last_seen_from (str | None): Last seen from filter.
                last_seen_to (str | None): Last seen to filter.
                first_seen_from (str | None): First seen from filter.
                first_seen_to (str | None): First seen to filter.
                status (str | None): Status filter.
                type_list (List[str] | None): List of types for filter.
                severity_list (List[str] | None): List of severities for filter.
                whitelisted (bool | None): Whitelist filter.
                source_ids (List[str] | None): List of source IDs for filter.
                kill_chain_phases (List[str] | None): List of phases for filter.
                limit (str): limit gor pagination.
                offset (str | None): Offset for pagination.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            params = remove_empty_elements(
                {
                    "lastUpdatedFrom": last_updated_from,
                    "lastUpdatedTo": last_updated_to,
                    "lastSeenFrom": last_seen_from,
                    "lastSeenTo": last_seen_to,
                    "firstSeenFrom": first_seen_from,
                    "firstSeenTo": first_seen_to,
                    "status": status,
                    "type": [remove_whitespaces(type) for type in type_list]
                    if type_list
                    else None,
                    "severity": severity_list if severity_list else None,
                    "whitelisted": whitelisted,
                    "sourceIds": source_ids if source_ids else None,
                    "killChainPhases": [
                        remove_whitespaces(phase) for phase in kill_chain_phases
                    ]
                    if kill_chain_phases
                    else None,
                    "limit": limit,
                    "offset": offset,
                }
            )
            url_suffix = f"{V3_PREFIX}/{UrlPrefix.IOC}"
            return self._http_request(
                method="GET", url_suffix=url_suffix, params=params, ok_codes=[HTTPStatus.OK]
            )

        def tags_ioc(self, ioc_value: str, tag_values: List[str]) -> dict[str, Any]:
            """
            Add tags for IOC.

            Args:
                ioc_value (str): IOC value.
                tag_values (List[str]): Tag to add.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = [{"iocValue": ioc_value, "tag": tag} for tag in tag_values]
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC}/tags"
            return self._http_request(
                method="POST",
                url_suffix=url_suffix,
                json_data=payload,
                ok_codes=[HTTPStatus.OK],
            )

        def update_ioc_severity(
            self, severity: str, ioc_values: List[str]
        ) -> dict[str, Any]:
            """
            Update severity to IOCs.

            Args:
                severity (str): Severity to update.
                ioc_values (List[str]): IOC values.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = [{"iocValue": ioc, "severity": severity} for ioc in ioc_values]
            url_suffix = f"{V2_PREFIX}/{UrlPrefix.IOC_SOURCE}/severity"
            return self._http_request(
                method="PATCH", url_suffix=url_suffix, json_data=payload
            )

        def add_ioc_comment(self, comment: str, ioc_values: List[str]) -> dict[str, Any]:
            """
            Add comment to IOCs.

            Args:
                comment (str): Comment to add.
                ioc_values (List[str]): IOC values.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = [{"iocValue": ioc, "comment": comment} for ioc in ioc_values]
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/comments"
            return self._http_request(
                method="POST", url_suffix=url_suffix, json_data=payload
            )

        def update_account_whitelist(
            self, is_whitelisted: str, ioc_values: List[str]
        ) -> dict[str, Any]:
            """
            Update account whitelist.

            Args:
                is_whitelisted (str): IOC status.
                ioc_values (List[str]): List of IOCs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """

            payload = {
                "iocs": [
                    {
                        "value": ioc,
                        "whitelisted": ALERT_WHITELIST[is_whitelisted],
                    }
                    for ioc in ioc_values
                ]
            }
            url_suffix = f"{V2_PREFIX}/{UrlPrefix.IOC_SOURCE}/user-whitelist"
            return self._http_request(
                method="POST", url_suffix=url_suffix, json_data=payload
            )

        def remove_account_whitelist(self, ioc_values: List[str]) -> dict[str, Any]:
            """
            Remove IOCs from account whitelist.

            Args:
                ioc_values (List[str]): List of IOCs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = {"iocs": ioc_values}
            url_suffix = f"{V2_PREFIX}/{UrlPrefix.IOC_SOURCE}/user-whitelist"
            return self._http_request(
                method="DELETE", url_suffix=url_suffix, json_data=payload
            )

        def add_ioc_blocklist(self, ioc_values: List[str]) -> dict[str, Any]:
            """
            Add IOCs to remediation blocklist.

            Args:
                ioc_values (List[str]): List of IOCs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = {"iocs": ioc_values}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/blocklist"
            return self._http_request(
                method="POST", url_suffix=url_suffix, json_data=payload
            )

        def remove_ioc_blocklist(self, ioc_values: List[str]) -> dict[str, Any]:
            """
            Remove IOCs from remediation blocklist.

            Args:
                ioc_values (List[str]): List of IOCs.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            payload = {"iocs": ioc_values}
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC_SOURCE}/blocklist"
            return self._http_request(
                method="DELETE", url_suffix=url_suffix, json_data=payload
            )

        def search_mention(
            self,
            search: str,
            report_date: str | None,
            page_number: int,
            source_types: str | None,
            only_dark_web: bool,
            highlight_tags: bool,
        ) -> dict[str, Any]:
            """
            Search for mentions.

            Args:
                search (str): Text for search.
                report_date (str | None): Report date
                page_number (int): Page number.
                source_types (str | None): Search source types.
                only_dark_web (bool): Show only mentions from the dark web or not.
                highlight_tags (bool): Show highlight tags (<em>) in the content or not.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """

            params = remove_empty_elements(
                {
                    "search": search,
                    "report-date": report_date,
                    "page-number": page_number,
                    "source-type": [remove_whitespaces(type_) for type_ in source_types]
                    if source_types
                    else None,
                    "only-dark-web": only_dark_web,
                    "highlight-tags": highlight_tags,
                }
            )
            url_suffix = f"{V2_PREFIX}/intellifind"
            return self._http_request(method="GET", url_suffix=url_suffix, params=params)

        def usage_quota_enrichment(self) -> dict[str, Any]:
            """
            Gets the current API enrichment credits.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC}/quota"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def enrich_ioc(self, ioc_value: str) -> dict[str, Any]:
            """
            Enrich IOC.

            Args:
                ioc_value (str): IOC value.

            Returns:
                dict[str, Any]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.IOC}/enrich/{ioc_value}"
            return self._http_request(method="GET", url_suffix=url_suffix)

        def list_mssp_user(self) -> List[dict[str, Any]]:
            """
            List MSSP users.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.MSSP}/users-details"
            return self._http_request(
                method="GET", url_suffix=url_suffix, ok_codes=[HTTPStatus.OK]
            )

        def list_mssp_customer(self) -> List[dict[str, Any]]:
            """
            List MSSP customer.

            Returns:
                List[dict[str, Any]]: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.MSSP}/customers"
            return self._http_request(
                method="GET", url_suffix=url_suffix, ok_codes=[HTTPStatus.OK]
            )

        def get_alert_csv(self, alert_id: str) -> Response:
            """
            Get alert csv.

            Args:
                alert_id (str): Alert ID.

            Returns:
                Response: API response from Threat Command API.
            """
            url_suffix = f"{V1_PREFIX}/{UrlPrefix.ALERT}/csv-file/{alert_id}"
            return self._http_request(
                method="GET",
                url_suffix=url_suffix,
                resp_type="response",
                ok_codes=[HTTPStatus.OK, HTTPStatus.BAD_REQUEST],
            )


    def list_cyber_term_cve_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List the Cyber-term CVEs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        cyber_term_id = args["cyber_term_id"]

        response = client.list_cyber_term_cve(cyber_term_id=cyber_term_id)
        paginated_response = manual_pagination(response["content"], args)
        mapped_response = list_parser(
            paginated_response, client.parser.cyber_term_cve_parser
        )

        return command_result_generate(
            readable_message=ReadableOutputs.CYBER_TERM_CVES.value.format(cyber_term_id),
            outputs=mapped_response,
            headers=["id", "publish_date", "vendor_product"],
            prefix="CVE",
            key_field="id",
            raw_response=response,
        )


    def list_cyber_term_ioc_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List the Cyber-term IOCs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        cyber_term_id = args["cyber_term_id"]
        paginated_response = auto_pagination(
            request_command=client.list_cyber_term_ioc,
            offset_path=["content", "nextOffset"],
            limit=arg_to_number(args.get("limit", 50)),
            page=arg_to_number(args.get("page")),
            page_size=arg_to_number(args.get("page_size")),
            cyber_term_id=args["cyber_term_id"],
            ioc_type=args.get("ioc_type"),
        )
        mapped_response = list_parser(
            values=dict_safe_get(paginated_response, ["content", "iocs"]),
            mapper_command=client.parser.cyber_term_ioc_parser,
        )

        return command_result_generate(
            readable_message=ReadableOutputs.CYBER_TERM_IOCS.value.format(cyber_term_id),
            outputs=mapped_response,
            headers=["value", "type", "is_whitelisted", "updated_date"],
            prefix="IOC",
            key_field="id",
            raw_response=paginated_response,
        )


    def list_cyber_term_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List Cyber-terms.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        paginated_response = auto_pagination(
            request_command=client.list_cyber_term,
            offset_path=["nextOffset"],
            limit=arg_to_number(args.get("limit", 50)),
            page=arg_to_number(args.get("page")),
            page_size=arg_to_number(args.get("page_size")),
            search=args.get("search"),
            types_=argToList(args.get("types")),
            severities=argToList(args.get("severities")),
            sectors=argToList(args.get("sectors")),
            countries=argToList(args.get("countries")),
            origin=argToList(args.get("origins")),
            ttp=argToList(args.get("ttps")),
            last_update_from=args.get("last_update_from"),
            last_update_to=args.get("last_update_to"),
        )

        mapped_response = list_parser(
            values=paginated_response["content"],
            mapper_command=client.parser.cyber_term_parser,
        )

        return command_result_generate(
            readable_message=ReadableOutputs.CYBER_TERM.value,
            outputs=mapped_response,
            headers=Headers.LIST_CYBER_TERM.value,
            prefix="CyberTerm",
            key_field="id",
            raw_response=paginated_response,
        )


    def list_source_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List IOC sources.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_source()
        fixed_response = [
            member | {"type": object_type}
            for object_type in response
            for member in response[object_type]
        ]

        paginated_response = manual_pagination(fixed_response, args)
        mapped_response = list_parser(paginated_response, response_obj_parser)
        return command_result_generate(
            readable_message=ReadableOutputs.IOC_SOURCE.value,
            outputs=mapped_response,
            headers=["id", "name", "confidence_level", "is_enable", "type"],
            prefix="Source",
            key_field="id",
            raw_response=response,
        )


    def create_source_document_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Create a document source.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        args = validate_create_source_document(args)

        name = args["name"]
        response = client.create_document_source(
            name=name,
            description=args["description"],
            confidence_level=args["confidence_level"],
            share=argToBoolean(args.get("share")) if args.get("share") else None,
            severity=args["severity"].lower() if args.get("severity") else None,
            tags=argToList(args.get("tags")),
            domains=argToList(args.get("domains")),
            urls=argToList(args.get("urls")),
            ips=argToList(args.get("ips")),
            hashes=argToList(args.get("hashes")),
            emails=argToList(args.get("emails")),
        )
        source_id = dict_safe_get(response, ["Data", "sourceDetails", "_id"])
        outputs = {"Files": {"id": source_id, "name": name}}
        return command_result_generate(
            readable_message=ReadableOutputs.DOCUMENT_CREATE.value,
            readable_outputs=outputs["Files"],
            outputs=outputs,
            headers=["id", "name"],
            prefix="Source",
            key_field="id",
            raw_response=response,
        )


    def delete_source_document_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Delete a document source.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        source_id = args["source_id"]
        client.delete_document_source(source_id=source_id)

        return CommandResults(
            readable_output=ReadableOutputs.DOCUMENT_DELETE.value.format(source_id)
        )


    def create_source_document_ioc_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Create a document source IOCs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        iocs = handle_iocs(args=args)

        source_id = args["source_id"]

        client.create_document_source_ioc(
            source_id=source_id,
            domains=argToList(args.get("domains")),
            urls=argToList(args.get("urls")),
            ips=argToList(args.get("ips")),
            hashes=argToList(args.get("hashes")),
            emails=argToList(args.get("emails")),
        )

        return CommandResults(
            readable_output=ReadableOutputs.CREATE_IOC.value.format(iocs, source_id)
        )


    def list_system_modules_command(client: Client, *_) -> CommandResults:
        """
        List system modules.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_system_modules()
        fixed_response = dict_to_lowercase(response)
        readable_outputs = [
            {"module_name": module, "status": status}
            for module, status in fixed_response.items()
        ]
        return command_result_generate(
            readable_message=ReadableOutputs.SYSTEM_MODULES.value,
            outputs=readable_outputs,
            headers=["module_name", "status"],
            prefix="SystemModule",
            key_field="module_name",
            raw_response=response,
        )


    def add_asset_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add a new asset to asset list.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        asset_type = args["asset_type"]
        asset_value = args["asset_value"]

        client.add_asset(asset_type=asset_type, asset_value=asset_value)
        outputs = {'type': asset_type, 'value': asset_value}
        return command_result_generate(
            readable_message=ReadableOutputs.CREATE_ASSET.value.format(
                asset_value, asset_type
            ),
            outputs=outputs,
            headers=['type', 'value'],
            prefix="Asset",
            key_field="value",
            raw_response=outputs,
        )


    def delete_asset_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Delete an asset from asset list.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        asset_type = args["asset_type"]
        asset_value = args["asset_value"]

        client.delete_asset(asset_type=asset_type, asset_value=asset_value)

        return CommandResults(
            readable_output=ReadableOutputs.DELETE_ASSET.value.format(
                asset_value, asset_type
            )
        )


    def list_assets_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List assets.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_assets(asset_types=argToList(args.get("asset_types")))
        fixed_response = [
            {"value": asset} | {"type": object_type}
            for object_type in response
            for asset in response[object_type]
        ]
        paginated_response = manual_pagination(fixed_response, args)

        return command_result_generate(
            readable_message=ReadableOutputs.LIST_ASSET.value,
            outputs=paginated_response,
            headers=["type", "value"],
            prefix="Asset",
            key_field="value",
            raw_response=response,
        )


    def list_asset_types_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List the asset types.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_asset_types()
        paginated_response = manual_pagination(response, args)

        return command_result_generate(
            readable_message=ReadableOutputs.ASSET_TYPES.value,
            outputs=paginated_response,
            headers=["type"],
            prefix="AssetType",
            key_field="value",
            raw_response=response,
        )


    def list_cve_command(client: Client, args: dict[str, Any]) -> List[CommandResults]:
        """
        List the account CVEs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_list_cve(args)
        response = client.list_cve(
            offset=args.get("offset"),
            publish_date_from=args.get("publish_date_from"),
            publish_date_to=args.get("publish_date_to"),
            update_date_from=args.get("update_date_from"),
            update_date_to=args.get("update_date_to"),
            severity_list=argToList(args.get("severity_list", [])),
            cpe_list=argToList(args.get("cpe_list", [])),
            cve_ids=argToList(args.get("cve_ids", [])),
        )
        paginated_response = manual_pagination(response["content"], args)
        mapped_response = list_parser(paginated_response, client.parser.cve_parser)
        return remove_empty_elements(
            [
                command_result_generate(
                    readable_message=ReadableOutputs.CVES.value,
                    outputs=mapped_response,
                    headers=[
                        "id",
                        "published_date",
                        "update_date",
                        "severity",
                        "intsights_score",
                        "cvss_score",
                    ],
                    prefix="CVE",
                    key_field="id",
                    raw_response=response,
                ),
                response.get("nextOffset")
                and command_result_generate(
                    readable_message=ReadableOutputs.CVE_NEXT_OFFSET.value,
                    outputs=response["nextOffset"],
                    headers=["offset"],
                    prefix="CveNextOffset",
                ),
            ]
        )


    def add_cve_command(client: Client, args: dict[str, Any]) -> List[CommandResults]:
        """
        Add CVEs to account list.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        cve_ids = argToList(args["cve_ids"])
        response = client.add_cve(cve_ids=cve_ids)
        return multi_status_handler(
            res=response,
            objects=cve_ids,
            object_key="cveId",
            success_readable=ReadableOutputs.ADD_CVE_SUCCESS.value,
            fail_readable=ReadableOutputs.ADD_CVE_FAIL.value,
        )


    def delete_cve_command(client: Client, args: dict[str, Any]) -> List[CommandResults]:
        """
        Delete CVEs from the account list.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
        """
        cve_ids = argToList(args["cve_ids"])
        response = client.delete_cve(cve_ids=cve_ids)
        return multi_status_handler(
            res=response,
            objects=cve_ids,
            object_key="cveId",
            success_readable=ReadableOutputs.DELETE_CVE_SUCCESS.value,
            fail_readable=ReadableOutputs.DELETE_CVE_FAIL.value,
        )


    def list_alert_handler_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List alerts handler.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_list_alert(args=args)
        params = {
            "last_updated_from": args.get("last_updated_from"),
            "last_updated_to": args.get("last_updated_to"),
            "alert_type": argToList(args.get("alert_type")),
            "severity": argToList(args.get("severity")),
            "source_type": argToList(args.get("source_type")),
            "network_type": argToList(args.get("network_type")),
            "matched_asset_value": argToList(args.get("matched_asset_value")),
            "source_date_from": args.get("source_date_from"),
            "source_date_to": args.get("source_date_to"),
            "found_date_from": args.get("found_date_from"),
            "found_date_to": args.get("found_date_to"),
            "assigned": arg_to_optional_bool(args.get("assigned")),
            "is_flagged": arg_to_optional_bool(args.get("is_flagged")),
            "is_closed": arg_to_optional_bool(args.get("is_closed")),
            "has_ioc": arg_to_optional_bool(args.get("has_ioc")),
        }

        if alert_id := args.get("alert_id"):
            return get_alert_details_command(client=client, alert_id=alert_id)

        if argToBoolean(args["retrieve_ids_only"]):
            return list_alert_command(client=client, args=args, **params)

        return list_alerts_details_command(client=client, args=args, **params)


    def list_alerts_details_command(
        client: Client, args: dict[str, Any], **params
    ) -> CommandResults:
        """
        Get alerts with complete details.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        paginated_response = auto_pagination(
            request_command=client.list_alert,
            offset_path=["nextOffset"],
            limit=arg_to_number(args.get("limit", 50)),
            page=arg_to_number(args.get("page")),
            page_size=arg_to_number(args.get("page_size")),
            **params,
        )

        alert_ids = [obj["_id"] for obj in paginated_response["content"]]
        data = [
            client.parser.alert_get_parser(client.get_alert(alert_id=alert_id))
            for alert_id in alert_ids
        ]
        readable_outputs = [
            alert_readable_outputs_handler(response=alert) for alert in data
        ]
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_LIST.value,
            readable_outputs=readable_outputs,
            outputs=data,
            headers=Headers.GET_ALERT.value,
            prefix="Alert",
            key_field="id",
            raw_response=data,
        )


    def list_alert_command(
        client: Client, args: dict[str, Any], **params
    ) -> CommandResults:
        """
        list alert ids and updated date.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        paginated_response = auto_pagination(
            request_command=client.list_alert,
            offset_path=["nextOffset"],
            limit=arg_to_number(args.get("limit", 50)),
            page=arg_to_number(args.get("page")),
            page_size=arg_to_number(args.get("page_size")),
            **params,
        )

        mapped_response = list_parser(
            values=paginated_response.get("content", []),
            mapper_command=response_obj_parser,
        )

        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_LIST.value,
            outputs=mapped_response,
            headers=["id", "update_date"],
            prefix="Alert",
            key_field="id",
            raw_response=paginated_response,
        )


    def get_alert_details_command(client: Client, alert_id: str) -> CommandResults:
        """
        Get alert with complete details.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.get_alert(alert_id=alert_id)
        mapped_response = client.parser.alert_get_parser(response)
        readable_outputs = alert_readable_outputs_handler(response=mapped_response)

        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_GET.value.format(alert_id),
            readable_outputs=readable_outputs,
            outputs=mapped_response,
            headers=Headers.GET_ALERT.value,
            prefix="Alert",
            key_field="id",
            raw_response=response,
        )


    def create_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Create a new alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_create_alert(args=args)
        response = client.create_alert(
            title=args["title"],
            description=args["description"],
            type_=args.get("type"),
            sub_type=args.get("sub_type"),
            severity=args["severity"],
            source_type=args["source_type"],
            source_network_type=args["source_network_type"],
            source_date=args.get("source_date"),
            found_date=args.get("found_date"),
            image_entry_ids=argToList(args.get("image_entry_ids")),
            scenario=args.get("scenario"),
            source_url=args.get("source_url"),
        )
        outputs = {"id": response.content.decode()}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_CREATE.value,
            outputs=outputs,
            headers=["id"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
        )


    def close_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Close alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_close_alert(args)

        alert_id = args["alert_id"]

        client.close_alert(
            alert_id=alert_id,
            reason=args["reason"],
            comment=args.get("comment"),
            is_hidden=argToBoolean(args["is_hidden"]),
            rate=arg_to_number(args.get("rate")),
        )
        outputs = {'id': alert_id, 'is_closed': True}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_CLOSE.value.format(alert_id),
            outputs=outputs,
            headers=["id", "is_closed"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
        )


    def update_alert_severity_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Update the alert severity.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_alert_ioc_severity(args)

        alert_id = args["alert_id"]
        severity = args["severity"]

        client.update_alert_severity(alert_id=alert_id, severity=severity)
        outputs = {'id': alert_id, 'severity': severity}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_SEVERITY.value.format(alert_id, severity),
            outputs=outputs,
            headers=["id", "severity"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
        )


    def assign_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Assign alert to user.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_assign_alert(args)
        alert_id = args["alert_id"]
        user_id = args["user_id"]

        client.assign_alert(
            alert_id=alert_id, user_id=user_id, is_mssp=argToBoolean(args.get("is_mssp"))
        )
        outputs = {'id': alert_id, 'assignees': [user_id]}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_ASSIGN.value.format(alert_id, user_id),
            outputs=outputs,
            headers=["id", "assignees"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
        )


    def unassign_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Unassign alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]

        client.unassign_alert(alert_id=alert_id)

        outputs = {'id': alert_id, 'assignees': None}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_UNASSIGN.value.format(alert_id),
            outputs=outputs,
            headers=["id", "assignees"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
        )


    def reopen_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Re-open closed alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]

        client.reopen_alert(alert_id=alert_id)
        return CommandResults(
            readable_output=ReadableOutputs.ALERT_REOPEN.value.format(alert_id)
        )


    def tag_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add tag to alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        tag_name = args["tag_name"]

        client.tag_alert(alert_id=alert_id, tag_name=tag_name)

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_TAG_ADD.value.format(alert_id, tag_name)
        )


    def untag_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Remove tag from alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        tag_id = args["tag_id"]

        client.untag_alert(alert_id=alert_id, tag_id=tag_id)

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_TAG_REMOVE.value.format(alert_id, tag_id)
        )


    def send_mail_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Send a mail with alert details.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        email_addresses = argToList(args["email_addresses"])
        content = args["content"]

        client.send_mail_alert(
            alert_id=alert_id, email_addresses=email_addresses, content=content
        )

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_MAIL.value.format(
                alert_id, email_addresses
            )
        )


    def analyst_ask_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Send a question to an analyst about the requested alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        question = args["question"]

        client.analyst_ask_alert(alert_id=alert_id, question=question)
        return CommandResults(
            readable_output=ReadableOutputs.ALERT_ANALYST.value.format(alert_id)
        )


    def list_alert_conversation_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        List alert's analyst messages.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]

        response = client.list_alert_conversation(alert_id=alert_id)
        if response.status_code == HTTPStatus.NO_CONTENT:
            return CommandResults(
                readable_output=ReadableOutputs.ALERT_NO_CONVERSATION_LIST.value
            )
        response_json = response.json()
        mapped_response = [dict_to_lowercase(msg) for msg in response_json]
        outputs = {"id": alert_id, "Message": mapped_response}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_CONVERSATION_LIST.value,
            outputs=outputs,
            headers=["initiator", "message", "date"],
            prefix="Alert",
            key_field="id",
            raw_response=response_json,
            readable_outputs=mapped_response,
        )


    def list_alert_activity_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List alert activity logs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]

        response = client.list_alert_activity(alert_id=alert_id)
        mapped_response = list_parser(response, client.parser.alert_activity_parser)
        outputs = {"ActivityLog": mapped_response, "id": alert_id}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_ACTIVITY.value.format(alert_id),
            readable_outputs=mapped_response,
            outputs=outputs,
            headers=["id", "type", "update_date", "sub_types", "initiator"],
            prefix="Alert",
            key_field="id",
            raw_response=response,
        )


    def add_alert_note_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add a note to alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        client.add_alert_note(
            alert_id=alert_id,
            note=args["note"],
            file_entry_ids=argToList(args.get("entry_ids")),
        )
        return CommandResults(
            readable_output=ReadableOutputs.ALERT_ADD_NOTE.value.format(alert_id)
        )


    def get_alert_blocklist_status_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Get alert's blocklist status.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]

        response = client.get_alert_blocklist(alert_id=alert_id)
        mapped_response = [dict_to_lowercase(msg) for msg in response]
        outputs = {"id": alert_id, "BlockList": mapped_response}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_BLOCKLIST_GET.value.format(alert_id),
            outputs=outputs,
            headers=["value", "status"],
            prefix="Alert",
            key_field="id",
            raw_response=response,
            readable_outputs=mapped_response,
        )


    def update_alert_blocklist_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Change selected IOCs blocklist status.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_update_alert_blocklist(args)

        alert_id = args["alert_id"]
        blocklist_status = args["blocklist_status"]

        client.update_alert_blocklist(
            alert_id=alert_id,
            domains=argToList(args.get("domains")),
            urls=argToList(args.get("urls")),
            ips=argToList(args.get("ips")),
            emails=argToList(args.get("emails")),
            blocklist_status=blocklist_status,
        )

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_BLOCKLIST_UPDATE.value.format(
                blocklist_status
            )
        )


    def list_alert_image_command(
        client: Client, args: dict[str, Any]
    ) -> List[CommandResults | List[Dict[str, Any]]] | CommandResults:
        """
        List alert images by alert ID.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        images = []
        alert_id = args["alert_id"]
        complete_alert = client.get_alert(alert_id=alert_id)
        img_ids = dict_safe_get(complete_alert, ["Details", "Images"], [])
        images = [
            fileResult(filename=f"{img}.png",
                       data=client.get_alert_image(img).content,
                       file_type=EntryType.ENTRY_INFO_FILE)
            for img in img_ids
        ]
        return (
            [
                CommandResults(
                    readable_output=ReadableOutputs.ALERT_IMAGES.value.format(alert_id)
                ),
                images,
            ]
            if images
            else CommandResults(
                readable_output=ReadableOutputs.ALERT_NO_IMAGES.value.format(alert_id)
            )
        )


    def takedown_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Send a takedown request for alert.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        client.takedown_alert(
            alert_id=alert_id,
            target=args["target"],
            close_alert_after_success=argToBoolean(args["close_alert_after_success"]),
        )

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_TAKEDOWN.value.format(alert_id)
        )


    def get_takedown_alert_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Get the alert's takedown status.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        response = client.get_takedown_alert(alert_id=alert_id)
        outputs = {"id": alert_id, "takedown_status": response.content.decode()}
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_TAKEDOWN_STATUS.value.format(alert_id),
            outputs=outputs,
            headers=["takedown_status"],
            prefix="Alert",
            key_field="id",
            raw_response=outputs,
            readable_outputs=outputs,
        )


    def list_alert_type_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List alert types.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_alert_type()
        fixed_response = [
            {"type": object_type, "sub_type": member}
            for object_type in response
            for member in response[object_type]
        ]
        paginated_response = manual_pagination(fixed_response, args)

        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_TYPES.value,
            outputs=paginated_response,
            headers=["type", "sub_type"],
            prefix="AlertType",
            key_field="sub_type",
            raw_response=response,
        )


    def list_alert_source_type_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        List alert source types.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_alert_source_type()
        paginated_response = manual_pagination(response, args)
        return command_result_generate(
            readable_message=ReadableOutputs.ALERT_SOURCE_TYPES.value,
            outputs=paginated_response,
            headers=["source_type"],
            prefix="AlertSourceType",
            raw_response=response,
        )


    def list_alert_scenario_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List alert scenarios.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_alert_scenario(
            type_=args.get("type"), sub_type=args.get("sub_type")
        )
        paginated_response = manual_pagination(response, args)
        fixed_response = [dict_to_lowercase(obj) for obj in paginated_response]
        return command_result_generate(
            readable_message=ReadableOutputs.SCENARIO_LIST.value,
            outputs=fixed_response,
            headers=["scenario", "description", "type", "subtype"],
            prefix="Scenario",
            key_field="scenario",
            raw_response=response,
        )


    def report_alert_ioc_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Report alert IOC.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        client.report_alert_ioc(
            alert_id=alert_id, external_sources=argToList(args["external_sources"])
        )

        return CommandResults(
            readable_output=ReadableOutputs.ALERT_REPORT.value.format(alert_id)
        )


    def list_account_user_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List account users.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        validate_list_account_user(args)
        response = client.list_account_user(
            user_type=args.get("user_type"),
            user_email=args.get("user_email"),
            user_id=args.get("user_id"),
        )
        paginated_response = manual_pagination(response, args)
        mapped_response = list_parser(paginated_response, response_obj_parser)

        return command_result_generate(
            readable_message=ReadableOutputs.ACCOUNT_USER_LIST.value,
            outputs=mapped_response,
            headers=["id", "email", "first_name", "last_name", "role", "is_deleted"],
            prefix="AccountUser",
            key_field="id",
            raw_response=response,
        )


    @polling_function(
        name="threat-command-ioc-search",
        interval=arg_to_number(demisto.args().get("interval_in_seconds", DEFAULT_INTERVAL)),
        timeout=arg_to_number(demisto.args().get("timeout_in_seconds", DEFAULT_TIMEOUT)),
        requires_polling_arg=False,
    )
    def search_ioc_handler_command(args: dict[str, Any], client: Client, execution_metrics: ExecutionMetrics) -> PollResult:
        """
        List IOCs handler.
        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        # validate_list_alert(args=args)
        if argToBoolean(args["enrichment"]):
            # Enrich IOC - Blocked.
            return enrich_ioc_handler(client=client, args=args, execution_metrics=execution_metrics)

        if ioc_value := args.get("ioc_value"):
            # Get IOC by value
            return PollResult(
                response=get_ioc_handler(client=client, ioc_value=ioc_value),
                continue_to_poll=False,
            )

        # Get IOC By filter
        validate_list_ioc(args)
        return PollResult(
            response=list_ioc_handler(client=client, args=args),
            continue_to_poll=False,
        )


    def enrich_ioc_handler(client: Client, args: dict[str, Any], execution_metrics: ExecutionMetrics) -> PollResult:
        """
        Enrich IOC with details.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        ioc_value = args["ioc_value"]
        response = client.enrich_ioc(ioc_value=ioc_value)
        command_results = []
        status = response["Status"]
        if status == "QuotaExceeded":
            execution_metrics.quota_error += 1
            command_results.append(
                CommandResults(
                    readable_output=ReadableErrors.ENRICH_FAIL.value.format(status)
                )
            )
            command_results.append(cast(CommandResults, execution_metrics.metrics))
            return PollResult(
                response=command_results,
                continue_to_poll=False,
            )
        if status == "Failed":
            execution_metrics.general_error += 1
            command_results.append(
                CommandResults(
                    readable_output=ReadableErrors.ENRICH_FAIL.value.format(status)
                )
            )
            command_results.append(cast(CommandResults, execution_metrics.metrics))
            return PollResult(
                response=command_results,
                continue_to_poll=False,
            )
        if response["Status"] == "Done":
            execution_metrics.success += 1
            filtered_response = client.parser.ioc_enrich_parser(response["Data"])
            command_results.append(
                command_result_generate(
                    readable_message=ReadableOutputs.ENRICH_GET.value.format(ioc_value),
                    outputs=filtered_response,
                    prefix="IOC",
                    headers=Headers.ENRICH_IOC.value,
                    key_field="value",
                    raw_response=response,
                )
            )
            command_results.append(cast(CommandResults, execution_metrics.metrics))
            return PollResult(
                response=command_results,
                continue_to_poll=False,
            )
        return PollResult(
            response=response["Status"],
            continue_to_poll=True,
            args_for_next_run=args,
        )


    def get_ioc_handler(client: Client, ioc_value: str) -> CommandResults:
        """
        Get IOC with details.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.get_ioc(ioc_value=ioc_value)
        mapped_response = client.parser.ioc_get_parser(response)
        return command_result_generate(
            readable_message=ReadableOutputs.IOC_GET.value.format(ioc_value),
            outputs=mapped_response,
            headers=Headers.GET_IOC.value,
            prefix="IOC",
            key_field="id",
            raw_response=response,
        )


    def list_ioc_handler(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List IOC by filters.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        paginated_response = auto_pagination(
            request_command=client.list_ioc,
            offset_path=["nextOffset"],
            limit=arg_to_number(args.get("limit", 50)),
            page=arg_to_number(args.get("page")),
            page_size=arg_to_number(args.get("page_size")),
            last_updated_from=args.get("last_updated_from"),
            last_updated_to=args.get("last_updated_to"),
            last_seen_from=args.get("last_seen_from"),
            last_seen_to=args.get("last_seen_to"),
            first_seen_from=args.get("first_seen_from"),
            first_seen_to=args.get("first_seen_to"),
            status=args.get("status"),
            type_list=argToList(args.get("type_list")),
            severity_list=argToList(args.get("severity_list")),
            whitelisted=args.get("whitelisted"),
            source_ids=argToList(args.get("source_ids")),
            kill_chain_phases=argToList(args.get("kill_chain_phases")),
        )
        mapped_response = list_parser(
            paginated_response["content"], client.parser.ioc_get_parser
        )

        return command_result_generate(
            readable_message=ReadableOutputs.IOC_LIST.value,
            outputs=mapped_response,
            headers=Headers.GET_IOC.value,
            prefix="IOC",
            key_field="id",
            raw_response=paginated_response,
        )


    def add_tags_ioc_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add tags to IOC.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        ioc_value = args["ioc_value"]
        tag_values = argToList(args["tag_values"])

        client.tags_ioc(ioc_value=ioc_value, tag_values=tag_values)

        return CommandResults(
            readable_output=ReadableOutputs.IOC_TAG_ADD.value.format(ioc_value, tag_values)
        )


    def update_ioc_severity_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Update severity for IOCs.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        severity = args["severity"]

        iocs = handle_iocs(args=args)

        validate_alert_ioc_severity(args)
        client.update_ioc_severity(
            severity=severity,
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.UPDATE_IOC_SEVERITY.value.format(iocs, severity)
        )


    def add_ioc_comment_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add comment to IOCs.

        Args:

            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        comment = args["comment"]

        iocs = handle_iocs(args=args)
        client.add_ioc_comment(
            comment=comment,
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.ADD_IOC_COMMENT.value.format(iocs, comment)
        )


    def update_account_whitelist_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Update account whitelist.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        is_whitelisted = args["is_whitelisted"]

        iocs = handle_iocs(args=args)
        validate_update_account_whitelist(args)
        client.update_account_whitelist(
            is_whitelisted=is_whitelisted,
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.UPDATE_ACCOUNT_WHITELIST.value.format(
                iocs, is_whitelisted
            )
        )


    def remove_account_whitelist_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Remove IOCs from account whitelist.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        iocs = handle_iocs(args=args)
        client.remove_account_whitelist(
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.REMOVE_ACCOUNT_WHITELIST.value.format(iocs)
        )


    def add_ioc_blocklist_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Add IOCs to remediation blocklist.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """

        iocs = handle_iocs(args=args)
        client.add_ioc_blocklist(
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.ADD_IOC_BLOCKLIST.value.format(iocs)
        )


    def remove_ioc_blocklist_command(
        client: Client, args: dict[str, Any]
    ) -> CommandResults:
        """
        Remove IOCs from remediation blocklist.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """

        iocs = handle_iocs(args=args)
        client.remove_ioc_blocklist(
            ioc_values=iocs,
        )

        return CommandResults(
            readable_output=ReadableOutputs.REMOVE_IOC_BLOCKLIST.value.format(iocs)
        )


    def search_mention_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        Search mentions.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        search = args["search"]
        page_number = arg_to_number(args["page_number"])
        validate_search_mentions(args)
        if not isinstance(page_number, int):
            raise ValueError(ReadableErrors.NUMBER.value)
        response = client.search_mention(
            search=search,
            report_date=args.get("report_date"),
            page_number=page_number,
            source_types=argToList(args.get("source_types")),
            only_dark_web=argToBoolean(args.get("only_dark_web")),
            highlight_tags=argToBoolean(args.get("highlight_tags")),
        )
        mapped_response = list_parser(response["Data"], client.parser.mention_parser)
        return command_result_generate(
            readable_message=ReadableOutputs.MENTIONS.value.format(search, page_number),
            outputs=mapped_response,
            headers=Headers.MENTION.value,
            prefix="Mentions",
            key_field="id",
            raw_response=response,
        )


    def usage_quota_enrichment_command(client: Client, *_) -> CommandResults:
        """
        Get enrichment quota.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.usage_quota_enrichment()
        mapped_response = response_obj_parser(dict_=response["EnrichIocsQuota"])
        return command_result_generate(
            readable_message=ReadableOutputs.ENRICH_QUOTA.value,
            outputs=mapped_response,
            headers=["time_period", "total", "remaining"],
            prefix="IOCsQuota",
            raw_response=response,
        )


    def list_mssp_user_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List MSSP users.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_mssp_user()
        paginated_response = manual_pagination(response, args)
        mapped_response = list_parser(paginated_response, response_obj_parser)
        return command_result_generate(
            readable_message=ReadableOutputs.MSSP_USER_LIST.value,
            outputs=mapped_response,
            headers=["id", "email", "role", "is_deleted"],
            prefix="MsspUser",
            key_field="id",
            raw_response=response,
        )


    def list_mssp_customer_command(client: Client, args: dict[str, Any]) -> CommandResults:
        """
        List MSSP customers.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        response = client.list_mssp_customer()
        paginated_response = manual_pagination(response, args)
        mapped_response = list_parser(paginated_response, response_obj_parser)
        return command_result_generate(
            readable_message=ReadableOutputs.MSSP_CUSTOMER_LIST.value,
            outputs=mapped_response,
            headers=["id", "company_name", "status", "note"],
            prefix="MsspCustomer",
            key_field="id",
            raw_response=response,
        )


    def get_alert_csv_command(
        client: Client, args: dict[str, Any]
    ) -> List[CommandResults | Dict[str, Any]] | CommandResults:
        """
        Get alert CSV file if exists.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.

        Returns:
            List[CommandResults | Dict[str, Any]] | CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        alert_id = args["alert_id"]
        csv_response = client.get_alert_csv(alert_id)
        if csv_response.status_code != HTTPStatus.OK:
            return CommandResults(
                readable_output=ReadableOutputs.ALERT_NO_CSV.value.format(alert_id)
            )
        csv_file = fileResult(filename=f"{alert_id}.csv", data=csv_response.content, file_type=EntryType.ENTRY_INFO_FILE)
        decoded_content = csv_response.content.decode()
        tab_based_content = list(csv.DictReader(decoded_content.splitlines(), delimiter="\t"))
        content = list(csv.DictReader(decoded_content.splitlines(), delimiter=","))
        if tab_based_content and content and (len(tab_based_content[0]) > len(content[0])):
            content = tab_based_content
        outputs = {"alert_id": alert_id, 'content': content}
        return [
            CommandResults(
                readable_output=ReadableOutputs.ALERT_CSV.value.format(alert_id),
                outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.CSV",
                outputs_key_field='alert_id',
                outputs=outputs,
                raw_response=outputs,
            ),
            csv_file,
        ]


    @polling_function(
        name="file",
        interval=arg_to_number(demisto.args().get("interval_in_seconds", DEFAULT_INTERVAL)),
        timeout=arg_to_number(demisto.args().get("timeout_in_seconds", DEFAULT_TIMEOUT)),
        requires_polling_arg=False,
    )
    def file_command(args: dict[str, Any], client: Client, execution_metrics: ExecutionMetrics) -> PollResult:
        """
        Enrich file IOC (Generic reputation command).

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            PollResult: outputs, readable outputs and raw response for XSOAR.
        """
        return reputation_handler(
            args, client, file_reputation_handler, IOCType.FILE.value.lower(), execution_metrics
        )


    @polling_function(
        name="ip",
        interval=arg_to_number(demisto.args().get("interval_in_seconds", DEFAULT_INTERVAL)),
        timeout=arg_to_number(demisto.args().get("timeout_in_seconds", DEFAULT_TIMEOUT)),
        requires_polling_arg=False,
    )
    def ip_command(args: dict[str, Any], client: Client, execution_metrics: ExecutionMetrics) -> PollResult:
        """
        Enrich ip IOC (Generic reputation command).

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            PollResult: outputs, readable outputs and raw response for XSOAR.
        """
        return reputation_handler(
            args, client, ip_reputation_handler, IOCType.IP.value.lower(), execution_metrics
        )


    @polling_function(
        name="url",
        interval=arg_to_number(demisto.args().get("interval_in_seconds", DEFAULT_INTERVAL)),
        timeout=arg_to_number(demisto.args().get("timeout_in_seconds", DEFAULT_TIMEOUT)),
        requires_polling_arg=False,
    )
    def url_command(args: dict[str, Any], client: Client, execution_metrics: ExecutionMetrics) -> PollResult:
        """
        Enrich URL IOC (Generic reputation command).

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            PollResult: outputs, readable outputs and raw response for XSOAR.
        """

        return reputation_handler(
            args, client, url_reputation_handler, IOCType.URL.value.lower(), execution_metrics
        )


    @polling_function(
        name="domain",
        interval=arg_to_number(demisto.args().get("interval_in_seconds", DEFAULT_INTERVAL)),
        timeout=arg_to_number(demisto.args().get("timeout_in_seconds", DEFAULT_TIMEOUT)),
        requires_polling_arg=False,
    )
    def domain_command(args: dict[str, Any], client: Client, execution_metrics: ExecutionMetrics) -> PollResult:
        """
        Enrich domain IOC (Generic reputation command).

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            PollResult: outputs, readable outputs and raw response for XSOAR.
        """
        return reputation_handler(
            args, client, domain_reputation_handler, IOCType.DOMAIN.value.lower(), execution_metrics
        )


    def reputation_handler(
        args: dict[str, Any], client: Client, handler_command: Callable, key: str, execution_metrics: ExecutionMetrics
    ) -> PollResult:
        """
        Handle with all reputation commands.

        Args:
            client (Client): Threat Command API client.
            args (Dict[str, Any]): Command arguments from XSOAR.
            handler_command (Callable): Handler command for each command.
            key (str): Key for the IOC.
            execution_metrics (ExecutionMetrics): Execution metrics.

        Returns:
            PollResult: outputs, readable outputs and raw response for XSOAR.
        """
        ioc_values: List[str] = argToList(args[key])

        responses = [client.enrich_ioc(ioc_value=ioc_value) for ioc_value in ioc_values]

        command_results = []
        done_responses = list(filter(
            lambda response: response["Status"] == "Done",
            responses
        ))
        failed_responses = list(filter(
            lambda response: response["Status"] == "Failed",
            responses
        ))
        quota_responses = list(filter(
            lambda response: response["Status"] == "QuotaExceeded",
            responses
        ))
        for response in done_responses + failed_responses + quota_responses:
            ioc_values.remove(response['OriginalValue'])

        if not ioc_values:
            execution_metrics.success += len(done_responses)
            execution_metrics.general_error += len(failed_responses)
            execution_metrics.quota_error += len(quota_responses)
            for response in done_responses:
                command_results.append(handler_command(client=client, obj=response, obj_id=response['OriginalValue']))
            for response in failed_responses + quota_responses:
                command_results.append(
                    CommandResults(readable_output=ReadableErrors.ENRICH_FAIL.value.format(response["Status"])))

            command_results.append(cast(CommandResults, execution_metrics.metrics))

            return PollResult(
                response=command_results,
                continue_to_poll=False,
                args_for_next_run=args
            )

        return PollResult(
            partial_result=CommandResults(
                readable_output=f'Waiting for "{ioc_values}" to finish...'),
            response=command_results,
            continue_to_poll=True,
            args_for_next_run=args
        )


    """ HELPER FUNCTIONS """


    def file_reputation_handler(
        client: Client, obj: dict[str, Any], obj_id: str
    ) -> CommandResults:
        """
        Handle with file enrichment response.

        Args:
            client (Client): Threat Command API client.
            obj (dict[str, Any]): File response.
            obj_id (str): File value.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        command_args = client.parser.file_reputation_parser(
            obj=obj, hash_=obj_id, reliability=client.reliability
        )
        file_indicator = Common.File(**command_args)
        command_args.pop("dbot_score")
        return CommandResults(
            outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.File",
            outputs_key_field="sha256",
            indicator=file_indicator,
            readable_output=tableToMarkdown(
                f"Rapid7 Threat Command - Hash Reputation for: {obj_id}", t=command_args
            ),
            outputs=command_args,
            raw_response=obj,
        )


    def ip_reputation_handler(
        client: Client, obj: Dict[str, Any], obj_id: str
    ) -> CommandResults:
        """
        Handle with IP enrichment response.

        Args:
            client (Client): Threat Command API client.
            obj (dict[str, Any]): IP response.
            obj_id (str): IP value.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        command_args = client.parser.ip_reputation_parser(
            obj=obj, ip=obj_id, reliability=client.reliability
        )
        ip_indicator = Common.IP(**command_args)
        command_args.pop("dbot_score")
        return CommandResults(
            outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.IP",
            outputs_key_field="ip",
            indicator=ip_indicator,
            readable_output=tableToMarkdown(
                f"Rapid7 Threat Command - IP Reputation for: {obj_id}", command_args
            ),
            outputs=command_args,
            raw_response=obj,
        )


    def url_reputation_handler(
        client: Client, obj: Dict[str, Any], obj_id: str
    ) -> CommandResults:
        """
        Handle with URL enrichment response.

        Args:
            client (Client): Threat Command API client.
            obj (dict[str, Any]): URL response.
            obj_id (str): URL value.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        command_args = client.parser.url_reputation_parser(
            obj=obj, url=obj_id, reliability=client.reliability
        )
        url_indicator = Common.URL(**command_args)
        command_args.pop("dbot_score")

        return CommandResults(
            outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.URL",
            outputs_key_field="url",
            indicator=url_indicator,
            readable_output=tableToMarkdown(
                f"Rapid7 Threat Command - URL Reputation for: {obj_id}", command_args
            ),
            outputs=command_args,
            raw_response=obj,
        )


    def domain_reputation_handler(
        client: Client, obj: Dict[str, Any], obj_id: str
    ) -> CommandResults:
        """
        Handle with domain enrichment response.

        Args:
            client (Client): Threat Command API client.
            obj (dict[str, Any]): Domain response.
            obj_id (str): Domain value.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        command_args = client.parser.domain_reputation_parser(
            obj=obj, domain=obj_id, reliability=client.reliability
        )
        domain_indicator = Common.Domain(**command_args)
        del command_args["dbot_score"]
        del command_args["dns_records"]
        return CommandResults(
            outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.Domain",
            outputs_key_field="domain",
            indicator=domain_indicator,
            readable_output=tableToMarkdown(
                f"Rapid7 Threat Command - domain Reputation for: {obj_id}",
                command_args,
            ),
            outputs=command_args,
            raw_response=obj,
        )


    def get_dbotscore(
        reliability: str, indicator: str = None, is_known_ioc: bool | None = None
    ) -> Common.DBotScore:
        """
        Get XSOAR score for the indicator.
        Args:
            reliability (str): Reliability of the source providing the intelligence data.
            indicator (str, optional): Indicator response.
                Defaults to None.
            is_known_ioc (bool, optional): Whether the IOC is known to Threat Command.
                Defaults to None.
        Returns:
            Common.DBotScore: DBot Score according to the disposition.
        """
        if is_known_ioc:
            score = Common.DBotScore.BAD

        elif is_known_ioc:
            score = Common.DBotScore.GOOD

        else:
            score = Common.DBotScore.NONE

        return Common.DBotScore(
            indicator=indicator,
            indicator_type=DBotScoreType.FILE,
            integration_name="ThreatCommand",
            reliability=reliability,
            score=score,
        )


    def get_enrich_hashes(response: dict[str, Any]) -> dict[str, Any]:
        """
        Get hashes values from hash enrichment response.

        Args:
            response (dict[str, Any]): Hash enrichment response from Threat Command API.

        Returns:
            dict[str, Any]: Hashes dictionary.
        """
        return (
            {
                hash["Type"]: hash["Value"]
                for hash in dict_safe_get(response, ["Data", "RelatedHashes"], [])
            }
            if isinstance(dict_safe_get(response, ["Data", "RelatedHashes"]), list)
            else {}
        )


    def get_enrich_file_nams(response: dict[str, Any]) -> List[str]:
        """
        Get file names from enrichment response.

        Args:
            response (dict[str, Any]): Hash enrichment response from Threat Command API.

        Returns:
            List[str]: File names.
        """
        return remove_empty_elements(
            [
                detection.get("Result") if detection.get("Result") != "" else None
                for detection in dict_safe_get(
                    response, ["Data", "AntivirusDetections"], []
                )
            ]
        )


    def remove_whitespaces(str_: str | None) -> str | None:
        """
        Remove whitespaces from string.

        Args:
            str_ (str | None): String to remove whitespaces from.

        Returns:
            str | None: String without whitespaces.
        """
        if str_:
            return str_.replace(" ", "")
        return None


    def files_handler(file_ids: List[str], is_image: bool = False) -> List[dict[str, Any]]:
        """
        Read XSOAR file ids and organized them in list.

        Args:
            file_ids (List[str]): XSOAR file ids.
            is_image (bool, optional): is the file are images for creating alert?. Defaults to False.

        Returns:
            List[dict[str, Any]]: List of the files with data.
        """
        files_data = []
        for image_id in file_ids:
            file_data = demisto.getFilePath(image_id)
            file_type = pathlib.Path(file_data["name"]).suffix[1:]
            with open(file_data["path"], "rb") as f:
                files_data.append(
                    {
                        "Data": base64.b64encode(f.read()).decode(),
                        "Type": "jpeg" if file_type == "jpg" else file_type,
                        "Name": file_data["name"] if not is_image else None,
                    }
                )
        return remove_empty_elements(files_data)


    def command_result_generate(
        readable_message: str,
        outputs: Dict[str, Any] | List[Any],
        headers: List[str],
        prefix: str,
        readable_outputs: Dict[str, Any] | List | None = None,
        key_field: str | None = None,
        raw_response: Dict[str, Any] | List[Any] | None = None,
    ) -> CommandResults:
        """
        Generate CommandResults object with readable output.

        Args:
            readable_message (str): Readable output message.
            outputs (Dict[str, Any] | List[Any]): Outputs to XSOAR outputs.
            headers (List[str]): Headers for readable outputs table.
            prefix (str): Outputs prefix.
            readable_outputs (Dict[str, Any] | List | None, optional): Readable outputs to show. Defaults to None.
            key_field (str): Outputs key field.
            raw_response (Dict[str, Any] | List[Any]): Raw response to XSOAR outputs.

        Returns:
            CommandResults: outputs, readable outputs and raw response for XSOAR.
        """
        return CommandResults(
            readable_output=tableToMarkdown(
                name=readable_message,
                t=readable_outputs if readable_outputs else outputs,
                headers=headers,
                headerTransform=string_to_table_header,
                removeNull=True,
            ),
            outputs_prefix=f"{INTEGRATION_ENTRY_CONTEXT}.{prefix}",
            outputs_key_field=key_field,
            outputs=outputs,
            raw_response=raw_response,
        )


    def manual_pagination(response: List[Any], args: dict[str, Any]) -> List[Any]:
        """
        Executing Manual paginate_results (using the limit argument).

        Args:
            response (List[dict[str, Any]]): API response.
            args (dict[str, Any]): Command arguments from XSOAR.

        Returns:
            List[dict[str, Any]]: Paginated results.
        """

        if argToBoolean(args.get("all_results", False)):
            return response

        limit = arg_to_number(args.get("limit", 50))

        if limit and limit < 1:
            raise ValueError(ReadableErrors.LIMIT.value)

        return response[:limit]


    def list_parser(
        values: List[dict[str, Any]], mapper_command: Callable
    ) -> List[dict[str, Any]]:
        """
        Handle with parse list of objects.

        Args:
            values (List[dict[str, Any]]): List of objects to map.
            mapper_command (Callable): The object parse command.

        Returns:
            List[dict[str, Any]]: Parsed list.
        """
        return [mapper_command(obj) for obj in values]


    def auto_pagination(
        request_command: Callable,
        offset_path: List[str],
        limit: int | None,
        page: int | None,
        page_size: int | None,
        offset: str | None = None,
        **kwargs,
    ) -> dict[str, Any]:
        """
        Handle with pagination when the API supports pagination.

        Args:
            request_command (Callable): List request command.
            offset_path (List[str]): The path to the offset arg (in order to handle with page, page_size).
            limit (int): Limit for pagination.
            page (int | None): Page for pagination
            page_size (int | None): Page size for pagination
            offset (str | None, optional): Offset for pagination. Defaults to None.

        Raises:
            ValueError: Error with pagination when there is no offset arg.

        Returns:
            dict[str, Any]: Paginated response.
        """
        command_args = copy.deepcopy(kwargs)
        command_args["offset"] = offset
        if page and page_size:
            if page == 1:
                command_args["limit"] = page_size
                return request_command(**command_args)
            calculate = (page - 1) * page_size
            command_args["limit"] = (
                calculate
                if calculate < API_MAX_LIMIT
                else calculate - calculate % page_size
            )
            offset = dict_safe_get(request_command(**command_args), offset_path)
            if calculate > API_MAX_LIMIT:
                auto_pagination(
                    request_command=request_command,
                    offset_path=offset_path,
                    page=int(page - command_args["limit"] / page_size),
                    page_size=page_size,
                    **command_args,
                )
            if offset is None:
                raise ValueError("Error with pagination.")

            command_args["limit"] = page_size
            command_args["offset"] = offset
            return request_command(**command_args)
        command_args["limit"] = limit
        return request_command(**command_args)


    def map_ioc_list(
        domains: List[str] | None = None,
        urls: List[str] | None = None,
        ips: List[str] | None = None,
        hashes: List[str] | None = None,
        emails: List[str] | None = None,
        blocklist_status: str = None,
    ) -> List[dict[str, Any]]:
        """
        Map lists of IOCs to Threat Command API form.

        Args:
            domains (List[str] | None, optional): A list of domain IOC values to add.. Defaults to None.
            urls (List[str] | None, optional): A list of URL IOC values to add.. Defaults to None.
            ips (List[str] | None, optional): A list of IP IOC values to add.. Defaults to None.
            hashes (List[str] | None, optional): A list of hash IOC values to add.. Defaults to None.
            emails (List[str] | None, optional): A list of email IOC values to add.. Defaults to None.
            blocklist_status (str, optional): Blocklist status in case of using blocklist command. Defaults to None.

        Returns:
            List[dict[str, Any]]: Mapped list of IOCs with types.
        """
        mapped_domains = [
            {
                "Type": "Domains",
                "Value": domain,
            }
            for domain in domains or []
        ]
        mapped_hashes = (
            [{"Type": "Hashes", "Value": hash} for hash in hashes] if hashes else []
        )

        mapped_urls = [
            {"Type": "URLs" if blocklist_status else "Urls", "Value": url}
            for url in urls or []
        ]
        mapped_ips = [
            {"Type": "IPs" if blocklist_status else "IpAddresses", "Value": ip}
            for ip in ips or []
        ]
        mapped_emails = [
            {"Type": "EmailAddresses" if blocklist_status else "Emails", "Value": email}
            for email in emails or []
        ]
        mapped_iocs = (
            mapped_domains + mapped_urls + mapped_ips + mapped_hashes + mapped_emails
        )
        if blocklist_status:
            for ioc in mapped_iocs:
                ioc |= {"BlocklistStatus": blocklist_status}
        return mapped_iocs


    def handle_iocs(args: dict[str, Any]) -> List[str]:
        """
        Validate IOC values.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR..

        Raises:
            ValueError: Insert correct domain.
            ValueError: Insert correct url.
            ValueError: Insert correct ip.
            ValueError: Insert correct hash.
            ValueError: Insert correct email.

        Returns:
            List[str]: List of IOCs.

        """
        domains = argToList(args.get("domains"))
        urls = argToList(args.get("urls"))
        ips = argToList(args.get("ips"))
        hashes = argToList(args.get("hashes"))
        emails = argToList(args.get("emails"))

        if all([not domains, not urls, not ips, not hashes, not emails]):
            raise ValueError(ReadableErrors.NO_IOCS.value)
        for iocs, ioc_type in [
            (urls, IOCType.URL),
            (ips, IOCType.IP),
            (hashes, IOCType.HASH),
            (emails, IOCType.EMAIL),
        ]:
            for ioc in iocs:
                if not re.match(pattern_and_readable_error_by_ioc_type[ioc_type][0], ioc):
                    raise ValueError(
                        pattern_and_readable_error_by_ioc_type[ioc_type][1].value.format(
                            ioc
                        )
                    )

        return domains + urls + ips + hashes + emails


    def validate_create_source_document(args: dict[str, Any]) -> dict[str, Any]:
        """
        Validate create source document arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: Error with one of the arguments.

        Returns:
            dict[str, Any]: Updated args.
        """
        validate_argument(
            args=args, key_="severity", values=ArgumentValues.ALERT_IOC_AND_DOCUMENT_SEVERITY.value
        )
        validate_argument(args=args, key_="share", values=ArgumentValues.BOOLEAN.value)
        confidence_level = arg_to_number(args["confidence_level"])
        if not confidence_level or any([confidence_level < 0, confidence_level > 3]):
            raise ValueError(ReadableErrors.CONFIDENCE_LEVEL.value)

        handle_iocs(args=args)
        return args | {"confidence_level": confidence_level}


    def multi_status_handler(
        res: dict[str, Any],
        objects: List[str],
        object_key: str,
        success_readable: str,
        fail_readable: str,
    ) -> List[CommandResults]:
        """
        Handle with multi status request.

        Args:
            res (dict[str, Any]): Response from the API.
            objects (List[str]): List of objects that sent with the request.
            object_key (str): Object key in the response.
            success_readable (str): Readable text for objects that succeeded.
            fail_readable (str): Readable text for objects that failed.

        Returns:
            List[CommandResults]: outputs, readable outputs and raw response for XSOAR.
        """
        succeeded = objects
        failed = []
        if (failure := res.get("failure")) and isinstance(failure, list):
            for obj in failure:
                reason = obj["failReason"]
                obj_id = obj[object_key]
                succeeded = list(set(succeeded) - {obj_id})
                failed.append(f"{obj_id} ({reason})")
        if not succeeded:
            raise ValueError(fail_readable.format((",").join(failed)))
        return remove_empty_elements(
            [
                CommandResults(
                    readable_output=success_readable.format((",").join(succeeded))
                )
                if succeeded
                else None,
                CommandResults(readable_output=fail_readable.format((",").join(failed)))
                if failed
                else None,
            ]
        )


    def validate_create_alert(args: dict[str, Any]):
        """
        Validator for create alerts arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        scenario = args.get("scenario")
        type_ = args.get("type")
        sub_type = args.get("sub_type")

        if any(
            [
                not any([scenario, type_, sub_type]),
                all([scenario, type_, sub_type]),
                all([scenario, sub_type]) or all([scenario, type_]),
            ]
        ):
            raise ValueError(ReadableErrors.SCENARIO_TYPES.value)
        if all([type_, not sub_type]):
            raise ValueError(ReadableErrors.ALERT_SUB_TYPE.value)
        if all([not type_, sub_type]):
            raise ValueError(ReadableErrors.ALERT_TYPE.value)

        validate_argument(args=args, key_="type", values=ArgumentValues.ALERT_TYPE.value)
        validate_argument(
            args=args, key_="severity", values=ArgumentValues.ALERT_IOC_AND_DOCUMENT_SEVERITY.value
        )
        validate_argument(
            args=args,
            key_="source_network_type",
            values=ArgumentValues.ALERT_SOURCE_NETWORK.value,
        )


    def validate_list_alert(args: dict[str, Any]):
        """
        Validator for list alert arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(
            args=args, key_="network_type", values=ArgumentValues.ALERT_SOURCE_NETWORK.value
        )
        validate_argument(
            args=args, key_="source_type", values=ArgumentValues.SOURCE_TYPE.value
        )
        validate_argument(
            args=args, key_="alert_type", values=ArgumentValues.ALERT_TYPE.value
        )

        if args.get("alert_id") and argToBoolean(args["retrieve_ids_only"]):
            raise ValueError(ReadableErrors.ALERT_LIST.value)


    def validate_close_alert(args: dict[str, Any]):
        """
        Validator for close alert arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(
            args=args, key_="reason", values=ArgumentValues.ALERT_CLOSE_REASON.value
        )
        validate_argument(args=args, key_="is_hidden", values=ArgumentValues.BOOLEAN.value)
        if argToBoolean(args["is_hidden"]) and args.get("reason") != "False Positive":
            raise ValueError(ReadableErrors.IS_HIDDEN.value)

        rate = arg_to_number(args.get("rate"))

        if rate and not 0 <= rate <= 5:
            raise ValueError(ReadableErrors.RATE.value)


    def validate_update_alert_blocklist(args: dict[str, Any]):
        """
        Validator for upadte alert blocklist arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        handle_iocs(args=args)
        validate_argument(
            args=args, key_="blocklist_status", values=ArgumentValues.ALERT_BLOCKLIST.value
        )


    def validate_assign_alert(args: dict[str, Any]):
        """
        Validator for assign alert.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(args=args, key_="is_mssp", values=ArgumentValues.BOOLEAN.value)


    def validate_list_cve(args: dict[str, Any]):
        """
        Validator for list CVEs.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        severity_list = argToList(args.get("severity_list"))
        if severity_list and not set(severity_list).issubset(ArgumentValues.CVE_SEVERITY.value):
            raise ValueError(
                ReadableErrors.ARGUMENT.value.format(
                    "severity_list", ArgumentValues.CVE_SEVERITY.value
                )
            )


    def validate_list_account_user(args: dict[str, Any]):
        """
        Validator for list account users.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(
            args=args, key_="user_type", values=ArgumentValues.USER_TYPE.value
        )


    def validate_alert_ioc_severity(args: dict[str, Any]):
        """
        Validator for alert IOC severity arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(
            args=args, key_="severity", values=ArgumentValues.ALERT_IOC_AND_DOCUMENT_SEVERITY.value
        )


    def validate_update_account_whitelist(args: dict[str, Any]):
        """
        Validator for update account whitelist arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        validate_argument(
            args=args, key_="is_whitelisted", values=ArgumentValues.WHITELIST_STATUS.value
        )


    def validate_list_ioc(args: dict[str, Any]):
        """
        Validator for list IOC arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        if not args.get("last_updated_from"):
            raise ValueError(ReadableErrors.INSERT_VALUE.value.format("last_updated_from"))


    def validate_search_mentions(args: dict[str, Any]):
        """
        Validator for search mentions arguments.

        Args:
            args (dict[str, Any]): Command arguments from XSOAR.

        Raises:
            ValueError: In case of wrong arguments.
        """
        if not isinstance(arg_to_number(args["page_number"]), int):
            raise ValueError(ReadableErrors.NUMBER.value)
        validate_argument(
            args=args, key_="source_type", values=ArgumentValues.MENTION_SOURCE_TYPE.value
        )
        validate_argument(
            args=args, key_="only_dark_web", values=ArgumentValues.BOOLEAN.value
        )
        validate_argument(
            args=args, key_="highlight_tags", values=ArgumentValues.BOOLEAN.value
        )


    def validate_argument(args: dict[str, Any], key_: str, values: List[str]):
        """
        Validate for XSOAR input arguments.

        Args:
            args (dict[str, Any]): XSOAR arguments.
            key_ (str): The key of the argument.
            values (List[str]): Optional values.

        Raises:
            ValueError: In case that the input is wrong.
        """
        if args.get(key_) and args[key_] not in values:
            raise ValueError(ReadableErrors.ARGUMENT.value.format(key_, values))


    def dict_to_lowercase(dict_: dict[str, Any]) -> dict[str, Any]:
        """
        Return a dictionary with lowercase keys.

        Args:
            dict_ (dict[str, Any]): Dictionary.

        Returns:
            dict[str, Any]: Dictionary with lowercase keys.
        """
        return {k.lower(): v for k, v in dict_.items()}


    def alert_readable_outputs_handler(response: dict[str, Any]) -> dict[str, Any]:
        """
        Create readable outputs for alert.

        Args:
            response (dict[str, Any]): Alert respose

        Returns:
            dict[str, Any]: Alert readable dictionary.
        """
        return copy.deepcopy(response) | {
            "Tags": [tag["name"] for tag in response.get("Tags", [])]
        }


    def arg_to_optional_bool(bool_: str | None) -> bool | None:
        """
        Returns the boolean value of the argument.

        Args:
            bool_ (str | None): Argument value.

        Returns:
            bool | None: Boolean argument.
        """
        if bool_ is None:
            return None
        return argToBoolean(bool_)


    def response_obj_parser(dict_: dict[str, Any]) -> dict[str, Any]:
        """
        Parse dictionary keys to lowercase.

        Args:
            dict_ (dict[str, Any]): Dictionary to parse.

        Returns:
            dict[str, Any]: Parsed dictionary.
        """
        return {
            camel_case_to_underscore(k if k != "_id" else "id"): v
            for k, v in dict_.items()
        }


    def minimum_severity_handler(severity: str | None) -> List[str]:
        """
        Replace minimum severity to list of the relevant severities.

        Args:
            severity (str | None): Severity value.

        Returns:
            List[str]: List of the relevant severities.
        """
        if not severity:
            return ["High", "Medium", "Low"]
        if severity == "High":
            return ["High"]
        if severity == "Medium":
            return ["High", "Medium"]
        return ["High", "Medium", "Low"]


    def test_module(client: Client, params: Dict) -> str:
        """
        Test module.

        Args:
            client (Client): Threat Command client.
            params (Dict): Integration parameters.

        Returns:
            str: Output message.
        """
        try:
            if params.get('isFetch'):
                first_fetch = arg_to_datetime(params.get("first_fetch"), arg_name="First fetch timestamp")
                max_fetch = arg_to_number(params["max_fetch"])
                if not max_fetch or not isinstance(max_fetch, int) or max_fetch < 1 or max_fetch > 200:
                    raise ValueError(ReadableErrors.MAX_FETCH_INVALID.value)
                if not isinstance(first_fetch, datetime):
                    raise ValueError(ReadableErrors.FIRST_FETCH_NOT_EXIST.value)
            client.list_system_modules()
        except Exception as error:
            demisto.debug(str(error))
            return f"Error: {error}"
        return "ok"


    def fetch_incidents(
        client: Client,
        last_run: Dict[str, Any],
        first_fetch: str,
        max_fetch: int,
        alert_types: List[str] | None,
        network_types: List[str] | None,
        alert_severities: List[str] | None,
        source_types: List[str] | None,
        fetch_csv: bool | None,
        is_closed: bool,
        fetch_attachments: bool | None,
    ) -> tuple[Dict[str, Any], List[dict]]:
        """
        Retrieves new alerts every interval (default is 1 minute).
        By default it's invoked by XSOAR every minute.
        It will use last_run to save the time of the last incident it processed and previous incident IDs.
        If last_run is not provided, first_fetch_time will be used to determine when to start fetching the first time.
        Args:
            client (Client): Cisco AMP client to run desired requests
            last_run (Dict[str, Any]):
                offset: Offset of the last fetched alert.
            first_fetch (str): Determines the time of when fetching has been started.
            max_fetch (int): Max number of incidents to fetch in a single run.

            alert_types (List[str], optional): Alert types to filter by.
            network_types (List[str], optional): Network types to filter by.
            alert_severities (List[str], optional): Alert severities to filter by.
            source_types (List[str], optional): Alert source types to filter by.
            fetch_csv (bool, optional): Whether to fetch CSV file if exist.
            is_closed (bool): Whether to fetch closed alerts.
            fetch_attachments (bool, optional): Whether to fetch images if exist.
        Returns:
            Tuple[Dict[str, Any], List[dict]]:
                next_run: Contains information that will be used in the next run.
                incidents: List of incidents that will be created in XSOAR.
        """
        incidents = []
        offset = None
        if (offset_time := last_run.get("time")) and (offset_id := last_run.get("last_id")):
            try:
                datetime.fromisoformat(offset_time.replace("Z", "+00:00"))
                offset = f"{offset_time}::{offset_id}"
            except ValueError:
                demisto.debug(f'Error occurred while transforming offset time "{offset_time}" from last run.')
                offset = None

        list_response = client.list_alert(
            offset=offset,
            limit=max_fetch,
            last_updated_from=first_fetch,
            alert_type=alert_types,
            network_type=network_types,
            severity=alert_severities,
            source_type=source_types,
            is_closed=is_closed,
        )
        if not list_response.get("content"):
            demisto.debug(f'Alerts not found with the provided parameters and with the offset "{offset}".')
            return last_run, []

        alert_ids = [alert["_id"] for alert in list_response["content"]]
        alert_ids_list = ', '.join(alert_ids)
        demisto.debug(
            f'List of alert IDs "{alert_ids_list}" found with the provided parameters and with the offset "{offset}".')
        for alert_id in alert_ids:
            alert_details = client.get_alert(alert_id=alert_id)
            incident = client.parser.alert_fetch_parser(alert_details)
            incident["fetch_csv"] = fetch_csv
            incident["fetch_attachments"] = fetch_attachments
            incidents.append(client.parser.parse_incident(alert=incident))

        offset_date = list_response["content"][-1].get("updateDate")
        offset_id = list_response["content"][-1].get("_id")
        next_run = {"time": offset_date, "last_id": offset_id}
        return next_run, incidents


    def main() -> None:
        params: dict[str, Any] = demisto.params()
        args: dict[str, Any] = demisto.args()
        base_url = params["base_url"]
        account_id = dict_safe_get(params, ["credentials", "identifier"])
        api_key = dict_safe_get(params, ["credentials", "password"])
        mssp_sub_account = params.get("mssp_sub_account")
        reliability = params.get("integrationReliability", DBotScoreReliability.C)
        verify_certificate: bool = not params.get("insecure", False)
        proxy = params.get("proxy", False)
        execution_metrics = ExecutionMetrics()

        if DBotScoreReliability.is_valid_type(reliability):
            reliability = DBotScoreReliability.get_dbot_score_reliability_from_str(
                reliability
            )
        else:
            raise ValueError(
                "Please provide a valid value for the Source Reliability parameter."
            )

        command = demisto.command()
        demisto.debug(f'The command being called is {command}.')
        commands: Dict[str, Callable] = {
            "threat-command-cyber-term-list": list_cyber_term_command,
            "threat-command-cyber-term-cve-list": list_cyber_term_cve_command,
            "threat-command-cyber-term-ioc-list": list_cyber_term_ioc_command,
            "threat-command-source-list": list_source_command,
            "threat-command-source-document-create": create_source_document_command,
            "threat-command-source-document-delete": delete_source_document_command,
            "threat-command-source-document-ioc-create": create_source_document_ioc_command,
            "threat-command-ioc-tags-add": add_tags_ioc_command,
            "threat-command-ioc-severity-update": update_ioc_severity_command,
            "threat-command-ioc-comment-add": add_ioc_comment_command,
            "threat-command-enrichment-quota-usage": usage_quota_enrichment_command,
            "threat-command-account-whitelist-update": update_account_whitelist_command,
            "threat-command-account-whitelist-remove": remove_account_whitelist_command,
            "threat-command-ioc-blocklist-add": add_ioc_blocklist_command,
            "threat-command-ioc-blocklist-remove": remove_ioc_blocklist_command,
            "threat-command-alert-list": list_alert_handler_command,
            "threat-command-alert-takedown-request": takedown_alert_command,
            "threat-command-alert-takedown-request-status-get": get_takedown_alert_command,
            "threat-command-alert-create": create_alert_command,
            "threat-command-alert-close": close_alert_command,
            "threat-command-alert-severity-update": update_alert_severity_command,
            "threat-command-alert-blocklist-get": get_alert_blocklist_status_command,
            "threat-command-alert-blocklist-update": update_alert_blocklist_command,
            "threat-command-alert-ioc-report": report_alert_ioc_command,
            "threat-command-alert-assign": assign_alert_command,
            "threat-command-alert-unassign": unassign_alert_command,
            "threat-command-alert-reopen": reopen_alert_command,
            "threat-command-alert-tag-add": tag_alert_command,
            "threat-command-alert-tag-remove": untag_alert_command,
            "threat-command-alert-send-mail": send_mail_alert_command,
            "threat-command-alert-analyst-ask": analyst_ask_alert_command,
            "threat-command-alert-analyst-conversation-list": list_alert_conversation_command,
            "threat-command-alert-activity-log-get": list_alert_activity_command,
            "threat-command-alert-csv-get": get_alert_csv_command,
            "threat-command-alert-note-add": add_alert_note_command,
            "threat-command-alert-image-list": list_alert_image_command,
            "threat-command-cve-list": list_cve_command,
            "threat-command-cve-add": add_cve_command,
            "threat-command-cve-delete": delete_cve_command,
            "threat-command-asset-add": add_asset_command,
            "threat-command-asset-list": list_assets_command,
            "threat-command-asset-type-list": list_asset_types_command,
            "threat-command-asset-delete": delete_asset_command,
            "threat-command-account-system-modules-list": list_system_modules_command,
            "threat-command-mention-search": search_mention_command,
            "threat-command-mssp-customer-list": list_mssp_customer_command,
            "threat-command-mssp-user-list": list_mssp_user_command,
            "threat-command-account-user-list": list_account_user_command,
            "threat-command-alert-type-list": list_alert_type_command,
            "threat-command-alert-source-type-list": list_alert_source_type_command,
            "threat-command-alert-scenario-list": list_alert_scenario_command,
        }
        polling_commands = {
            "threat-command-ioc-search": search_ioc_handler_command,
            "file": file_command,
            "ip": ip_command,
            "url": url_command,
            "domain": domain_command,
        }

        try:
            client: Client = Client(
                base_url=base_url,
                account_id=account_id,
                api_key=api_key,
                mssp_sub_account=mssp_sub_account,
                reliability=reliability,
                verify=verify_certificate,
                proxy=proxy,
            )
            if command == "test-module":
                return_results(test_module(client, params))
            elif command in polling_commands:
                return_results(polling_commands[command](args, client, execution_metrics))
            elif command in commands:
                return_results(commands[command](client, args))
            elif command == "fetch-incidents":
                first_fetch = arg_to_datetime(params.get("first_fetch"))
                max_fetch = arg_to_number(params["max_fetch"])
                if isinstance(max_fetch, int) and max_fetch > 200:
                    demisto.debug(f"The max fetch value is {max_fetch}, which is greater than the maximum allowed value "
                                  "of 200. Setting it to 200.")
                    max_fetch = 200
                alert_types = argToList(params.get("alert_types"))
                network_types = argToList(params.get("network_types"))
                alert_severities = minimum_severity_handler(params.get("alert_severity"))
                source_types = argToList(params.get("source_types"))
                is_closed = argToBoolean(params["fetch_closed_incidents"])
                fetch_csv = argToBoolean(params["fetch_csv"])
                fetch_attachments = argToBoolean(params["fetch_attachments"])
                if not max_fetch or max_fetch < 1:
                    raise ValueError("max_fetch must be a positive integer.")

                if not isinstance(first_fetch, datetime):
                    raise ValueError(ReadableErrors.FIRST_FETCH_NOT_EXIST.value)

                first_fetch_time = first_fetch.strftime(ISO_8601_FORMAT)

                last_run = demisto.getLastRun()
                next_run, incidents = fetch_incidents(
                    client=client,
                    last_run=last_run,
                    first_fetch=first_fetch_time,
                    max_fetch=max_fetch,
                    alert_types=alert_types,
                    network_types=network_types,
                    alert_severities=alert_severities,
                    source_types=source_types,
                    is_closed=is_closed,
                    fetch_csv=fetch_csv,
                    fetch_attachments=fetch_attachments,
                )
                demisto.info(f'Fetched {len(incidents)} new incidents.')
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
            else:
                raise NotImplementedError(f"{command} command is not implemented.")

        except Exception as e:
            return_error(str(e))


    if __name__ in ["__main__", "builtin", "builtins"]:
        main()

    register_module_line('rapid7_threat_command', 'end', __line__())
  subtype: python3
  type: python
system: true
