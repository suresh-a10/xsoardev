category: Identity and Access Management
commonfields:
  id: Zoom_IAM
  version: -1
configuration:
- defaultvalue: https://api.zoom.us/v2/
  display: Server URL (e.g., 'https://api.zoom.us/v2/')
  name: url
  required: false
  type: 0
- display: Account ID (OAuth)
  name: account_id
  required: false
  type: 0
- display: Client ID (OAuth)
  displaypassword: Client Secret (OAuth)
  name: credentials
  required: false
  type: 9
- additionalinfo: This authentication method is deprecated.
  display: ""
  displaypassword: API Key (JWT-Deprecated)
  hiddenusername: true
  name: creds_api_key
  required: false
  type: 9
- additionalinfo: This authentication method is deprecated.
  display: ""
  displaypassword: API Secret (JWT-Deprecated)
  hiddenusername: true
  name: creds_api_secret
  required: false
  type: 9
- additionalinfo: This authentication method is deprecated.
  display: API Key (JWT-Deprecated)
  hidden: true
  name: api_key
  required: false
  type: 4
- additionalinfo: This authentication method is deprecated.
  display: API Secret (JWT-Deprecated)
  hidden: true
  name: api_secret
  required: false
  type: 4
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Allow disabling users
  name: disable-user-enabled
  required: false
  type: 8
- display: Allow enabling users
  name: enable-user-enabled
  required: false
  type: 8
- defaultvalue: User Profile - SCIM (Incoming)
  display: Incoming Mapper
  name: mapper_in
  required: true
  type: 0
- defaultvalue: User Profile - SCIM (Outgoing)
  display: Outgoing Mapper
  name: mapper_out
  required: true
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 1.6.10
    packID: Zoom
    packName: Zoom
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: An Identity and Access Management integration template.
detaileddescription: |-
  ## Zoom IAM Integration
  In order to use this integration, you need to enter your Zoom credentials in the relevant integration instance parameters.
  There are two authentication methods available: **OAuth** and **JWT**(deprecated).

  Log in to your Zoom admin user account, and follow these steps:
  Click [here](https://marketplace.zoom.us/develop/create) to create an app.
  ### For the OAuth method:
  - Enable permissions.
  - Create an Server-to-Server OAuth app.
  - Add relevant scopes.
  - Use the following account credentials to get an access token:
      Account ID
      Client ID
      Client secret

  For more information about creating an OAuth app click [here](https://marketplace.zoom.us/docs/guides/build/server-to-server-oauth-app/).

  ### For the JWT methodÂ (deprecated)
  - Create an JWT app.
  - Use the following account credentials to get an access token:
      API Key
      API Secret

  For more information about creating an JWT app click [here](https://marketplace.zoom.us/docs/guides/build/jwt-app/).


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/zoom-iam)
display: Zoom_IAM
image: data:image/png;base64,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
name: Zoom_IAM
script:
  commands:
  - arguments:
    - description: |
        A User Profile indicator. For example: `{"email": "john.doe@example.com"}`
      name: user-profile
      required: true
    description: Disable an active user.
    execution: true
    name: iam-disable-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: |
        A User Profile indicator.
        For example: `{"email": "john.doe@example.com"}`
      name: user-profile
      required: true
    description: Enable a deactivated user.
    execution: true
    name: iam-enable-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: "A User Profile indicator.          \nFor example: `{\"email\":
        \"john.doe@example.com\"}`\n"
      name: user-profile
      required: true
    description: Retrieves a single user resource.
    name: iam-get-user
  - arguments: []
    description: Retrieves a User Profile schema, which holds all of the user fields
      within the application. Used for outgoing-mapping through the Get Schema option.
    name: get-mapping-fields
  dockerimage: demisto/auth-utils:1.0.0.76157
  ismappable: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('Zoom_IAM', 'start', __line__())
    ### pack version: 1.6.10



    import urllib3

    ### GENERATED CODE ###: from IAMApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('IAMApiModule', 'start', __line__(), wrapper=-3)





    class IAMErrors(object):
        """
        An enum class to manually handle errors in IAM integrations
        :return: None
        :rtype: ``None``
        """
        BAD_REQUEST = 400, 'Bad request - failed to perform operation'
        USER_DOES_NOT_EXIST = 404, 'User does not exist'
        USER_ALREADY_EXISTS = 409, 'User already exists'


    class IAMActions(object):
        """
        Enum: contains all the IAM actions (e.g. get, update, create, etc.)
        :return: None
        :rtype: ``None``
        """
        GET_USER = 'get'
        UPDATE_USER = 'update'
        CREATE_USER = 'create'
        DISABLE_USER = 'disable'
        ENABLE_USER = 'enable'


    class IAMVendorActionResult:
        """ This class is used in IAMUserProfile class to represent actions data.
        :return: None
        :rtype: ``None``
        """

        def __init__(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                     error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            self._brand = demisto.callingContext.get('context', {}).get('IntegrationBrand')
            self._instance_name = demisto.callingContext.get('context', {}).get('IntegrationInstance')
            self._success = success
            self._active = active
            self._iden = iden
            self._username = username
            self._email = email
            self._error_code = error_code
            self._error_message = error_message
            self._details = details
            self._skip = skip
            self._skip_reason = skip_reason
            self._action = action
            self._return_error = return_error

        def should_return_error(self):
            return self._return_error

        def create_outputs(self):
            """ Sets the outputs in `_outputs` attribute.
            """
            outputs = {
                'brand': self._brand,
                'instanceName': self._instance_name,
                'action': self._action,
                'success': self._success,
                'active': self._active,
                'id': self._iden,
                'username': self._username,
                'email': self._email,
                'errorCode': self._error_code,
                'errorMessage': self._error_message,
                'details': self._details,
                'skipped': self._skip,
                'reason': self._skip_reason
            }
            return outputs

        def create_readable_outputs(self, outputs):
            """ Sets the human readable output in `_readable_output` attribute.

            :param outputs: (dict) the command outputs.
            """
            title = self._action.title() + ' User Results ({})'.format(self._brand)

            if not self._skip:
                headers = ["brand", "instanceName", "success", "active", "id", "username",
                           "email", "errorCode", "errorMessage", "details"]
            else:
                headers = ["brand", "instanceName", "skipped", "reason"]

            readable_output = tableToMarkdown(
                name=title,
                t=outputs,
                headers=headers,
                removeNull=True
            )

            return readable_output


    class IAMUserProfile:
        """ A User Profile object class for IAM integrations.

        :type _user_profile: ``str``
        :param _user_profile: The user profile information.

        :type _user_profile_delta: ``str``
        :param _user_profile_delta: The user profile delta.

        :type _vendor_action_results: ``list``
        :param _vendor_action_results: A List of data returned from the vendor.

        :return: None
        :rtype: ``None``
        """

        DEFAULT_INCIDENT_TYPE = 'User Profile'
        CREATE_INCIDENT_TYPE = 'User Profile - Create'
        UPDATE_INCIDENT_TYPE = 'User Profile - Update'
        DISABLE_INCIDENT_TYPE = 'User Profile - Disable'
        ENABLE_INCIDENT_TYPE = 'User Profile - Enable'

        def __init__(self, user_profile, mapper: str, incident_type: str, user_profile_delta=None):
            self._user_profile = safe_load_json(user_profile)
            # Mapping is added here for GET USER commands, where we need to map Cortex XSOAR fields to the given app fields.
            self.mapped_user_profile = None
            self.mapped_user_profile = self.map_object(mapper, incident_type, map_old_data=True) if \
                mapper else self._user_profile
            self._user_profile_delta = safe_load_json(user_profile_delta) if user_profile_delta else {}
            self._vendor_action_results: List = []

        def get_attribute(self, item, use_old_user_data=False, user_profile_data: Optional[Dict] = None):
            user_profile = user_profile_data if user_profile_data else self._user_profile
            if use_old_user_data and user_profile.get('olduserdata', {}).get(item):
                return user_profile.get('olduserdata', {}).get(item)
            return user_profile.get(item)

        def to_entry(self):
            """ Generates a XSOAR IAM entry from the data in _vendor_action_results.
            Note: Currently we are using only the first element of the list, in the future we will support multiple results.

            :return: A XSOAR entry.
            :rtype: ``dict``
            """

            outputs = self._vendor_action_results[0].create_outputs()
            readable_output = self._vendor_action_results[0].create_readable_outputs(outputs)

            entry_context = {
                'IAM.UserProfile(val.email && val.email == obj.email)': self._user_profile,
                'IAM.Vendor(val.instanceName && val.instanceName == obj.instanceName && '
                'val.email && val.email == obj.email)': outputs
            }

            return_entry = {
                'ContentsFormat': EntryFormat.JSON,
                'Contents': outputs,
                'EntryContext': entry_context
            }

            if self._vendor_action_results[0].should_return_error():
                return_entry['Type'] = EntryType.ERROR
            else:
                return_entry['Type'] = EntryType.NOTE
                return_entry['HumanReadable'] = readable_output

            return return_entry

        def return_outputs(self):
            return_results(self.to_entry())

        def set_result(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                       error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            if not email:
                email = self.get_attribute('email')

            if not details:
                details = self.mapped_user_profile

            vendor_action_result = IAMVendorActionResult(
                success=success,
                active=active,
                iden=iden,
                username=username,
                email=email,
                error_code=error_code,
                error_message=error_message if error_message else '',
                details=details,
                skip=skip,
                skip_reason=skip_reason if skip_reason else '',
                action=action,
                return_error=return_error
            )

            self._vendor_action_results.append(vendor_action_result)

        def map_object(self, mapper_name, incident_type, map_old_data: bool = False):
            """ Returns the user data, in an application data format.

            :type mapper_name: ``str``
            :param mapper_name: The outgoing mapper from XSOAR to the application.

            :type incident_type: ``str``
            :param incident_type: The incident type used.

            :type map_old_data ``bool``
            :param map_old_data: Whether to map old data as well.

            :return: the user data, in the app data format.
            :rtype: ``dict``
            """
            if self.mapped_user_profile:
                if not map_old_data:
                    return {k: v for k, v in self.mapped_user_profile.items() if k != 'olduserdata'}
                return self.mapped_user_profile
            if incident_type not in [IAMUserProfile.CREATE_INCIDENT_TYPE, IAMUserProfile.UPDATE_INCIDENT_TYPE,
                                     IAMUserProfile.DISABLE_INCIDENT_TYPE,
                                     IAMUserProfile.ENABLE_INCIDENT_TYPE]:
                raise DemistoException('You must provide a valid incident type to the map_object function.')
            if not self._user_profile:
                raise DemistoException('You must provide the user profile data.')
            app_data = demisto.mapObject(self._user_profile, mapper_name, incident_type)
            if map_old_data and 'olduserdata' in self._user_profile:
                app_data['olduserdata'] = demisto.mapObject(self._user_profile.get('olduserdata', {}), mapper_name,
                                                            incident_type)
            return app_data

        def update_with_app_data(self, app_data, mapper_name, incident_type=None):
            """ updates the user_profile attribute according to the given app_data

            :type app_data: ``dict``
            :param app_data: The user data in app

            :type mapper_name: ``str``
            :param mapper_name: Incoming mapper name

            :type incident_type: ``str``
            :param incident_type: Optional - incident type
            """
            if not incident_type:
                incident_type = IAMUserProfile.DEFAULT_INCIDENT_TYPE
            if not isinstance(app_data, dict):
                app_data = safe_load_json(app_data)
            self._user_profile = demisto.mapObject(app_data, mapper_name, incident_type)

        def get_first_available_iam_user_attr(self, iam_attrs: List[str], use_old_user_data: bool = False):
            # Special treatment for ID field, because he is not included in outgoing mappers.
            for iam_attr in iam_attrs:
                # Special treatment for ID field, because he is not included in outgoing mappers.
                if iam_attr == 'id':
                    if attr_value := self.get_attribute(iam_attr, use_old_user_data):
                        return iam_attr, attr_value
                if attr_value := self.get_attribute(iam_attr, use_old_user_data, self.mapped_user_profile):
                    # Special treatment for emails, as mapper maps it to a list object.
                    if iam_attr == 'emails' and not isinstance(attr_value, str):
                        if isinstance(attr_value, dict):
                            attr_value = attr_value.get('value')
                        elif isinstance(attr_value, list):
                            if not attr_value:
                                continue
                            attr_value = next((email.get('value') for email in attr_value if email.get('primary', False)),
                                              attr_value[0].get('value', ''))
                    return iam_attr, attr_value

            raise DemistoException('Your user profile argument must contain at least one attribute that is mapped into one'
                                   f' of the following attributes in the outgoing mapper: {iam_attrs}')

        def set_user_is_already_disabled(self, details):
            self.set_result(
                action=IAMActions.DISABLE_USER,
                skip=True,
                skip_reason='User is already disabled.',
                details=details
            )

        def set_user_is_already_enabled(self, details):
            self.set_result(
                action=IAMActions.ENABLE_USER,
                skip=True,
                skip_reason='User is already enabled.',
                details=details
            )


    class IAMUserAppData:
        """ Holds user attributes retrieved from an application.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, user_id, username, is_active, app_data, email=None):
            self.id = user_id
            self.username = username
            self.is_active = is_active
            self.full_data = app_data
            self.email = email


    class IAMCommand:
        """ A class that implements the IAM CRUD commands - should be used.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, is_create_enabled=True, is_enable_enabled=True, is_disable_enabled=True, is_update_enabled=True,
                     create_if_not_exists=True, mapper_in=None, mapper_out=None, get_user_iam_attrs=None):
            """ The IAMCommand c'tor

            :param is_create_enabled: (bool) Whether or not to allow creating users in the application.
            :param is_enable_enabled: (bool) Whether or not to allow enabling users in the application.
            :param is_disable_enabled: (bool) Whether or not to allow disabling users in the application.
            :param is_update_enabled: (bool) Whether or not to allow updating users in the application.
            :param create_if_not_exists: (bool) Whether or not to create a user if does not exist in the application.
            :param mapper_in: (str) Incoming mapper from the application to Cortex XSOAR
            :param mapper_out: (str) Outgoing mapper from the Cortex XSOAR to the application
            :param get_user_iam_attrs (List[str]): List of IAM attributes supported by integration by precedence
                                                            order to get user details.
            """
            if get_user_iam_attrs is None:
                get_user_iam_attrs = ['email']
            self.is_create_enabled = is_create_enabled
            self.is_enable_enabled = is_enable_enabled
            self.is_disable_enabled = is_disable_enabled
            self.is_update_enabled = is_update_enabled
            self.create_if_not_exists = create_if_not_exists
            self.mapper_in = mapper_in
            self.mapper_out = mapper_out
            self.get_user_iam_attrs = get_user_iam_attrs

        def get_user(self, client, args):
            """ Searches a user in the application and updates the user profile object with the data.
                If not found, the error details will be resulted instead.
            :param client: (Client) The integration Client object that implements a get_user() method
            :param args: (dict) The `iam-get-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            try:
                iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(self.get_user_iam_attrs)
                user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                if not user_app_data:
                    error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    user_profile.set_result(action=IAMActions.GET_USER,
                                            success=False,
                                            error_code=error_code,
                                            error_message=error_message)
                else:
                    user_profile.update_with_app_data(user_app_data.full_data, self.mapper_in)
                    user_profile.set_result(
                        action=IAMActions.GET_USER,
                        active=user_app_data.is_active,
                        iden=user_app_data.id,
                        email=user_profile.get_attribute('email') or user_app_data.email,
                        username=user_app_data.username,
                        details=user_app_data.full_data
                    )

            except Exception as e:
                client.handle_exception(user_profile, e, IAMActions.GET_USER)

            return user_profile

        def disable_user(self, client, args):
            """ Disables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user() and disable_user() methods
            :param args: (dict) The `iam-disable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_disable_enabled:
                user_profile.set_result(action=IAMActions.DISABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.DISABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if user_app_data.is_active:
                            disabled_user = client.disable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.DISABLE_USER,
                                active=False,
                                iden=disabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=disabled_user.username,
                                details=disabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_disabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.DISABLE_USER)

            return user_profile

        def enable_user(self, client, args):
            """ Enables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user(),
                                    enable_user() and handle_exception methods
            :param args: (dict) The `iam-enable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_enable_enabled:
                user_profile.set_result(action=IAMActions.ENABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.ENABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if not user_app_data.is_active:
                            enabled_user = client.enable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.ENABLE_USER,
                                active=True,
                                iden=enabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=enabled_user.username,
                                details=enabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_enabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.ENABLE_USER)

            return user_profile

        def create_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If a user in the app already holds the email in the given user profile, updates
                its data with the given data.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-create-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
            if not self.is_create_enabled:
                user_profile.set_result(action=IAMActions.CREATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        # if user exists, update it
                        user_profile = self.update_user(client, args)

                    else:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.CREATE_INCIDENT_TYPE)
                        created_user = client.create_user(app_profile)
                        user_profile.set_result(
                            action=IAMActions.CREATE_USER,
                            active=created_user.is_active,
                            iden=created_user.id,
                            email=user_profile.get_attribute('email') or created_user.email,
                            username=created_user.username,
                            details=created_user.full_data
                        )

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.CREATE_USER)

            return user_profile

        def update_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If the user is disabled and `allow-enable` argument is `true`, also enables the user.
                If the user does not exist in the app and the `create-if-not-exist` parameter is checked, creates the user.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-update-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            allow_enable = args.get('allow-enable') == 'true' and self.is_enable_enabled
            if not self.is_update_enabled:
                user_profile.set_result(action=IAMActions.UPDATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs, use_old_user_data=True)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.UPDATE_INCIDENT_TYPE)

                        if allow_enable and not user_app_data.is_active:
                            client.enable_user(user_app_data.id)

                        updated_user = client.update_user(user_app_data.id, app_profile)

                        if updated_user.is_active is None:
                            updated_user.is_active = True if allow_enable else user_app_data.is_active

                        user_profile.set_result(
                            action=IAMActions.UPDATE_USER,
                            active=updated_user.is_active,
                            iden=updated_user.id,
                            email=user_profile.get_attribute('email') or updated_user.email or user_app_data.email,
                            username=updated_user.username,
                            details=updated_user.full_data
                        )
                    else:
                        if self.create_if_not_exists:
                            user_profile = self.create_user(client, args)
                        else:
                            _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                            user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                    skip=True,
                                                    skip_reason=error_message)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.UPDATE_USER)

            return user_profile


    def get_first_primary_email_by_scim_schema(res: Dict):
        return next((email.get('value') for email in res.get('emails', []) if email.get('primary')), None)

    register_module_line('IAMApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###      # noqa: E402

    ### GENERATED CODE ###: from ZoomApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('ZoomApiModule', 'start', __line__(), wrapper=-3)


    from datetime import timedelta
    import dateparser

    ''' CONSTANTS '''

    OAUTH_TOKEN_GENERATOR_URL = 'https://zoom.us/oauth/token'
    # The tokenâs time to live is 1 hour,
    # two minutes were subtract for extra safety.
    TOKEN_LIFE_TIME = timedelta(minutes=58)
    # the lifetime for an JWT token is 90 minutes == 5400 seconds
    # 400 seconds were subtract for extra safety.
    JWT_LIFETIME = 5000
    # maximun records that the api can return in one request
    MAX_RECORDS_PER_PAGE = 300

    # ERRORS
    INVALID_CREDENTIALS = 'Invalid credentials. Please verify that your credentials are valid.'
    INVALID_API_SECRET = 'Invalid API Secret. Please verify that your API Secret is valid.'
    INVALID_ID_OR_SECRET = 'Invalid Client ID or Client Secret. Please verify that your ID and Secret is valid.'
    INVALID_TOKEN = 'Invalid Authorization token. Please verify that your Bot ID and Bot Secret is valid.'
    INVALID_BOT_ID = 'No Chatbot can be found with the given robot_jid value. Please verify that your Bot JID is correct'
    '''CLIENT CLASS'''


    class Zoom_Client(BaseClient):
        """ A client class that implements logic to authenticate with Zoom application. """

        def __init__(
            self,
            base_url: str,
            api_key: str | None = None,
            api_secret: str | None = None,
            account_id: str | None = None,
            client_id: str | None = None,
            client_secret: str | None = None,
            bot_client_id: str | None = None,
            bot_client_secret: str | None = None,
            verify=True,
            proxy=False,
            bot_jid: str | None = None,
        ):
            super().__init__(base_url, verify, proxy)
            self.api_key = api_key
            self.api_secret = api_secret
            self.account_id = account_id
            self.client_id = client_id
            self.client_secret = client_secret
            self.bot_client_id = bot_client_id
            self.bot_client_secret = bot_client_secret
            self.bot_jid = bot_jid
            try:
                self.access_token, self.bot_access_token = self.get_oauth_token()
            except Exception as e:
                demisto.info(f"Cannot get access token. Error: {e}")
                self.access_token = None
                self.bot_access_token = None

        def generate_oauth_token(self):
            """
            Generate an OAuth Access token using the app credentials (AKA: client id and client secret) and the account id

            :return: valid token
            """
            token_res = self._http_request(method="POST", full_url=OAUTH_TOKEN_GENERATOR_URL,
                                           params={"account_id": self.account_id,
                                                   "grant_type": "account_credentials"},
                                           auth=(self.client_id, self.client_secret))
            return token_res.get('access_token')

        def generate_oauth_client_token(self):
            """
            Generate an OAuth Access token using the app credentials (AKA: client id and client secret) and the account id

            :return: valid token
            """
            token_res = self._http_request(method="POST", full_url=OAUTH_TOKEN_GENERATOR_URL,
                                           params={"account_id": self.account_id,
                                                   "grant_type": "client_credentials"},
                                           auth=(self.bot_client_id, self.bot_client_secret))
            return token_res.get('access_token')

        def get_oauth_token(self, force_gen_new_token=False):
            """
                Retrieves the token from the server if it's expired and updates the global HEADERS to include it

                :param force_gen_new_token: If set to True will generate a new token regardless of time passed

                :rtype: ``str``
                :return: Token
            """
            now = datetime.now()
            ctx = get_integration_context()
            client_oauth_token = None
            oauth_token = None

            if not ctx or not ctx.get('token_info').get('generation_time', force_gen_new_token):
                # new token is needed
                if self.client_id and self.client_secret:
                    oauth_token = self.generate_oauth_token()
                if self.bot_client_id and self.bot_client_secret:
                    client_oauth_token = self.generate_oauth_client_token()
                ctx = {}
            else:
                if generation_time := dateparser.parse(
                    ctx.get('token_info').get('generation_time')
                ):
                    time_passed = now - generation_time
                else:
                    time_passed = TOKEN_LIFE_TIME
                if time_passed < TOKEN_LIFE_TIME:
                    # token hasn't expired
                    return ctx.get('token_info', {}).get('oauth_token'), ctx.get('token_info', {}).get('client_oauth_token')
                else:
                    # token expired
                    # new token is needed
                    if self.client_id and self.client_secret:
                        oauth_token = self.generate_oauth_token()
                    if self.bot_client_id and self.bot_client_secret:
                        client_oauth_token = self.generate_oauth_client_token()

            ctx.update({'token_info': {'oauth_token': oauth_token, 'client_oauth_token': client_oauth_token,
                       'generation_time': now.strftime("%Y-%m-%dT%H:%M:%S")}})
            set_integration_context(ctx)
            return oauth_token, client_oauth_token

        def error_handled_http_request(self, method, url_suffix='', full_url=None, headers=None,
                                       auth=None, json_data=None, params=None, files=None, data=None,
                                       return_empty_response: bool = False, resp_type: str = 'json', stream: bool = False, ):

            # all future functions should call this function instead of the original _http_request.
            # This is needed because the OAuth token may not behave consistently,
            # First the func will make an http request with a token,
            # and if it turns out to be invalid, the func will retry again with a new token.
            try:
                return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                             auth=auth, json_data=json_data, params=params, files=files, data=data,
                                             return_empty_response=return_empty_response, resp_type=resp_type, stream=stream)
            except DemistoException as e:
                if any(message in e.message for message in ["Invalid access token",
                                                            "Access token is expired.",
                                                            "Invalid authorization token"]):
                    if url_suffix == '/im/chat/messages':
                        demisto.debug('generate new bot client token')
                        self.bot_access_token = self.generate_oauth_client_token()
                        headers = {'authorization': f'Bearer {self.bot_access_token}'}
                    else:
                        self.access_token = self.generate_oauth_token()
                        headers = {'authorization': f'Bearer {self.access_token}'}
                    return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                                 auth=auth, json_data=json_data, params=params, files=files, data=data,
                                                 return_empty_response=return_empty_response, resp_type=resp_type, stream=stream)
                else:
                    raise DemistoException(e.message, url_suffix)


    ''' HELPER FUNCTIONS '''

    register_module_line('ZoomApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###     # noqa: E402
    # Disable insecure warnings
    urllib3.disable_warnings()

    DEFAULT_OUTGOING_MAPPER = "User Profile - SCIM (Outgoing)"
    DEFAULT_INCOMING_MAPPER = "User Profile - SCIM (Incoming)"

    ERROR_CODES_TO_SKIP = [
        404
    ]

    '''CLIENT CLASS'''


    class Client(Zoom_Client):
        """ A client class that implements logic to authenticate with Zoom application. """

        def test(self):
            """ Tests connectivity with the application. """

            self.get_user('', 'me')
            return 'ok'

        def get_user(self, _, filter_value: str) -> Optional[IAMUserAppData]:
            uri = f'/users/{filter_value}'

            res = self.error_handled_http_request(
                method='GET',
                url_suffix=uri,
                headers={'authorization': f'Bearer {self.access_token}',
                         'Accept': 'application/json',
                         'Content-Type': 'application/json',
                         },
            )
            if res and (not res.get('users')):
                user_app_data = res
                user_id = user_app_data.get('id')
                is_active = True if user_app_data.get('status') == 'active' else False
                email = user_app_data.get('email')
                # the API does not provide user name
                username = ''

                return IAMUserAppData(user_id, username, is_active, user_app_data, email=email)
            return None

        def update_user(self, user_id: str, user_data: Dict[str, Any]) -> IAMUserAppData:
            """ Updates a user in the application using REST API.

            :type user_id: ``str``
            :param user_id: ID of the user in the application

            :type user_data: ``Dict[str, Any]``
            :param user_data: User data in the application format

            :return: An IAMUserAppData object that contains the data of the updated user in the application.
            :rtype: ``IAMUserAppData``
            """
            uri = f'/users/{user_id}/status'
            self.error_handled_http_request(
                method='PUT',
                url_suffix=uri,
                json_data=user_data,
                return_empty_response=True,
                headers={'authorization': f'Bearer {self.access_token}',
                         'Accept': 'application/json',
                         'Content-Type': 'application/json',
                         },
            )
            # res is an empty *response object*
            user_app_data: dict = {}
            # if we wanted to disable the user and request succeeded,
            # we get to this line and know the user's status
            is_active = True if user_data.get('action', '') == 'activate' else False
            username = ''

            return IAMUserAppData(user_id, username, is_active, user_app_data)

        def disable_user(self, user_id: str) -> IAMUserAppData:
            """ Disables a user in the application using REST API.

            :type user_id: ``str``
            :param user_id: ID of the user in the application

            :return: An IAMUserAppData object that contains the data of the user in the application.
            :rtype: ``IAMUserAppData``
            """

            user_data = {'action': 'deactivate'}
            return self.update_user(user_id, user_data)

        def enable_user(self, user_id: str) -> IAMUserAppData:
            """ Enables a user in the application using REST API.

            :type user_id: ``str``
            :param user_id: ID of the user in the application

            :return: An IAMUserAppData object that contains the data of the user in the application.
            :rtype: ``IAMUserAppData``
            """

            user_data = {'action': 'activate'}
            return self.update_user(user_id, user_data)

        def get_app_fields(self):
            user_app_data = self.get_user('', 'me')
            if user_app_data:
                return {k: underscoreToCamelCase(k) for k, _ in user_app_data.full_data.items()}
            raise DemistoException('Could not retrieve fields for mapping')

        @staticmethod
        def handle_exception(user_profile: IAMUserProfile,
                             e: Union[DemistoException, Exception],
                             action: IAMActions):
            """ Handles failed responses from the application API by setting the User Profile object with the result.
                The result entity should contain the following data:
                1. action        (``IAMActions``)       The failed action                       Required
                2. success       (``bool``)             The success status                      Optional (by default, True)
                3. skip          (``bool``)             Whether or not the command was skipped  Optional (by default, False)
                3. skip_reason   (``str``)              Skip reason                             Optional (by default, None)
                4. error_code    (``Union[str, int]``)  HTTP error code                         Optional (by default, None)
                5. error_message (``str``)              The error description                   Optional (by default, None)

                Note: This is the place to determine how to handle specific edge cases from the API, e.g.,
                when a DISABLE action was made on a user which is already disabled and therefore we can't
                perform another DISABLE action.

            :type user_profile: ``IAMUserProfile``
            :param user_profile: The user profile object

            :type e: ``Union[DemistoException, Exception]``
            :param e: The exception object - if type is DemistoException, holds the response json object (`res` attribute)

            :type action: ``IAMActions``
            :param action: An enum represents the current action (GET, UPDATE, CREATE, DISABLE or ENABLE)
            """
            if isinstance(e, DemistoException) and e.res is not None:
                error_code = e.res.status_code

                if action == IAMActions.DISABLE_USER and error_code in ERROR_CODES_TO_SKIP:
                    skip_message = 'Users is already disabled or does not exist in the system.'
                    user_profile.set_result(action=action,
                                            skip=True,
                                            skip_reason=skip_message)

                try:
                    resp = e.res.json()
                    error_message = get_error_details(resp)
                except ValueError:
                    error_message = str(e)
            else:
                error_code = ''
                error_message = str(e)

            user_profile.set_result(action=action,
                                    success=False,
                                    error_code=error_code,
                                    error_message=error_message)

            demisto.error(traceback.format_exc())


    '''HELPER FUNCTIONS'''


    def get_error_details(res: Dict[str, Any]) -> str:
        """ Parses the error details retrieved from the application and outputs the resulted string.

        :type res: ``Dict[str, Any]``
        :param res: The error data retrieved from the application.

        :return: The parsed error details.
        :rtype: ``str``
        """
        message = res.get('code', '')
        details = res.get('message', '')
        return f'{message}: {details}'


    '''COMMAND FUNCTIONS'''


    def test_module(client: Client):
        """Tests connectivity with the client.
        Takes as an argument all client arguments to create a new client
        """
        try:
            client.test()
        except DemistoException as e:
            error_message = e.message
            if 'Invalid access token' in error_message:
                error_message = INVALID_CREDENTIALS
            elif "The Token's Signature resulted invalid" in error_message:
                error_message = INVALID_API_SECRET
            elif 'Invalid client_id or client_secret' in error_message:
                error_message = INVALID_ID_OR_SECRET
            else:
                error_message = f'Problem reaching Zoom API, check your credentials. Error message: {error_message}'
            return error_message
        return 'ok'


    def get_mapping_fields(client: Client):
        mapping = client.get_app_fields()
        incident_type_scheme = SchemeTypeMapping(type_name=IAMUserProfile.DEFAULT_INCIDENT_TYPE, fields=mapping)
        return GetMappingFieldsResponse([incident_type_scheme])


    def check_authentication_type_arguments(api_key: str, api_secret: str,
                                            account_id: str, client_id: str, client_secret: str):
        if any((api_key, api_secret)) and any((account_id, client_id, client_secret)):
            raise DemistoException("""Too many fields were filled.
                                       You should fill the Account ID, Client ID, and Client Secret fields (OAuth),
                                       OR the API Key and API Secret fields (JWT - Deprecated)""")


    def main():  # pragma: no cover
        user_profile = None
        params = demisto.params()
        base_url = params.get('url')
        api_key = params.get('creds_api_key', {}).get('password') or params.get('api_key')
        api_secret = params.get('creds_api_secret', {}).get('password') or params.get('api_secret')
        account_id = params.get('account_id')
        client_id = params.get('credentials', {}).get('identifier')
        client_secret = params.get('credentials', {}).get('password')
        mapper_in = params.get('mapper_in', DEFAULT_INCOMING_MAPPER)
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        command = demisto.command()
        args = demisto.args()

        is_disable_enabled = argToBoolean(params.get('disable-user-enabled'))
        is_enable_enabled = argToBoolean(params.get('enable-user-enabled'))

        iam_command = IAMCommand(is_create_enabled=False,
                                 is_enable_enabled=is_enable_enabled,
                                 is_disable_enabled=is_disable_enabled,
                                 is_update_enabled=False,
                                 create_if_not_exists=False,
                                 mapper_in=mapper_in,
                                 # Currently we don't use scim API endpoints, so we don't map the arguments.
                                 mapper_out=None,
                                 get_user_iam_attrs=['id', 'username', 'email']
                                 )
        try:
            check_authentication_type_arguments(api_key, api_secret, account_id, client_id, client_secret)

            client = Client(
                base_url=base_url,
                verify=verify_certificate,
                proxy=proxy,
                api_key=api_key,
                api_secret=api_secret,
                account_id=account_id,
                client_id=client_id,
                client_secret=client_secret,
            )

            if command == 'test-module':
                return_results(test_module(client=client))

            demisto.debug(f'Command being called is {command}')

            '''CRUD commands'''
            if command == 'iam-disable-user':
                user_profile = iam_command.disable_user(client, args)
            if command == 'iam-enable-user':
                user_profile = iam_command.enable_user(client, args)
            if command == 'iam-get-user':
                user_profile = iam_command.get_user(client, args)

            if user_profile:
                return_results(user_profile)

            '''non-CRUD commands'''

            if command == 'get-mapping-fields':
                return_results(get_mapping_fields(client))

        except Exception as e:
            # For any other integration command exception, return an error
            return_error(f'Failed to execute {command} command. Error: {str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Zoom_IAM', 'end', __line__())
  subtype: python3
  type: python
system: true
