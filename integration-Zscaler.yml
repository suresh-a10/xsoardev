category: Network Security
commonfields:
  id: Zscaler
  version: -1
configuration:
- display: Cloud Name (i.e., <https://zsapi.zscalertwo.net>)
  name: cloud
  required: true
  section: Connect
  type: 0
- display: Username
  name: credentials
  required: true
  section: Connect
  type: 9
- display: ""
  displaypassword: API Key
  hiddenusername: true
  name: creds_key
  required: false
  section: Connect
  type: 9
- display: API Key
  hidden: true
  name: key
  required: false
  section: Connect
  type: 4
- additionalinfo: Reliability of the source providing the intelligence data.
  advanced: true
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: reliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: false
  section: Collect
  type: 15
- additionalinfo: If enabled, the integration will log out after executing each command.
  advanced: true
  defaultvalue: "true"
  display: Auto Logout
  name: auto_logout
  required: false
  section: Connect
  type: 8
- additionalinfo: If enabled, the integration will activate the command changes after
    each execution. If disabled, use the 'zscaler-activate-changes' command to activate
    Zscaler command changes.
  advanced: true
  defaultvalue: "true"
  display: Auto Activate Changes
  name: auto_activate
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "15"
  display: Timeout (in seconds) for HTTP requests to Zscaler
  name: requestTimeout
  required: false
  section: Connect
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.3.20
    packID: Zscaler
    packName: Zscaler Internet Access
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Zscaler is a cloud security solution built for performance and flexible
  scalability. This integration enables you to manage URL and IP address allow lists
  and block lists, manage and update categories, get Sandbox reports, create, manage,
  and update IP destination groups and manually log in, log out, and activate changes
  in a Zscaler session.
detaileddescription: |
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/zscaler)
display: Zscaler Internet Access
image: data:image/png;base64,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
name: Zscaler
script:
  commands:
  - arguments:
    - default: true
      description: A comma-separated list of URLs to add to block list. For example,
        snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Adds the specified URLs to the block list.
    execution: true
    name: zscaler-blacklist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs for which to look up the classification.  For
        example, abc.com,xyz.com. The maximum number of URLs per call is 100. A URL
        cannot exceed 1024 characters. If there are multiple URLs, set the 'multiple'
        argument to 'true'.
      isArray: true
      name: url
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether there are multiple URLs in the 'url' argument. If a URL
        contains commas, set this argument to 'false' and enter the single URL as
        the 'url' argument.
      name: multiple
      predefined:
      - "true"
      - "false"
    description: Looks up the classification for the each of the specified URLs.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL that was searched.
      type: string
    - contextPath: URL.Address
      description: The URL that was searched.
      type: string
    - contextPath: Zscaler.URL.urlClassifications
      description: The classification of the URL. For example, MUSIC or WEB_SEARCH.
      type: string
    - contextPath: Zscaler.URL.urlClassificationsWithSecurityAlert
      description: The classifications of the URLs that have security alerts.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that tagged the URL as malicious.
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason the vendor tagged the URL as malicious.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
  - arguments:
    - default: true
      description: A comma-separated list of IP address for which to look up the classification.
        For example, 8.8.8.8,1.2.3.4. The maximum number of URLs per call is 100.
        An IP address cannot exceed 1024 characters.
      isArray: true
      name: ip
      required: true
    description: Looks up the classification for each of the specified IP addresses.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address that was searched.
      type: string
    - contextPath: Zscaler.IP.ipClassifications
      description: The classification of the IP address. For example, MUSIC or WEB_SEARCH.
      type: string
    - contextPath: Zscaler.IP.iplClassificationsWithSecurityAlert
      description: Classifications that have a security alert for the IP address.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that tagged the IP address
        as malicious.
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason the vendor tagged the IP
        address as malicious.
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
  - arguments:
    - default: true
      description: A comma-separated list of URLs to remove from the block list. For
        example, snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Removes the specified URLs from the block list.
    execution: true
    name: zscaler-undo-blacklist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs to add to the allow list. For example,
        snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Adds the specified URLs to the allow list.
    execution: true
    name: zscaler-whitelist-url
  - arguments:
    - default: true
      description: A comma-separated list of URLs to remove from the allow list. For
        example, snapchat.com,facebook.com.
      isArray: true
      name: url
      required: true
    description: Removes the specified URLs from the allow list.
    execution: true
    name: zscaler-undo-whitelist-url
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to remove from the allow
        list. For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Removes the specified IP addresses from the allow list.
    execution: true
    name: zscaler-undo-whitelist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to add to the allow list.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Adds the specified IP address to the allow list.
    execution: true
    name: zscaler-whitelist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to remove from the block
        list. For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Removes the specified IP addresses from the block list.
    name: zscaler-undo-blacklist-ip
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to add to the block list.
        For example, 8.8.8.8,1.2.3.4.
      isArray: true
      name: ip
      required: true
    description: Adds the specified IP addresses to the block list.
    execution: true
    name: zscaler-blacklist-ip
  - arguments:
    - description: The ID of the category to add the specified URLs to. For example,
        RADIO_STATIONS. You can retrieve the category IDs by running the 'zscaler-get-categories'
        command.
      name: category-id
      required: true
    - description: A comma-separated list of URLs to add to the specified category.
        For example, pandora.com,spotify.com.
      isArray: true
      name: url
    - description: A comma-separated list of URLs to add to the retaining parent category
        section inside the specified category. For example, pandora.com,spotify.com.
      isArray: true
      name: retaining-parent-category-url
    description: Adds URLs to the specified category.
    name: zscaler-category-add-url
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - description: The ID of the category to add the specified IP addresses to. For
        example, RADIO_STATIONS. You can retrieve the category IDs by running the
        'zscaler-get-categories' command.
      name: category-id
      required: true
    - description: A comma-separated list of IP address to add to the specified category.
        For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: ip
    - description: A comma-separated list of IP address to add to the retaining parent
        category section inside the specified category. For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: retaining-parent-category-ip
    description: Adds IP address to the specified category.
    name: zscaler-category-add-ip
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - description: The ID of the category to remove the specified URLs from. For example,
        RADIO_STATIONS. You can retrieve the category IDs by running the 'zscaler-get-categories'
        command.
      name: category-id
      required: true
    - description: A comma-separated list of URLs to remove from the specified category.
        For example, pandora.com,spotify.com.
      isArray: true
      name: url
    - description: A comma-separated list of URLs to remove from the retaining parent
        category section inside the specified category. For example, pandora.com,spotify.com.
      isArray: true
      name: retaining-parent-category-url
    description: Removes URLs from the specified category.
    name: zscaler-category-remove-url
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - description: The ID of the category to remove the specified IP addresses from.
        For example, RADIO_STATIONS. You can retrieve the category IDs by running
        the 'zscaler-get-categories' command.
      name: category-id
      required: true
    - description: A comma-separated list of IP addresses to remove from the specified
        category. For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: ip
    - description: A comma-separated list of IP address to remove from the retaining
        parent category section inside the specified category. For example, 1.2.3.4,8.8.8.8.
      isArray: true
      name: retaining-parent-category-ip
    description: Removes IP address from the specified category.
    name: zscaler-category-remove-ip
    outputs:
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to display the URLs of each category in the War Room. URLs
        will always be returned to the Context Data.
      name: displayURL
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to retrieve only custom categories to the War Room.
      name: custom_categories_only
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to retrieve only a list containing URL category IDs and
        names. Even if *displayURL* is set to true, URLs will not be returned. Please
        note - the API does not support the combination of custom_only and get_ids_and_names_only.
      name: get_ids_and_names_only
      predefined:
      - "true"
      - "false"
    description: Retrieves a list of all categories.
    name: zscaler-get-categories
    outputs:
    - contextPath: Zscaler.Category.ID
      description: The ID of the category.
      type: string
    - contextPath: Zscaler.Category.CustomCategory
      description: True, if the category is a custom category. Otherwise, false.
      type: boolean
    - contextPath: Zscaler.Category.URL
      description: The URL of the category.
      type: string
    - contextPath: Zscaler.Category.Description
      description: The description of the category.
      type: string
    - contextPath: Zscaler.Category.Name
      description: The name of the category.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: Filter results by URL or IP objects.
      name: filter
      predefined:
      - url
      - ip
    - description: Query (Python regular expression) to match against. For example,
        8.*.*.8.
      name: query
    description: Retrieves the Zscaler default block list.
    name: zscaler-get-blacklist
    outputs:
    - contextPath: Zscaler.Blacklist
      description: The Zscaler block list.
      type: string
  - arguments: []
    description: Retrieves the Zscaler default allow list.
    name: zscaler-get-whitelist
    outputs:
    - contextPath: Zscaler.Whitelist
      description: The Zscaler allow list.
      type: string
  - arguments:
    - description: The MD5 hash of a file.
      name: md5
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: The type of report. Possible values are 'full' or 'summary'. Default
        is 'full'.
      name: details
      predefined:
      - full
      - summary
    description: Retrieves a full or summary report of the file that was analyzed
      by Sandbox. The file is represented by the specified MD5 hash.
    name: zscaler-sandbox-report
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that tagged the file as malicious.
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason the vendor tagged the file as malicious.
      type: string
    - contextPath: File.DetectedMalware
      description: The malware detected in the file.
      type: string
    - contextPath: File.FileType
      description: The file type.
      type: string
    - contextPath: DBotScore.Indicator
      description: The MD5 hash file that was tested.
      type: string
    - contextPath: DBotScore.Type
      description: The MD5 hash file type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor that calculated the DBot score.
      type: string
    - contextPath: DBotScore.Score
      description: The actual DBot score.
      type: number
  - arguments: []
    description: Manually create a Zscaler login session. This command will also try
      to log out of the previous session.
    name: zscaler-login
  - arguments: []
    description: Logs out of the current Zscaler session.
    name: zscaler-logout
  - arguments: []
    description: Activates the changes executed by other Zscaler commands in this
      session.
    name: zscaler-activate-changes
  - arguments: []
    description: Gets information on the number of unique URLs that are currently
      provisioned for your organization as well as how many URLs you can add before
      reaching that number.
    name: zscaler-url-quota
    outputs:
    - contextPath: Zscaler.remainingUrlsQuota
      description: The number of URLs you can add before reaching the quota.
      type: Number
    - contextPath: Zscaler.uniqueUrlsProvisioned
      description: The number of unique URLs that are currently provisioned for your
        organization.
      type: Number
  - arguments:
    - description: Filer by user name.
      name: name
    - description: Specifies the page offset.
      name: page
    - default: true
      defaultValue: "100"
      description: Specifies the page size.
      name: pageSize
    description: Get Zscaler users.
    name: zscaler-get-users
  - arguments:
    - description: The unique identifier for the user.
      name: id
      required: true
    - description: 'New user information. Docs: https://help.zscaler.com/zia/api#/User%20Management/updateUser.'
      name: user
      required: true
    description: Updates the user information for the specified ID.
    name: zscaler-update-user
  - arguments:
    - description: Filter by department name.
      name: name
    - description: Specifies the page offset.
      name: page
    - default: true
      defaultValue: "100"
      description: Specifies the page size.
      name: pageSize
    description: Get a list of departments. It can be searched by name.
    name: zscaler-get-departments
  - arguments:
    - description: Filter by group name or comment.
      name: name
    - description: Specifies the page offset.
      name: page
    - default: true
      defaultValue: "100"
      description: Specifies the page size.
      name: pageSize
    description: Gets a list of groups.
    name: zscaler-get-usergroups
  - arguments:
    - description: Destination IP group name.
      name: name
      required: true
      type: textArea
    - auto: PREDEFINED
      description: Destination IP group type (i.e., the group can contain destination
        IP addresses, countries, URL categories or FQDNs).
      name: type
      predefined:
      - DSTN_IP
      - DSTN_FQDN
      - DSTN_DOMAIN
      - DSTN_OTHER
      required: true
      type: textArea
    - description: Destination IP addresses, FQDNs, or wildcard FQDNs added to the
        group.
      isArray: true
      name: addresses
      type: textArea
    - description: Additional information about the destination IP group.
      name: description
      type: textArea
    - auto: PREDEFINED
      description: Destination IP address URL categories. You can identify destinations
        based on the URL category of the domain. To retrieve a list of possible values,
        you can execute the zscaler-get-categories command.
      isArray: true
      name: ip_categories
      predefined:
      - ANY
      - NONE
      - OTHER_ADULT_MATERIAL
      - ADULT_THEMES
      - LINGERIE_BIKINI
      - NUDITY
      - PORNOGRAPHY
      - SEXUALITY
      - ADULT_SEX_EDUCATION
      - K_12_SEX_EDUCATION
      - SOCIAL_ADULT
      - OTHER_BUSINESS_AND_ECONOMY
      - CORPORATE_MARKETING
      - FINANCE
      - PROFESSIONAL_SERVICES
      - CLASSIFIEDS
      - TRADING_BROKARAGE_INSURANCE
      - CUSTOM_00
      - CUSTOM_01
      - CUSTOM_02
      - CUSTOM_03
      - CUSTOM_04
      - CUSTOM_05
      - CUSTOM_06
      - CUSTOM_07
      - CUSTOM_08
      - CUSTOM_09
      - CUSTOM_10
      - CUSTOM_11
      - CUSTOM_12
      - CUSTOM_13
      - CUSTOM_14
      - CUSTOM_15
      - CUSTOM_16
      - CUSTOM_17
      - CUSTOM_18
      - CUSTOM_19
      - CUSTOM_20
      - CUSTOM_21
      - CUSTOM_22
      - CUSTOM_23
      - CUSTOM_24
      - CUSTOM_25
      - CUSTOM_26
      - CUSTOM_27
      - CUSTOM_28
      - CUSTOM_29
      - CUSTOM_30
      - CUSTOM_31
      - CUSTOM_32
      - CUSTOM_33
      - CUSTOM_34
      - CUSTOM_35
      - CUSTOM_36
      - CUSTOM_37
      - CUSTOM_38
      - CUSTOM_39
      - CUSTOM_40
      - CUSTOM_41
      - CUSTOM_42
      - CUSTOM_43
      - CUSTOM_44
      - CUSTOM_45
      - CUSTOM_46
      - CUSTOM_47
      - CUSTOM_48
      - CUSTOM_49
      - CUSTOM_50
      - CUSTOM_51
      - CUSTOM_52
      - CUSTOM_53
      - CUSTOM_54
      - CUSTOM_55
      - CUSTOM_56
      - CUSTOM_57
      - CUSTOM_58
      - CUSTOM_59
      - CUSTOM_60
      - CUSTOM_61
      - CUSTOM_62
      - CUSTOM_63
      - CUSTOM_64
      - CUSTOM_65
      - CUSTOM_66
      - CUSTOM_67
      - CUSTOM_68
      - CUSTOM_69
      - CUSTOM_70
      - CUSTOM_71
      - CUSTOM_72
      - CUSTOM_73
      - CUSTOM_74
      - CUSTOM_75
      - CUSTOM_76
      - CUSTOM_77
      - CUSTOM_78
      - CUSTOM_79
      - CUSTOM_80
      - CUSTOM_81
      - CUSTOM_82
      - CUSTOM_83
      - CUSTOM_84
      - CUSTOM_85
      - CUSTOM_86
      - CUSTOM_87
      - CUSTOM_88
      - CUSTOM_89
      - CUSTOM_90
      - CUSTOM_91
      - CUSTOM_92
      - CUSTOM_93
      - CUSTOM_94
      - CUSTOM_95
      - CUSTOM_96
      - CUSTOM_97
      - CUSTOM_98
      - CUSTOM_99
      - CUSTOM_100
      - CUSTOM_101
      - CUSTOM_102
      - CUSTOM_103
      - CUSTOM_104
      - CUSTOM_105
      - CUSTOM_106
      - CUSTOM_107
      - CUSTOM_108
      - CUSTOM_109
      - CUSTOM_110
      - CUSTOM_111
      - CUSTOM_112
      - CUSTOM_113
      - CUSTOM_114
      - CUSTOM_115
      - CUSTOM_116
      - CUSTOM_117
      - CUSTOM_118
      - CUSTOM_119
      - CUSTOM_120
      - CUSTOM_121
      - CUSTOM_122
      - CUSTOM_123
      - CUSTOM_124
      - CUSTOM_125
      - CUSTOM_126
      - CUSTOM_127
      - CUSTOM_128
      - CUSTOM_129
      - CUSTOM_130
      - CUSTOM_131
      - CUSTOM_132
      - CUSTOM_133
      - CUSTOM_134
      - CUSTOM_135
      - CUSTOM_136
      - CUSTOM_137
      - CUSTOM_138
      - CUSTOM_139
      - CUSTOM_140
      - CUSTOM_141
      - CUSTOM_142
      - CUSTOM_143
      - CUSTOM_144
      - CUSTOM_145
      - CUSTOM_146
      - CUSTOM_147
      - CUSTOM_148
      - CUSTOM_149
      - CUSTOM_150
      - CUSTOM_151
      - CUSTOM_152
      - CUSTOM_153
      - CUSTOM_154
      - CUSTOM_155
      - CUSTOM_156
      - CUSTOM_157
      - CUSTOM_158
      - CUSTOM_159
      - CUSTOM_160
      - CUSTOM_161
      - CUSTOM_162
      - CUSTOM_163
      - CUSTOM_164
      - CUSTOM_165
      - CUSTOM_166
      - CUSTOM_167
      - CUSTOM_168
      - CUSTOM_169
      - CUSTOM_170
      - CUSTOM_171
      - CUSTOM_172
      - CUSTOM_173
      - CUSTOM_174
      - CUSTOM_175
      - CUSTOM_176
      - CUSTOM_177
      - CUSTOM_178
      - CUSTOM_179
      - CUSTOM_180
      - CUSTOM_181
      - CUSTOM_182
      - CUSTOM_183
      - CUSTOM_184
      - CUSTOM_185
      - CUSTOM_186
      - CUSTOM_187
      - CUSTOM_188
      - CUSTOM_189
      - CUSTOM_190
      - CUSTOM_191
      - CUSTOM_192
      - CUSTOM_193
      - CUSTOM_194
      - CUSTOM_195
      - CUSTOM_196
      - CUSTOM_197
      - CUSTOM_198
      - CUSTOM_199
      - CUSTOM_200
      - CUSTOM_201
      - CUSTOM_202
      - CUSTOM_203
      - CUSTOM_204
      - CUSTOM_205
      - CUSTOM_206
      - CUSTOM_207
      - CUSTOM_208
      - CUSTOM_209
      - CUSTOM_210
      - CUSTOM_211
      - CUSTOM_212
      - CUSTOM_213
      - CUSTOM_214
      - CUSTOM_215
      - CUSTOM_216
      - CUSTOM_217
      - CUSTOM_218
      - CUSTOM_219
      - CUSTOM_220
      - CUSTOM_221
      - CUSTOM_222
      - CUSTOM_223
      - CUSTOM_224
      - CUSTOM_225
      - CUSTOM_226
      - CUSTOM_227
      - CUSTOM_228
      - CUSTOM_229
      - CUSTOM_230
      - CUSTOM_231
      - CUSTOM_232
      - CUSTOM_233
      - CUSTOM_234
      - CUSTOM_235
      - CUSTOM_236
      - CUSTOM_237
      - CUSTOM_238
      - CUSTOM_239
      - CUSTOM_240
      - CUSTOM_241
      - CUSTOM_242
      - CUSTOM_243
      - CUSTOM_244
      - CUSTOM_245
      - CUSTOM_246
      - CUSTOM_247
      - CUSTOM_248
      - CUSTOM_249
      - CUSTOM_250
      - CUSTOM_251
      - CUSTOM_252
      - CUSTOM_253
      - CUSTOM_254
      - CUSTOM_255
      - CUSTOM_256
      - OTHER_DRUGS
      - MARIJUANA
      - OTHER_EDUCATION
      - CONTINUING_EDUCATION_COLLEGES
      - HISTORY
      - K_12
      - REFERENCE_SITES
      - SCIENCE_AND_TECHNOLOGY
      - OTHER_ENTERTAINMENT_AND_RECREATION
      - ENTERTAINMENT
      - TELEVISION_AND_MOVIES
      - MUSIC
      - STREAMING_MEDIA
      - RADIO_STATIONS
      - GAMBLING
      - OTHER_GAMES
      - SOCIAL_NETWORKING_GAMES
      - OTHER_GOVERNMENT_AND_POLITICS
      - GOVERNMENT
      - POLITICS
      - HEALTH
      - OTHER_ILLEGAL_OR_QUESTIONABLE
      - COPYRIGHT_INFRINGEMENT
      - COMPUTER_HACKING
      - QUESTIONABLE
      - PROFANITY
      - MATURE_HUMOR
      - ANONYMIZER
      - OTHER_INFORMATION_TECHNOLOGY
      - TRANSLATORS
      - IMAGE_HOST
      - FILE_HOST
      - SHAREWARE_DOWNLOAD
      - WEB_BANNERS
      - WEB_HOST
      - WEB_SEARCH
      - PORTALS
      - SAFE_SEARCH_ENGINE
      - CDN
      - OSS_UPDATES
      - DNS_OVER_HTTPS
      - OTHER_INTERNET_COMMUNICATION
      - INTERNET_SERVICES
      - DISCUSSION_FORUMS
      - ONLINE_CHAT
      - EMAIL_HOST
      - BLOG
      - P2P_COMMUNICATION
      - REMOTE_ACCESS
      - WEB_CONFERENCING
      - ZSPROXY_IPS
      - JOB_SEARCH
      - MILITANCY_HATE_AND_EXTREMISM
      - OTHER_MISCELLANEOUS
      - MISCELLANEOUS_OR_UNKNOWN
      - NEWLY_REG_DOMAINS
      - NON_CATEGORIZABLE
      - NEWS_AND_MEDIA
      - OTHER_RELIGION
      - TRADITIONAL_RELIGION
      - CULT
      - ALT_NEW_AGE
      - OTHER_SECURITY
      - ADWARE_OR_SPYWARE
      - ENCR_WEB_CONTENT
      - MALICIOUS_TLD
      - OTHER_SHOPPING_AND_AUCTIONS
      - SPECIALIZED_SHOPPING
      - REAL_ESTATE
      - ONLINE_AUCTIONS
      - OTHER_SOCIAL_AND_FAMILY_ISSUES
      - SOCIAL_ISSUES
      - FAMILY_ISSUES
      - OTHER_SOCIETY_AND_LIFESTYLE
      - ART_CULTURE
      - ALTERNATE_LIFESTYLE
      - HOBBIES_AND_LEISURE
      - DINING_AND_RESTAURANT
      - ALCOHOL_TOBACCO
      - SOCIAL_NETWORKING
      - SPECIAL_INTERESTS
      - SPORTS
      - TASTELESS
      - TRAVEL
      - USER_DEFINED
      - VEHICLES
      - VIOLENCE
      - WEAPONS_AND_BOMBS
      type: textArea
    - auto: PREDEFINED
      description: Destination IP address countries. You can identify destinations
        based on the location of a server. A list of possible values can be found
        here https://help.zscaler.com/zia/firewall-policies#/ipDestinationGroups-post
      isArray: true
      name: countries
      predefined:
      - ANY
      - NONE
      - COUNTRY_AD
      - COUNTRY_AE
      - COUNTRY_AF
      - COUNTRY_AG
      - COUNTRY_AI
      - COUNTRY_AL
      - COUNTRY_AM
      - COUNTRY_AN
      - COUNTRY_AO
      - COUNTRY_AQ
      - COUNTRY_AR
      - COUNTRY_AS
      - COUNTRY_AT
      - COUNTRY_AU
      - COUNTRY_AW
      - COUNTRY_AZ
      - COUNTRY_BA
      - COUNTRY_BB
      - COUNTRY_BD
      - COUNTRY_BE
      - COUNTRY_BF
      - COUNTRY_BG
      - COUNTRY_BH
      - COUNTRY_BI
      - COUNTRY_BJ
      - COUNTRY_BM
      - COUNTRY_BN
      - COUNTRY_BO
      - COUNTRY_BR
      - COUNTRY_BS
      - COUNTRY_BT
      - COUNTRY_BV
      - COUNTRY_BW
      - COUNTRY_BY
      - COUNTRY_BZ
      - COUNTRY_CA
      - COUNTRY_CC
      - COUNTRY_CD
      - COUNTRY_CF
      - COUNTRY_CG
      - COUNTRY_CH
      - COUNTRY_CI
      - COUNTRY_CK
      - COUNTRY_CL
      - COUNTRY_CM
      - COUNTRY_CN
      - COUNTRY_CO
      - COUNTRY_CR
      - COUNTRY_CU
      - COUNTRY_CV
      - COUNTRY_CX
      - COUNTRY_CY
      - COUNTRY_CZ
      - COUNTRY_DE
      - COUNTRY_DJ
      - COUNTRY_DK
      - COUNTRY_DM
      - COUNTRY_DO
      - COUNTRY_DZ
      - COUNTRY_EC
      - COUNTRY_EE
      - COUNTRY_EG
      - COUNTRY_EH
      - COUNTRY_ER
      - COUNTRY_ES
      - COUNTRY_ET
      - COUNTRY_FI
      - COUNTRY_FJ
      - COUNTRY_FK
      - COUNTRY_FM
      - COUNTRY_FO
      - COUNTRY_FR
      - COUNTRY_FX
      - COUNTRY_GA
      - COUNTRY_GB
      - COUNTRY_GD
      - COUNTRY_GE
      - COUNTRY_GF
      - COUNTRY_GH
      - COUNTRY_GI
      - COUNTRY_GL
      - COUNTRY_GM
      - COUNTRY_GN
      - COUNTRY_GP
      - COUNTRY_GQ
      - COUNTRY_GR
      - COUNTRY_GS
      - COUNTRY_GT
      - COUNTRY_GU
      - COUNTRY_GW
      - COUNTRY_GY
      - COUNTRY_HK
      - COUNTRY_HM
      - COUNTRY_HN
      - COUNTRY_HR
      - COUNTRY_HT
      - COUNTRY_HU
      - COUNTRY_ID
      - COUNTRY_IE
      - COUNTRY_IL
      - COUNTRY_IN
      - COUNTRY_IO
      - COUNTRY_IQ
      - COUNTRY_IR
      - COUNTRY_IS
      - COUNTRY_IT
      - COUNTRY_JM
      - COUNTRY_JO
      - COUNTRY_JP
      - COUNTRY_KE
      - COUNTRY_KG
      - COUNTRY_KH
      - COUNTRY_KI
      - COUNTRY_KM
      - COUNTRY_KN
      - COUNTRY_KP
      - COUNTRY_KR
      - COUNTRY_KW
      - COUNTRY_KY
      - COUNTRY_KZ
      - COUNTRY_LA
      - COUNTRY_LB
      - COUNTRY_LC
      - COUNTRY_LI
      - COUNTRY_LK
      - COUNTRY_LR
      - COUNTRY_LS
      - COUNTRY_LT
      - COUNTRY_LU
      - COUNTRY_LV
      - COUNTRY_LY
      - COUNTRY_MA
      - COUNTRY_MC
      - COUNTRY_MD
      - COUNTRY_MG
      - COUNTRY_MH
      - COUNTRY_MK
      - COUNTRY_ML
      - COUNTRY_MM
      - COUNTRY_MN
      - COUNTRY_MO
      - COUNTRY_MP
      - COUNTRY_MQ
      - COUNTRY_MR
      - COUNTRY_MS
      - COUNTRY_MT
      - COUNTRY_MU
      - COUNTRY_MV
      - COUNTRY_MW
      - COUNTRY_MX
      - COUNTRY_MY
      - COUNTRY_MZ
      - COUNTRY_NA
      - COUNTRY_NC
      - COUNTRY_NE
      - COUNTRY_NF
      - COUNTRY_NG
      - COUNTRY_NI
      - COUNTRY_NL
      - COUNTRY_NO
      - COUNTRY_NP
      - COUNTRY_NR
      - COUNTRY_NU
      - COUNTRY_NZ
      - COUNTRY_OM
      - COUNTRY_PA
      - COUNTRY_PE
      - COUNTRY_PF
      - COUNTRY_PG
      - COUNTRY_PH
      - COUNTRY_PK
      - COUNTRY_PL
      - COUNTRY_PM
      - COUNTRY_PN
      - COUNTRY_PR
      - COUNTRY_PS
      - COUNTRY_PT
      - COUNTRY_PW
      - COUNTRY_PY
      - COUNTRY_QA
      - COUNTRY_RE
      - COUNTRY_RO
      - COUNTRY_RU
      - COUNTRY_RW
      - COUNTRY_SA
      - COUNTRY_SB
      - COUNTRY_SC
      - COUNTRY_SD
      - COUNTRY_SE
      - COUNTRY_SG
      - COUNTRY_SH
      - COUNTRY_SI
      - COUNTRY_SJ
      - COUNTRY_SK
      - COUNTRY_SL
      - COUNTRY_SM
      - COUNTRY_SN
      - COUNTRY_SO
      - COUNTRY_SR
      - COUNTRY_ST
      - COUNTRY_SV
      - COUNTRY_SY
      - COUNTRY_SZ
      - COUNTRY_TC
      - COUNTRY_TD
      - COUNTRY_TF
      - COUNTRY_TG
      - COUNTRY_TH
      - COUNTRY_TJ
      - COUNTRY_TK
      - COUNTRY_TM
      - COUNTRY_TN
      - COUNTRY_TO
      - COUNTRY_TL
      - COUNTRY_TR
      - COUNTRY_TT
      - COUNTRY_TV
      - COUNTRY_TW
      - COUNTRY_TZ
      - COUNTRY_UA
      - COUNTRY_UG
      - COUNTRY_UM
      - COUNTRY_US
      - COUNTRY_UY
      - COUNTRY_UZ
      - COUNTRY_VA
      - COUNTRY_VC
      - COUNTRY_VE
      - COUNTRY_VG
      - COUNTRY_VI
      - COUNTRY_VN
      - COUNTRY_VU
      - COUNTRY_WF
      - COUNTRY_WS
      - COUNTRY_YE
      - COUNTRY_YT
      - COUNTRY_RS
      - COUNTRY_ZA
      - COUNTRY_ZM
      - COUNTRY_ME
      - COUNTRY_ZW
      - COUNTRY_AX
      - COUNTRY_GG
      - COUNTRY_IM
      - COUNTRY_JE
      - COUNTRY_BL
      - COUNTRY_MF
      type: textArea
    description: Adds a new IP destination group.
    name: zscaler-create-ip-destination-group
    outputs:
    - contextPath: Zscaler.IPDestinationGroup.ID
      description: Unique identifier for the destination IP group.
      type: number
    - contextPath: Zscaler.IPDestinationGroup.Name
      description: Destination IP group name.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Type
      description: Destination IP group type (i.e., the group can contain destination
        IP addresses, countries, URL categories or FQDNs).
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Description
      description: Destination IP group description.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Addresses
      description: Destination IP addresses, FQDNs, or wildcard FQDNs added to the
        group.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.IpCategories
      description: Destination IP address URL categories. You can identify destinations
        based on the URL category of the domain.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Countries
      description: Destination IP address countries. You can identify destinations
        based on the location of a server.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.IsNonEditable
      description: If set to true, the destination IP address group is non-editable.
        This field is applicable only to predefined IP address groups, which cannot
        be modified.
      type: boolean
  - arguments:
    - description: The unique identifier for the IP destination group.
      name: ip_group_id
      required: true
      type: textArea
    - description: Destination IP group name.
      name: name
      type: textArea
    - description: Destination IP addresses, FQDNs, or wildcard FQDNs added to the
        group.
      isArray: true
      name: addresses
      type: textArea
    - description: Additional information about the destination IP group.
      name: description
      type: textArea
    - auto: PREDEFINED
      description: Destination IP address URL categories. You can identify destinations
        based on the URL category of the domain. To retrieve a list of possible values
        you can execute the zscaler-get-categories command.
      isArray: true
      name: ip_categories
      predefined:
      - ANY
      - NONE
      - OTHER_ADULT_MATERIAL
      - ADULT_THEMES
      - LINGERIE_BIKINI
      - NUDITY
      - PORNOGRAPHY
      - SEXUALITY
      - ADULT_SEX_EDUCATION
      - K_12_SEX_EDUCATION
      - SOCIAL_ADULT
      - OTHER_BUSINESS_AND_ECONOMY
      - CORPORATE_MARKETING
      - FINANCE
      - PROFESSIONAL_SERVICES
      - CLASSIFIEDS
      - TRADING_BROKARAGE_INSURANCE
      - CUSTOM_00
      - CUSTOM_01
      - CUSTOM_02
      - CUSTOM_03
      - CUSTOM_04
      - CUSTOM_05
      - CUSTOM_06
      - CUSTOM_07
      - CUSTOM_08
      - CUSTOM_09
      - CUSTOM_10
      - CUSTOM_11
      - CUSTOM_12
      - CUSTOM_13
      - CUSTOM_14
      - CUSTOM_15
      - CUSTOM_16
      - CUSTOM_17
      - CUSTOM_18
      - CUSTOM_19
      - CUSTOM_20
      - CUSTOM_21
      - CUSTOM_22
      - CUSTOM_23
      - CUSTOM_24
      - CUSTOM_25
      - CUSTOM_26
      - CUSTOM_27
      - CUSTOM_28
      - CUSTOM_29
      - CUSTOM_30
      - CUSTOM_31
      - CUSTOM_32
      - CUSTOM_33
      - CUSTOM_34
      - CUSTOM_35
      - CUSTOM_36
      - CUSTOM_37
      - CUSTOM_38
      - CUSTOM_39
      - CUSTOM_40
      - CUSTOM_41
      - CUSTOM_42
      - CUSTOM_43
      - CUSTOM_44
      - CUSTOM_45
      - CUSTOM_46
      - CUSTOM_47
      - CUSTOM_48
      - CUSTOM_49
      - CUSTOM_50
      - CUSTOM_51
      - CUSTOM_52
      - CUSTOM_53
      - CUSTOM_54
      - CUSTOM_55
      - CUSTOM_56
      - CUSTOM_57
      - CUSTOM_58
      - CUSTOM_59
      - CUSTOM_60
      - CUSTOM_61
      - CUSTOM_62
      - CUSTOM_63
      - CUSTOM_64
      - CUSTOM_65
      - CUSTOM_66
      - CUSTOM_67
      - CUSTOM_68
      - CUSTOM_69
      - CUSTOM_70
      - CUSTOM_71
      - CUSTOM_72
      - CUSTOM_73
      - CUSTOM_74
      - CUSTOM_75
      - CUSTOM_76
      - CUSTOM_77
      - CUSTOM_78
      - CUSTOM_79
      - CUSTOM_80
      - CUSTOM_81
      - CUSTOM_82
      - CUSTOM_83
      - CUSTOM_84
      - CUSTOM_85
      - CUSTOM_86
      - CUSTOM_87
      - CUSTOM_88
      - CUSTOM_89
      - CUSTOM_90
      - CUSTOM_91
      - CUSTOM_92
      - CUSTOM_93
      - CUSTOM_94
      - CUSTOM_95
      - CUSTOM_96
      - CUSTOM_97
      - CUSTOM_98
      - CUSTOM_99
      - CUSTOM_100
      - CUSTOM_101
      - CUSTOM_102
      - CUSTOM_103
      - CUSTOM_104
      - CUSTOM_105
      - CUSTOM_106
      - CUSTOM_107
      - CUSTOM_108
      - CUSTOM_109
      - CUSTOM_110
      - CUSTOM_111
      - CUSTOM_112
      - CUSTOM_113
      - CUSTOM_114
      - CUSTOM_115
      - CUSTOM_116
      - CUSTOM_117
      - CUSTOM_118
      - CUSTOM_119
      - CUSTOM_120
      - CUSTOM_121
      - CUSTOM_122
      - CUSTOM_123
      - CUSTOM_124
      - CUSTOM_125
      - CUSTOM_126
      - CUSTOM_127
      - CUSTOM_128
      - CUSTOM_129
      - CUSTOM_130
      - CUSTOM_131
      - CUSTOM_132
      - CUSTOM_133
      - CUSTOM_134
      - CUSTOM_135
      - CUSTOM_136
      - CUSTOM_137
      - CUSTOM_138
      - CUSTOM_139
      - CUSTOM_140
      - CUSTOM_141
      - CUSTOM_142
      - CUSTOM_143
      - CUSTOM_144
      - CUSTOM_145
      - CUSTOM_146
      - CUSTOM_147
      - CUSTOM_148
      - CUSTOM_149
      - CUSTOM_150
      - CUSTOM_151
      - CUSTOM_152
      - CUSTOM_153
      - CUSTOM_154
      - CUSTOM_155
      - CUSTOM_156
      - CUSTOM_157
      - CUSTOM_158
      - CUSTOM_159
      - CUSTOM_160
      - CUSTOM_161
      - CUSTOM_162
      - CUSTOM_163
      - CUSTOM_164
      - CUSTOM_165
      - CUSTOM_166
      - CUSTOM_167
      - CUSTOM_168
      - CUSTOM_169
      - CUSTOM_170
      - CUSTOM_171
      - CUSTOM_172
      - CUSTOM_173
      - CUSTOM_174
      - CUSTOM_175
      - CUSTOM_176
      - CUSTOM_177
      - CUSTOM_178
      - CUSTOM_179
      - CUSTOM_180
      - CUSTOM_181
      - CUSTOM_182
      - CUSTOM_183
      - CUSTOM_184
      - CUSTOM_185
      - CUSTOM_186
      - CUSTOM_187
      - CUSTOM_188
      - CUSTOM_189
      - CUSTOM_190
      - CUSTOM_191
      - CUSTOM_192
      - CUSTOM_193
      - CUSTOM_194
      - CUSTOM_195
      - CUSTOM_196
      - CUSTOM_197
      - CUSTOM_198
      - CUSTOM_199
      - CUSTOM_200
      - CUSTOM_201
      - CUSTOM_202
      - CUSTOM_203
      - CUSTOM_204
      - CUSTOM_205
      - CUSTOM_206
      - CUSTOM_207
      - CUSTOM_208
      - CUSTOM_209
      - CUSTOM_210
      - CUSTOM_211
      - CUSTOM_212
      - CUSTOM_213
      - CUSTOM_214
      - CUSTOM_215
      - CUSTOM_216
      - CUSTOM_217
      - CUSTOM_218
      - CUSTOM_219
      - CUSTOM_220
      - CUSTOM_221
      - CUSTOM_222
      - CUSTOM_223
      - CUSTOM_224
      - CUSTOM_225
      - CUSTOM_226
      - CUSTOM_227
      - CUSTOM_228
      - CUSTOM_229
      - CUSTOM_230
      - CUSTOM_231
      - CUSTOM_232
      - CUSTOM_233
      - CUSTOM_234
      - CUSTOM_235
      - CUSTOM_236
      - CUSTOM_237
      - CUSTOM_238
      - CUSTOM_239
      - CUSTOM_240
      - CUSTOM_241
      - CUSTOM_242
      - CUSTOM_243
      - CUSTOM_244
      - CUSTOM_245
      - CUSTOM_246
      - CUSTOM_247
      - CUSTOM_248
      - CUSTOM_249
      - CUSTOM_250
      - CUSTOM_251
      - CUSTOM_252
      - CUSTOM_253
      - CUSTOM_254
      - CUSTOM_255
      - CUSTOM_256
      - OTHER_DRUGS
      - MARIJUANA
      - OTHER_EDUCATION
      - CONTINUING_EDUCATION_COLLEGES
      - HISTORY
      - K_12
      - REFERENCE_SITES
      - SCIENCE_AND_TECHNOLOGY
      - OTHER_ENTERTAINMENT_AND_RECREATION
      - ENTERTAINMENT
      - TELEVISION_AND_MOVIES
      - MUSIC
      - STREAMING_MEDIA
      - RADIO_STATIONS
      - GAMBLING
      - OTHER_GAMES
      - SOCIAL_NETWORKING_GAMES
      - OTHER_GOVERNMENT_AND_POLITICS
      - GOVERNMENT
      - POLITICS
      - HEALTH
      - OTHER_ILLEGAL_OR_QUESTIONABLE
      - COPYRIGHT_INFRINGEMENT
      - COMPUTER_HACKING
      - QUESTIONABLE
      - PROFANITY
      - MATURE_HUMOR
      - ANONYMIZER
      - OTHER_INFORMATION_TECHNOLOGY
      - TRANSLATORS
      - IMAGE_HOST
      - FILE_HOST
      - SHAREWARE_DOWNLOAD
      - WEB_BANNERS
      - WEB_HOST
      - WEB_SEARCH
      - PORTALS
      - SAFE_SEARCH_ENGINE
      - CDN
      - OSS_UPDATES
      - DNS_OVER_HTTPS
      - OTHER_INTERNET_COMMUNICATION
      - INTERNET_SERVICES
      - DISCUSSION_FORUMS
      - ONLINE_CHAT
      - EMAIL_HOST
      - BLOG
      - P2P_COMMUNICATION
      - REMOTE_ACCESS
      - WEB_CONFERENCING
      - ZSPROXY_IPS
      - JOB_SEARCH
      - MILITANCY_HATE_AND_EXTREMISM
      - OTHER_MISCELLANEOUS
      - MISCELLANEOUS_OR_UNKNOWN
      - NEWLY_REG_DOMAINS
      - NON_CATEGORIZABLE
      - NEWS_AND_MEDIA
      - OTHER_RELIGION
      - TRADITIONAL_RELIGION
      - CULT
      - ALT_NEW_AGE
      - OTHER_SECURITY
      - ADWARE_OR_SPYWARE
      - ENCR_WEB_CONTENT
      - MALICIOUS_TLD
      - OTHER_SHOPPING_AND_AUCTIONS
      - SPECIALIZED_SHOPPING
      - REAL_ESTATE
      - ONLINE_AUCTIONS
      - OTHER_SOCIAL_AND_FAMILY_ISSUES
      - SOCIAL_ISSUES
      - FAMILY_ISSUES
      - OTHER_SOCIETY_AND_LIFESTYLE
      - ART_CULTURE
      - ALTERNATE_LIFESTYLE
      - HOBBIES_AND_LEISURE
      - DINING_AND_RESTAURANT
      - ALCOHOL_TOBACCO
      - SOCIAL_NETWORKING
      - SPECIAL_INTERESTS
      - SPORTS
      - TASTELESS
      - TRAVEL
      - USER_DEFINED
      - VEHICLES
      - VIOLENCE
      - WEAPONS_AND_BOMBS
      type: textArea
    - auto: PREDEFINED
      description: Destination IP address countries. You can identify destinations
        based on the location of a server. A list of possible values can be found
        here https://help.zscaler.com/zia/firewall-policies#/ipDestinationGroups/{ipGroupId}-put.
      isArray: true
      name: countries
      predefined:
      - ANY
      - NONE
      - COUNTRY_AD
      - COUNTRY_AE
      - COUNTRY_AF
      - COUNTRY_AG
      - COUNTRY_AI
      - COUNTRY_AL
      - COUNTRY_AM
      - COUNTRY_AN
      - COUNTRY_AO
      - COUNTRY_AQ
      - COUNTRY_AR
      - COUNTRY_AS
      - COUNTRY_AT
      - COUNTRY_AU
      - COUNTRY_AW
      - COUNTRY_AZ
      - COUNTRY_BA
      - COUNTRY_BB
      - COUNTRY_BD
      - COUNTRY_BE
      - COUNTRY_BF
      - COUNTRY_BG
      - COUNTRY_BH
      - COUNTRY_BI
      - COUNTRY_BJ
      - COUNTRY_BM
      - COUNTRY_BN
      - COUNTRY_BO
      - COUNTRY_BR
      - COUNTRY_BS
      - COUNTRY_BT
      - COUNTRY_BV
      - COUNTRY_BW
      - COUNTRY_BY
      - COUNTRY_BZ
      - COUNTRY_CA
      - COUNTRY_CC
      - COUNTRY_CD
      - COUNTRY_CF
      - COUNTRY_CG
      - COUNTRY_CH
      - COUNTRY_CI
      - COUNTRY_CK
      - COUNTRY_CL
      - COUNTRY_CM
      - COUNTRY_CN
      - COUNTRY_CO
      - COUNTRY_CR
      - COUNTRY_CU
      - COUNTRY_CV
      - COUNTRY_CX
      - COUNTRY_CY
      - COUNTRY_CZ
      - COUNTRY_DE
      - COUNTRY_DJ
      - COUNTRY_DK
      - COUNTRY_DM
      - COUNTRY_DO
      - COUNTRY_DZ
      - COUNTRY_EC
      - COUNTRY_EE
      - COUNTRY_EG
      - COUNTRY_EH
      - COUNTRY_ER
      - COUNTRY_ES
      - COUNTRY_ET
      - COUNTRY_FI
      - COUNTRY_FJ
      - COUNTRY_FK
      - COUNTRY_FM
      - COUNTRY_FO
      - COUNTRY_FR
      - COUNTRY_FX
      - COUNTRY_GA
      - COUNTRY_GB
      - COUNTRY_GD
      - COUNTRY_GE
      - COUNTRY_GF
      - COUNTRY_GH
      - COUNTRY_GI
      - COUNTRY_GL
      - COUNTRY_GM
      - COUNTRY_GN
      - COUNTRY_GP
      - COUNTRY_GQ
      - COUNTRY_GR
      - COUNTRY_GS
      - COUNTRY_GT
      - COUNTRY_GU
      - COUNTRY_GW
      - COUNTRY_GY
      - COUNTRY_HK
      - COUNTRY_HM
      - COUNTRY_HN
      - COUNTRY_HR
      - COUNTRY_HT
      - COUNTRY_HU
      - COUNTRY_ID
      - COUNTRY_IE
      - COUNTRY_IL
      - COUNTRY_IN
      - COUNTRY_IO
      - COUNTRY_IQ
      - COUNTRY_IR
      - COUNTRY_IS
      - COUNTRY_IT
      - COUNTRY_JM
      - COUNTRY_JO
      - COUNTRY_JP
      - COUNTRY_KE
      - COUNTRY_KG
      - COUNTRY_KH
      - COUNTRY_KI
      - COUNTRY_KM
      - COUNTRY_KN
      - COUNTRY_KP
      - COUNTRY_KR
      - COUNTRY_KW
      - COUNTRY_KY
      - COUNTRY_KZ
      - COUNTRY_LA
      - COUNTRY_LB
      - COUNTRY_LC
      - COUNTRY_LI
      - COUNTRY_LK
      - COUNTRY_LR
      - COUNTRY_LS
      - COUNTRY_LT
      - COUNTRY_LU
      - COUNTRY_LV
      - COUNTRY_LY
      - COUNTRY_MA
      - COUNTRY_MC
      - COUNTRY_MD
      - COUNTRY_MG
      - COUNTRY_MH
      - COUNTRY_MK
      - COUNTRY_ML
      - COUNTRY_MM
      - COUNTRY_MN
      - COUNTRY_MO
      - COUNTRY_MP
      - COUNTRY_MQ
      - COUNTRY_MR
      - COUNTRY_MS
      - COUNTRY_MT
      - COUNTRY_MU
      - COUNTRY_MV
      - COUNTRY_MW
      - COUNTRY_MX
      - COUNTRY_MY
      - COUNTRY_MZ
      - COUNTRY_NA
      - COUNTRY_NC
      - COUNTRY_NE
      - COUNTRY_NF
      - COUNTRY_NG
      - COUNTRY_NI
      - COUNTRY_NL
      - COUNTRY_NO
      - COUNTRY_NP
      - COUNTRY_NR
      - COUNTRY_NU
      - COUNTRY_NZ
      - COUNTRY_OM
      - COUNTRY_PA
      - COUNTRY_PE
      - COUNTRY_PF
      - COUNTRY_PG
      - COUNTRY_PH
      - COUNTRY_PK
      - COUNTRY_PL
      - COUNTRY_PM
      - COUNTRY_PN
      - COUNTRY_PR
      - COUNTRY_PS
      - COUNTRY_PT
      - COUNTRY_PW
      - COUNTRY_PY
      - COUNTRY_QA
      - COUNTRY_RE
      - COUNTRY_RO
      - COUNTRY_RU
      - COUNTRY_RW
      - COUNTRY_SA
      - COUNTRY_SB
      - COUNTRY_SC
      - COUNTRY_SD
      - COUNTRY_SE
      - COUNTRY_SG
      - COUNTRY_SH
      - COUNTRY_SI
      - COUNTRY_SJ
      - COUNTRY_SK
      - COUNTRY_SL
      - COUNTRY_SM
      - COUNTRY_SN
      - COUNTRY_SO
      - COUNTRY_SR
      - COUNTRY_ST
      - COUNTRY_SV
      - COUNTRY_SY
      - COUNTRY_SZ
      - COUNTRY_TC
      - COUNTRY_TD
      - COUNTRY_TF
      - COUNTRY_TG
      - COUNTRY_TH
      - COUNTRY_TJ
      - COUNTRY_TK
      - COUNTRY_TM
      - COUNTRY_TN
      - COUNTRY_TO
      - COUNTRY_TL
      - COUNTRY_TR
      - COUNTRY_TT
      - COUNTRY_TV
      - COUNTRY_TW
      - COUNTRY_TZ
      - COUNTRY_UA
      - COUNTRY_UG
      - COUNTRY_UM
      - COUNTRY_US
      - COUNTRY_UY
      - COUNTRY_UZ
      - COUNTRY_VA
      - COUNTRY_VC
      - COUNTRY_VE
      - COUNTRY_VG
      - COUNTRY_VI
      - COUNTRY_VN
      - COUNTRY_VU
      - COUNTRY_WF
      - COUNTRY_WS
      - COUNTRY_YE
      - COUNTRY_YT
      - COUNTRY_RS
      - COUNTRY_ZA
      - COUNTRY_ZM
      - COUNTRY_ME
      - COUNTRY_ZW
      - COUNTRY_AX
      - COUNTRY_GG
      - COUNTRY_IM
      - COUNTRY_JE
      - COUNTRY_BL
      - COUNTRY_MF
      type: textArea
    - auto: PREDEFINED
      defaultValue: "False"
      description: If set to true, the destination IP address group is non-editable.
        This field is applicable only to predefined IP address groups, which cannot
        be modified.
      name: is_non_editable
      predefined:
      - "True"
      - "False"
      type: textArea
    description: Updates the IP destination group information for the specified group
      ID.
    name: zscaler-edit-ip-destination-group
    outputs:
    - contextPath: Zscaler.IPDestinationGroup.ID
      description: Unique identifier for the destination IP group.
      type: number
    - contextPath: Zscaler.IPDestinationGroup.Name
      description: Destination IP group name.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Type
      description: Destination IP group type (i.e., the group can contain destination
        IP addresses, countries, URL categories or FQDNs).
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Description
      description: Destination IP group description.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Addresses
      description: Destination IP addresses, FQDNs, or wildcard FQDNs added to the
        group.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.IpCategories
      description: Destination IP address URL categories. You can identify destinations
        based on the URL category of the domain.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Countries
      description: Destination IP address countries. You can identify destinations
        based on the location of a server.
      type: string
  - arguments:
    - description: A comma-separated list of unique identifiers for the IP destination
        groups.
      isArray: true
      name: ip_group_id
      type: textArea
    - auto: PREDEFINED
      description: The IP group type to be excluded from the results.
      name: exclude_type
      predefined:
      - DSTN_IP
      - DSTN_FQDN
      - DSTN_DOMAIN
      - DSTN_OTHER
      type: textArea
    - auto: PREDEFINED
      description: The IP group type to be filtered from results. This argument is
        only supported when the 'lite' argument is set to True.
      isArray: true
      name: category_type
      predefined:
      - DSTN_IP
      - DSTN_FQDN
      - DSTN_DOMAIN
      - DSTN_OTHER
    - auto: PREDEFINED
      defaultValue: "False"
      description: Retrieve IPv6 destination groups.
      name: include_ipv6
      predefined:
      - "True"
      - "False"
      type: textArea
    - defaultValue: "50"
      description: Limit of the results to be retrieved.
      name: limit
      type: textArea
    - auto: PREDEFINED
      defaultValue: "False"
      description: Whether to retrieve all results at once.
      name: all_results
      predefined:
      - "True"
      - "False"
      type: textArea
    - auto: PREDEFINED
      defaultValue: "False"
      description: Whether to retrieve only limited information of IP destination
        groups. Includes ID, name and type of the IP destination groups.
      name: lite
      predefined:
      - "True"
      - "False"
      type: textArea
    description: Gets a list of all IP destination groups or the IP destination group
      information for the specified group ID.
    name: zscaler-list-ip-destination-groups
    outputs:
    - contextPath: Zscaler.IPDestinationGroup.ID
      description: Unique identifier for the destination IP group.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Name
      description: Destination IP group name.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Type
      description: Destination IP group type (i.e., the group can contain destination
        IP addresses, countries, URL categories or FQDNs).
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Addresses
      description: Destination IP addresses, FQDNs, or wildcard FQDNs added to the
        group.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Description
      description: Additional information about the destination IP group.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.IpCategories
      description: Destination IP address URL categories. You can identify destinations
        based on the URL category of the domain.
      type: string
    - contextPath: Zscaler.IPDestinationGroup.Countries
      description: Destination IP address countries. You can identify destinations
        based on the location of a server.
      type: string
  - arguments:
    - description: A comma-separated list of unique identifiers for the IP destination
        groups.
      isArray: true
      name: ip_group_ids
      type: textArea
    description: Deletes the IP destination groups for the specified group ID.
    name: zscaler-delete-ip-destination-groups
  dockerimage: demisto/python3:3.10.14.92207
  runonce: false
  script: |
    register_module_line('Zscaler', 'start', __line__())
    ### pack version: 1.3.20




    """ GLOBAL VARS """
    ADD = "ADD_TO_LIST"
    REMOVE = "REMOVE_FROM_LIST"
    INTEGRATION_NAME = "Zscaler"
    SUSPICIOUS_CATEGORIES = ["SUSPICIOUS_DESTINATION", "SPYWARE_OR_ADWARE"]
    CLOUD_NAME = demisto.params()["cloud"]
    USERNAME = demisto.params()["credentials"]["identifier"]
    PASSWORD = demisto.params()["credentials"]["password"]
    API_KEY = str(demisto.params().get("creds_key", {}).get("password", "")) or str(
        demisto.params().get("key", "")
    )
    if not API_KEY:
        raise Exception("API Key is missing. Please provide an API Key.")
    BASE_URL = CLOUD_NAME + "/api/v1"
    USE_SSL = not demisto.params().get("insecure", False)
    PROXY = demisto.params().get("proxy", True)
    REQUEST_TIMEOUT = int(demisto.params().get("requestTimeout", 15))
    DEFAULT_HEADERS = {"content-type": "application/json"}
    SESSION_ID_KEY = "session_id"
    ERROR_CODES_DICT = {
        400: "Invalid or bad request",
        401: "Session is not authenticated or timed out",
        403: "One of the following permission errors occurred:\n-The API key was disabled by your service provider\n"
        "-User role has no access permissions or functional scope\n-A required SKU subscription is missing\n"
        "Contact support or your account team for assistance.",
        404: "Resource does not exist",
        409: "Request could not be processed because of possible edit conflict occurred. Another admin might be saving a "
        "configuration change at the same time. In this scenario, the client is expected to retry after a short "
        "time period.",
        406: "Not Acceptable",
        415: "Unsupported media type.",
        429: "Exceeded the rate limit or quota.",
        500: "Unexpected error",
        503: "Service is temporarily unavailable",
    }
    AUTO_ACTIVATE_CHANGES_COMMANDS = (
        "zscaler-blacklist-url",
        "zscaler-undo-blacklist-url",
        "zscaler-whitelist-url",
        "zscaler-undo-whitelist-url",
        "zscaler-blacklist-ip",
        "zscaler-undo-blacklist-ip",
        "zscaler-whitelist-ip",
        "zscaler-undo-whitelist-ip",
        "zscaler-category-add-url",
        "zscaler-category-add-ip",
        "zscaler-category-remove-url",
        "zscaler-category-remove-ip",
        "zscaler-list-ip-destination-groups",
        "zscaler-edit-ip-destination-groups",
        "zscaler-create-ip-destination-group",
        "zscaler-delete-ip-destination-groups",
    )

    """ HANDLE PROXY """
    # Remove proxy if not set to true in params
    handle_proxy()

    """ HELPER CLASSES """


    class AuthorizationError(DemistoException):
        """Error to be raised when 401/403 headers are present in http response"""


    """ HELPER FUNCTIONS """


    def error_handler(res):
        """
            Deals with unsuccessful calls
        """
        if res.status_code in (401, 403):
            raise AuthorizationError(res.content)
        elif (
            res.status_code == 400
            and res.request.method == "PUT"
            and "/urlCategories/" in res.request.url
        ):
            raise Exception(
                "Bad request, This could be due to reaching your organizations quota."
                " For more info about your quota usage, run the command zscaler-url-quota."
            )
        else:
            if res.status_code in ERROR_CODES_DICT:
                raise Exception(
                    f"The request failed with the following error: {ERROR_CODES_DICT[res.status_code]}.\nMessage: {res.text}"
                )
            else:
                raise Exception(
                    f"The request failed with the following error: {res.status_code}.\nMessage: {res.text}"
                )


    def http_request(method, url_suffix, data=None, headers=None, resp_type='json'):
        time_sensitive = is_time_sensitive()
        demisto.debug(f'{time_sensitive=}')
        retries = 0 if time_sensitive else 3
        status_list_to_retry = None if time_sensitive else [429]
        timeout = 2 if time_sensitive else REQUEST_TIMEOUT
        try:
            res = generic_http_request(method=method,
                                       server_url=BASE_URL,
                                       timeout=timeout,
                                       verify=USE_SSL,
                                       proxy=PROXY,
                                       client_headers=DEFAULT_HEADERS,
                                       headers=headers,
                                       url_suffix=url_suffix,
                                       data=data or {},
                                       ok_codes=(200, 204),
                                       error_handler=error_handler,
                                       retries=retries,
                                       status_list_to_retry=status_list_to_retry,
                                       resp_type=resp_type)

        except Exception as e:
            LOG(f"Zscaler request failed with url suffix={url_suffix}\tdata={data}")
            LOG(e)
            raise e
        return res


    def validate_urls(urls):
        for url in urls:
            if url.startswith(("http://", "https://")):
                return_error(
                    "Enter a valid URL address without an http:// or https:// prefix. URL should have at least host."
                    "domain pattern to qualify."
                )


    """ FUNCTIONS """


    def login():
        """
        Try to use integration context if available and valid, otherwise create new session
        """
        cmd_url = "/authenticatedSession"

        def obfuscateApiKey(seed):
            now = str(int(time.time() * 1000))
            n = now[-6:]
            r = str(int(n) >> 1).zfill(6)
            key = ""
            for i in range(0, len(n), 1):
                key += seed[int(n[i])]
            for j in range(0, len(r), 1):
                key += seed[int(r[j]) + 2]
            return now, key

        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if session_id:
            DEFAULT_HEADERS["cookie"] = session_id
            try:
                return test_module()
            except AuthorizationError as e:
                demisto.info(
                    f"Zscaler encountered an authentication error.\nError: {str(e)}"
                )
        ts, key = obfuscateApiKey(API_KEY)
        data = {"username": USERNAME, "timestamp": ts, "password": PASSWORD, "apiKey": key}
        json_data = json.dumps(data)
        result = http_request("POST", cmd_url, json_data, DEFAULT_HEADERS, resp_type='response')
        auth = result.headers["Set-Cookie"]
        ctx[SESSION_ID_KEY] = DEFAULT_HEADERS["cookie"] = auth[: auth.index(";")]
        set_integration_context(ctx)
        return test_module()


    def activate_changes():
        cmd_url = "/status/activate"
        return http_request("POST", cmd_url, None, DEFAULT_HEADERS)


    def logout():
        cmd_url = "/authenticatedSession"
        return http_request("DELETE", cmd_url, None, DEFAULT_HEADERS)


    def blacklist_url(url):
        urls_to_blacklist = argToList(url)
        validate_urls(urls_to_blacklist)
        cmd_url = "/security/advanced/blacklistUrls?action=ADD_TO_LIST"
        data = {"blacklistUrls": urls_to_blacklist}
        json_data = json.dumps(data)
        http_request("POST", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ""
        for url in urls_to_blacklist:
            list_of_urls += "- " + url + "\n"
        return "Added the following URLs to the blacklist successfully:\n" + list_of_urls


    def unblacklist_url(url):
        urls_to_unblacklist = argToList(url)
        cmd_url = "/security/advanced/blacklistUrls?action=REMOVE_FROM_LIST"

        # Check if given URLs is blacklisted
        blacklisted_urls = get_blacklist()["blacklistUrls"]
        if len(urls_to_unblacklist) == 1:  # Given only one URL to unblacklist
            if urls_to_unblacklist[0] not in blacklisted_urls:
                raise Exception("Given URL is not blacklisted.")
        elif not any(
            url in urls_to_unblacklist for url in blacklisted_urls
        ):  # Given more than one URL to blacklist
            raise Exception("Given URLs are not blacklisted.")

        data = {"blacklistUrls": urls_to_unblacklist}
        json_data = json.dumps(data)
        http_request("POST", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ""
        for url in urls_to_unblacklist:
            list_of_urls += "- " + url + "\n"
        return (
            "Removed the following URLs from the blacklist successfully:\n" + list_of_urls
        )


    def blacklist_ip(ip):
        ips_to_blacklist = argToList(ip)
        cmd_url = "/security/advanced/blacklistUrls?action=ADD_TO_LIST"
        data = {"blacklistUrls": ips_to_blacklist}
        json_data = json.dumps(data)
        http_request("POST", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ""
        for ip in ips_to_blacklist:
            list_of_ips += "- " + ip + "\n"
        return (
            "Added the following IP addresses to the blacklist successfully:\n"
            + list_of_ips
        )


    def unblacklist_ip(ip):
        ips_to_unblacklist = argToList(ip)
        cmd_url = "/security/advanced/blacklistUrls?action=REMOVE_FROM_LIST"
        # Check if given IPs is blacklisted
        blacklisted_ips = get_blacklist()["blacklistUrls"]
        if len(ips_to_unblacklist) == 1:  # Given only one IP address to blacklist
            if ips_to_unblacklist[0] not in blacklisted_ips:
                raise Exception("Given IP address is not blacklisted.")
        elif not set(ips_to_unblacklist).issubset(
            set(blacklisted_ips)
        ):  # Given more than one IP address to blacklist
            raise Exception("Given IP addresses are not blacklisted.")
        data = {"blacklistUrls": ips_to_unblacklist}
        json_data = json.dumps(data)
        http_request("POST", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ""
        for ip in ips_to_unblacklist:
            list_of_ips += "- " + ip + "\n"
        return (
            "Removed the following IP addresses from the blacklist successfully:\n"
            + list_of_ips
        )


    def whitelist_url(url):
        cmd_url = "/security"
        urls_to_whitelist = argToList(url)
        # Get the current whitelist
        whitelist_urls = get_whitelist()
        if not whitelist_urls:
            whitelist_urls["whitelistUrls"] = []

        whitelist_urls["whitelistUrls"] += urls_to_whitelist
        json_data = json.dumps(whitelist_urls)
        http_request("PUT", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ""
        for url in urls_to_whitelist:
            list_of_urls += "- " + url + "\n"
        return "Added the following URLs to the whitelist successfully:\n" + list_of_urls


    def unwhitelist_url(url):
        cmd_url = "/security"
        urls_to_unwhitelist = argToList(url)
        # Get the current whitelist
        whitelist_urls = get_whitelist()
        if not whitelist_urls:
            whitelist_urls["whitelistUrls"] = []

        # Check if given URL is whitelisted
        if len(urls_to_unwhitelist) == 1:  # Given only one URL to whitelist
            if urls_to_unwhitelist[0] not in whitelist_urls["whitelistUrls"]:
                raise Exception("Given host address is not whitelisted.")
        elif not set(urls_to_unwhitelist).issubset(
            set(whitelist_urls["whitelistUrls"])
        ):  # Given more than one URL to whitelist
            raise Exception("Given host addresses are not whitelisted.")
        # List comprehension to remove requested URLs from the whitelist
        whitelist_urls["whitelistUrls"] = [
            x for x in whitelist_urls["whitelistUrls"] if x not in urls_to_unwhitelist
        ]
        json_data = json.dumps(whitelist_urls)
        http_request("PUT", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_urls = ""
        for url in whitelist_urls:
            list_of_urls += "- " + url + "\n"
        return (
            "Removed the following URLs from the whitelist successfully:\n" + list_of_urls
        )


    def whitelist_ip(ip):
        cmd_url = "/security"
        ips_to_whitelist = argToList(ip)
        # Get the current whitelist
        whitelist_ips = get_whitelist()
        if not whitelist_ips:
            whitelist_ips["whitelistUrls"] = []

        whitelist_ips["whitelistUrls"] += ips_to_whitelist
        json_data = json.dumps(whitelist_ips)
        http_request("PUT", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ""
        for ip in ips_to_whitelist:
            list_of_ips += "- " + ip + "\n"
        return "Added the following URLs to the whitelist successfully:\n" + list_of_ips


    def unwhitelist_ip(ip):
        cmd_url = "/security"
        ips_to_unwhitelist = argToList(ip)
        # Get the current whitelist
        whitelist_ips = get_whitelist()
        if not whitelist_ips:
            whitelist_ips["whitelistUrls"] = []

        # Check if given IP is whitelisted
        if len(ips_to_unwhitelist) == 1:  # Given only one IP to whitelist
            if ips_to_unwhitelist[0] not in whitelist_ips["whitelistUrls"]:
                raise Exception("Given IP address is not whitelisted.")
        elif not set(ips_to_unwhitelist).issubset(
            set(whitelist_ips["whitelistUrls"])
        ):  # Given more than one IP to whitelist
            raise Exception("Given IP address is not whitelisted.")
        # List comprehension to remove requested IPs from the whitelist
        whitelist_ips["whitelistUrls"] = [
            x for x in whitelist_ips["whitelistUrls"] if x not in ips_to_unwhitelist
        ]
        json_data = json.dumps(whitelist_ips)
        http_request("PUT", cmd_url, json_data, DEFAULT_HEADERS)
        list_of_ips = ""
        for ip in ips_to_unwhitelist:
            list_of_ips += "- " + ip + "\n"
        return (
            "Removed the following IP addresses from the whitelist successfully:\n"
            + list_of_ips
        )


    def get_blacklist_command(args):
        blacklist = get_blacklist().get("blacklistUrls")
        if blacklist:
            filter_ = args.get("filter", "")
            query = args.get("query", "")
            if filter_ or query:
                filtered_blacklist = []
                for entity in blacklist:
                    # if filter / query were not provided, then there is a match on it vacuously
                    is_filter_match = not filter_
                    is_query_match = not query
                    if filter_:
                        if re.match(ipv4Regex, entity):
                            if filter_ == "ip":
                                is_filter_match = True
                        elif filter_ == "url":
                            is_filter_match = True
                    if query:
                        if re.search(query, entity):
                            is_query_match = True
                        else:
                            is_query_match = False
                    if is_filter_match and is_query_match:
                        filtered_blacklist.append(entity)
                blacklist = filtered_blacklist
        if blacklist:
            hr = "### Zscaler blacklist\n"
            for url in blacklist:
                hr += "- " + url + "\n"
            ec = {"Zscaler.Blacklist": blacklist}
            entry = {
                "Type": entryTypes["note"],
                "Contents": blacklist,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": hr,
                "EntryContext": ec,
            }
            return entry
        else:
            return "No results found"


    def get_blacklist():
        cmd_url = "/security/advanced"
        result = http_request("GET", cmd_url, None, DEFAULT_HEADERS, resp_type='content')
        return json.loads(result)


    def get_whitelist_command():
        whitelist = get_whitelist().get("whitelistUrls")
        if whitelist:
            hr = "### Zscaler whitelist\n"
            for url in whitelist:
                hr += "- " + url + "\n"
            ec = {"Zscaler.Whitelist": whitelist}
            entry = {
                "Type": entryTypes["note"],
                "Contents": whitelist,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": hr,
                "EntryContext": ec,
            }
            return entry
        else:
            return "No results found"


    def get_whitelist():
        cmd_url = "/security"
        result = http_request("GET", cmd_url, None, DEFAULT_HEADERS, resp_type='content')
        return json.loads(result)


    def url_lookup(args):
        url = args.get("url", "")
        multiple = args.get("multiple", "true").lower() == "true"
        response = lookup_request(url, multiple)
        raw_res = json.loads(response)

        urls_list = argToList(url)
        results: List[CommandResults] = []

        for data in raw_res:
            res_url = data.get("url")
            for url in urls_list:
                # since zscaler expects to recieve a URL without the protocol, we omit it in `lookup_request`
                # in the response, the URL is returned as it was sent, so we add back the protocol by replacing
                # the URL retruned with the one we got as an argument
                if "http://" + res_url in url or "https://" + res_url in url:
                    data["url"] = url

            ioc_context = {"Address": data["url"], "Data": data["url"]}
            score = Common.DBotScore.GOOD

            if len(data["urlClassifications"]) == 0:
                data["urlClassifications"] = ""
            else:
                data["urlClassifications"] = "".join(data["urlClassifications"])
                ioc_context["urlClassifications"] = data["urlClassifications"]
                if data["urlClassifications"] == "MISCELLANEOUS_OR_UNKNOWN":
                    score = Common.DBotScore.NONE

            if len(data["urlClassificationsWithSecurityAlert"]) == 0:
                data["urlClassificationsWithSecurityAlert"] = ""
            else:
                data["urlClassificationsWithSecurityAlert"] = "".join(
                    data["urlClassificationsWithSecurityAlert"]
                )
                ioc_context["urlClassificationsWithSecurityAlert"] = data[
                    "urlClassificationsWithSecurityAlert"
                ]
                if data["urlClassificationsWithSecurityAlert"] in SUSPICIOUS_CATEGORIES:
                    score = Common.DBotScore.SUSPICIOUS
                else:
                    score = Common.DBotScore.BAD

                data["ip"] = data.pop("url")

            url_indicator = Common.URL(
                url=ioc_context["Data"],
                dbot_score=Common.DBotScore(
                    indicator=ioc_context["Data"],
                    indicator_type=DBotScoreType.URL,
                    integration_name=INTEGRATION_NAME,
                    malicious_description=data.get(
                        "urlClassificationsWithSecurityAlert", None
                    ),
                    score=score,
                    reliability=demisto.params().get("reliability")
                ),
            )

            results.append(
                CommandResults(
                    outputs_prefix=f"{INTEGRATION_NAME}.URL",
                    outputs_key_field="Data",
                    indicator=url_indicator,
                    readable_output=tableToMarkdown(
                        f'Zscaler URL Lookup for {ioc_context["Data"]}',
                        data,
                        removeNull=True,
                    ),
                    outputs=createContext(data=ioc_context, removeNull=True),
                    raw_response=data,
                )
            )

        return results or "No results found."


    def ip_lookup(ip):
        results: List[CommandResults] = []

        response = lookup_request(ip, multiple=True)
        raw_res = json.loads(response)

        for data in raw_res:
            ioc_context = {"Address": data["url"]}
            score = Common.DBotScore.GOOD

            if len(data["urlClassifications"]) == 0:
                data["iplClassifications"] = ""
            else:
                data["ipClassifications"] = "".join(data["urlClassifications"])
                ioc_context["ipClassifications"] = data["ipClassifications"]

            del data["urlClassifications"]

            if len(data["urlClassificationsWithSecurityAlert"]) == 0:
                data["ipClassificationsWithSecurityAlert"] = ""
            else:
                data["ipClassificationsWithSecurityAlert"] = "".join(
                    data["urlClassificationsWithSecurityAlert"]
                )
                ioc_context["ipClassificationsWithSecurityAlert"] = data[
                    "ipClassificationsWithSecurityAlert"
                ]
                if data["urlClassificationsWithSecurityAlert"] in SUSPICIOUS_CATEGORIES:
                    score = Common.DBotScore.SUSPICIOUS
                else:
                    score = Common.DBotScore.BAD

            del data["urlClassificationsWithSecurityAlert"]

            data["ip"] = data.pop("url")

            ip_indicator = Common.IP(
                ip=data["ip"],
                dbot_score=Common.DBotScore(
                    indicator=data["ip"],
                    indicator_type=DBotScoreType.IP,
                    integration_name=INTEGRATION_NAME,
                    malicious_description=data.get(
                        "ipClassificationsWithSecurityAlert", None
                    ),
                    score=score,
                    reliability=demisto.params().get("reliability"),
                ),
            )
            results.append(
                CommandResults(
                    outputs_prefix=f"{INTEGRATION_NAME}.IP",
                    indicator=ip_indicator,
                    outputs_key_field="Address",
                    readable_output=tableToMarkdown(
                        f'Zscaler IP Lookup for {ioc_context["Address"]}',
                        data,
                        removeNull=True,
                    ),
                    outputs=createContext(data=ioc_context, removeNull=True),
                    raw_response=data,
                )
            )

        return results or "No results found."


    def lookup_request(ioc, multiple=True):
        cmd_url = "/urlLookup"
        if multiple:
            ioc_list = argToList(ioc)
        else:
            ioc_list = [ioc]
        ioc_list = [url.replace("https://", "").replace("http://", "") for url in ioc_list]
        json_data = json.dumps(ioc_list)
        response = http_request("POST", cmd_url, json_data, DEFAULT_HEADERS, resp_type='content')
        return response


    def category_add(category_id, data, retaining_parent_category_data, data_type):
        if not any((data, retaining_parent_category_data)):
            return_error(f'Either {data_type} argument or retaining-parent-category-{data_type} argument must be provided.')

        category_data = get_category_by_id(category_id)
        demisto.debug(f'{category_data=}')
        if category_data:  # check if the category exists
            data_list = argToList(data)
            all_data = data_list[:]
            all_data.extend([x.strip() for x in category_data["urls"]])
            category_data["urls"] = all_data
            retaining_parent_category_data_list = argToList(retaining_parent_category_data)
            if not any((data_list, retaining_parent_category_data_list)):
                return_error(f'Either {data_type} argument or retaining-parent-category-{data_type} argument must be provided.')

            add_or_remove_urls_from_category(
                ADD, data_list, category_data, retaining_parent_category_data_list
            )  # add the urls to the category
            context = {
                "ID": category_id,
                "CustomCategory": category_data.get("customCategory"),
                "URL": category_data.get("urls"),
            }
            if category_data.get("description"):  # Custom might not have description
                context["Description"] = category_data["description"]
            ec = {"Zscaler.Category(val.ID && val.ID === obj.ID)": context}
            added_data = ""
            for item in data_list:
                added_data += f"- {item}\n"

            hr = f"Added the following {data_type.upper()} addresses to category {category_id}:\n{added_data}"

            entry = {
                "Type": entryTypes["note"],
                "Contents": category_data,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": hr,
                "EntryContext": ec,
            }
            return entry
        else:
            return return_error("Category could not be found.")


    def category_remove(category_id, data, retaining_parent_category_data, data_type):
        if not any((data, retaining_parent_category_data)):
            return_error(f'Either {data_type} argument or retaining-parent-category-{data_type} argument must be provided.')

        category_data = get_category_by_id(category_id)  # check if the category exists
        demisto.debug(f'{category_data=}')

        if category_data:
            removed_data = ''
            data_list = []
            retaining_parent_category_data_list = []

            if data:
                data_list = argToList(data)
                updated_data = [
                    item for item in category_data["urls"] if item not in data_list
                ]
                if updated_data == category_data["urls"]:
                    return return_error(f"Could not find given {data_type.upper()} in the category.")
                category_data["urls"] = updated_data
                for item in data_list:
                    removed_data += f"- {item}\n"

            if retaining_parent_category_data:
                retaining_parent_category_data_list = argToList(retaining_parent_category_data)
                for item in retaining_parent_category_data_list:
                    removed_data += f"- {item}\n"

            add_or_remove_urls_from_category(
                REMOVE, data_list, category_data, retaining_parent_category_data_list)  # remove the urls from list

            context = {
                "ID": category_id,
                "CustomCategory": category_data.get("customCategory"),
                "URL": category_data.get("urls"),
            }
            if category_data.get("description"):  # Custom might not have description
                context["Description"] = category_data["description"]

            hr = f"Removed the following {data_type.upper()} addresses to category {category_id}:\n{removed_data}"

            ec = {"Zscaler.Category(val.ID && val.ID === obj.ID)": context}
            entry = {
                "Type": entryTypes["note"],
                "Contents": category_data,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": hr,
                "EntryContext": ec,
            }
            return entry
        else:
            return return_error("Category could not be found.")


    def add_or_remove_urls_from_category(action, urls, category_data, retaining_parent_category_data=None):
        """
        Add or remove urls from a category.
        Args:
            str action: The action requested, can be 'ADD_TO_LIST' for adding or 'REMOVE_FROM'_LIST for removing.
            List[Any] urls: the list of urls to add or remove from the category
            Dict[str: Any] category_data: the data of the category as returned from the API

        Returns:
            The response as returned from the API

        """

        demisto.debug('##### add_or_remove_urls_from_category function is now running')
        cmd_url = "/urlCategories/" + category_data.get("id") + "?action=" + action
        data = {
            "customCategory": category_data.get("customCategory"),
            "urls": urls,
            "id": category_data.get("id"),
        }
        if retaining_parent_category_data:
            data['dbCategorizedUrls'] = retaining_parent_category_data
        if "description" in category_data:
            data["description"] = category_data["description"]
        if "configuredName" in category_data:
            data["configuredName"] = category_data["configuredName"]
        demisto.debug(f'{data=}')
        json_data = json.dumps(data)
        http_request(
            "PUT", cmd_url, json_data
        )  # if the request is successful, it returns an empty response


    def url_quota_command():
        cmd_url = "/urlCategories/urlQuota"
        response = http_request("GET", cmd_url)

        human_readable = {
            "Unique Provisioned URLs": response.get("uniqueUrlsProvisioned"),
            "Remaining URLs Quota": response.get("remainingUrlsQuota"),
        }
        entry = {
            "Type": entryTypes["note"],
            "Contents": response,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown("Quota Information", human_readable),
            "EntryContext": {"Zscaler.Quota": response},
        }
        return entry


    def get_categories_command(args):
        display_urls = argToBoolean(
            args.get("displayURL")
        )  # urls returned to context data even if set to false
        custom_only = argToBoolean(args.get("custom_categories_only", False))
        ids_and_names_only = argToBoolean(
            args.get("get_ids_and_names_only", False)
        )  # won't get URLs at all
        categories = []
        raw_categories = get_categories(custom_only, ids_and_names_only)
        for raw_category in raw_categories:
            category = {
                "ID": raw_category["id"],
                "CustomCategory": raw_category["customCategory"],
            }
            if raw_category.get("urls"):
                category["URL"] = raw_category["urls"]
            if "description" in raw_category:
                category["Description"] = raw_category["description"]
            if "configuredName" in raw_category:
                category["Name"] = raw_category["configuredName"]
            categories.append(category)
        ec = {"Zscaler.Category(val.ID && val.ID === obj.ID)": categories}
        if display_urls and not ids_and_names_only:
            headers = ["ID", "Description", "URL", "CustomCategory", "Name"]
        else:
            headers = ["ID", "Description", "CustomCategory", "Name"]
        title = "Zscaler Categories"
        entry = {
            "Type": entryTypes["note"],
            "Contents": raw_categories,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown(title, categories, headers),
            "EntryContext": ec,
        }
        return entry


    def get_categories(custom_only=False, ids_and_names_only=False):
        if ids_and_names_only:
            # if you only want a list of URL category IDs and names (i.e without urls list).
            # Note: API does not support the combination of custom_only and 'lite' endpoint
            cmd_url = "/urlCategories/lite"
        else:
            cmd_url = "/urlCategories?customOnly=true" if custom_only else "/urlCategories"

        response = http_request("GET", cmd_url)
        return response


    def sandbox_report_command():
        md5 = demisto.getArg("md5")
        details = demisto.getArg("details")
        res = sandbox_report(md5, details)

        report = "Full Details" if details == "full" else "Summary"
        ctype = demisto.get(res, f"{report}.Classification.Type")
        dbot_score = (
            3
            if ctype == "MALICIOUS"
            else 2
            if ctype == "SUSPICIOUS"
            else 1
            if ctype == "BENIGN"
            else 0
        )

        ec = {
            outputPaths["dbotscore"]: {
                "Indicator": md5,
                "Type": "file",
                "Vendor": "Zscaler",
                "Score": dbot_score,
                "Reliability": demisto.params().get("reliability"),
            }
        }

        human_readable_report = ec["DBotScore"].copy()
        human_readable_report["Detected Malware"] = str(
            demisto.get(res, f"{report}.Classification.DetectedMalware")
        )
        human_readable_report["Zscaler Score"] = demisto.get(
            res, f"{report}.Classification.Score"
        )
        human_readable_report["Category"] = demisto.get(
            res, f"{report}.Classification.Category"
        )
        ec[outputPaths["file"]] = {
            "MD5": md5,
            "Zscaler": {
                "DetectedMalware": demisto.get(
                    res, f"{report}.Classification.DetectedMalware"
                ),
                "FileType": demisto.get(res, f"{report}.File Properties.File Type"),
            },
        }
        if dbot_score == 3:
            ec[outputPaths["file"]]["Malicious"] = {
                "Vendor": "Zscaler",
                "Description": "Classified as Malicious, with threat score: "
                               + str(human_readable_report["Zscaler Score"]),
            }
        entry = {
            "Type": entryTypes["note"],
            "Contents": res,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown(
                "Full Sandbox Report", human_readable_report, removeNull=True
            ),
            "EntryContext": ec,
        }

        return entry


    def sandbox_report(md5, details):
        cmd_url = f"/sandbox/report/{md5}?details={details}"

        response = http_request("GET", cmd_url)
        return response


    def login_command():
        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if session_id:
            try:
                DEFAULT_HEADERS["cookie"] = session_id
                demisto.info(
                    "Zscaler logout active session triggered by zscaler-login command."
                )
                logout()
            except Exception as e:
                demisto.info(f"Zscaler logout failed with: {str(e)}")
        login()
        return CommandResults(readable_output="Zscaler session created successfully.")


    def logout_command():
        ctx = get_integration_context() or {}
        session_id = ctx.get(SESSION_ID_KEY)
        if not session_id:
            return CommandResults(
                readable_output="No API session was found. No action was performed."
            )
        try:
            DEFAULT_HEADERS["cookie"] = session_id
            raw_res = logout().json()
        except AuthorizationError:
            return CommandResults(
                readable_output="API session is not authenticated. No action was performed."
            )
        return CommandResults(
            readable_output="API session logged out of Zscaler successfully.",
            raw_response=raw_res,
        )


    def activate_command():
        raw_res = activate_changes().json()
        return CommandResults(
            readable_output="Changes have been activated successfully.",
            raw_response=raw_res,
        )


    def test_module():
        http_request("GET", "/status", None, DEFAULT_HEADERS)
        return "ok"


    def get_category_by_id(category_id):
        categories = get_categories()
        for category in categories:
            if category["id"] == category_id:
                return category
        return None


    def get_users_command(args):
        name = args.get("name", None)
        pageSize = args.get("pageSize")
        pageNo = args.get("page", 1)
        if name is not None:
            cmd_url = f"/users?page={pageNo}&pageSize={pageSize}&name={name}"
        else:
            cmd_url = f"/users?page={pageNo}&pageSize={pageSize}"
        response = http_request("GET", cmd_url)

        if len(response) < 10:
            human_readable = tableToMarkdown(f"Users ({len(response)})", response)
        else:
            human_readable = f"Retrieved {len(response)} users"

        entry = {
            "Type": entryTypes["note"],
            "Contents": response,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": human_readable,
            "EntryContext": {"Zscaler.Users": response},
        }
        return entry


    def get_departments_command(args):
        name = args.get("name", None)
        pageSize = args.get("pageSize")
        pageNo = args.get("page", 1)
        if name is not None:
            cmd_url = f"/departments?page={pageNo}&pageSize={pageSize}&search={name}&limitSearch=true"
        else:
            cmd_url = f"/departments?page={pageNo}&pageSize={pageSize}"
        response = http_request("GET", cmd_url)

        if len(response) < 10:
            human_readable = tableToMarkdown(
                f"Departments ({len(response)})", response
            )
        else:
            human_readable = f"Retrieved {len(response)} departments"

        entry = {
            "Type": entryTypes["note"],
            "Contents": response,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": human_readable,
            "EntryContext": {"Zscaler.Departments": response},
        }
        return entry


    def get_usergroups_command(args):
        name = args.get("name", None)
        pageSize = args.get("pageSize")
        pageNo = args.get("page", 1)
        if name is not None:
            cmd_url = f"/groups?page={pageNo}&pageSize={pageSize}&search={name}"
        else:
            cmd_url = f"/groups?page={pageNo}&pageSize={pageSize}"
        response = http_request("GET", cmd_url)

        if len(response) < 10:
            human_readable = tableToMarkdown(
                f"User groups ({len(response)})", response
            )
        else:
            human_readable = f"Retrieved {len(response)} user groups"

        entry = {
            "Type": entryTypes["note"],
            "Contents": response,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": human_readable,
            "EntryContext": {"Zscaler.UserGroups": response},
        }
        return entry


    def set_user_command(args):
        userId = args.get("id")
        params = json.loads(args.get("user"))
        cmd_url = f"/users/{userId}"

        response = http_request("PUT", cmd_url, json.dumps(params), DEFAULT_HEADERS, resp_type='response')
        responseJson = response.json()
        if response.status_code == 200:
            entry = {
                "Type": entryTypes["note"],
                "Contents": responseJson,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": "Successfully updated the user (id: {} name: {})".format(
                    responseJson["id"], responseJson["name"]
                ),
                "EntryContext": {"Zscaler.Users": responseJson},
            }
            return entry
        else:
            return responseJson


    def create_ip_destination_group(args: dict):
        headers = [
            "ID",
            "Name",
            "Type",
            "Description",
            "Addresses",
            "Countries",
            "IpCategories",
            "IsNonEditable",
        ]
        payload = {
            "name": args.get("name", ""),
            "type": args.get("type", ""),
            "countries": argToList(args.get("countries", "")),
            "ipCategories": argToList(args.get("ip_categories", "")),
            "description": args.get("description", ""),
            "addresses": argToList(args.get("addresses", "")),
            "isNonEditable": args.get("is_non_editable", False),
        }
        cmd_url = "/ipDestinationGroups"
        response = http_request("POST", cmd_url, data=json.dumps(payload), headers=DEFAULT_HEADERS)
        content = {
            "ID": int(response.get("id", "")),
            "Name": response.get("name", ""),
            "Type": response.get("type", ""),
            "Description": response.get("description", ""),
            "Addresses": response.get("addresses", []),
            "IpCategories": response.get("ipCategories", []),
            "Countries": response.get("countries", []),
            "IsNonEditable": response.get("isNonEditable", False),
        }
        markdown = tableToMarkdown(
            "IPv4 Destination group created", content, headers, removeNull=True
        )
        results = CommandResults(
            readable_output=markdown,
            outputs_prefix="Zscaler.IPDestinationGroup",
            outputs_key_field="ID",
            outputs=content,
        )
        return results


    def list_ip_destination_groups(args: dict):
        ip_group_ids = argToList(args.get("ip_group_id", ""))
        exclude_type = str(args.get("exclude_type", "")).strip()
        category_type = argToList(args.get("type", ""))
        include_ipv6 = argToBoolean(args.get("include_ipv6", False))
        limit = arg_to_number(args.get("limit", 50))
        all_results = argToBoolean(args.get("all_results", False))
        lite = argToBoolean(args.get("lite", False))
        headers = [
            "ID",
            "Name",
            "Type",
            "Description",
            "Addresses",
            "Countries",
            "IpCategories",
        ]

        def get_contents(responses: List[dict]):
            contents = []
            for response in responses:
                content = {
                    "ID": int(response.get("id", "")),
                    "Name": response.get("name", ""),
                    "Type": response.get("type", ""),
                    "Description": response.get("description", ""),
                    "Addresses": response.get("addresses", []),
                    "IpCategories": response.get("ipCategories", []),
                    "Countries": response.get("countries", []),
                }
                contents.append(content)
            return contents

        def get_contents_lite(responses: List[dict]):
            contents = []
            for response in responses:
                content = {}
                for key, value in response.items():
                    if key == "extensions":
                        for extensions_key, extensions_value in value.items():
                            content[f"{extensions_key.capitalize()}"] = extensions_value
                    elif key == "id":
                        content[key.upper()] = value
                    else:
                        content[key.capitalize()] = value
                contents.append(content)
            return contents

        if len(ip_group_ids) == 0:
            lite_endpoint = "/lite" if lite else ""
            if exclude_type:
                exclude_type_param = f"?excludeType={exclude_type}&"
            else:
                exclude_type_param = "?"
            type_params = [f"type={t}" for t in category_type]
            type_params_str = "&".join(type_params)
            if include_ipv6:
                ipv4_cmd_url = (
                    "/ipDestinationGroups"
                    + lite_endpoint
                    + exclude_type_param
                    + type_params_str
                )
                ipv6_cmd_url = (
                    "/ipDestinationGroups/ipv6DestinationGroups"
                    + lite_endpoint
                    + exclude_type_param
                    + type_params_str
                )
                ipv4_responses = http_request("GET", ipv4_cmd_url)
                ipv6_responses = http_request("GET", ipv6_cmd_url)
                ipv4_contents_filter = (
                    get_contents_lite(ipv4_responses)
                    if lite
                    else get_contents(ipv4_responses)
                )
                ipv4_contents = (
                    ipv4_contents_filter if all_results else ipv4_contents_filter[:limit]
                )
                ipv6_contents_filter = (
                    get_contents_lite(ipv6_responses)
                    if lite
                    else get_contents(ipv6_responses)
                )
                ipv6_contents = (
                    ipv6_contents_filter if all_results else ipv6_contents_filter[:limit]
                )
                markdown = tableToMarkdown(
                    f"IPv4 Destination groups ({len(ipv4_contents)})",
                    ipv4_contents,
                    headers,
                    removeNull=True,
                )
                markdown += tableToMarkdown(
                    f"IPv6 Destination groups ({len(ipv6_contents)})",
                    ipv6_contents,
                    headers,
                    removeNull=True,
                )
                contents = ipv4_contents + ipv6_contents

                results = CommandResults(
                    readable_output=markdown,
                    outputs_prefix="Zscaler.IPDestinationGroup",
                    outputs_key_field="ID",
                    outputs=contents,
                )
                return results
            else:
                cmd_url = (
                    "/ipDestinationGroups"
                    + lite_endpoint
                    + exclude_type_param
                    + type_params_str
                )
                responses = http_request("GET", cmd_url)
                contents_filter = (
                    get_contents_lite(responses) if lite else get_contents(responses)
                )
                contents = contents_filter if all_results else contents_filter[:limit]
                markdown = tableToMarkdown(
                    f"IPv4 Destination groups ({len(contents)})",
                    contents,
                    headers,
                    removeNull=True,
                )

                results = CommandResults(
                    readable_output=markdown,
                    outputs_prefix="Zscaler.IPDestinationGroup",
                    outputs_key_field="ID",
                    outputs=contents,
                )
                return results
        else:
            responses = []
            for ip_group_id in ip_group_ids:
                cmd_url = f"/ipDestinationGroups/{ip_group_id}"
                responses.append(http_request("GET", cmd_url))
            contents = get_contents(responses)
            markdown = tableToMarkdown(
                f"IPv4 Destination groups ({len(contents)})",
                contents,
                headers,
                removeNull=True,
            )

            results = CommandResults(
                readable_output=markdown,
                outputs_prefix="Zscaler.IPDestinationGroup",
                outputs_key_field="ID",
                outputs=contents,
            )
            return results


    def edit_ip_destination_group(args: dict):
        headers = [
            "ID",
            "Name",
            "Type",
            "Description",
            "Addresses",
            "Countries",
            "IpCategories",
        ]
        payload = {}
        ip_group_id = str(args.get("ip_group_id", "")).strip()
        check_url = f"/ipDestinationGroups/{ip_group_id}"
        response_data = {}
        response_data = http_request("GET", check_url)
        if response_data.get("id", 0) == 0:
            raise Exception(f"Resource not found with ip_group_id {ip_group_id}")

        payload["name"] = args.get("name", response_data["name"])
        payload["countries"] = argToList(args.get("countries", response_data["countries"]))
        payload["ipCategories"] = argToList(
            args.get("ip_categories", response_data["ipCategories"])
        )
        payload["addresses"] = argToList(args.get("addresses", response_data["addresses"]))
        payload["description"] = args.get("description", response_data["description"])
        payload["isNonEditable"] = args.get("is_non_editable", False)
        payload["type"] = response_data["type"]

        cmd_url = f"/ipDestinationGroups/{ip_group_id}"
        json_data = json.dumps(payload)
        response = http_request("PUT", cmd_url, json_data, DEFAULT_HEADERS)
        content = {
            "ID": int(response.get("id", "")),
            "Name": response.get("name", ""),
            "Type": response.get("type", ""),
            "Description": response.get("description", ""),
            "Addresses": response.get("addresses", []),
            "IpCategories": response.get("ipCategories", []),
            "Countries": response.get("countries", []),
        }
        markdown = tableToMarkdown(
            "IPv4 Destination group updated", content, headers, removeNull=True
        )
        results = CommandResults(
            readable_output=markdown,
            outputs_prefix="Zscaler.IPDestinationGroup",
            outputs_key_field="ID",
            outputs=content
        )
        return results


    def delete_ip_destination_groups(args: dict):
        ip_group_ids = argToList(args.get("ip_group_id", ""))
        for ip_group_id in ip_group_ids:
            cmd_url = f"/ipDestinationGroups/{ip_group_id}"
            _ = http_request("DELETE", cmd_url, None, DEFAULT_HEADERS)
        markdown = "### IP Destination Group {} deleted successfully".format(
            ",".join(ip_group_ids)
        )

        results = CommandResults(
            readable_output=markdown,
            outputs_prefix="Zscaler.IPDestinationGroup",
            outputs_key_field=None,
            outputs=None
        )
        return results


    """ EXECUTION CODE """


    def main():  # pragma: no cover
        command = demisto.command()

        demisto.debug(f"command is {command}")
        args = demisto.args()
        if command == "zscaler-login":
            return_results(login_command())
        elif command == "zscaler-logout":
            return_results(logout_command())
        else:
            login()
            try:
                if command == "test-module":
                    return_results(test_module())
                elif command == "url":
                    return_results(url_lookup(demisto.args()))
                elif command == "ip":
                    return_results(ip_lookup(args.get("ip")))
                elif command == "zscaler-blacklist-url":
                    return_results(blacklist_url(args.get("url")))
                elif command == "zscaler-undo-blacklist-url":
                    return_results(unblacklist_url(args.get("url")))
                elif command == "zscaler-whitelist-url":
                    return_results(whitelist_url(args.get("url")))
                elif command == "zscaler-undo-whitelist-url":
                    return_results(unwhitelist_url(args.get("url")))
                elif command == "zscaler-blacklist-ip":
                    return_results(blacklist_ip(args.get("ip")))
                elif command == "zscaler-undo-blacklist-ip":
                    return_results(unblacklist_ip(args.get("ip")))
                elif command == "zscaler-whitelist-ip":
                    return_results(whitelist_ip(args.get("ip")))
                elif command == "zscaler-undo-whitelist-ip":
                    return_results(unwhitelist_ip(args.get("ip")))
                elif command == "zscaler-category-add-url":
                    return_results(
                        category_add(args.get("category-id"), args.get("url"), args.get('retaining-parent-category-url'), "url")
                    )
                elif command == "zscaler-category-add-ip":
                    return_results(category_add(args.get("category-id"), args.get("ip"), args.get('retaining-parent-category-ip'),
                                   "ip"))
                elif command == "zscaler-category-remove-url":
                    return_results(
                        category_remove(args.get("category-id"), args.get("url"), args.get('retaining-parent-category-url'),
                                        "url"))
                elif command == "zscaler-category-remove-ip":
                    return_results(
                        category_remove(args.get("category-id"), args.get("ip"), args.get('retaining-parent-category-ip'),
                                        "ip")
                    )
                elif command == "zscaler-get-categories":
                    return_results(get_categories_command(args))
                elif command == "zscaler-get-blacklist":
                    return_results(get_blacklist_command(args))
                elif command == "zscaler-get-whitelist":
                    return_results(get_whitelist_command())
                elif command == "zscaler-sandbox-report":
                    return_results(sandbox_report_command())
                elif command == "zscaler-activate-changes":
                    return_results(activate_command())
                elif command == "zscaler-url-quota":
                    return_results(url_quota_command())
                elif command == "zscaler-get-users":
                    return_results(get_users_command(demisto.args()))
                elif command == "zscaler-update-user":
                    return_results(set_user_command(demisto.args()))
                elif command == "zscaler-get-departments":
                    return_results(get_departments_command(demisto.args()))
                elif command == "zscaler-get-usergroups":
                    return_results(get_usergroups_command(demisto.args()))
                elif command == "zscaler-list-ip-destination-groups":
                    return_results(list_ip_destination_groups(demisto.args()))
                elif command == "zscaler-create-ip-destination-group":
                    return_results(create_ip_destination_group(demisto.args()))
                elif command == "zscaler-edit-ip-destination-group":
                    return_results(edit_ip_destination_group(demisto.args()))
                elif command == "zscaler-delete-ip-destination-groups":
                    return_results(delete_ip_destination_groups(demisto.args()))
            except Exception as e:
                return_error(f"Failed to execute {command} command. Error: {str(e)}")
                raise
            finally:
                try:
                    # activate changes only when required
                    if (
                        demisto.params().get("auto_activate")
                        and command in AUTO_ACTIVATE_CHANGES_COMMANDS
                    ):
                        activate_changes()
                    if demisto.params().get("auto_logout"):
                        logout()
                except Exception as err:
                    demisto.info("Zscaler error: " + str(err))


    # python2 uses __builtin__ python3 uses builtins
    if __name__ in ("__builtin__", "builtins", "__main__"):  # pragma: no cover
        main()

    register_module_line('Zscaler', 'end', __line__())
  subtype: python3
  type: python
system: true
