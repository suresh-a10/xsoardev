category: Analytics & SIEM
commonfields:
  id: Azure Sentinel
  version: -1
configuration:
- additionalinfo: When selecting the Custom option, the Server URL parameter must
    be filled. More information about National clouds can be found here - https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#using-national-cloud
  advanced: true
  defaultvalue: Worldwide
  display: Azure Cloud
  name: azure_cloud
  options:
  - Worldwide
  - US GCC
  - US GCC-High
  - DoD
  - Germany
  - China
  - Custom
  required: false
  section: Connect
  type: 15
- defaultvalue: "20"
  display: Maximum number of incidents per fetch.
  name: limit
  required: false
  section: Collect
  type: 0
- display: ""
  displaypassword: Tenant ID
  hiddenusername: true
  name: creds_tenant_id
  required: false
  section: Connect
  type: 9
- display: Tenant ID
  hidden: true
  name: tenant_id
  required: false
  section: Connect
  type: 4
- display: Client ID
  name: credentials
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication. As appears in the "Certificates
    & secrets" page of the app.
  advanced: true
  display: Certificate Thumbprint
  displaypassword: Private Key
  name: creds_certificate
  required: false
  section: Connect
  type: 9
- additionalinfo: Used for certificate authentication. As appears in the "Certificates
    & secrets" page of the app.
  advanced: true
  display: Certificate Thumbprint
  hidden: true
  name: certificate_thumbprint
  required: false
  section: Connect
  type: 4
- additionalinfo: Used for certificate authentication. The private key of the registered
    certificate.
  advanced: true
  display: Private Key
  hidden: true
  name: private_key
  required: false
  section: Connect
  type: 14
- additionalinfo: Relevant only if the integration is running on Azure VM. If selected,
    authenticates based on the value provided for the Azure Managed Identities Client
    ID field. If no value is provided for the Azure Managed Identities Client ID field,
    authenticates based on the System Assigned Managed Identity. For additional information,
    see the Help tab.
  advanced: true
  display: Use Azure Managed Identities
  name: use_managed_identities
  required: false
  section: Connect
  type: 8
- additionalinfo: The Managed Identities client id for authentication - relevant only
    if the integration is running on Azure VM.
  advanced: true
  display: ""
  displaypassword: Azure Managed Identities Client ID
  hiddenusername: true
  name: managed_identities_client_id
  required: false
  section: Connect
  type: 9
- additionalinfo: The parameter can be saved as 000-000 and added as an argument to
    each command, but Test button will fail.
  display: Default Subscription ID
  name: subscriptionID
  required: true
  section: Connect
  type: 0
- additionalinfo: The parameter can be saved as 000-000 and added as an argument to
    each command, but the Test button will fail.
  display: Default Resource Group Name
  name: resourceGroupName
  required: true
  section: Connect
  type: 0
- display: Workspace Name
  name: workspaceName
  required: true
  section: Connect
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  section: Collect
  type: 0
- advanced: true
  defaultvalue: Informational
  display: The minimum severity of incidents to fetch
  name: min_severity
  options:
  - Informational
  - Low
  - Medium
  - High
  required: false
  section: Collect
  type: 15
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- additionalinfo: Use this option when required to customize the URL to the Azure
    management endpoint. More information can be found here - https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication#using-national-cloud
  advanced: true
  defaultvalue: https://management.azure.com
  display: Server URL
  name: server_url
  required: false
  section: Connect
  type: 0
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- additionalinfo: |
    Choose what additional info to fetch for each incident.
    Note that this will increase the number of API calls.
  advanced: true
  display: Additional info to fetch
  name: fetch_additional_info
  options:
  - Alerts
  - Entities
  - Comments
  - Relations
  required: false
  section: Collect
  type: 16
- defaultvalue: None
  display: Mirroring Direction
  name: mirror_direction
  options:
  - None
  - Incoming
  - Outgoing
  - Incoming And Outgoing
  required: false
  section: Collect
  type: 15
- additionalinfo: When selected, closing the Microsoft Sentinel ticket is mirrored
    in Cortex XSOAR.
  advanced: true
  defaultvalue: "false"
  display: Close Mirrored XSOAR Incident
  name: close_incident
  required: false
  section: Collect
  type: 8
- additionalinfo: When selected, closing the Cortex XSOAR incident is mirrored in
    Microsoft Sentinel.
  advanced: true
  defaultvalue: "false"
  display: Close Mirrored Microsoft Sentinel Ticket
  name: close_ticket
  required: false
  section: Collect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.5.46
    packID: AzureSentinel
    packName: Microsoft Sentinel
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: Microsoft Sentinel - Classifier
defaultmapperin: Microsoft Sentinel - Incoming Mapper
defaultmapperout: Microsoft Sentinel - Outgoing Mapper
description: 'Microsoft Sentinel is a scalable, cloud-native solution that provides:
  Security information and event management (SIEM) Security orchestration, automation,
  and response (SOAR).'
detaileddescription: "Full documentation for this integration is available at our
  [reference docs](https://xsoar.pan.dev/docs/reference/integrations/azure-sentinel).\n\n\n##
  Authorize Cortex XSOAR for Azure Sentinel\n\n#### Self-Deployed Authentication\nFollow
  these steps for a self-deployed configuration:\n\n1. To use a self-configured Azure
  application, add a new Azure App Registration in the Azure Portal. To add the registration,
  see the [Microsoft article](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n2.
  In your registered app - create a new Client secret.\n   1. Navigate in the Azure
  Portal to **App registrations** > your registered application > **Certificates &
  secrets** and click **+ New client secret**.\n   2. Copy and save the new secret
  value to use in the add credentials step.\n3. Assign a role to the registered app.\n
  \  1. In Azure portal, go to the Subscriptions and select the subscription you are
  using -> Access control (IAM).\n   2. Click Add -> Add role assignment.\n   3. Select
  the Microsoft Sentinel Contributor role -> Select your registered app, and click
  Save.\n4. In Cortex XSOAR, go to  **Settings** > **Integrations** > **Credentials**
  and create a new credentials set. \n5. In the *Username* parameter, enter your registered
  app Application (client) ID.\n6. In the *Password* parameter, enter the secret value
  you created.\n7. Copy your tenant ID for the integration configuration usage.\n\n####
  Azure Managed Identities Authentication\n##### Note: This option is relevant only
  if the integration is running on Azure VM.\nFollow one of these steps for authentication
  based on Azure Managed Identities:\n\n- ##### To use System Assigned Managed Identity\n
  \  - Select the **Use Azure Managed Identities** checkbox and leave the **Azure
  Managed Identities Client ID** field empty.\n\n- ##### To use User Assigned Managed
  Identity\n   1. Go to [Azure Portal](https://portal.azure.com/) -> **Managed Identities**.\n
  \  2. Select your User Assigned Managed Identity -> copy the Client ID -> paste
  it in the **Azure Managed Identities Client ID** field in the instance settings.\n
  \  3. Select the **Use Azure Managed Identities** checkbox.\n\nFor information,
  see [Managed identities for Azure resources](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview).\n##
  Configure the Server URL\nIf you have a dedicated server URL, enter it in the *Server
  Url* parameter. \n\n## Get the Additional Instance Parameters\n\nTo get the *Subscription
  ID*, *Workspace Name*, and *Resource Group* parameters, in the Azure Portal navigate
  to **Azure Sentinel** > your workspace > **Settings** and click the **Workspace
  Settings** tab.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-sentinel)"
display: Microsoft Sentinel
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAspQTFRFAAAAAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInXAIjWAIrWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWAInWlY44CQAAAO50Uk5TAAwnAiyWKAAmvqUDBwRY1+NDMIALCOX+qhNz3D0SkfL/90AdwbcJG5LFSOhLAcj97luaxCREHxDb9XZg7fxcVAZ95hWbigqNM9nnUIfd0U1M1C9qtg8OeQXAX1X56Rz68SINnt5dLs/7k3uLOOu0FvhCGbolxyHiPy0aKmFiRnKEOjTwlep6v5RxNfTzMTxSwrw+OYHYycrLzM27R86Zol6wdStWAwMDaOR8kKlZr8Of0ndvrtBs9t8Uxn7VazJaTlOOjOzgf3Qe1juzpKOrgjYXV2PTGKggrCNpN4agbeGmsbmhnGV4RZ2IZ4mD701pBogAAAVxSURBVHic7Zf7WxRVGMfPOuGSw8pVjpbou6F4axjiIi7ucllog0REEFlzcRENF+OyYkKIYYp4RRQRBDMw7aJ5SUUltTTzUpaU3dSgu920+h+amTOzM7ssz1M9tP4Q31/OzDvvvp95z3nnPWcRGtSgBvUfSzWEui/cB7yG3g+s2vvBYTTl43GuZrivnz8KCAzyMHfE8GA8chT90MOjPYpVh4wZC9pH1KHj8PgwT4InTNQCTApDk6eA9lHGY1g6IJwFiHgMMZHcGBXtMXDMJAwA46ai2GncqIvzEFY1Xc/hwBBPMQn8C8CUIWpPcBOTjDwNpiWjoBThCh439eesMZkGqrfFPsEKMC03walpBPzkjH6c1ekzM2YNEDiT5AuzsxDK1pFrdk4//SsnDdjIgVmHueGEBblmZJ4nXgP7FO3OmZmP9Za8BQPBpeKtBKX3RmhovgSGcQvdeRcswiMX46cH4jsvXEJAtiI10ix1cMHyjLsaKl5cMsuLLS37FyBG4xRQnW4nIL9lCJUvl8FgfNbNr+PsKyoSIiqfI3cTqhxaidTRVWVk8UdER/MVUlA91ER7r3p+JW8z1ax+IW6N3IvVa2tFzjpuT8qsU4BhUWwfrmkJrNcs2MAWEcJGq6T8TYgOt+aSnDZvqd/KDTXBMxty8wASuMa4bTuLWWxvrJKyzokUKfYdXKz5eiXYmNkH3GTXbkbmndCcQ/Jv2dXa2rY7wwYvRiO6DZaSsMWsIZUb9tRVxun9Gl+agahlldi3fWdHLZ4jNeO9Igq/zBexaZ9FSQ6f68INK4INGoT21+NXhPJiqFdfo18PO2A7WMVl1QpvuIDrKw8tQD4mtDXDcjiZs0z2taWQSKooTBgRR8gEHDUowNZ4l/ry3m3J5YbEN+FYgWIajtefoJzAWATjtHLBEGhpzeJHn0AoEQzmTpELR5NJkKknlSmfKnQGZ+ua+cVDp7veWuMwnjnLjuFnngMnEXCTBLaeE+5Nb8M75Ml5KwhjdavULi6IuTGFixVge7pTj6JL8TBhcc83C5mT6V9vSKvg3ehdfcD6d4X76C046aKgA1oBTEdKE7tL3hNqmhXk2rXKVlGogw3vXeLkNROOq4hNveryFVKEdAtcdQEfJIeoBqwIyRsCpCLuel+O7jPdrnCLzFEkvI8rQlFg2UGMH1zDV8nhkOLApM2ukcB+Hwr3o4H96Pr1693d3R0dHdx92cdS+Chle2TO5ctg/V75QcVZdsVGonVGaBdw5YcNpeJsUWfhE1rM0BlcaDHcUC7Z8BIp/Amz0v5pigzGUSqHfUZJxGc+otrZjGreFje2WUwdqedBEdnSLoIEJiVYlgefK5bszBdS9CtfIifFjrfJ5E7ppaibeHuo5BJj1K7mTP75um2OT24RjrrFj6NuEnBNXSUBM7fxvK+IjyYRaXqkyjIcct1setvknNv2i8ZyI3ydKHmsbIRGDVq43PbNCMevsrtqO7lI1LclDnATeXJEr/MSikU1fQfq9ZVCXzvvwkXq1O8cYEMKWTiqB7pkR6oHa3vDvjfYW0oF/TAfoVs/gvZO56abJYdtLuCgJC2cutTT2X48Px79ZGdFTez7l4X6Wd4u9AFkZY7CbsVB37sWAvd0ya/3C1f1Db4stlh06XsMAvjXPAmMYtODgbVbsK67GqX2Et24McqJSatCCzNP/2aUJ/u2sPsGFcdUK9yY4pis0BiH/IXVLUu4OzGuiSnw9+c7asjoBsfHSE299/uYu6uq+jkn0iFbLwbeiWq+rPyU4fIR997upEns7wjKmBM1fc5qjDmkonjb0mMtwVZwo9nJf5/8T2SqvvDHyZYrf9rcQYUFvOf24DeoQQ3q/6q/ADbMp/aIHsXEAAAAAElFTkSuQmCC
name: Azure Sentinel
script:
  commands:
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a single incident from Azure Sentinel.
    name: azure-sentinel-get-incident-by-id
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeObjectID
      description: The object ID of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.AssigneeUPN
      description: The user principal name of incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.IncidentUrl
      description: The deep-link URL to the incident in the Azure portal.
      type: String
  - arguments:
    - defaultValue: "50"
      description: The maximum number of incidents to return. The maximum value is
        200.
      name: limit
    - description: 'Filter results using OData syntax. For example: properties/createdTimeUtc
        gt 2020-02-02T14:00:00Z`). For more information, see the Azure documentation:
        https://docs.microsoft.com/bs-latn-ba/azure/search/search-query-odata-filter.'
      name: filter
    - description: A link that specifies a starting point to use for subsequent calls.
        This argument overrides all of the other command arguments.
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of incidents from Azure Sentinel.
    name: azure-sentinel-list-incidents
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns partial results. If a response contains
        a NextLink element, its value specifies a starting point to use for subsequent
        calls.
      type: String
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
  - arguments:
    - description: Alias of the specific watchlist to get.
      name: watchlist_alias
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of watchlists from Azure Sentinel.
    name: azure-sentinel-list-watchlists
    outputs:
    - contextPath: AzureSentinel.Watchlist.ID
      description: The watchlist ID.
      type: String
    - contextPath: AzureSentinel.Watchlist.Description
      description: A description of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.DisplayName
      description: The display name of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Provider
      description: The provider of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Source
      description: The source of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Created
      description: The time the watchlist was created.
      type: Date
    - contextPath: AzureSentinel.Watchlist.Updated
      description: The last time the watchlist was updated.
      type: Date
    - contextPath: AzureSentinel.Watchlist.CreatedBy
      description: The name of the user who created the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.UpdatedBy
      description: The name of the user who updated the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Alias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Label
      description: Label that will be used to tag and filter on.
      type: unknown
    - contextPath: AzureSentinel.Watchlist.ItemsSearchKey
      description: The search key is used to optimize query performance when using
        watchlists for joins with other data. For example, enable a column with IP
        addresses to be the designated SearchKey field, then use this field as the
        key field when joining to other event data by IP address.
      type: String
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns partial results. If a response contains
        a NextLink element, its value specifies a starting point to use for subsequent
        calls.
      type: String
  - arguments:
    - description: Alias of the watchlist to be deleted.
      name: watchlist_alias
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Delete a watchlist from Azure Sentinel.
    name: azure-sentinel-delete-watchlist
  - arguments:
    - description: The alias of the new watchlist or the watchlist to update.
      name: watchlist_alias
      required: true
    - description: The display name of the watchlist.
      name: watchlist_display_name
      required: true
    - description: The description of the watchlist.
      name: description
    - defaultValue: XSOAR
      description: The provider of the watchlist.
      name: provider
    - description: The labels of the watchlist.
      isArray: true
      name: labels
    - defaultValue: "0"
      description: The number of lines in the CSV content to skip before the header.
      name: lines_to_skip
    - description: A file entry with raw content that represents the watchlist items
        to create.
      name: file_entry_id
      required: true
    - description: The search key is used to optimize query performance when using
        watchlists for joins with other data. For example, enable a column with IP
        addresses to be the designated SearchKey field, then use this field as the
        key field when joining to other event data by IP address.
      name: items_search_key
      required: true
    - defaultValue: Text/Csv
      description: The content type of the raw content. For now, only text/csv is
        valid.
      name: content_type
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Create or update a watchlist in Azure Sentinel.
    name: azure-sentinel-watchlist-create-update
    outputs:
    - contextPath: AzureSentinel.Watchlist.Name
      description: The name of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.ID
      description: The ID (GUID) of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Description
      description: A description of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Provider
      description: The provider of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Source
      description: The source of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Created
      description: The time the watchlist was created.
      type: Date
    - contextPath: AzureSentinel.Watchlist.Updated
      description: The time the watchlist was updated.
      type: Date
    - contextPath: AzureSentinel.Watchlist.CreatedBy
      description: The user who created the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.UpdatedBy
      description: The user who updated the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Alias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.Watchlist.Label
      description: List of labels relevant to this watchlist.
      type: Unknown
    - contextPath: AzureSentinel.Watchlist.ItemsSearchKey
      description: The search key is used to optimize query performance when using
        watchlists for joins with other data.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The incident's title.
      name: title
    - description: Description of the incident.
      name: description
    - auto: PREDEFINED
      description: The incident severity.
      name: severity
      predefined:
      - High
      - Medium
      - Low
      - Informational
    - auto: PREDEFINED
      description: The incident status.
      name: status
      predefined:
      - New
      - Active
      - Closed
    - auto: PREDEFINED
      description: The reason the incident was closed. Required when updating the
        status to Closed.
      name: classification
      predefined:
      - BenignPositive
      - FalsePositive
      - TruePositive
      - Undetermined
    - description: Describes the reason the incident was closed.
      name: classification_comment
    - auto: PREDEFINED
      description: The classification reason the incident was closed with. Required
        when updating the status to Closed and the classification is determined.
      name: classification_reason
      predefined:
      - InaccurateData
      - IncorrectAlertLogic
      - SuspiciousActivity
      - SuspiciousButExpected
    - description: The email address of the incident assignee. It is recommended to
        update *user_principal_name* instead of this field. Note that the updated
        API field is `owner.email`.
      name: assignee_email
    - description: The user principal name of the client. Note that the updated API
        field is `owner.userPrincipalName`.
      name: user_principal_name
    - description: Object ID of assignee. This is the unique object ID of a user to
        update the assignee of the incident. Updated key is owner.objectId.
      name: assignee_objectid
    - description: Incident labels. Note that all labels will be set as labelType='User'.
      isArray: true
      name: labels
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    - auto: PREDEFINED
      description: If set to true, the assignee will be removed and the incident will
        remain unassigned. Overrides the other arguments related to the assignee.
      name: unassign
      predefined:
      - "false"
      - "true"
      type: unknown
    description: Updates a single incident in Azure Sentinel.
    name: azure-sentinel-update-incident
    outputs:
    - contextPath: AzureSentinel.Incident.ID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.Incident.Title
      description: The incident's title.
      type: String
    - contextPath: AzureSentinel.Incident.Description
      description: Description of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Severity
      description: The incident severity.
      type: String
    - contextPath: AzureSentinel.Incident.Status
      description: The incident status.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeName
      description: The name of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeEmail
      description: The email address of the incident assignee.
      type: String
    - contextPath: AzureSentinel.Incident.AssigneeObjectID
      description: The object ID of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.AssigneeUPN
      description: The user principal name of the incident assignee.
      type: string
    - contextPath: AzureSentinel.Incident.Label.Name
      description: The name of the incident label.
      type: String
    - contextPath: AzureSentinel.Incident.Label.Type
      description: The incident label type.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeUTC
      description: The date and time of the incident's first activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeUTC
      description: The date and time of the incident's last activity.
      type: Date
    - contextPath: AzureSentinel.Incident.LastModifiedTimeUTC
      description: The date and time the incident was last modified.
      type: Date
    - contextPath: AzureSentinel.Incident.CreatedTimeUTC
      description: The date and time the incident was created.
      type: Date
    - contextPath: AzureSentinel.Incident.IncidentNumber
      description: The incident number.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertsCount
      description: The number of the alerts in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.BookmarkCount
      description: The number of bookmarks in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.CommentCount
      description: The number of comments in the incident.
      type: Number
    - contextPath: AzureSentinel.Incident.AlertProductNames
      description: The alert product names of the incident.
      type: String
    - contextPath: AzureSentinel.Incident.Tactics
      description: The incident's tactics.
      type: String
    - contextPath: AzureSentinel.Incident.FirstActivityTimeGenerated
      description: The incident's generated first activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.LastActivityTimeGenerated
      description: The incident's generated last activity time.
      type: Date
    - contextPath: AzureSentinel.Incident.Etag
      description: The Etag of the incident.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes a single incident in Azure Sentinel.
    name: azure-sentinel-delete-incident
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - defaultValue: "50"
      description: The maximum number of incident comments to return. The maximum
        value is 50.
      name: limit
    - description: A link that specifies a starting point to use for subsequent calls.
        Using this argument overrides all of the other command arguments.
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets the comments of an incident from Azure Sentinel.
    name: azure-sentinel-list-incident-comments
    outputs:
    - contextPath: AzureSentinel.IncidentComment.ID
      description: The ID of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.IncidentID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.IncidentComment.Message
      description: The incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorName
      description: The name of the author of the incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorEmail
      description: The email address of the author of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.CreatedTimeUTC
      description: The date and time that the incident comment was created.
      type: Date
    - contextPath: AzureSentinel.NextLink.Description
      description: Description of NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns a partial result. If a response contains
        a NextLink element, its value specifies a starting point to use for subsequent
        calls.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The comment message.
      name: message
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Adds a comment to an incident in Azure Sentinel.
    name: azure-sentinel-incident-add-comment
    outputs:
    - contextPath: AzureSentinel.IncidentComment.ID
      description: The ID of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.IncidentID
      description: The incident ID.
      type: String
    - contextPath: AzureSentinel.IncidentComment.Message
      description: The incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorName
      description: The name of the author of the incident's comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.AuthorEmail
      description: The email address of the author of the incident comment.
      type: String
    - contextPath: AzureSentinel.IncidentComment.CreatedTimeUTC
      description: The date and time that the incident comment was created.
      type: Date
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The comment ID.
      name: comment_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes a comment from incident in Azure Sentinel.
    name: azure-sentinel-incident-delete-comment
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - defaultValue: "50"
      description: The maximum number of related entities to return.
      name: limit
    - description: A link that specifies a starting point to use for subsequent calls.
        Using this argument overrides all of the other command arguments.
      name: next_link
    - description: |-
        A comma-separated list of entity kinds to filter by. By default, the results won't be filtered by kind.
        The optional kinds are: Account, Host, File, AzureResource, CloudApplication, DnsResolution, FileHash, Ip, Malware, Process, RegistryKey, RegistryValue, SecurityGroup, Url, IoTDevice, SecurityAlert, Bookmark.
      isArray: true
      name: entity_kinds
      predefined:
      - ""
    - description: 'Filter results using OData syntax. For example: properties/createdTimeUtc
        gt 2020-02-02T14:00:00Z`). For more information see the Azure documentation:
        https://docs.microsoft.com/bs-latn-ba/azure/search/search-query-odata-filter.'
      name: filter
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's related entities from Azure Sentinel.
    name: azure-sentinel-list-incident-relations
    outputs:
    - contextPath: AzureSentinel.IncidentRelatedResource.ID
      description: The ID of the incident's related resource.
      type: String
    - contextPath: AzureSentinel.IncidentRelatedResource.Kind
      description: The kind of the incident's related resource.
      type: String
    - contextPath: AzureSentinel.NextLink.Description
      description: The description about NextLink.
      type: String
    - contextPath: AzureSentinel.NextLink.URL
      description: Used if an operation returns a partial result. If a response contains
        a NextLink element, its value specifies a starting point to use for subsequent
        calls.
      type: String
    - contextPath: AzureSentinel.IncidentRelatedResource.IncidentID
      description: The incident ID.
      type: String
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's entities from Azure Sentinel.
    name: azure-sentinel-list-incident-entities
    outputs:
    - contextPath: AzureSentinel.IncidentEntity.ID
      description: The ID of the entity.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.IncidentId
      description: The ID of the incident.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.Kind
      description: The kind of the entity.
      type: String
    - contextPath: AzureSentinel.IncidentEntity.Properties
      description: The properties of the entity.
      type: Unknown
  - arguments:
    - description: The incident ID.
      name: incident_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of an incident's alerts from Azure Sentinel.
    name: azure-sentinel-list-incident-alerts
    outputs:
    - contextPath: AzureSentinel.IncidentAlert.ID
      description: The ID of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.IncidentId
      description: The ID of the incident.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Kind
      description: The kind of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Tactic
      description: The tactics of the alert.
      type: Unknown
    - contextPath: AzureSentinel.IncidentAlert.Techniques
      description: The techniques of the alert.
      type: Unknown
    - contextPath: AzureSentinel.IncidentAlert.DisplayName
      description: The display name of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Description
      description: The description of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ConfidenceLevel
      description: The confidence level of this alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.Severity
      description: The severity of the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.VendorName
      description: The name of the vendor that raised the alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ProductName
      description: The name of the product that published this alert.
      type: String
    - contextPath: AzureSentinel.IncidentAlert.ProductComponentName
      description: The name of a component inside the product which generated the
        alert.
      type: String
  - arguments:
    - description: The alias of the watchlist.
      name: watchlist_alias
      required: true
    - description: The ID of the single watchlist item.
      name: watchlist_item_id
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Get a single watchlist item or list of watchlist items.
    name: azure-sentinel-list-watchlist-items
    outputs:
    - contextPath: AzureSentinel.WatchlistItem.WatchlistAlias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ID
      description: The ID (GUID) of the watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.Created
      description: The time the watchlist item was created.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.Updated
      description: The last time the watchlist item was updated.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.CreatedBy
      description: The name of the user.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.UpdatedBy
      description: The user who updated this item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ItemsKeyValue
      description: Key-value pairs for a watchlist item.
      type: Unknown
  - arguments:
    - description: The watchlist alias.
      name: watchlist_alias
      required: true
    - description: The watchlist item ID to be deleted.
      name: watchlist_item_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Delete a watchlist item.
    name: azure-sentinel-delete-watchlist-item
  - arguments:
    - description: The watchlist alias.
      name: watchlist_alias
      required: true
    - description: The watchlist item ID (GUID) to update.
      name: watchlist_item_id
    - description: The JSON for the itemsKeyValue of the item (the key value is different
        from watchlist to watchlist).
      name: item_key_value
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Create or update a watchlist item.
    name: azure-sentinel-create-update-watchlist-item
    outputs:
    - contextPath: AzureSentinel.WatchlistItem.WatchlistAlias
      description: The alias of the watchlist.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ID
      description: The ID (GUID) of the watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.Created
      description: The time the watchlist item was created.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.Updated
      description: The last time the watchlist item was updated.
      type: Date
    - contextPath: AzureSentinel.WatchlistItem.CreatedBy
      description: The name of the user who created this watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.UpdatedBy
      description: The user who updated this watchlist item.
      type: String
    - contextPath: AzureSentinel.WatchlistItem.ItemsKeyValue
      description: Key-value pairs for a watchlist item.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
    - defaultValue: "50"
      description: The maximum number of indicators to return.
      name: limit
    - description: |-
        A link that specifies a starting point to use for subsequent calls.
        This argument overrides all of the other command arguments.
        There may be no support for pagination.
      name: next_link
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Returns a list of threat indicators.
    name: azure-sentinel-threat-indicator-list
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - defaultValue: "50"
      description: The maximum number of indicators to return.
      name: limit
    - description: |-
        A link that specifies a starting point to use for subsequent calls.
        This argument overrides all of the other command arguments.
        There may be no support for pagination.
      name: next_link
    - description: The minimum confidence number for a threat indicator.
      name: min_confidence
    - description: The maximum confidence number for a threat indicator.
      name: max_confidence
    - description: Minimum valid until value of indicators to query.
      name: min_valid_until
    - description: Maximum valid until value of indicators to query.
      name: max_valid_until
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, the query also returns disabled indicators.
      name: include_disabled
      predefined:
      - "true"
      - "false"
    - description: The sources of the threat indicator.
      isArray: true
      name: sources
    - auto: PREDEFINED
      description: The indicator types of the threat indicator.
      isArray: true
      name: indicator_types
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
    - description: A comma-separated list of keywords.
      isArray: true
      name: keywords
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Returns a list of threat indicators with specific entities.
    name: azure-sentinel-threat-indicator-query
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The value of the threat indicator.
      name: value
      required: true
    - description: The display name of the new indicator.
      name: display_name
      required: true
    - description: The description of the new indicator.
      name: description
    - auto: PREDEFINED
      description: The type of the new indicator.
      name: indicator_type
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
      required: true
    - auto: PREDEFINED
      description: The hash type of the new indicator. This argument is mandatory
        if the indicator type is file.
      name: hash_type
      predefined:
      - MD5
      - SHA-1
      - SHA-256
      - SHA-512
    - description: The confidence of the new threat indicator. Should be a number
        between 0-100.
      name: confidence
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
      required: true
    - description: The kill chains phases of the indicator.
      isArray: true
      name: kill_chains
    - description: A comma-separated list of tags of the new threat indicator.
      isArray: true
      name: tags
    - description: The date from which the indicator is valid.
      name: valid_from
    - description: The date until which the indicator is valid.
      name: valid_until
    - description: The creator of the new indicator.
      name: created_by
    - auto: PREDEFINED
      defaultValue: "false"
      description: If true, the indicator is revoked.
      name: revoked
      predefined:
      - "true"
      - "false"
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Creates a new threat indicator.
    name: azure-sentinel-threat-indicator-create
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: The value of the indicator.
      name: value
      required: true
    - description: The display name of the indicator.
      name: display_name
      required: true
    - description: The description of the threat indicator.
      name: description
    - auto: PREDEFINED
      description: The type of the indicator.
      name: indicator_type
      predefined:
      - ipv4
      - ipv6
      - file
      - url
      - domain
      required: true
    - description: If indicator_type is a file, this entry is mandatory.
      name: hash_type
    - description: Whether the indicator is revoked.
      name: revoked
    - description: The confidence of the threat indicator. This is a number between
        0-100.
      name: confidence
    - auto: PREDEFINED
      description: A comma-separated list of threat types of the threat indicator.
      isArray: true
      name: threat_types
      predefined:
      - anomalous-activity
      - attribution
      - anonymization
      - benign
      - malicious-activity
      - compromised
      - unknown
    - description: A comma-separated list of  kill chains phases of the indicator.
      isArray: true
      name: kill_chains
    - description: A comma-separated list of tags of the threat indicator.
      isArray: true
      name: tags
    - description: The date from which the indicator is valid.
      name: valid_from
    - description: The date until which the indicator is valid.
      name: valid_until
    - description: The creator of the indicator.
      name: created_by
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Updates an existing threat indicator.
    name: azure-sentinel-threat-indicator-update
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Was the threat indicator revoked or not.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: A comma-separated list of indicators to delete.
      isArray: true
      name: indicator_names
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes an existing threat indicator.
    name: azure-sentinel-threat-indicator-delete
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: A comma-separated list of tags to append.
      isArray: true
      name: tags
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Appends new tags to an existing indicator.
    name: azure-sentinel-threat-indicator-tags-append
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Was the threat indicator revoked or not.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: The name of the indicator.
      name: indicator_name
      required: true
    - description: A comma-separated list of tags to replace.
      isArray: true
      name: tags
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Replaces the tags of a given indicator.
    name: azure-sentinel-threat-indicator-tags-replace
    outputs:
    - contextPath: AzureSentinel.ThreatIndicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Name
      description: The name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETag
      description: The ETag of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Kind
      description: The kind of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicators.Confidence
      description: The confidence of the threat indicator. This is a number between
        0-100.
      type: Number
    - contextPath: AzureSentinel.ThreatIndicator.Created
      description: When the threat indicator was created.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.CreatedByRef
      description: The creator of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ExternalID
      description: The external ID of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Revoked
      description: Whether the threat indicator was revoked.
      type: Boolean
    - contextPath: AzureSentinel.ThreatIndicator.Source
      description: The source of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ETags
      description: The Etags of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.DisplayName
      description: The display name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.Description
      description: The description of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ThreatTypes
      description: The threat types of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.KillChainName
      description: The kill chain's name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeKey
      description: The pattern type key of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Pattern
      description: The pattern of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.PatternType
      description: The pattern type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ValidFrom
      description: The date from which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.ValidUntil
      description: The date until which the indicator is valid.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.KillChainPhases.PhaseName
      description: The phase name of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.Value
      description: The value of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.ParsedPattern.PatternTypeValues.ValueType
      description: The value type of the indicator.
      type: String
    - contextPath: AzureSentinel.ThreatIndicator.LastUpdatedTimeUtc
      description: The last updated time of the indicator.
      type: Date
    - contextPath: AzureSentinel.ThreatIndicator.Tags
      description: The tags of the indicator.
      type: Unknown
    - contextPath: AzureSentinel.ThreatIndicator.Types
      description: The threat types of the indicator.
      type: Unknown
  - arguments:
    - description: Date string representing the local time. The incident is only returned
        if it was modified after the last update time.
      name: lastUpdate
      required: true
    description: Gets the list of incidents and detections that were modified since
      the last update time. This method is used for debugging purposes.
    name: get-modified-remote-data
  - arguments:
    - description: The remote incident ID.
      name: id
      required: true
    - defaultValue: "0"
      description: The UTC timestamp in seconds of the last update. The incident is
        only updated if it was modified after the last update time.
      name: lastUpdate
    description: Gets data from a remote incident. This method does not update the
      current incident, and should be used for debugging purposes only.
    name: get-remote-data
  - arguments: []
    description: Returns the list of fields to map in outgoing mirroring. This command
      is only used for debugging purposes.
    name: get-mapping-fields
  - arguments: []
    description: Updates the remote incident with local incident changes. This method
      is only used for debugging purposes and will not update the current incident.
    name: update-remote-system
  - arguments:
    - description: The rule ID. If not given, will return all rules.
      name: rule_id
    - defaultValue: "50"
      description: The maximum number of rules to return.
      name: limit
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of all alert rules.
    name: azure-sentinel-list-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to create this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule
        to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks
        at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the
        last time this alert rule was triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled
        or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time this alert rule was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings.aggregationKind
      description: The event grouping aggregation kinds.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.entityType
      description: The V3 type of the mapped entity.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.fieldMappings.identifier
      description: The V3 identifier of the entity.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings.fieldMappings.columnName
      description: The column name to be mapped to the identifier.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertDisplayNameFormat
      description: The format containing the columns' name(s) used to override the
        alert name.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertDescriptionFormat
      description: The format containing columns' name(s) used to override the alert
        description.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertTacticsColumnName
      description: The column name to take the alert tactics from.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride.alertSeverityColumnName
      description: The column name to take the alert severity from.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.createIncident
      description: Create incidents from alerts triggered by this analytics rule.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.enabled
      description: Whether grouping is enabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.reopenClosedIncident
      description: Re-open closed matching incidents.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.lookbackDuration
      description: Limit the group to alerts created within the lookback duration
        (in ISO 8601 duration format).
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.matchingMethod
      description: Grouping matching method. When method is Selected at least one
        of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided
        and not empty.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByEntities
      description: A list of entity types to group by (when matchingMethod is Selected).
        Only entities defined in the current alert rule may be used.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByAlertDetails
      description: A list of alert details to group by (when matchingMethod is Selected).
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration.groupingConfiguration.groupByCustomDetails
      description: A list of custom details keys to group by (when matchingMethod
        is Selected). Only keys defined in the current alert rule may be used.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
  - arguments:
    - description: The alert rule template ID. If not given, will return all alert
        rule templates.
      name: template_id
    - defaultValue: "50"
      description: The maximum number of templates to return.
      name: limit
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Gets a list of all alert rule templates.
    name: azure-sentinel-list-alert-rule-template
    outputs:
    - contextPath: AzureSentinel.AlertRuleTemplate.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.type
      description: The type of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule
        to run.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks
        at.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.triggerOperator
      description: The operation against the threshold that triggers alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.displayName
      description: The display name for the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.description
      description: The description of the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.tactics
      description: The tactics of the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.lastUpdatedDateUTC
      description: The time this alert rule template was last updated.
      type: Date
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.createdDateUTC
      description: The time this alert rule template was added.
      type: Date
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.status
      description: The alert rule template status.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.version
      description: The version of this template in the format <a.b.c>, where all are
        numbers. For example <1.0.2>.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.requiredDataConnectors.connectorId
      description: The connector ID that provides the following data types.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.requiredDataConnectors.dataTypes
      description: The data types used by the alert rule template.
      type: String
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.alertRulesCreatedByTemplateCount
      description: The number of alert rules that were created by this template.
      type: Number
    - contextPath: AzureSentinel.AlertRuleTemplate.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
  - arguments:
    - description: The alert rule ID to delete.
      name: rule_id
      required: true
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Deletes the specified alert rule.
    name: azure-sentinel-delete-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.ID
      description: The alert rule ID.
      type: String
    - contextPath: AzureSentinel.AlertRule.Deleted
      description: Whether the alert rule was deleted.
      type: Boolean
  - arguments:
    - description: The alert rule name to create.
      name: rule_name
      required: true
    - auto: PREDEFINED
      description: |
        The alert rule kind to create.
        Required for all types.
      name: kind
      predefined:
      - fusion
      - microsoft_security_incident_creation
      - scheduled
    - description: |
        The name of the alert rule template used to create this rule.
        Required for Fusion, optional for Scheduled rules.
      name: template_name
    - auto: PREDEFINED
      description: |
        Determines whether this alert rule is enabled or disabled.
        Required for all types.
      name: enabled
      predefined:
      - "yes"
      - "no"
    - description: ETag of the Azure resource.
      name: etag
    - description: |
        The display name for alerts created by this alert rule.
        Required for MicrosoftSecurityIncidentCreation and scheduled rules.
      name: displayName
    - auto: PREDEFINED
      description: |
        The alerts' productName on which the cases will be generated.
        Required for MicrosoftSecurityIncidentCreation rules.
      name: product_filter
      predefined:
      - azure_active_directory_identity_protection
      - azure_advanced_threat_protection
      - azure_security_center
      - azure_security_center_for_iot
      - microsoft_cloud_app_security
    - description: |
        The description of the alert rule.
        Relevant for MicrosoftSecurityIncidentCreation and scheduled rules.
      name: description
    - description: |
        Alerts' displayNames on which the cases will not be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: name_exclude_filter
    - description: |
        Alerts' displayNames on which the cases will be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: name_include_filter
    - description: |
        Alerts' severities on which the cases will be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: severity_filter
    - description: |
        The query that creates alerts for this rule.
        Required for scheduled rules.
      name: query
    - description: |
        The frequency (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) for this alert rule to run.
        Required for scheduled rules.
      name: query_frequency
    - description: |
        The period (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) that this alert rule looks at.
        Required for scheduled rules.
      name: query_period
    - auto: PREDEFINED
      description: |
        The severity for alerts created by this alert rule.
        Required for scheduled rules.
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
    - description: |
        The suppression (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) to wait since the last time this alert rule was triggered.
        Required for scheduled rules.
      name: suppression_duration
    - auto: PREDEFINED
      description: |
        Determines whether the suppression for this alert rule is enabled or disabled.
        Required for scheduled rules.
      name: suppression_enabled
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      description: |
        The operation against the threshold that triggers the alert rule.
        Required for scheduled rules.
      name: trigger_operator
      predefined:
      - equal
      - greater_than
      - less_than
      - not_equal
    - description: |
        The threshold that triggers this alert rule.
        Required for scheduled rules.
      name: trigger_threshold
    - description: |
        The tactics of the alert rule.
        Relevant for scheduled rules.
      isArray: true
      name: tactics
    - description: |
        The techniques of the alert rule.
        Relevant for scheduled rules.
      isArray: true
      name: techniques
    - description: |
        Option to insert a configured rule JSON instead of using the arguments.
      name: rule_json
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Creates a new alert rule.
    name: azure-sentinel-create-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource, e.g., "Microsoft.Compute/virtualMachines"
        or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to create this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time that this alert was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule
        to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks
        at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold that triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the
        last time this alert rule was triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled
        or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings
      description: The event grouping settings.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.customDetails
      description: Dictionary of string key-value pairs of columns to be attached
        to the alert.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings
      description: Array of the entity mappings of the alert rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride
      description: The alert details override settings.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration
      description: The settings of the incidents that were created from alerts triggered
        by this analytics rule.
      type: Unknown
  - arguments:
    - description: The alert rule name to update.
      name: rule_name
      required: true
    - auto: PREDEFINED
      description: |
        The alert rule kind to update.
        Required for all types.
      name: kind
      predefined:
      - fusion
      - microsoft_security_incident_creation
      - scheduled
    - description: |
        The name of the alert rule template used to update this rule.
        Required for Fusion, optional for Scheduled rules.
      name: template_name
    - auto: PREDEFINED
      description: |
        Determines whether this alert rule is enabled or disabled.
        Required for all types.
      name: enabled
      predefined:
      - "yes"
      - "no"
    - description: ETag of the Azure resource.
      name: etag
    - description: |
        The display name for alerts created by this alert rule.
        Required for MicrosoftSecurityIncidentCreation and scheduled rules.
      name: displayName
    - auto: PREDEFINED
      description: |
        The alerts' productName on which the cases will be generated.
        Required for MicrosoftSecurityIncidentCreation rules.
      name: product_filter
      predefined:
      - azure_active_directory_identity_protection
      - azure_advanced_threat_protection
      - azure_security_center
      - azure_security_center_for_iot
      - microsoft_cloud_app_security
    - description: |
        The description of the alert rule.
        Relevant for MicrosoftSecurityIncidentCreation and scheduled rules.
      name: description
    - description: |
        Alerts' displayNames on which the cases will not be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: name_exclude_filter
    - description: |
        Alerts' displayNames on which the cases will be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: name_include_filter
    - description: |
        Alerts' severities on which the cases will be generated.
        Relevant for MicrosoftSecurityIncidentCreation rules.
      isArray: true
      name: severity_filter
    - description: |
        The query that creates alerts for this rule.
        Required for scheduled rules.
      name: query
    - description: |
        The frequency (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) for this alert rule to run.
        Required for scheduled rules.
      name: query_frequency
    - description: |
        The period (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) that this alert rule looks at.
        Required for scheduled rules.
      name: query_period
    - auto: PREDEFINED
      description: |
        The severity for alerts created by this alert rule.
        Required for scheduled rules.
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
    - description: |
        The suppression (in ISO 8601 duration format: PnYnMnDTnHnMnS or PnW) to wait since the last time this alert rule was triggered.
        Required for scheduled rules.
      name: suppression_duration
    - auto: PREDEFINED
      description: |
        Determines whether the suppression for this alert rule is enabled or disabled.
        Required for scheduled rules.
      name: suppression_enabled
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      description: |
        The operation against the threshold that triggers the alert rule.
        Required for scheduled rules.
      name: trigger_operator
      predefined:
      - equal
      - greater_than
      - less_than
      - not_equal
    - description: |
        The threshold that triggers this alert rule.
        Required for scheduled rules.
      name: trigger_threshold
    - description: |
        The tactics of the alert rule.
        Relevant for scheduled rules.
      isArray: true
      name: tactics
    - description: |
        The techniques of the alert rule.
        Relevant for scheduled rules.
      isArray: true
      name: techniques
    - description: |
        Option to insert a configured rule JSON instead of using the arguments.
      name: rule_json
    - description: The subscription ID.
      name: subscription_id
    - description: The resource group name.
      name: resource_group_name
    description: Updates an alert rule.
    name: azure-sentinel-update-alert-rule
    outputs:
    - contextPath: AzureSentinel.AlertRule.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.etag
      description: ETag of the Azure resource.
      type: String
    - contextPath: AzureSentinel.AlertRule.type
      description: The type of the resource, e.g., "Microsoft.Compute/virtualMachines"
        or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.AlertRule.kind
      description: The alert rule kind.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.displayName
      description: The display name for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.description
      description: The description of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.alertRuleTemplateName
      description: The name of the alert rule template used to update this rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.tactics
      description: The tactics of the alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severity
      description: The severity for alerts created by this alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.enabled
      description: Determines whether this alert rule is enabled or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.lastModifiedUtc
      description: The last time this alert was modified.
      type: Date
    - contextPath: AzureSentinel.AlertRule.properties.productFilter
      description: The alerts' productName on which the cases will be generated.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.severitiesFilter
      description: The alerts' severities on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.displayNamesFilter
      description: The alerts' displayNames on which the cases will be generated.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.query
      description: The query that creates alerts for this rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryFrequency
      description: The frequency (in ISO 8601 duration format) for this alert rule
        to run.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.queryPeriod
      description: The period (in ISO 8601 duration format) that this alert rule looks
        at.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerOperator
      description: The operation against the threshold that triggers alert rule.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.triggerThreshold
      description: The threshold triggers this alert rule.
      type: Number
    - contextPath: AzureSentinel.AlertRule.properties.suppressionDuration
      description: The suppression (in ISO 8601 duration format) to wait since the
        last time this alert rule been triggered.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.suppressionEnabled
      description: Determines whether the suppression for this alert rule is enabled
        or disabled.
      type: Boolean
    - contextPath: AzureSentinel.AlertRule.properties.eventGroupingSettings
      description: The event grouping settings.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.customDetails
      description: Dictionary of string key-value pairs of columns to be attached
        to the alert.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.entityMappings
      description: Array of the entity mappings of the alert rule.
      type: Unknown
    - contextPath: AzureSentinel.AlertRule.properties.alertDetailsOverride
      description: The alert details override settings.
      type: String
    - contextPath: AzureSentinel.AlertRule.properties.incidentConfiguration
      description: The settings of the incidents that were created from alerts triggered
        by this analytics rule.
      type: Unknown
  - arguments: []
    description: Lists all subscriptions.
    name: azure-sentinel-subscriptions-list
    outputs:
    - contextPath: AzureSentinel.SubscriptionId
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.displayName
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.authorizationSource
      description: The authorization source of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.managedByTenants
      description: The subscriptions that are managed by tenants of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.tenetId
      description: The tenet ID of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.state
      description: The state of the resource.
      type: String
    - contextPath: AzureSentinel.Subscription.subscriptionPolicies
      description: The subscription policies of the resource.
      type: String
  - arguments:
    - description: 'The subscription ID. Note: The integration default Subscription
        ID will be used unless this argument is provided.'
      name: subscription_id
      type: String
    - description: A single tag in the form of '{"Tag Name":"Tag Value"}' to filter
        the list by.
      name: tag
      type: String
    - defaultValue: "50"
      description: The maximum number of resource groups to return.
      name: limit
      type: Number
    description: List all resource groups for a subscription.
    name: azure-sentinel-resource-group-list
    outputs:
    - contextPath: AzureSentinel.ResourceGroup.id
      description: Fully qualified resource ID for the resource.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.name
      description: The name of the resource.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.type
      description: The type of the resource. E.g., "Microsoft.Compute/virtualMachines"
        or "Microsoft.Storage/storageAccounts".
      type: String
    - contextPath: AzureSentinel.ResourceGroup.location
      description: The location of the resource group.
      type: String
    - contextPath: AzureSentinel.ResourceGroup.tags
      description: The tags of the resource group.
      type: Dictionary
    - contextPath: AzureSentinel.ResourceGroup.properties
      description: The properties of the resource group.
      type: dictionary
  - arguments: []
    description: Run this command if for some reason you need to rerun the authentication
      process.
    name: azure-sentinel-auth-reset
  dockerimage: demisto/crypto:1.0.0.94037
  isfetch: true
  ismappable: true
  isremotesyncin: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('Azure Sentinel', 'start', __line__())
    ### pack version: 1.5.46



    # IMPORTS

    import json
    import urllib3
    import requests
    import dateparser
    import uuid


    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)


    # pylint: disable=E9010, E9011
    import traceback


    import requests
    import re
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM


    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'  # resource_manager


    class Resources:
        graph = 'https://graph.microsoft.com/'
        security_center = 'https://api.securitycenter.microsoft.com/'
        security = 'https://api.security.microsoft.com/'
        management_azure = 'https://management.azure.com/'  # resource_manager
        manage_office = 'https://manage.office.com/'


    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line
    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'
    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'
    REGEX_SEARCH_ERROR_DESC = r"^.*?:\s(?P<desc>.*?\.)"
    SESSION_STATE = 'session_state'

    # Deprecated, prefer using AZURE_CLOUDS
    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.us',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"
    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"


    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris
    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api
    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'geo-us': 'https://login.microsoftonline.com',
        'geo-eu': 'https://login.microsoftonline.com',
        'geo-uk': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
    }

    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'geo-us': 'https://graph.microsoft.com',
        'geo-eu': 'https://graph.microsoft.com',
        'geo-uk': 'https://graph.microsoft.com',
        'gcc': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        'com': 'https://securitycenter.onmicrosoft.com',
        'geo-us': 'https://securitycenter.onmicrosoft.com',
        'geo-eu': 'https://securitycenter.onmicrosoft.com',
        'geo-uk': 'https://securitycenter.onmicrosoft.com',
        'gcc': 'https://securitycenter.onmicrosoft.com',
        'gcc-high': 'https://securitycenter.onmicrosoft.us',
        'dod': 'https://securitycenter.onmicrosoft.us',
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
    }

    # Azure Managed Identities
    MANAGED_IDENTITIES_TOKEN_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01'
    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = 'SYSTEM_ASSIGNED'
    TOKEN_EXPIRED_ERROR_CODES = {50173, 700082, 70008, 54005, 7000222,
                                 }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism
    MAX_DELAY_REQUEST_COUNTER = 6


    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     management=None,
                     resource_manager=None,
                     sql_management=None,
                     batch_resource_id=None,
                     gallery=None,
                     active_directory=None,
                     active_directory_resource_id=None,
                     active_directory_graph_resource_id=None,
                     microsoft_graph_resource_id=None,
                     active_directory_data_lake_resource_id=None,
                     vm_image_alias_doc=None,
                     media_resource_id=None,
                     ossrdbms_resource_id=None,
                     log_analytics_resource_id=None,
                     app_insights_resource_id=None,
                     app_insights_telemetry_channel_resource_id=None,
                     synapse_analytics_resource_id=None,
                     attestation_resource_id=None,
                     portal=None,
                     keyvault=None,
                     exchange_online=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault
            self.exchange_online = exchange_online

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes

        def __init__(self,  # pylint: disable=unused-argument
                     storage_endpoint=None,
                     storage_sync_endpoint=None,
                     keyvault_dns=None,
                     mhsm_dns=None,
                     sql_server_hostname=None,
                     azure_datalake_store_file_system_endpoint=None,
                     azure_datalake_analytics_catalog_and_job_endpoint=None,
                     acr_login_server_endpoint=None,
                     mysql_server_endpoint=None,
                     postgresql_server_endpoint=None,
                     mariadb_server_endpoint=None,
                     synapse_analytics_endpoint=None,
                     attestation_endpoint=None):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """ Represents an Azure Cloud instance """

        def __init__(self,
                     origin,
                     name,
                     abbreviation,
                     endpoints=None,
                     suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        'Embedded',
        'AzureCloud',
        'com',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.windows.net/',
            resource_manager='https://management.azure.com/',
            sql_management='https://management.core.windows.net:8443/',
            batch_resource_id='https://batch.core.windows.net/',
            gallery='https://gallery.azure.com/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.windows.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.com/',
            active_directory_data_lake_resource_id='https://datalake.azure.net/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.azure.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.windows.net',
            app_insights_resource_id='https://api.applicationinsights.io',
            log_analytics_resource_id='https://api.loganalytics.io',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.com/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.net',
            attestation_resource_id='https://attest.azure.net',
            portal='https://portal.azure.com',
            keyvault='https://vault.azure.net',
            exchange_online='https://outlook.office365.com'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.windows.net',
            storage_sync_endpoint='afs.azure.net',
            keyvault_dns='.vault.azure.net',
            mhsm_dns='.managedhsm.azure.net',
            sql_server_hostname='.database.windows.net',
            mysql_server_endpoint='.mysql.database.azure.com',
            postgresql_server_endpoint='.postgres.database.azure.com',
            mariadb_server_endpoint='.mariadb.database.azure.com',
            azure_datalake_store_file_system_endpoint='azuredatalakestore.net',
            azure_datalake_analytics_catalog_and_job_endpoint='azuredatalakeanalytics.net',
            acr_login_server_endpoint='.azurecr.io',
            synapse_analytics_endpoint='.dev.azuresynapse.net',
            attestation_endpoint='.attest.azure.net'))

    AZURE_US_GCC_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.com',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook.office365.com'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'gcc-high',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook.office365.us'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))

    AZURE_DOD_CLOUD = AzureCloud(
        'Embedded',
        'AzureUSGovernment',
        'dod',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.usgovcloudapi.net/',
            resource_manager='https://management.usgovcloudapi.net/',
            sql_management='https://management.core.usgovcloudapi.net:8443/',
            batch_resource_id='https://batch.core.usgovcloudapi.net/',
            gallery='https://gallery.usgovcloudapi.net/',
            active_directory='https://login.microsoftonline.us',
            active_directory_resource_id='https://management.core.usgovcloudapi.net/',
            active_directory_graph_resource_id='https://graph.windows.net/',
            microsoft_graph_resource_id='https://dod-graph.microsoft.us/',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.usgovcloudapi.net',
            ossrdbms_resource_id='https://ossrdbms-aad.database.usgovcloudapi.net',
            app_insights_resource_id='https://api.applicationinsights.us',
            log_analytics_resource_id='https://api.loganalytics.us',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.us/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.usgovcloudapi.net',
            portal='https://portal.azure.us',
            keyvault='https://vault.usgovcloudapi.net',
            exchange_online='https://outlook-dod.office365.us'

        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.usgovcloudapi.net',
            storage_sync_endpoint='afs.azure.us',
            keyvault_dns='.vault.usgovcloudapi.net',
            mhsm_dns='.managedhsm.usgovcloudapi.net',
            sql_server_hostname='.database.usgovcloudapi.net',
            mysql_server_endpoint='.mysql.database.usgovcloudapi.net',
            postgresql_server_endpoint='.postgres.database.usgovcloudapi.net',
            mariadb_server_endpoint='.mariadb.database.usgovcloudapi.net',
            acr_login_server_endpoint='.azurecr.us',
            synapse_analytics_endpoint='.dev.azuresynapse.usgovcloudapi.net'))


    AZURE_GERMAN_CLOUD = AzureCloud(
        'Embedded',
        'AzureGermanCloud',
        'de',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.cloudapi.de/',
            resource_manager='https://management.microsoftazure.de',
            sql_management='https://management.core.cloudapi.de:8443/',
            batch_resource_id='https://batch.cloudapi.de/',
            gallery='https://gallery.cloudapi.de/',
            active_directory='https://login.microsoftonline.de',
            active_directory_resource_id='https://management.core.cloudapi.de/',
            active_directory_graph_resource_id='https://graph.cloudapi.de/',
            microsoft_graph_resource_id='https://graph.microsoft.de',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.cloudapi.de',
            ossrdbms_resource_id='https://ossrdbms-aad.database.cloudapi.de',
            portal='https://portal.microsoftazure.de',
            keyvault='https://vault.microsoftazure.de',
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.cloudapi.de',
            keyvault_dns='.vault.microsoftazure.de',
            mhsm_dns='.managedhsm.microsoftazure.de',
            sql_server_hostname='.database.cloudapi.de',
            mysql_server_endpoint='.mysql.database.cloudapi.de',
            postgresql_server_endpoint='.postgres.database.cloudapi.de',
            mariadb_server_endpoint='.mariadb.database.cloudapi.de'))

    AZURE_CHINA_CLOUD = AzureCloud(
        'Embedded',
        'AzureChinaCloud',
        'cn',
        endpoints=AzureCloudEndpoints(
            management='https://management.core.chinacloudapi.cn/',
            resource_manager='https://management.chinacloudapi.cn',
            sql_management='https://management.core.chinacloudapi.cn:8443/',
            batch_resource_id='https://batch.chinacloudapi.cn/',
            gallery='https://gallery.chinacloudapi.cn/',
            active_directory='https://login.chinacloudapi.cn',
            active_directory_resource_id='https://management.core.chinacloudapi.cn/',
            active_directory_graph_resource_id='https://graph.chinacloudapi.cn/',
            microsoft_graph_resource_id='https://microsoftgraph.chinacloudapi.cn',
            vm_image_alias_doc='https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json',  # noqa: E501
            media_resource_id='https://rest.media.chinacloudapi.cn',
            ossrdbms_resource_id='https://ossrdbms-aad.database.chinacloudapi.cn',
            app_insights_resource_id='https://api.applicationinsights.azure.cn',
            log_analytics_resource_id='https://api.loganalytics.azure.cn',
            app_insights_telemetry_channel_resource_id='https://dc.applicationinsights.azure.cn/v2/track',
            synapse_analytics_resource_id='https://dev.azuresynapse.azure.cn',
            portal='https://portal.azure.cn',
            keyvault='https://vault.azure.cn',
            exchange_online='https://partner.outlook.cn'
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint='core.chinacloudapi.cn',
            keyvault_dns='.vault.azure.cn',
            mhsm_dns='.managedhsm.azure.cn',
            sql_server_hostname='.database.chinacloudapi.cn',
            mysql_server_endpoint='.mysql.database.chinacloudapi.cn',
            postgresql_server_endpoint='.postgres.database.chinacloudapi.cn',
            mariadb_server_endpoint='.mariadb.database.chinacloudapi.cn',
            acr_login_server_endpoint='.azurecr.cn',
            synapse_analytics_endpoint='.dev.azuresynapse.azure.cn'))


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    AZURE_CLOUD_NAME_CUSTOM = "Custom"

    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }


    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(origin: str,
                                  name: str | None = None,
                                  abbreviation: str | None = None,
                                  defaults: AzureCloud | None = None,
                                  endpoints: dict | None = None,
                                  suffixes: dict | None = None):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get('management', defaults.endpoints.management),
                resource_manager=endpoints.get('resource_manager', defaults.endpoints.resource_manager),
                sql_management=endpoints.get('sql_management', defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get('batch_resource_id', defaults.endpoints.batch_resource_id),
                gallery=endpoints.get('gallery', defaults.endpoints.gallery),
                active_directory=endpoints.get('active_directory', defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get('active_directory_resource_id',
                                                           defaults.endpoints.active_directory_resource_id),
                active_directory_graph_resource_id=endpoints.get(
                    'active_directory_graph_resource_id', defaults.endpoints.active_directory_graph_resource_id),
                microsoft_graph_resource_id=endpoints.get('microsoft_graph_resource_id',
                                                          defaults.endpoints.microsoft_graph_resource_id),
                active_directory_data_lake_resource_id=endpoints.get(
                    'active_directory_data_lake_resource_id', defaults.endpoints.active_directory_data_lake_resource_id),
                vm_image_alias_doc=endpoints.get('vm_image_alias_doc', defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get('media_resource_id', defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get('ossrdbms_resource_id', defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get('app_insights_resource_id', defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get('log_analytics_resource_id', defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    'app_insights_telemetry_channel_resource_id', defaults.endpoints.app_insights_telemetry_channel_resource_id),
                synapse_analytics_resource_id=endpoints.get(
                    'synapse_analytics_resource_id', defaults.endpoints.synapse_analytics_resource_id),
                attestation_resource_id=endpoints.get('attestation_resource_id', defaults.endpoints.attestation_resource_id),
                portal=endpoints.get('portal', defaults.endpoints.portal),
                keyvault=endpoints.get('keyvault', defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get('storage_endpoint', defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get('storage_sync_endpoint', defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get('keyvault_dns', defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get('mhsm_dns', defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get('sql_server_hostname', defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get('mysql_server_endpoint', defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get('postgresql_server_endpoint', defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get('mariadb_server_endpoint', defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    'azure_datalake_store_file_system_endpoint', defaults.suffixes.azure_datalake_store_file_system_endpoint),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    'azure_datalake_analytics_catalog_and_job_endpoint',
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint),
                acr_login_server_endpoint=suffixes.get('acr_login_server_endpoint', defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get('synapse_analytics_endpoint', defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get('attestation_endpoint', defaults.suffixes.attestation_endpoint),
            ))


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, 'com')
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get('azure_cloud')
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if 'server_url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'resource_manager': params.get('server_url')
                                                            or 'https://management.azure.com'})
            if 'azure_ad_endpoint' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={
                                                     'active_directory': params.get('azure_ad_endpoint')
                                                     or 'https://login.microsoftonline.com'
                                                 })
            # in multiple Graph integrations, the url is called 'url' instead of 'server_url' and the default url is different.
            if 'url' in params:
                return create_custom_azure_cloud(integration_name, defaults=AZURE_WORLDWIDE_CLOUD,
                                                 endpoints={'microsoft_graph_resource_id': params.get('url')
                                                            or 'https://graph.microsoft.com'})

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str | None = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str | None = '',
                     multi_resource: bool = False,
                     resources: list[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: int | None = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
                     endpoint: str = "__NA__",  # Deprecated
                     certificate_thumbprint: str | None = None,
                     retry_on_rate_limit: bool = False,
                     private_key: str | None = None,
                     managed_identities_client_id: str | None = None,
                     managed_identities_resource_uri: str | None = None,
                     base_url: str | None = None,
                     command_prefix: str | None = "command_prefix",
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            demisto.debug(f'Initializing MicrosoftClient with: {endpoint=} | {azure_cloud.abbreviation}')
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=self.azure_cloud.endpoints.active_directory
                                                                      .rstrip("/"))
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(
                endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get('context', {})
            executed_commands = ctx.get('ExecutedCommands', [{'moduleBrand': 'Scripts'}])

            if executed_commands:
                return executed_commands[0].get('moduleBrand', "") != 'Scripts'

            return True

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: str | None = None,
                resource: str = '', overwrite_rate_limit_retry=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs['timeout'] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get('error_handler'):
                kwargs['error_handler'] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge('6.2.0'):
                command_args = demisto.args()
                ran_once_flag = command_args.get('ran_once_flag')
                demisto.info(f'429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}')
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = 'Rate limit reached on retry - 429 Response'
                    demisto.info(f'Error in retry for MS rate limit - {error_message}')
                    raise DemistoException(error_message)

                else:
                    demisto.info(f'Scheduling command {demisto.command()}')
                    command_args['ran_once_flag'] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    try:
                        import defusedxml.ElementTree as defused_ET
                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug('defused_ET is not supported, using ET instead.')
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f'Failed to parse json object from response: {response.content}', exception)

        def get_access_token(self, resource: str = '', scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else \
                            min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug('Set integration context successfully.')

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = 'Error in Microsoft authorization.'
            try:
                demisto.info(
                    f'Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} '
                    f'{oproxy_response.text}'
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r'{.*}', oproxy_response.text)
                microsoft_response = self.extract_microsoft_error(json.loads(search_microsoft_response.group())) \
                    if search_microsoft_response else ""
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f' body: {err_str}'
                err_response = oproxy_response.json()
                server_msg = err_response.get('message', '') or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f' Server message: {server_msg}'
            except Exception as ex:
                demisto.error(f'Failed parsing error response - Exception: {ex}')
            raise Exception(msg)

        def _oproxy_authorize_build_request(self, headers: dict[str, str], content: str,
                                            scope: str | None = None, resource: str = ''
                                            ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

        def _oproxy_authorize(self, resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get('delay_request_counter', 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(next_request_time=next_request_time, delay_request_counter=delay_request_counter,
                                              context=context)
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: str | None = None,
                                     integration_context: dict | None = None
                                     ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:

                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return '', expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                      resource)
                    self.resource_to_access_token[resource] = access_token

                return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: str | None = None,
                                                        resource: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope or self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = (self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED)
                resource = resource or self.managed_identities_resource_uri

                demisto.debug('try to get Managed Identities token')

                params = {'resource': resource}
                if not use_system_assigned:
                    params['client_id'] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={'Metadata': 'True'}).json()
                access_token = response_json.get('access_token')
                expires_in = int(response_json.get('expires_in', 3595))
                if access_token:
                    return access_token, expires_in, ''

                err = response_json.get('error_description')
            except Exception as e:
                err = f'{str(e)}'

            return_error(f'Error in Microsoft authorization with Azure Managed Identities: {err}')
            return None

        def _get_token_device_code(
            self, refresh_token: str = '', scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(readable_output="Rate limit reached, rerunning the command in 1 min",
                                  scheduled_command=ScheduledCommand(command=demisto.command(), next_run_in_seconds=60,
                                                                     args=args_for_next_run, timeout_in_seconds=900))

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ['test-module', 'fetch-incidents']:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get('error', {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get('error_description', '')

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += f"\nYou can run the ***{self.command_prefix}-auth-reset*** command " \
                               f"to reset the authentication process."
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f'Failed getting integration info: {str(e)}')

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search['url'] if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
            Calculates the next request time based on the delay_request_counter.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2 ** delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
            Sets the next_request_time in the integration context.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context['next_request_time'] = next_request_time
        context['delay_request_counter'] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context['delay_request_counter'] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
            Checks if the request should be delayed based on context variables.
            This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get('auth_type') or params.get('authentication_type')
        if params and (argToBoolean(params.get('use_managed_identities') or auth_type == 'Azure Managed Identities')):
            client_id = params.get('managed_identities_client_id', {}).get('password')
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient,
                           login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException("Please make sure you entered the Authorization configuration correctly. "
                                   f"Missing:{','.join(missing)}")

        login_url = urljoin(login_url, f'{client.tenant_id}/oauth2/v2.0/authorize?'
                            f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
                            f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}')

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.
    You will be automatically redirected to a link with the following structure:
    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```
    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)
    and paste it in your instance configuration under the **Authorization code** parameter.
     """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f'No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.')


    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(readable_output='Authorization was reset successfully. Please regenerate the credentials, '
                                              'and then click **Test** to validate the credentials and connection.')

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    # Disable insecure warnings
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    ''' CONSTANTS '''

    APP_NAME = 'ms-azure-sentinel'

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    DATE_FORMAT_WITH_MILLISECONDS = '%Y-%m-%dT%H:%M:%S.%fZ'

    API_VERSION = '2022-11-01'

    NEXT_LINK_DESCRIPTION = 'NextLink for listing commands'

    XSOAR_USER_AGENT = 'SentinelPartner-PaloAltoNetworks-CortexXsoar/1.0.0'

    AUTHORIZATION_ERROR_MSG = 'There was a problem in retrieving an updated access token.\n' \
                              'The response from the server did not contain the expected content.'

    INCIDENT_HEADERS = ['ID', 'IncidentNumber', 'Title', 'Description', 'Severity', 'Status', 'IncidentUrl', 'AssigneeName',
                        'AssigneeEmail', 'AssigneeObjectID', 'AssigneeUPN', 'Label', 'FirstActivityTimeUTC', 'LastActivityTimeUTC',
                        'LastModifiedTimeUTC', 'CreatedTimeUTC', 'AlertsCount', 'BookmarksCount', 'CommentsCount',
                        'AlertProductNames', 'Tactics', 'FirstActivityTimeGenerated', 'LastActivityTimeGenerated']

    COMMENT_HEADERS = ['ID', 'IncidentID', 'Message', 'AuthorName', 'AuthorEmail', 'CreatedTimeUTC']

    ENTITIES_RETENTION_PERIOD_MESSAGE = '\nNotice that in the current Azure Sentinel API version, the retention period ' \
                                        'for GetEntityByID is 30 days.'

    DEFAULT_LIMIT = 20

    DEFAULT_SOURCE = 'Microsoft Sentinel'

    THREAT_INDICATORS_HEADERS = ['Name', 'DisplayName', 'Values', 'Types', 'Source', 'Confidence', 'Tags']

    # =========== Mirroring Mechanism Globals ===========

    MIRROR_DIRECTION_DICT = {
        'None': None,
        'Incoming': 'In',
        'Outgoing': 'Out',
        'Incoming And Outgoing': 'Both'
    }

    MIRROR_STATUS_DICT = {
        'Undetermined': 'Other',
        'TruePositive': 'Resolved',
        'BenignPositive': 'Resolved',
        'FalsePositive': 'False Positive',
    }

    MIRROR_DIRECTION = MIRROR_DIRECTION_DICT.get(demisto.params().get('mirror_direction'))
    INTEGRATION_INSTANCE = demisto.integrationInstance()

    INCOMING_MIRRORED_FIELDS = ['ID', 'Etag', 'Title', 'Description', 'Severity', 'Status', 'owner', 'tags', 'FirstActivityTimeUTC',
                                      'LastActivityTimeUTC', 'LastModifiedTimeUTC', 'CreatedTimeUTC', 'IncidentNumber', 'AlertsCount',
                                      'AlertProductNames', 'Tactics', 'relatedAnalyticRuleIds', 'IncidentUrl', 'classification',
                                      'classificationComment', 'alerts', 'entities', 'comments', 'relations']
    OUTGOING_MIRRORED_FIELDS = {'etag', 'title', 'description', 'severity', 'status', 'tags', 'firstActivityTimeUtc',
                                'lastActivityTimeUtc', 'classification', 'classificationComment', 'classificationReason'}
    OUTGOING_MIRRORED_FIELDS = {filed: pascalToSpace(filed) for filed in OUTGOING_MIRRORED_FIELDS}

    LEVEL_TO_SEVERITY = {0: 'Informational', 0.5: 'Informational', 1: 'Low', 2: 'Medium', 3: 'High', 4: 'High'}
    CLASSIFICATION_REASON = {'FalsePositive': 'InaccurateData', 'TruePositive': 'SuspiciousActivity',
                             'BenignPositive': 'SuspiciousButExpected'}


    class AzureSentinelClient:
        def __init__(self, tenant_id: str, client_id: str,
                     client_secret: str, subscription_id: str,
                     resource_group_name: str, workspace_name: str, certificate_thumbprint: Optional[str],
                     private_key: Optional[str], verify: bool = True, proxy: bool = False,
                     managed_identities_client_id: Optional[str] = None,
                     azure_cloud: Optional[AzureCloud] = None):
            """
            AzureSentinelClient class that make use client credentials for authorization with Azure.

            :type azure_cloud: ``AzureCloud | None``
            :param azure_cloud: The Azure Cloud settings.

            :type tenant_id: ``str``
            :param tenant_id: The tenant id.

            :type client_id: ``str``
            :param client_id: The client id.

            :type client_secret: ``str``
            :param client_secret: The client secret from Azure registered application.

            :type subscription_id: ``str``
            :param subscription_id: The subscription id.

            :type resource_group_name: ``str``
            :param resource_group_name: The resource group name.

            :type workspace_name: ``str``
            :param workspace_name: The workspace name.

            :type certificate_thumbprint: ``str``
            :param certificate_thumbprint: The certificate thumbprint as appears in the AWS GUI.

            :type private_key: ``str``
            :param private_key: The certificate private key.

            :type verify: ``bool``
            :param verify: Whether the request should verify the SSL certificate.

            :type proxy: ``bool``
            :param proxy: Whether to run the integration using the system proxy.

            :type managed_identities_client_id: ``str``
            :param managed_identities_client_id: The Azure Managed Identities client id.
            """

            self.azure_cloud = azure_cloud or AZURE_WORLDWIDE_CLOUD
            base_url = urljoin(self.azure_cloud.endpoints.resource_manager, f'subscriptions/{subscription_id}/'
                               f'resourceGroups/{resource_group_name}/providers/Microsoft.OperationalInsights/workspaces/'
                               f'{workspace_name}/providers/Microsoft.SecurityInsights')
            self._client = MicrosoftClient(
                tenant_id=tenant_id,
                auth_id=client_id,
                enc_key=client_secret,
                self_deployed=True,
                grant_type=CLIENT_CREDENTIALS,
                scope=urljoin(self.azure_cloud.endpoints.resource_manager, '.default'),
                ok_codes=(200, 201, 202, 204),
                verify=verify,
                proxy=proxy,
                azure_cloud=self.azure_cloud,
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key,
                managed_identities_client_id=managed_identities_client_id,
                managed_identities_resource_uri=self.azure_cloud.endpoints.resource_manager,
                base_url=base_url,
                command_prefix="azure-sentinel",
            )

        def http_request(self, method, url_suffix=None, full_url=None, params=None, data=None):
            """
            Wrapped the client's `http_request` for adding some required params and headers
            """
            if not full_url:
                params = params or {}
                params['api-version'] = API_VERSION

            res = self._client.http_request(
                method=method,  # disable-secrets-detection
                url_suffix=url_suffix,
                full_url=full_url,
                headers={'User-Agent': XSOAR_USER_AGENT},
                json_data=data,
                params=params,
                error_handler=error_handler,
                resp_type='response',
            )

            if res.content:
                return res.json()

            return res


    ''' INTEGRATION HELPER METHODS '''


    def get_error_kind(code):
        """
        Get the kind of the error based on the http error code.
        """
        return {
            400: 'BadRequest',
            401: 'UnAuthorized',
            403: 'Forbidden',
            404: 'NotFound',
        }.get(code)


    def error_handler(response: requests.Response):
        """
        raise informative exception in case of error response
        """
        if response.status_code in (400, 401, 403, 404):
            try:
                error_json = response.json()
            except json.JSONDecodeError:
                error_json = {
                    'error': {
                        'code': get_error_kind(code=response.status_code),
                        'message': response.text
                    }
                }
            error_kind = error_json.get('error', {}).get('code', 'BadRequest')
            error_msg = error_json.get('error', {}).get('message', error_json)
            raise ValueError(
                f'[{error_kind} {response.status_code}] {error_msg}'
            )


    def format_date(date):
        if not date:
            return None
        return dateparser.parse(date).strftime(DATE_FORMAT)  # type:ignore


    def incident_data_to_xsoar_format(inc_data, is_fetch_incidents=False):
        """
        Convert the incident data from the raw to XSOAR format.

        :param inc_data: (dict) The incident raw data.
        :param is_fetch_incidents: (bool) Is it part of a fetch incidents command.
        """
        properties = inc_data.get('properties', {})

        formatted_data = {
            'ID': inc_data.get('name'),
            'IncidentNumber': properties.get('incidentNumber'),
            'IncidentUrl': properties.get('incidentUrl'),
            'Title': properties.get('title'),
            'Description': properties.get('description'),
            'Severity': properties.get('severity'),
            'Status': properties.get('status'),
            'AssigneeName': properties.get('owner', {}).get('assignedTo'),
            'AssigneeEmail': properties.get('owner', {}).get('email'),
            'AssigneeObjectID': properties.get('owner', {}).get('objectId'),
            'AssigneeUPN': properties.get('owner', {}).get('userPrincipalName'),
            'Label': [{
                'Name': label.get('labelName'),
                'Type': label.get('labelType')
            } for label in properties.get('labels', [])],
            'FirstActivityTimeUTC': format_date(properties.get('firstActivityTimeUtc')),
            'LastActivityTimeUTC': format_date(properties.get('lastActivityTimeUtc')),
            'LastModifiedTimeUTC': format_date(properties.get('lastModifiedTimeUtc')),
            'CreatedTimeUTC': format_date(properties.get('createdTimeUtc')),
            'AlertsCount': properties.get('additionalData', {}).get('alertsCount'),
            'BookmarksCount': properties.get('additionalData', {}).get('bookmarksCount'),
            'CommentsCount': properties.get('additionalData', {}).get('commentsCount'),
            'AlertProductNames': properties.get('additionalData', {}).get('alertProductNames'),
            'Tactics': properties.get('additionalData', {}).get('tactics'),
            'Techniques': properties.get('additionalData', {}).get('techniques'),
            'FirstActivityTimeGenerated': format_date(properties.get('firstActivityTimeGenerated')),
            'LastActivityTimeGenerated': format_date(properties.get('lastActivityTimeGenerated')),
            'Etag': inc_data.get('etag'),
            'Deleted': False
        }
        if is_fetch_incidents:
            formatted_data |= {
                'tags': [label.get('labelName') for label in properties.get('labels', [])],
                'owner': properties.get('owner'),
                'relatedAnalyticRuleIds': [rule_id.split('/')[-1] for rule_id in properties.get('relatedAnalyticRuleIds', [])],
                "classification": properties.get('classification'),
                "classificationComment": properties.get('classificationComment'),
                "classificationReason": properties.get('classificationReason')
            }
        return formatted_data


    def watchlist_data_to_xsoar_format(watchlist_data):
        """
        Convert the watchlist data from the raw to XSOAR format.

        :param watchlist_data: (dict) The alert raw data.
        """
        properties = watchlist_data.get('properties', {})

        formatted_data = {
            'Name': watchlist_data.get('name'),
            'ID': properties.get('watchlistId'),
            'Description': properties.get('description'),
            'Provider': properties.get('provider'),
            'Source': properties.get('source'),
            'Created': format_date(properties.get('created')),
            'Updated': format_date(properties.get('updated')),
            'CreatedBy': properties.get('createdBy', {}).get('name'),
            'UpdatedBy': properties.get('updatedBy', {}).get('name'),
            'Alias': properties.get('watchlistAlias'),
            'Label': properties.get('labels', []),
            'ItemsSearchKey': properties.get('itemsSearchKey')
        }
        return formatted_data


    def alert_data_to_xsoar_format(alert_data):
        """
        Convert the alert data from the raw to XSOAR format.

        :param alert_data: (dict) The alert raw data.
        """
        properties = alert_data.get('properties', {})
        formatted_data = {
            'ID': properties.get('systemAlertId'),
            'Kind': alert_data.get('kind'),
            'Tactic': properties.get('tactics'),
            'Technique': properties.get('additionalData', {}).get('MitreTechniques'),
            'DisplayName': properties.get('alertDisplayName'),
            'Description': properties.get('description'),
            'ConfidenceLevel': properties.get('confidenceLevel'),
            'Severity': properties.get('severity'),
            'VendorName': properties.get('vendorName'),
            'ProductName': properties.get('productName'),
            'ProductComponentName': properties.get('productComponentName'),
        }
        return formatted_data


    def watchlist_item_data_to_xsoar_format(item_data):
        """
        Convert the watchlist item from the raw to XSOAR format.

        :param item_data: (dict) The item raw data.
        """
        properties = item_data.get('properties', {})
        formatted_data = {
            'Name': item_data.get('name'),
            'ID': properties.get('watchlistItemId'),
            'Created': format_date(properties.get('created')),
            'Updated': format_date(properties.get('updated')),
            'CreatedBy': demisto.get(properties, 'createdBy.name'),
            'UpdatedBy': demisto.get(properties, 'updatedBy.name'),
            'ItemsKeyValue': properties.get('itemsKeyValue'),
        }
        return formatted_data


    def get_update_incident_request_data(client: AzureSentinelClient, args: Dict[str, str]):
        """
        Prepare etag and other mandatory incident properties for update_incident command.

        :param client: The client.
        :param args: The args for the command.
        """
        fetched_incident_data = get_incident_by_id_command(client, args).raw_response

        title = args.get('title')
        description = args.get('description')
        severity = args.get('severity')
        status = args.get('status')
        classification = args.get('classification')
        classification_comment = args.get('classification_comment')
        classification_reason = args.get('classification_reason')
        assignee_email = args.get('assignee_email')
        assignee_objectid = args.get('assignee_objectid')
        user_principal_name = args.get('user_principal_name')
        labels = argToList(args.get('labels', ''))
        unassign = args.get('unassign')
        owner = demisto.get(fetched_incident_data, 'properties.owner', {})

        if not title:
            title = demisto.get(fetched_incident_data, 'properties.title')
        if not description:
            description = demisto.get(fetched_incident_data, 'properties.description')
        if not severity:
            severity = demisto.get(fetched_incident_data, 'properties.severity')
        if not status:
            status = demisto.get(fetched_incident_data, 'properties.status')
        if unassign == 'true':
            owner = {}
        elif assignee_objectid:
            owner = {'objectId': assignee_objectid}
        else:
            if user_principal_name:
                owner = {'userPrincipalName': user_principal_name}
            if assignee_email:
                owner['email'] = assignee_email

        existing_labels = demisto.get(fetched_incident_data, 'properties.labels')
        if not labels:  # not provided as arg
            labels_formatted = existing_labels

        else:
            labels_formatted = [{"labelName": label, "labelType": "User"}
                                for label in argToList(labels) if label]  # labels can not be blank
        incident_data = {
            'etag': fetched_incident_data.get('etag'),
            'properties': {
                'title': title,
                'description': description,
                'severity': severity,
                'status': status,
                'classification': classification,
                'classificationComment': classification_comment,
                'classificationReason': classification_reason,
                'labels': labels_formatted,
                'owner': owner
            }
        }
        remove_nulls_from_dictionary(incident_data['properties'])

        return incident_data


    def comment_data_to_xsoar_format(comment_data, inc_id):
        """
        Convert the comment data from the raw to XSOAR format.

        :param comment_data: (dict) The comment raw data.
        :param inc_id: The id of the incident hold this comment.
        """
        properties = comment_data.get('properties', {})

        formatted_data = {
            'ID': comment_data.get('name'),
            'IncidentID': inc_id,
            'Message': properties.get('message'),
            'AuthorName': properties.get('author', {}).get('assignedTo'),
            'AuthorEmail': properties.get('author', {}).get('email'),
            'CreatedTimeUTC': format_date(properties.get('createdTimeUtc'))
        }
        return formatted_data


    def incident_related_resource_data_to_xsoar_format(resource_data, incident_id):
        """
        Convert the incident relation from the raw to XSOAR format.

        :param resource_data: (dict) The related resource raw data.
        :param incident_id: The incident id.
        """
        properties = resource_data.get('properties', {})

        formatted_data = {
            'ID': properties.get('relatedResourceName'),
            'Kind': properties.get('relatedResourceKind'),
            'IncidentID': incident_id
        }
        return formatted_data


    def entity_related_resource_data_to_xsoar_format(resource_data, entity_id):
        """
        Convert the entity relation from the raw to XSOAR format.

        :param resource_data: (dict) The related resource raw data.
        :param entity_id: The entity id.
        """
        properties = resource_data.get('properties', {})

        formatted_data = {
            'ID': properties.get('relatedResourceName'),
            'Kind': properties.get('relatedResourceKind'),
            'EntityID': entity_id
        }
        return formatted_data


    def severity_to_level(severity):
        """
        Maps severity to a level represented by number.
        """
        if severity == 'Informational':
            return 0.5
        elif severity == 'Low':
            return 1
        elif severity == 'Medium':
            return 2
        elif severity == 'High':
            return 3
        return 0


    def generic_list_incident_items(client, incident_id, items_kind, key_in_raw_result, outputs_prefix, xsoar_transformer):
        """
        Get a list of incident's items

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param incident_id:  (str) the incident id.
        :param items_kind: (str) the name of the entity e.g. entities, alerts.
        :param key_in_raw_result: (str) the key hold the relevant result in the raw data.
        :param outputs_prefix: (str) the context output key that will hold the command result.
        :param xsoar_transformer: (function) a function to transform the raw data to xsoar format.
        """

        url_suffix = f'incidents/{incident_id}/{items_kind}'

        result = client.http_request('POST', url_suffix)
        raw_items = result.get(key_in_raw_result, [])
        items = [dict(IncidentId=incident_id, **xsoar_transformer(item)) for item in raw_items]

        readable_output = tableToMarkdown(f'Incident {incident_id} {items_kind.capitalize()} ({len(items)} results)', items,
                                          headers=['ID', 'Kind', 'IncidentId'],
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs=items,
            outputs_prefix=outputs_prefix,
            outputs_key_field=['ID', 'IncidentId'],
            raw_response=result
        )


    ''' MIRRORING COMMANDS '''


    def add_mirroring_fields(incident: Dict):
        """
            Updates the given incident to hold the needed mirroring fields.
        """
        incident['mirror_direction'] = MIRROR_DIRECTION
        incident['mirror_instance'] = INTEGRATION_INSTANCE


    def get_modified_remote_data_command(client: AzureSentinelClient, args: Dict[str, Any]) -> GetModifiedRemoteDataResponse:
        """
        Gets the modified remote incidents IDs.
        Args:
            client: The client object.
            args: The command arguments.

        Returns:
            GetModifiedRemoteDataResponse object, which contains a list of the modified incidents IDs.
        """
        remote_args = GetModifiedRemoteDataArgs(args)
        last_update = dateparser.parse(remote_args.last_update, settings={'TIMEZONE': 'UTC'}).strftime(  # type: ignore[union-attr]
            DATE_FORMAT_WITH_MILLISECONDS)
        demisto.debug(f'Getting modified incidents from {last_update}')

        raw_incidents = []

        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None
            params = None if full_url else {'$filter': f'properties/lastModifiedTimeUtc ge {last_update}'}

            response = client.http_request('GET', 'incidents', full_url=full_url, params=params)
            raw_incidents += response.get('value', [])
            next_link = response.get('nextLink')

        modified_ids_to_mirror = [raw_incident.get('name') for raw_incident in raw_incidents]

        demisto.debug(f'All ids to mirror in are: {modified_ids_to_mirror}')
        return GetModifiedRemoteDataResponse(modified_ids_to_mirror)


    def get_remote_incident_data(client: AzureSentinelClient, incident_id: str):
        """
        Gets the remote incident data.
        Args:
            client: The client object.
            incident_id: The incident ID to retrieve.

        Returns:
            mirrored_data: The raw mirrored data.
            updated_object: The updated object to set in the XSOAR incident.
        """
        mirrored_data = client.http_request('GET', f'incidents/{incident_id}')
        incident_mirrored_data = incident_data_to_xsoar_format(mirrored_data, is_fetch_incidents=True)
        fetch_incidents_additional_info(client, incident_mirrored_data)
        updated_object: Dict[str, Any] = {}

        for field in INCOMING_MIRRORED_FIELDS:
            if value := incident_mirrored_data.get(field):
                updated_object[field] = value

        return mirrored_data, updated_object


    def set_xsoar_incident_entries(updated_object: Dict[str, Any], entries: List, remote_incident_id: str) -> None:
        """
        Sets the XSOAR incident entries.
        Args:
            updated_object: The updated object to set in the XSOAR incident.
            entries: The entries to set.
            remote_incident_id: The remote incident ID.
        Returns:
            None.
        """
        if demisto.params().get('close_incident'):
            if updated_object.get('Status') == 'Closed':
                close_reason = updated_object.get('classification', '')
                close_notes = updated_object.get('classificationComment', '')
                close_in_xsoar(entries, remote_incident_id, close_reason, close_notes)
            elif updated_object.get('Status') in ('New', 'Active'):
                reopen_in_xsoar(entries, remote_incident_id)


    def close_in_xsoar(entries: List, remote_incident_id: str, close_reason: str, close_notes: str) -> None:
        demisto.debug(f'Incident is closed: {remote_incident_id}')
        entries.append({
            'Type': EntryType.NOTE,
            'Contents': {
                'dbotIncidentClose': True,
                'closeReason': MIRROR_STATUS_DICT.get(close_reason, close_reason),
                'closeNotes': f'{close_notes}\nClosed on Microsoft Sentinel'.strip()
            },
            'ContentsFormat': EntryFormat.JSON
        })


    def reopen_in_xsoar(entries: List, remote_incident_id: str):
        demisto.debug(f'Incident is opened (or reopened): {remote_incident_id}')
        entries.append({
            'Type': EntryType.NOTE,
            'Contents': {
                'dbotIncidentReopen': True
            },
            'ContentsFormat': EntryFormat.JSON
        })


    def get_remote_data_command(client: AzureSentinelClient, args: Dict[str, Any]) -> GetRemoteDataResponse:
        """
        Args:
            client: The client object.
            args: The command arguments.
        Returns:
            GetRemoteDataResponse object, which contain the incident data to update.
        """
        remote_args = GetRemoteDataArgs(args)
        remote_incident_id = remote_args.remote_incident_id

        mirrored_data: Dict[str, Any] = {}
        entries: list = []

        try:
            demisto.debug(f'Performing get-remote-data command with incident id: {remote_incident_id} '
                          f'and last_update: {remote_args.last_update}')

            mirrored_data, updated_object = get_remote_incident_data(client, remote_incident_id)
            if updated_object:
                demisto.debug(f'Update incident {remote_incident_id} with fields: {updated_object}')
                set_xsoar_incident_entries(updated_object, entries, remote_incident_id)

            return GetRemoteDataResponse(mirrored_object=updated_object, entries=entries)

        except Exception as e:
            demisto.debug(f"Error in Microsoft Sentinel incoming mirror for incident: {remote_incident_id}\n"
                          f"Error message: {str(e)}")

            if not mirrored_data:
                mirrored_data = {'id': remote_incident_id}
            mirrored_data['in_mirror_error'] = str(e)

            return GetRemoteDataResponse(mirrored_object=mirrored_data, entries=[])


    def get_mapping_fields_command() -> GetMappingFieldsResponse:
        mapping_response = GetMappingFieldsResponse()
        incident_type_scheme = SchemeTypeMapping(type_name='Microsoft Sentinel Incident')

        for argument, description in OUTGOING_MIRRORED_FIELDS.items():
            incident_type_scheme.add_field(name=argument, description=description)
        mapping_response.add_scheme_type(incident_type_scheme)

        return mapping_response


    def close_incident_in_remote(delta: Dict[str, Any], data: Dict[str, Any]) -> bool:
        """
        Closing in the remote system should happen only when both:
            1. The user asked for it
            2. A closing reason was provided (either in the delta or before in the data).
        """
        closing_field = 'classification'
        closing_reason = delta.get(closing_field, data.get(closing_field, ''))
        return demisto.params().get('close_ticket') and bool(closing_reason)


    def update_incident_request(client: AzureSentinelClient, incident_id: str, data: Dict[str, Any], delta: Dict[str, Any],
                                close_ticket: bool = False) -> Dict[str, Any]:
        """
        Args:
            client (AzureSentinelClient)
            incident_id (str): the incident ID
            data (Dict[str, Any]): all the data of the incident
            delta (Dict[str, Any]): the delta of the changes in the incident's data
            close_ticket (bool, optional): whether to close the ticket or not (defined by the close_incident_in_remote).
                                           Defaults to False.

        Returns:
            Dict[str, Any]: the response of the update incident request
        """
        fetched_incident_data = get_incident_by_id_command(client, {'incident_id': incident_id}).raw_response
        required_fields = ('severity', 'status', 'title')
        if any(field not in data for field in required_fields):
            raise DemistoException(f'Update incident request is missing one of the required fields for the '
                                   f'API: {required_fields}')
        properties = {
            'title': data.get('title'),
            'description': delta.get('description'),
            'severity': LEVEL_TO_SEVERITY[data.get('severity', '')],
            'status': 'Active',
            'firstActivityTimeUtc': delta.get('firstActivityTimeUtc'),
            'lastActivityTimeUtc': delta.get('lastActivityTimeUtc'),
            'owner': demisto.get(fetched_incident_data, 'properties.owner', {}),
            'labels': demisto.get(fetched_incident_data, 'properties.labels', [])
        }

        properties['labels'] += [{'labelName': label, 'type': 'User'} for label in delta.get('tags', [])]

        if close_ticket:
            properties |= {
                'status': 'Closed',
                'classification': delta.get('classification') or data.get('classification'),
                'classificationComment': delta.get('classificationComment') or data.get('classificationComment'),
                'classificationReason': CLASSIFICATION_REASON.get(delta.get('classification', data.get('classification', '')))
            }
        remove_nulls_from_dictionary(properties)
        data = {
            'etag': fetched_incident_data.get('etag') or delta.get('etag') or data.get('etag'),
            'properties': properties
        }
        demisto.debug(f'Updating incident with remote ID {incident_id} with data: {data}')
        response = client.http_request('PUT', f'incidents/{incident_id}', data=data)
        return response


    def update_remote_incident(client: AzureSentinelClient, data: Dict[str, Any], delta: Dict[str, Any],
                               incident_status: IncidentStatus, incident_id: str) -> str:
        if incident_status == IncidentStatus.DONE:
            if close_incident_in_remote(delta, data):
                demisto.debug(f'Closing incident with remote ID {incident_id} in remote system.')
                return str(update_incident_request(client, incident_id, data, delta, close_ticket=True))
            elif delta.keys() <= {'classification', 'classificationComment'}:
                demisto.debug(f'Incident with remote ID {incident_id} is closed in XSOAR, '
                              'but not in the remote system ("Close Mirrored Microsoft Sentinel Ticket" parameter is not set).')
                return ''
            else:  # The delta contains fields that are not related to closing the incident and close_incident_in_remote() is False
                demisto.debug(f'Updating incident with remote ID {incident_id} in remote system (but not closing it).')
                return str(update_incident_request(client, incident_id, data, delta))

        elif incident_status == IncidentStatus.ACTIVE:
            demisto.debug(f'Updating incident with remote ID {incident_id} in remote system.')
            return str(update_incident_request(client, incident_id, data, delta))

        demisto.debug(f'Incident with remote ID {incident_id} is not Active or Closed, not updating. (status: {incident_status})')
        return ''


    def update_remote_system_command(client: AzureSentinelClient, args: Dict[str, Any]):
        """ Mirrors out local changes to the remote system.
        Args:
            client: The client object.
            args: The command arguments.
        Returns:
            The remote incident id that was modified. This is important when the incident is newly created remotely.
        """
        parsed_args = UpdateRemoteSystemArgs(args)
        delta = parsed_args.delta
        data = parsed_args.data
        remote_incident_id = parsed_args.remote_incident_id
        demisto.debug(f'Got the following data {data}, and delta {delta}.')
        if parsed_args.incident_changed and delta:
            demisto.debug(f'Got the following delta keys {list(delta.keys())}.')
            try:
                if result := update_remote_incident(
                    client, data, delta, parsed_args.inc_status, remote_incident_id
                ):
                    demisto.debug(f'Incident updated successfully. Result: {result}')

            except Exception as e:
                demisto.error(f'Error in Microsoft Sentinel outgoing mirror for incident {remote_incident_id}. '
                              f'Error message: {str(e)}')
        else:
            demisto.debug(f"Skipping updating remote incident {remote_incident_id} as it didn't change.")

        return remote_incident_id


    ''' INTEGRATION COMMANDS '''


    def get_incident_by_id_command(client, args):
        inc_id = args.get('incident_id')
        url_suffix = f'incidents/{inc_id}'

        result = client.http_request('GET', url_suffix)
        incident = incident_data_to_xsoar_format(result)
        readable_output = tableToMarkdown(f'Incident {inc_id} details', incident, url_keys=['IncidentUrl'],
                                          headers=INCIDENT_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.Incident',
            outputs=incident,
            outputs_key_field='ID',
            raw_response=result
        )


    def test_module(client: AzureSentinelClient, _: Dict[str, Any]):
        """
        Test connection to Azure by calling the list incidents API with limit=1
        """
        client.http_request('GET', 'incidents', params={'$top': 1})
        return 'ok'


    def list_incidents_command(client: AzureSentinelClient, args, is_fetch_incidents=False):
        """ Retrieves incidents from Sentinel.
        Args:
            client: An AzureSentinelClient client.
            args: Demisto args.
            is_fetch_incidents: Is it part of a fetch incidents command.
        Returns:
            A CommandResult object with the array of incidents as output.
        """
        filter_expression = args.get('filter')
        limit = min(DEFAULT_LIMIT, int(args.get('limit')))
        next_link = args.get('next_link', '')

        if next_link:
            next_link = next_link.replace('%20', ' ')  # Next link syntax can't handle '%' character
            result = client.http_request('GET', full_url=next_link)
        else:
            url_suffix = 'incidents'
            params = {
                '$top': limit,
                '$filter': filter_expression,
                '$orderby': args.get('orderby', 'properties/createdTimeUtc asc')
            }
            remove_nulls_from_dictionary(params)

            result = client.http_request('GET', url_suffix, params=params)

        incidents = [incident_data_to_xsoar_format(inc, is_fetch_incidents) for inc in result.get('value')]

        if is_fetch_incidents:
            return CommandResults(outputs=incidents, outputs_prefix='AzureSentinel.Incident')

        outputs = {'AzureSentinel.Incident(val.ID === obj.ID)': incidents}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(f'Incidents List ({len(incidents)} results)', incidents,
                                          headers=INCIDENT_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            raw_response=result
        )


    def list_watchlists_command(client, args):
        url_suffix = 'watchlists'
        specific_watchlists_alias = args.get('watchlist_alias')
        if specific_watchlists_alias:
            url_suffix += f'/{specific_watchlists_alias}'

        result = client.http_request('GET', url_suffix)

        iterable_watchlists = [result] if specific_watchlists_alias else result.get('value')
        watchlists = [watchlist_data_to_xsoar_format(watchlist) for watchlist in iterable_watchlists]
        readable_output = tableToMarkdown('Watchlists results', watchlists,
                                          headers=['Name', 'ID', 'Description'],
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.Watchlist',
            outputs=watchlists,
            outputs_key_field='ID',
            raw_response=result
        )


    def delete_watchlist_command(client, args):
        alias = args.get('watchlist_alias')
        url_suffix = f'watchlists/{alias}'
        client.http_request('DELETE', url_suffix)
        return CommandResults(readable_output=f'Watchlist {alias} was deleted successfully.')


    def delete_watchlist_item_command(client, args):
        alias = args.get('watchlist_alias')
        item_id = args.get('watchlist_item_id')
        url_suffix = f'watchlists/{alias}/watchlistItems/{item_id}'
        client.http_request('DELETE', url_suffix)
        return CommandResults(readable_output=f'Watchlist item {item_id} was deleted successfully.')


    def create_update_watchlist_command(client, args):
        """ Create or update a watchlist in Azure Sentinel.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get('watchlist_alias')
        raw_content = ''
        path = args.get('file_entry_id')
        if path:
            path = demisto.getFilePath(path)
            with open(path['path'], 'rb') as file:
                raw_content = file.read().decode()
        data = {
            'properties': {
                'watchlistAlias': alias,
                'displayName': args.get('watchlist_display_name'),
                'description': args.get('description', ''),
                'provider': args.get('provider', 'XSOAR'),
                'source': 'Local file',
                'labels': argToList(args.get('labels', ''), ','),
                'numberOfLinesToSkip': arg_to_number(args.get('lines_to_skip', '0')),
                'rawContent': raw_content,
                'itemsSearchKey': args.get('items_search_key'),
                'contentType': args.get('content_type', 'Text/Csv'),
            }
        }

        # request
        raw_result = client.http_request('PUT', url_suffix=f'watchlists/{alias}', data=data)

        # prepare result
        watchlist = watchlist_data_to_xsoar_format(raw_result)

        readable_output = tableToMarkdown('Create watchlist results', watchlist,
                                          headers=['Name', 'ID', 'Description'],
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.Watchlist',
            outputs=watchlist,
            outputs_key_field='ID',
            raw_response=raw_result
        )


    def create_update_watchlist_item_command(client, args):
        """ Create or update a watchlist item in Azure Sentinel.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get('watchlist_alias')
        watchlist_item_id = args.get('watchlist_item_id', uuid.uuid4())
        item_key_value_str = args.get('item_key_value', '{}')
        item_key_value = json.loads(item_key_value_str)
        item_data = {
            'properties': {
                'itemsKeyValue': item_key_value
            }
        }

        # request
        url_suffix = f'watchlists/{alias}/watchlistItems/{watchlist_item_id}'
        raw_item = client.http_request('PUT', url_suffix=url_suffix, data=item_data)

        # prepare result
        item = {'WatchlistAlias': alias, **watchlist_item_data_to_xsoar_format(raw_item)}
        readable_output = tableToMarkdown('Create watchlist item results', item,
                                          headers=['ID', 'ItemsKeyValue'],
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.WatchlistItem',
            outputs=item,
            outputs_key_field='ID',
            raw_response=raw_item
        )


    def list_watchlist_items_command(client, args):
        """
        Get specific watchlist item or list of watchlist items.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        # prepare the request
        alias = args.get('watchlist_alias', '')
        url_suffix = f'watchlists/{alias}/watchlistItems'
        item_id = args.get('watchlist_item_id')
        if item_id:
            url_suffix += f'/{item_id}'

        # request
        result = client.http_request('GET', url_suffix)

        # prepare result
        raw_items = [result] if item_id else result.get('value')
        items = [{'WatchlistAlias': alias, **watchlist_item_data_to_xsoar_format(item)} for item in raw_items]
        readable_output = tableToMarkdown('Watchlist items results', items,
                                          headers=['ID', 'ItemsKeyValue'],
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.WatchlistItem',
            outputs=items,
            outputs_key_field='ID',
            raw_response=result
        )


    def update_incident_command(client: AzureSentinelClient, args: Dict[str, Any]):
        inc_id = args.get('incident_id')
        inc_data = get_update_incident_request_data(client, args)

        url_suffix = f'incidents/{inc_id}'
        result = client.http_request('PUT', url_suffix, data=inc_data)
        incident = incident_data_to_xsoar_format(result)
        readable_output = tableToMarkdown(f'Updated incidents {inc_id} details', incident,
                                          headers=INCIDENT_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.Incident',
            outputs=incident,
            outputs_key_field='ID',
            raw_response=result
        )


    def delete_incident_command(client, args):
        inc_id = args.get('incident_id')
        url_suffix = f'incidents/{inc_id}'

        client.http_request('DELETE', url_suffix)

        context = {
            'ID': inc_id,
            'Deleted': True
        }

        return CommandResults(
            readable_output=f'Incident {inc_id} was deleted successfully.',
            outputs_prefix='AzureSentinel.Incident',
            outputs=context,
            outputs_key_field='ID',
            raw_response={}
        )


    def list_incident_comments_command(client, args):
        inc_id = args.get('incident_id')
        limit = min(DEFAULT_LIMIT, int(args.get('limit')))
        next_link = args.get('next_link', '')

        if next_link:
            next_link = next_link.replace('%20', ' ')  # Next link syntax can't handle '%' character
            result = client.http_request('GET', full_url=next_link)
        else:
            url_suffix = f'incidents/{inc_id}/comments'
            params = {'$top': limit}
            remove_nulls_from_dictionary(params)

            result = client.http_request('GET', url_suffix, params=params)

        comments = [comment_data_to_xsoar_format(inc, inc_id) for inc in result.get('value')]

        outputs = {f'AzureSentinel.IncidentComment(val.ID === obj.ID && val.IncidentID === {inc_id})': comments}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(f'Incident {inc_id} Comments ({len(comments)} results)', comments,
                                          headers=COMMENT_HEADERS,  # disable-secrets-detection
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            raw_response=result
        )


    def incident_add_comment_command(client, args):
        import random

        inc_id = args.get('incident_id')
        url_suffix = f'incidents/{inc_id}/comments/{str(random.getrandbits(128))}'
        comment_data = {
            'properties': {
                'message': args.get('message')
            }
        }

        result = client.http_request('PUT', url_suffix, data=comment_data)
        comment = comment_data_to_xsoar_format(result, inc_id)

        readable_output = tableToMarkdown(f'Incident {inc_id} new comment details', comment,
                                          headers=COMMENT_HEADERS,  # disable-secrets-detection
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.IncidentComment',
            outputs=comment,
            outputs_key_field=['ID', 'IncidentID'],
            raw_response=result
        )


    def incident_delete_comment_command(client, args):
        inc_id = args.get('incident_id')
        comment_id = args.get('comment_id')
        url_suffix = f'incidents/{inc_id}/comments/{comment_id}'

        res = client.http_request('DELETE', url_suffix)
        if isinstance(res, requests.Response) and res.status_code == 204:
            readable_output = f'Comment {comment_id} does not exist.'
        else:
            readable_output = f'Comment {comment_id} was deleted successfully.'

        return CommandResults(readable_output=readable_output)


    def list_incident_entities_command(client, args):
        """
        Get a list of incident's entities.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """

        def xsoar_transformer(entity):
            return {
                'ID': entity.get('name'),
                'Kind': entity.get('kind'),
                'Properties': entity.get('properties')
            }

        return generic_list_incident_items(
            client=client, incident_id=args.get('incident_id'),
            items_kind='entities', key_in_raw_result='entities',
            outputs_prefix='AzureSentinel.IncidentEntity',
            xsoar_transformer=xsoar_transformer
        )


    def list_incident_alerts_command(client, args):
        """
        Get a list of incident's alerts.

        :param client: (AzureSentinelClient) The Azure Sentinel client to work with.
        :param args:  (dict) arguments for this command.
        """
        return generic_list_incident_items(
            client=client, incident_id=args.get('incident_id'),
            items_kind='alerts', key_in_raw_result='value',
            outputs_prefix='AzureSentinel.IncidentAlert',
            xsoar_transformer=alert_data_to_xsoar_format
        )


    def list_incident_relations_command(client, args):
        inc_id = args.get('incident_id')
        limit = min(50, int(args.get('limit')))
        next_link = args.get('next_link', '')
        entity_kinds = args.get('entity_kinds')
        filter_expression = args.get('filter', '')

        if next_link:
            next_link = next_link.replace('%20', ' ')  # Next link syntax can't handle '%' character
            result = client.http_request('GET', full_url=next_link)
        else:
            # Handle entity kinds to filter by
            if entity_kinds:
                if filter_expression:
                    filter_expression += ' and '
                filter_expression += f"search.in(properties/relatedResourceKind, '{entity_kinds}', ',')"

            url_suffix = f'incidents/{inc_id}/relations'
            params = {
                '$top': limit,
                '$filter': filter_expression
            }
            remove_nulls_from_dictionary(params)

            result = client.http_request('GET', url_suffix, params=params)

        relations = [
            incident_related_resource_data_to_xsoar_format(resource, inc_id) for resource in result.get('value')
        ]

        outputs = {f'AzureSentinel.IncidentRelatedResource(val.ID === obj.ID && val.IncidentID == {inc_id})': relations}

        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(f'Incident {inc_id} Relations ({len(relations)} results)', relations,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)
        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            raw_response=result
        )


    def update_next_link_in_context(result: dict, outputs: dict):
        """
        Update the output context with the next link if exist
        """
        # we don't want whitespaces in this value, so it won't be considered as two arguments in the CLI by mistake
        next_link = result.get('nextLink', '').replace(' ', '%20')
        if next_link:
            next_link_item = {
                'Description': NEXT_LINK_DESCRIPTION,
                'URL': next_link,
            }
            outputs[f'AzureSentinel.NextLink(val.Description == "{NEXT_LINK_DESCRIPTION}")'] = next_link_item


    def fetch_incidents_additional_info(client: AzureSentinelClient, incidents: List | Dict):
        """Fetches additional info of an incidents array or a single incident.

        Args:
            client: An AzureSentinelClient client.
            incidents: An incidents array or a single incident to fetch additional info for.

        Returns:
            None. Updates the incidents array with the additional info.
        """
        additional_fetch = {'Alerts': {'method': 'POST', 'result_key': 'value'},
                            'Entities': {'method': 'POST', 'result_key': 'entities'},
                            'Comments': {'method': 'GET', 'result_key': 'value'},
                            'Relations': {'method': 'GET', 'result_key': 'value'}}

        if isinstance(incidents, dict):
            incidents = [incidents]

        for incident in incidents:
            for additional_info in demisto.params().get('fetch_additional_info', []):
                info_type = additional_info.lower()
                method = additional_fetch[additional_info]['method']
                results_key = additional_fetch[additional_info]['result_key']
                incident_id = incident.get('ID')

                incident[info_type] = client.http_request(method, f'incidents/{incident_id}/{info_type}').get(results_key)


    def fetch_incidents(client: AzureSentinelClient, last_run: dict, first_fetch_time: str, min_severity: int) -> tuple:
        """Fetching incidents.
        Args:
            first_fetch_time: The first fetch time.
            client: An AzureSentinelClient client.
            last_run: An dictionary of the last run.
            min_severity: A minimum severity of incidents to fetch.

        Returns:
            (tuple): 1. The LastRun object updated with the last run details.
            2. An array of incidents.

        """
        # Get the last fetch details, if exist
        limit = demisto.params().get("limit", DEFAULT_LIMIT)
        last_fetch_time = last_run.get('last_fetch_time')
        last_fetch_ids = last_run.get('last_fetch_ids', [])
        last_incident_number = last_run.get('last_incident_number')
        demisto.debug(f"{last_fetch_time=}, {last_fetch_ids=}, {last_incident_number=}")

        if last_fetch_time is None or not last_incident_number:
            demisto.debug("handle via timestamp")
            if last_fetch_time is None:
                last_fetch_time_str, _ = parse_date_range(first_fetch_time, DATE_FORMAT)
                latest_created_time = dateparser.parse(last_fetch_time_str)
                if not latest_created_time:
                    raise DemistoException(f'Got empty latest_created_time. {last_fetch_time_str=} {last_fetch_time=}')
            else:
                latest_created_time = dateparser.parse(last_fetch_time)
                if not latest_created_time:
                    raise DemistoException(f'Got empty latest_created_time. {last_fetch_time=}')

            latest_created_time_str = latest_created_time.strftime(DATE_FORMAT)
            command_args = {
                'filter': f'properties/createdTimeUtc ge {latest_created_time_str}',
                'orderby': 'properties/createdTimeUtc asc',
                'limit': limit
            }

        else:
            demisto.debug("last fetch time is empty, trying to fetch incidents by last incident id")
            latest_created_time = dateparser.parse(last_fetch_time)
            if latest_created_time is None:
                raise DemistoException(f"{last_fetch_time=} couldn't be parsed")
            command_args = {
                'filter': f'properties/incidentNumber gt {last_incident_number}',
                'orderby': 'properties/incidentNumber asc',
                'limit': limit
            }

        raw_incidents = list_incidents_command(client, command_args, is_fetch_incidents=True).outputs
        if isinstance(raw_incidents, dict):
            raw_incidents = [raw_incidents]
        demisto.debug(f"raw incidents id before dedup: {[incident['ID'] for incident in raw_incidents]}")
        raw_incidents = list(filter(lambda incident: incident['ID'] not in last_fetch_ids, raw_incidents))
        demisto.debug(f"raw incidents id after dedup: {[incident['ID'] for incident in raw_incidents]}")

        fetch_incidents_additional_info(client, raw_incidents)

        return process_incidents(raw_incidents, min_severity,
                                 latest_created_time, last_incident_number)  # type: ignore[attr-defined]


    def fetch_incidents_command(client, params):
        # How much time before the first fetch to retrieve incidents
        first_fetch_time = params.get('fetch_time', '3 days').strip()
        min_severity = severity_to_level(params.get('min_severity', 'Informational'))
        # Set and define the fetch incidents command to run after activated via integration settings.
        last_run = demisto.getLastRun()
        demisto.debug(f"Current last run is {last_run}")
        next_run, incidents = fetch_incidents(
            client=client,
            last_run=last_run,
            first_fetch_time=first_fetch_time,
            min_severity=min_severity
        )
        demisto.debug(f"New last run is {last_run}")
        demisto.setLastRun(next_run)
        demisto.incidents(incidents)


    def process_incidents(raw_incidents: list, min_severity: int, latest_created_time: datetime,
                          last_incident_number):
        """Processing the raw incidents
        Args:
            raw_incidents: The incidents that were fetched from the API.
            last_incident_number: The last incident number that was fetched.
            latest_created_time: The latest created time.
            min_severity: The minimum severity.

        Returns:
            A next_run dictionary, and an array of incidents.
        """

        incidents = []
        current_fetch_ids = []
        if not last_incident_number:
            last_incident_number = 0

        for incident in raw_incidents:
            incident_severity = severity_to_level(incident.get('Severity'))
            demisto.debug(f"{incident.get('ID')=}, {incident_severity=}, {incident.get('IncidentNumber')=}")

            incident_created_time = dateparser.parse(incident.get('CreatedTimeUTC'))
            current_fetch_ids.append(incident.get('ID'))
            if incident_severity >= min_severity:
                add_mirroring_fields(incident)
                xsoar_incident = {
                    'name': '[Azure Sentinel] ' + incident.get('Title'),
                    'occurred': incident.get('CreatedTimeUTC'),
                    'severity': incident_severity,
                    'rawJSON': json.dumps(incident)
                }
                incidents.append(xsoar_incident)
            else:
                demisto.debug(f"drop creation of {incident.get('IncidentNumber')=} "
                              f"due to the {incident_severity=} is lower then {min_severity=}")

            # Update last run to the latest fetch time
            if incident_created_time is None:
                raise DemistoException(f"{incident.get('CreatedTimeUTC')=} couldn't be parsed")

            if incident_created_time > latest_created_time:
                latest_created_time = incident_created_time
            if incident.get('IncidentNumber') > last_incident_number:
                last_incident_number = incident.get('IncidentNumber')
        next_run = {
            'last_fetch_time': latest_created_time.strftime(DATE_FORMAT),
            'last_fetch_ids': current_fetch_ids,
            'last_incident_number': last_incident_number,
        }
        return next_run, incidents


    def threat_indicators_data_to_xsoar_format(ind_data):
        """
        Convert the threat indicators data from the raw to XSOAR format.

        :param ind_data: (dict) The incident raw data.
        """

        properties = ind_data.get('properties', {})
        pattern = properties.get('parsedPattern', [])[0] if properties.get('parsedPattern', []) else {}

        formatted_data = {
            'ID': ind_data.get('id'),
            'Name': ind_data.get('name'),
            'ETag': ind_data.get('etag'),
            'Type': ind_data.get('type'),
            'Kind': ind_data.get('kind'),

            'Confidence': properties.get('confidence', ''),
            'Created': format_date(properties.get('created', '')),
            'CreatedByRef': properties.get('createdByRef', ''),
            'ExternalId': properties.get('externalId', ''),
            'LastUpdatedTimeUtc': format_date(properties.get('lastUpdatedTimeUtc', '')),
            'Revoked': properties.get('revoked', ''),
            'Source': properties.get('source', ''),
            'Tags': properties.get('threatIntelligenceTags', 'No Tags'),
            'DisplayName': properties.get('displayName', ''),
            'Description': properties.get('description', ''),
            'Types': properties.get('threatTypes', ''),
            'KillChainPhases': [{
                'KillChainName': phase.get('killChainName'),
                'PhaseName': phase.get('phaseName')
            } for phase in properties.get('KillChainPhases', [])],
            'ParsedPattern': {
                'PatternTypeKey': pattern.get('patternTypeKey'),
                'PatternTypeValues': {
                    'Value': dict_safe_get(pattern, ['patternTypeValues', 0, 'value']),
                    'ValueType': dict_safe_get(pattern, ['patternTypeValues', 0, 'valueType']),
                }
            } if pattern else None,

            'Pattern': properties.get('pattern', ''),
            'PatternType': properties.get('patternType', ''),
            'ValidFrom': format_date(properties.get('validFrom', '')),
            'ValidUntil': format_date(properties.get('validUntil', '')),
            'Values': dict_safe_get(pattern, ['patternTypeValues', 0, 'value']),
            'Deleted': False
        }
        remove_nulls_from_dictionary(formatted_data)

        return formatted_data


    def build_query_filter(args):
        filtering_args = {
            'minConfidence': args.get('min_confidence', ''),
            'maxConfidence': args.get('max_confidence', ''),
            'minValidUntil': format_date(args.get('min_valid_from', '')),
            'maxValidUntil': format_date(args.get('max_valid_from', '')),
            'sources': argToList(args.get('sources')),
            'keywords': ' '.join(argToList(args.get('keywords'))),
            'threatTypes': argToList(args.get('threat_types')),
            'patternTypes': []
        }

        indicator_types = argToList(args.get('indicator_types'))
        if indicator_types:
            for ind_type in indicator_types:
                pattern_type = {
                    'ipv4': '{ind_type}-address',
                    'ipv6': '{ind_type}-address',
                    'domain': '{ind_type}-name',
                }.get(ind_type, "{ind_type}").format(ind_type=ind_type)
                filtering_args['patternTypes'].append(pattern_type)

        include_disabled = args.get('include_disabled', 'false') == 'true'
        filtering_args['includeDisabled'] = include_disabled

        remove_nulls_from_dictionary(filtering_args)

        return filtering_args


    def build_threat_indicator_data(args, source):
        value = args.get('value')

        data = {
            'displayName': args.get('display_name'),
            'description': args.get('description'),
            'revoked': args.get('revoked', ''),
            'confidence': arg_to_number(args.get('confidence')),
            'threatTypes': argToList(args.get('threat_types')),
            'includeDisabled': args.get('include_disabled', ''),
            'source': source,
            'threatIntelligenceTags': argToList(args.get('tags')),
            'validFrom': format_date(args.get('valid_from', '')),
            'validUntil': format_date(args.get('valid_until', '')),
            'createdByRef': args.get('created_by', ''),
        }

        indicator_type = args.get('indicator_type')
        if indicator_type == 'ipv4':
            indicator_type = 'ipv4-addr'
        elif indicator_type == 'ipv6':
            indicator_type = 'ipv6-addr'
        elif indicator_type == 'domain':
            indicator_type = 'domain-name'

        data['patternType'] = indicator_type

        if indicator_type == 'file':
            hash_type = args.get('hash_type')
            data['hashType'] = hash_type
            data['pattern'] = f"[file:hashes.'{hash_type}' = '{value}']"
        else:
            data['pattern'] = f"[{indicator_type}:value = '{value}']"

        data['killChainPhases'] = []

        kill_chains = argToList(args.get('kill_chains', []))
        if kill_chains:
            for kill_chain_phase in kill_chains:
                data['killChainPhases'].append(
                    {'killChainName': kill_chain_phase,
                     'phaseName': kill_chain_phase})

        remove_nulls_from_dictionary(data)

        return data


    def build_updated_indicator_data(new_ind_data, original_ind_data):
        original_extracted_data = extract_original_data_from_indicator(original_ind_data.get('properties'))
        # When updating an indicator, one can not change the original source
        source = original_extracted_data.get('source')
        new_data = build_threat_indicator_data(new_ind_data, source)

        original_extracted_data.update(new_data)

        return original_extracted_data


    def extract_original_data_from_indicator(original_data):
        extracted_data = {
            'description': original_data.get('description', ''),
            'revoked': original_data.get('revoked', ''),
            'confidence': arg_to_number(original_data.get('confidence')),
            'threatTypes': argToList(original_data.get('threatTypes')),
            'killChainPhases': argToList(original_data.get('killChainPhases')),
            'threatIntelligenceTags': argToList(original_data.get('threatIntelligenceTags')),
            'validFrom': original_data.get('validFrom', ''),
            'validUntil': original_data.get('validUntil', ''),
            'createdByRef': original_data.get('createdByRef', ''),
            'created': original_data.get('created', ''),
            'externalId': original_data.get('externalId'),
            'displayName': original_data.get('displayName'),
            'source': original_data.get('source', DEFAULT_SOURCE)
        }

        remove_nulls_from_dictionary(extracted_data)
        return extracted_data


    def list_threat_indicator_command(client, args):
        url_suffix = 'threatIntelligence/main/indicators'
        limit = arg_to_number(args.get('limit', DEFAULT_LIMIT))  # the default limit is 50

        next_link = args.get('next_link', '')
        if next_link:
            next_link = next_link.replace('%20', ' ')  # Next link syntax can't handle '%' character
            result = client.http_request('GET', full_url=next_link)
        else:
            if indicator_name := args.get('indicator_name'):
                url_suffix += f'/{indicator_name}'

            result = client.http_request('GET', url_suffix, params={'$top': limit})

        num_of_threat_indicators = 0
        threat_indicators = []

        if result.get('value'):
            threat_indicators = [threat_indicators_data_to_xsoar_format(ind) for ind in result.get('value')]
            num_of_threat_indicators = len(threat_indicators)

        outputs = {'AzureSentinel.ThreatIndicator': threat_indicators}
        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f'Threat Indicators ({num_of_threat_indicators} results)',
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True,
        )

        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            outputs_key_field='ID',
            raw_response=result
        )


    def query_threat_indicators_command(client, args):
        url_suffix = 'threatIntelligence/main/queryIndicators'
        limit = arg_to_number(args.get('limit', DEFAULT_LIMIT))  # the default limit is 50
        data = build_query_filter(args)
        next_link = args.get('next_link', '')
        if next_link:
            next_link = next_link.replace('%20', ' ')  # Next link syntax can't handle '%' character
            result = client.http_request('POST', full_url=next_link, data=data)
        else:

            result = client.http_request('POST', url_suffix, params={'$top': limit}, data=data)

        num_of_threat_indicators = 0
        threat_indicators = []

        if result.get('value') is not None:
            threat_indicators = [threat_indicators_data_to_xsoar_format(ind) for ind in result.get('value')]
            num_of_threat_indicators = len(threat_indicators)

        outputs = {'AzureSentinel.ThreatIndicator': threat_indicators}
        update_next_link_in_context(result, outputs)

        readable_output = tableToMarkdown(
            f'Threat Indicators ({num_of_threat_indicators} results)',
            threat_indicators,
            headers=THREAT_INDICATORS_HEADERS,
            headerTransform=pascalToSpace,
            removeNull=True
        )

        return CommandResults(
            readable_output=readable_output,
            outputs=outputs,
            outputs_key_field='ID',
            raw_response=result
        )


    def create_threat_indicator_command(client, args):
        url_suffix = 'threatIntelligence/main/createIndicator'

        data = {'kind': 'indicator', 'properties': build_threat_indicator_data(args, source=DEFAULT_SOURCE)}

        result = client.http_request('POST', url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        readable_output = tableToMarkdown('New threat Indicator was created', threat_indicators,
                                          headers=THREAT_INDICATORS_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.ThreatIndicator',
            outputs=threat_indicators,
            outputs_key_field='ID',
            raw_response=result
        )


    def update_threat_indicator_command(client, args):
        indicator_name = args.get('indicator_name')
        get_indicator_url_suffix = f'threatIntelligence/main/indicators/{indicator_name}'

        original_data = client.http_request('GET', get_indicator_url_suffix)

        updated_data = build_updated_indicator_data(args, original_data)

        data = {
            "kind": "indicator",
            "properties": updated_data
        }

        update_indicator_url_suffix = f'threatIntelligence/main/indicators/{indicator_name}'

        result = client.http_request('PUT', update_indicator_url_suffix, data=data)
        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        readable_output = tableToMarkdown(f'Threat Indicator {indicator_name} was updated',
                                          threat_indicators,
                                          headers=THREAT_INDICATORS_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.ThreatIndicator',
            outputs=threat_indicators,
            outputs_key_field='ID',
            raw_response=result
        )


    def delete_threat_indicator_command(client, args):
        indicator_names = argToList(args.get('indicator_names'))
        outputs = []

        for indicator_name in indicator_names:
            url_suffix = f'threatIntelligence/main/indicators/{indicator_name}'
            client.http_request('DELETE', url_suffix)
            outputs.append({
                'Name': indicator_name,
                'Deleted': True
            })

        return CommandResults(
            readable_output='Threat Intelligence Indicators ' + ', '.join(indicator_names)
                            + ' were deleted successfully',
            outputs_prefix='AzureSentinel.ThreatIndicator',
            outputs_key_field='Name',
            outputs=outputs,
            raw_response={},
        )


    def append_tags_threat_indicator_command(client, args):
        indicator_name = args.get('indicator_name')
        tags = argToList(args.get('tags'))
        url_suffix = f'threatIntelligence/main/indicators/{indicator_name}/appendTags'

        data = {'threatIntelligenceTags': tags}

        result = client.http_request('POST', url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        return CommandResults(
            readable_output=f'Tags were appended to {indicator_name} Threat Indicator.',
            outputs_prefix='AzureSentinel.ThreatIndicator',
            outputs=threat_indicators,
            outputs_key_field='ID',
            raw_response=result
        )


    def replace_tags_threat_indicator_command(client, args):
        indicator_name = args.get('indicator_name')
        tags = argToList(args.get('tags'))
        url_suffix = f'threatIntelligence/main/indicators/{indicator_name}/replaceTags'

        data = {
            "properties": {
                'threatIntelligenceTags': tags
            }
        }

        result = client.http_request('POST', url_suffix, data=data)

        threat_indicators = [threat_indicators_data_to_xsoar_format(result)]

        return CommandResults(
            readable_output=f'Tags were replaced to {indicator_name} Threat Indicator.',
            outputs_prefix='AzureSentinel.ThreatIndicator',
            outputs=threat_indicators,
            outputs_key_field='ID',
            raw_response=result
        )


    def list_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        limit = int(args.get('limit', 50))
        rule_id = args.get('rule_id')

        url_suffix = 'alertRules' + (f'/{rule_id}' if rule_id else '')

        raw_results = []
        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None

            response = client.http_request('GET', url_suffix, full_url=full_url)

            raw_results += [response] if rule_id else response.get('value', [])

            next_link = response.get('nextLink')
            if len(raw_results) >= limit:
                next_link = False

        raw_results = raw_results[:limit]

        readable_result = [
            {
                'ID': rule.get('name'),
                'Kind': rule.get('kind'),
                'Severity': rule.get('properties', {}).get('severity'),
                'Display Name': rule.get('properties', {}).get('displayName'),
                'Description': rule.get('properties', {}).get('description'),
                'Enabled': rule.get('properties', {}).get('enabled')
            } for rule in raw_results]
        tabel_name = 'Azure Sentinel Alert Rules' + (f' ({len(raw_results)} results)' if len(raw_results) > 1 else '')
        readable_output = tableToMarkdown(tabel_name, readable_result, sort_headers=False)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.AlertRule',
            outputs=raw_results,
            outputs_key_field='name',
            raw_response=raw_results
        )


    def list_alert_rule_template_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        limit = int(args.get('limit', 50))
        template_id = args.get('template_id')

        url_suffix = 'alertRuleTemplates' + (f'/{template_id}' if template_id else '')

        raw_results = []
        next_link = True
        while next_link:
            full_url = next_link if isinstance(next_link, str) else None

            response = client.http_request('GET', url_suffix, full_url=full_url)

            raw_results += [response] if template_id else response.get('value', [])

            next_link = response.get('nextLink')
            if len(raw_results) >= limit:
                next_link = False

        raw_results = raw_results[:limit]

        readable_result = [
            {
                'ID': rule.get('name'),
                'Kind': rule.get('kind'),
                'Severity': rule.get('properties', {}).get('severity'),
                'Display Name': rule.get('properties', {}).get('displayName'),
                'Description': rule.get('properties', {}).get('description'),
                'Status': rule.get('properties', {}).get('status'),
                'Created Date UTC': rule.get('properties', {}).get('createdDateUTC'),
                'Last Updated Date UTC': rule.get('properties', {}).get('lastUpdatedDateUTC'),
                'Alert Rules Created By Template Count': rule.get('properties', {}).get('alertRulesCreatedByTemplateCount'),
            } for rule in raw_results]
        tabel_name = 'Azure Sentinel Alert Rule Template' + (f' ({len(raw_results)} results)' if len(raw_results) > 1 else '')
        readable_output = tableToMarkdown(tabel_name, readable_result, sort_headers=False)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.AlertRuleTemplate',
            outputs=raw_results,
            outputs_key_field='name',
            raw_response=raw_results
        )


    def delete_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        rule_id = args.get('rule_id')
        url_suffix = f'alertRules/{rule_id}'
        response = client.http_request('DELETE', url_suffix)

        if isinstance(response, requests.Response) and response.status_code == 204:
            return CommandResults(readable_output=f'Alert rule {rule_id} does not exist.')

        return CommandResults(readable_output=f'Alert rule {rule_id} was deleted successfully.')


    def list_subscriptions_command(client: AzureSentinelClient) -> CommandResults:      # pragma: no cover

        full_url = urljoin(client.azure_cloud.endpoints.resource_manager, 'subscriptions?api-version=2020-01-01')

        response = client.http_request('GET', full_url=full_url)
        data_from_response = response.get('value', [])

        readable_output = tableToMarkdown(
            'Azure Sentinel Subscriptions',
            data_from_response,
            ['subscriptionId', 'tenantId', 'displayName', 'state'], removeNull=True,
            headerTransform=string_to_table_header)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.Subscription',
            outputs=data_from_response,
            outputs_key_field='subscriptionId',
            raw_response=response
        )


    def list_resource_groups_command(client: AzureSentinelClient,
                                     args: Dict[str, Any], subscription_id: str) -> CommandResults:     # pragma: no cover
        tag = args.get('tag')
        limit = arg_to_number(args.get('limit', 50))
        subscription_id = subscription_id

        # extracting the tag name and value from the tag argument that is received from the user as a string
        filter_by_tag = azure_tag_formatter(tag) if tag else ''

        full_url = urljoin(client.azure_cloud.endpoints.resource_manager, f'subscriptions/{subscription_id}/resourcegroups?$filter=\
    {filter_by_tag}&$top={limit}&api-version=2021-04-01')

        response = client.http_request('GET', full_url=full_url)
        data_from_response = response.get('value', [])

        readable_output = tableToMarkdown(
            'Azure Sentinel Resource Groups',
            data_from_response,
            ['name', 'location', 'tags', 'properties.provisioningState'], removeNull=True,
            headerTransform=string_to_table_header)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.ResourceGroup',
            outputs=data_from_response,
            outputs_key_field='name',
            raw_response=response
        )


    def validate_required_arguments_for_alert_rule(args: Dict[str, Any]) -> None:
        required_args_by_kind = {
            'fusion': ['rule_name', 'template_name', 'enabled'],
            'microsoft_security_incident_creation': ['rule_name', 'displayName', 'enabled', 'product_filter'],
            'scheduled': ['rule_name', 'displayName', 'enabled', 'query', 'query_frequency', 'query_period', 'severity',
                          'suppression_duration', 'suppression_enabled', 'trigger_operator', 'trigger_threshold']
        }

        kind = args.get('kind', '')
        if not kind:
            raise DemistoException('The "kind" argument is required for alert rule.')
        for arg in required_args_by_kind.get(kind, []):
            if not args.get(arg):
                raise DemistoException(f'"{arg}" is required for "{kind}" alert rule.')


    def create_data_for_alert_rule(args: Dict[str, Any]) -> Dict[str, Any]:
        validate_required_arguments_for_alert_rule(args)

        properties = {
            'alertRuleTemplateName': args.get('template_name'),
            'enabled': argToBoolean(args.get('enabled')) if args.get('enabled') else None,
            'displayName': args.get('displayName'),
            'productFilter': string_to_table_header(args.get('product_filter', '')),
            'description': args.get('description'),
            'displayNamesExcludeFilter': args.get('name_exclude_filter'),
            'displayNamesFilter': args.get('name_include_filter'),
            'severitiesFilter': args.get('severity_filter'),
            'query': args.get('query'),
            'queryFrequency': args.get('query_frequency'),
            'queryPeriod': args.get('query_period'),
            'severity': pascalToSpace(args.get('severity')),
            'suppressionDuration': args.get('suppression_duration'),
            'suppressionEnabled': argToBoolean(args.get('suppression_enabled')) if args.get('suppression_enabled') else None,
            'triggerOperator': underscoreToCamelCase(args.get('trigger_operator')),
            'triggerThreshold': args.get('trigger_threshold'),
            'tactics': argToList(args.get('tactics')),
            'techniques': argToList(args.get('techniques'))
        }
        remove_nulls_from_dictionary(properties)

        return {
            'kind': underscoreToCamelCase(args.get('kind')),
            'etag': args.get('etag'),
            'properties': properties
        }


    def create_and_update_alert_rule_command(client: AzureSentinelClient, args: Dict[str, Any]) -> CommandResults:
        rule_json = json.loads(args.get('rule_json', '')) if args.get('rule_json') else None
        data = rule_json or create_data_for_alert_rule(args)
        demisto.debug(f'Try to creating/updating alert rule with the following data: {data}')

        response = client.http_request('PUT', f'alertRules/{args.get("rule_name")}', data=data)

        readable_result = {
            'ID': response.get('id').split('/')[-1],
            'Name': response.get('name'),
            'Kind': response.get('kind'),
            'Severity': response.get('properties', {}).get('severity'),
            'Display Name': response.get('properties', {}).get('displayName'),
            'Description': response.get('properties', {}).get('description'),
            'Enabled': response.get('properties', {}).get('enabled'),
            'Etag': response.get('etag')
        }
        readable_output = tableToMarkdown('Azure Sentinel Alert Rule successfully created/updated',
                                          readable_result,
                                          removeNull=True,
                                          sort_headers=False)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureSentinel.AlertRule',
            outputs=response,
            outputs_key_field='name',
            raw_response=response
        )


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        args = demisto.args()
        command = demisto.command()

        demisto.debug(f'Command being called is {command}')
        try:
            client_secret = params.get('credentials', {}).get('password')
            certificate_thumbprint = params.get('creds_certificate', {}).get('identifier') or \
                params.get('certificate_thumbprint')
            private_key = (replace_spaces_in_credential(params.get('creds_certificate', {}).get('password'))
                           or params.get('private_key'))
            managed_identities_client_id = get_azure_managed_identities_client_id(params)
            if not managed_identities_client_id and not client_secret and not (certificate_thumbprint and private_key):
                raise DemistoException('Key or Certificate Thumbprint and Private Key must be provided.')

            tenant_id = params.get('creds_tenant_id', {}).get('password', '') or params.get('tenant_id', '')

            if not tenant_id:
                raise ValueError('Tenant ID must be provided.')

            subscription_id = args.get('subscription_id') or params.get('subscriptionID', '')
            resource_group_name = args.get('resource_group_name') or params.get('resourceGroupName', '')

            client = AzureSentinelClient(
                azure_cloud=get_azure_cloud(params, 'AzureSentinel'),
                tenant_id=tenant_id,
                client_id=params.get('credentials', {}).get('identifier'),
                client_secret=client_secret,
                subscription_id=subscription_id,
                resource_group_name=resource_group_name,
                workspace_name=params.get('workspaceName', ''),
                verify=not params.get('insecure', False),
                proxy=params.get('proxy', False),
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key,
                managed_identities_client_id=managed_identities_client_id
            )

            commands = {
                'test-module': test_module,
                'azure-sentinel-get-incident-by-id': get_incident_by_id_command,
                'azure-sentinel-list-incidents': list_incidents_command,
                'azure-sentinel-update-incident': update_incident_command,
                'azure-sentinel-delete-incident': delete_incident_command,
                'azure-sentinel-list-incident-comments': list_incident_comments_command,
                'azure-sentinel-incident-add-comment': incident_add_comment_command,
                'azure-sentinel-incident-delete-comment': incident_delete_comment_command,
                'azure-sentinel-list-incident-relations': list_incident_relations_command,
                'azure-sentinel-list-incident-entities': list_incident_entities_command,
                'azure-sentinel-list-incident-alerts': list_incident_alerts_command,
                'azure-sentinel-list-watchlists': list_watchlists_command,
                'azure-sentinel-delete-watchlist': delete_watchlist_command,
                'azure-sentinel-watchlist-create-update': create_update_watchlist_command,
                'azure-sentinel-list-watchlist-items': list_watchlist_items_command,
                'azure-sentinel-delete-watchlist-item': delete_watchlist_item_command,
                'azure-sentinel-create-update-watchlist-item': create_update_watchlist_item_command,
                'azure-sentinel-threat-indicator-list': list_threat_indicator_command,
                'azure-sentinel-threat-indicator-query': query_threat_indicators_command,
                'azure-sentinel-threat-indicator-create': create_threat_indicator_command,
                'azure-sentinel-threat-indicator-update': update_threat_indicator_command,
                'azure-sentinel-threat-indicator-delete': delete_threat_indicator_command,
                'azure-sentinel-threat-indicator-tags-append': append_tags_threat_indicator_command,
                'azure-sentinel-threat-indicator-tags-replace': replace_tags_threat_indicator_command,
                'azure-sentinel-list-alert-rule': list_alert_rule_command,
                'azure-sentinel-list-alert-rule-template': list_alert_rule_template_command,
                'azure-sentinel-delete-alert-rule': delete_alert_rule_command,
                'azure-sentinel-create-alert-rule': create_and_update_alert_rule_command,
                'azure-sentinel-update-alert-rule': create_and_update_alert_rule_command,
                # mirroring commands
                'get-modified-remote-data': get_modified_remote_data_command,
                'get-remote-data': get_remote_data_command,
                'update-remote-system': update_remote_system_command
            }

            if command == 'fetch-incidents':
                fetch_incidents_command(client, params)

            # mirroring command
            elif command == 'get-mapping-fields':
                return_results(get_mapping_fields_command())
            elif command == 'azure-sentinel-subscriptions-list':
                return_results(list_subscriptions_command(client))
            elif command == 'azure-sentinel-resource-group-list':
                return_results(list_resource_groups_command(client, args, subscription_id))
            elif command == 'azure-sentinel-auth-reset':
                return_results(reset_auth())

            elif command in commands:
                return_results(commands[command](client, args))  # type: ignore

        except Exception as e:
            return_error(
                f'Failed to execute {command} command. Error: {str(e)}'
            )


    if __name__ in ('__main__', '__builtin__', 'builtins'):  # pragma: no cover
        main()

    register_module_line('Azure Sentinel', 'end', __line__())
  subtype: python3
  type: python
system: true
