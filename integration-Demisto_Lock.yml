category: Utilities
commonfields:
  id: Demisto Lock
  version: -1
configuration:
- advanced: true
  defaultvalue: "600"
  display: Default timeout (seconds) for wait on locks to be released
  name: timeout
  required: true
  section: Connect
  type: 0
- additionalinfo: Whether to sync the integration cache with the database (Available
    from Cortex XSOAR 6.2.0).
  advanced: true
  defaultvalue: "false"
  display: Sync integration cache
  name: sync
  required: false
  section: Connect
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.1.3
    packID: DemistoLocking
    packName: Cortex Lock
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Locking mechanism that prevents concurrent execution of different tasks.
detaileddescription: "The Demisto Locking integration allows prevention of concurrent
  execution of scripts or commands, using a wait-lock-release flow (mutex). \nUse
  the lock name argument to support multiple locks in different flows.\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/demisto-lock)"
display: Demisto Lock
image: data:image/png;base64,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
name: Demisto Lock
script:
  commands:
  - arguments:
    - default: true
      description: Name of lock. When omitted, name is set to Default.
      name: name
    - description: Additional information to provide for the lock instance.
      name: info
    - description: Timeout (seconds) for wait on lock to be freed.
      name: timeout
    - description: Polling interval (seconds) between each lock acquire attempt.
      name: polling_interval
    - description: Unique identifier value of the lock.
      hidden: true
      name: guid
    - description: Polling Timeout error message.
      hidden: true
      name: timeout_err_msg
    description: Gets a specific lock. If the lock doesn't exist, it creates one.
      If the lock is already in use, the command waits until the lock is released
      or until timeout is reached. If timeout is reached and the lock hasn't been
      released, the command fails to get the lock.
    name: demisto-lock-get
    polling: true
  - arguments:
    - default: true
      description: Name of lock to release. When omitted, name is set to Default.
      name: name
    description: Release a lock.
    name: demisto-lock-release
  - arguments:
    - default: true
      description: Specific lock to show info for. If not specified, shows info for
        all locks.
      name: name
    description: Show information on locks.
    name: demisto-lock-info
  - arguments: []
    description: Release all locks.
    name: demisto-lock-release-all
  runonce: false
  script: |
    // pack version: 1.1.3
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
          .toString(16)
          .substring(1);
      }
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    var sync = params.sync;
    function setLock(guid, info, version) {
        if (sync) {
            mergeVersionedIntegrationContext({newContext : {[lockName] : {guid: guid, info: info}}, version : version});
        } else {
            var integrationContext = getIntegrationContext() || {};
            integrationContext[lockName] = {guid: guid, info: info};
            setIntegrationContext(integrationContext);
        }
    } function getLock() {
        if (sync) {
            var versionedIntegrationContext = getVersionedIntegrationContext(true, true) || {};
            var integrationContext = versionedIntegrationContext.context;
            if (!integrationContext[lockName]) {
                integrationContext[lockName] = {};
            }
            return [integrationContext[lockName], versionedIntegrationContext.version];
        } else {
            var integrationContext = getIntegrationContext() || {};
            if (!integrationContext[lockName]) {
                integrationContext[lockName] = {};
            }
            return [integrationContext[lockName], null];
        }
    }
    function attemptToAcquireLock(guid, lockInfo, version) {
        logDebug("Attempting to acquire lock");
        try {
            setLock(guid, lockInfo, version);
        } catch (err) {
            logDebug(err.message);
        }
    }
    var lockName = args.name || 'Default';

    switch (command) {
        case 'test-module':
            return 'ok';

        case 'demisto-lock-get':
            var lockTimeout = args.timeout || params.timeout || 600;
            var lockInfo = 'Locked by incident #' + incidents[0].id + '.';
            lockInfo += (args.info) ? ' Additional info: ' + args.info : '';
            var pollingInterval = args.polling_interval || '20';

            var guid = args.guid || guid();
            var time = 0;
            var lock, version, lock_candidate;

            if (isDemistoVersionGE('8.0.0')) {  // XSOAR 8 lock implementation with polling.
                logDebug('Running on XSOAR version 8');

                // check if a lock already exists in the integration context
                [lock, version] = getLock();

                if (typeof version === "object") {
                    version = JSON.stringify(version)
                }
                logDebug('Task guid: ' + guid + ' | Current lock is: ' + JSON.stringify(lock) + ', version: ' + version);

                // if no lock found, try to acquire a new lock
                if (!lock.guid) {
                    attemptToAcquireLock(guid, lockInfo, version)
                    lock_candidate = getLock();
                }

                // stopping condition - the lock is acquired successfully
                if (lock_candidate && lock_candidate[0].guid === guid) {
                    var md = '### Demisto Locking Mechanism\n';
                    md += 'Lock acquired successfully\n';
                    md += 'GUID: ' + guid;
                    logDebug(md)
                    return { ContentsFormat: formats.markdown, Type: entryTypes.note, Contents: md };
                }
                else { // polling condition - the lock acquire attempt failed (another lock already exist)
                    var timeout_err_msg = 'Timeout waiting for lock\n';
                    timeout_err_msg += 'Lock name: ' + lockName + '\n';
                    timeout_err_msg += 'Lock info: ' + lock.info + '\n';
                    logDebug(timeout_err_msg)
                    return {
                        Type: entryTypes.note,
                        Contents: 'Lock was not acquired, Polling.',
                        PollingCommand: 'demisto-lock-get',
                        NextRun: pollingInterval,
                        PollingArgs: { name: lockName, info: args.info, timeout: args.timeout, polling_interval: pollingInterval ,guid: guid, timeout_err_msg: timeout_err_msg },
                        Timeout: String(lockTimeout)
                    }
                }
            } else {  // XSOAR 6 lock implementation without polling.
                logDebug('Running on XSOAR version 6');
                do {
                    [lock, version] = getLock();
                    if (lock.guid === guid) {
                        break;
                    }
                    if (!lock.guid) {
                        try {
                            setLock(guid, lockInfo, version);
                        } catch (err) {
                            logDebug(err.message)
                        }
                    }
                    wait(1);
                } while (time++ < lockTimeout);

                [lock, version] = getLock();

                if (lock.guid === guid) {
                    var md = '### Demisto Locking Mechanism\n';
                    md += 'Lock acquired successfully\n';
                    md += 'GUID: ' + guid;
                    return { ContentsFormat: formats.markdown, Type: entryTypes.note, Contents: md };
                } else {
                    var md = 'Timeout waiting for lock\n';
                    md += 'Lock name: ' + lockName + '\n';
                    md += 'Lock info: ' + lock.info + '\n';
                    return { ContentsFormat: formats.text, Type: entryTypes.error, Contents: md };
                }
                break;
            }

        case 'demisto-lock-release':
            logDebug('Releasing lock lockName: ' + lockName);
            if(sync)   {
                mergeVersionedIntegrationContext({newContext : {[lockName] : 'remove'}, retries : 5});
            } else {
                integrationContext = getVersionedIntegrationContext(sync);
                delete integrationContext[lockName];
                setVersionedIntegrationContext(integrationContext, sync);
            }
            [lock, version] = getLock();
            logDebug('Current lock is: ' + JSON.stringify(lock) + ', version: ' + JSON.stringify(version));


            var md = '### Demisto Locking Mechanism\n';
            md += 'Lock released successfully';
            return { ContentsFormat: formats.markdown, Type: entryTypes.note, Contents: md } ;

        case 'demisto-lock-release-all':
            setVersionedIntegrationContext({}, sync);

            var md = '### Demisto Locking Mechanism\n';
            md += 'All locks released successfully';
            return { ContentsFormat: formats.markdown, Type: entryTypes.note, Contents: md } ;

        case 'demisto-lock-info':
            integrationContext = getVersionedIntegrationContext(sync);
            var obj = [];

            var res;
            var md = '### Demisto Locking Mechanism\n';
            var locks = (lockName === 'Default') ? Object.keys(integrationContext) : [lockName];

            locks.forEach(function(lock){
                md += 'Lock name: ' + lock + ' - ';
                if (integrationContext[lock] && integrationContext[lock].guid) {
                    md += 'Locked.\n';
                    md += '- GUID: ' + integrationContext[lock].guid + '\n';
                    md += '- Info: ' + integrationContext[lock].info + '\n\n';
                    obj.push({lock: lock, state: integrationContext[lock]});
                } else {
                    md += 'Not locked\n\n';
                }

            });
            return { ContentsFormat: formats.json, Type: entryTypes.note, Contents: obj, HumanReadable: md } ;

        default:
            var md = 'Unknown command ' + command;
            return { ContentsFormat: formats.text, Type: entryTypes.error, Contents: md };
    }
  type: javascript
system: true
