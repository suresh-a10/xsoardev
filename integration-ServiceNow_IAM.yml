category: Identity and Access Management
commonfields:
  id: ServiceNow IAM
  version: -1
configuration:
- display: ServiceNow URL (https://<domain>.service-now.com)
  name: url
  required: true
  type: 0
- display: ServiceNow API Version (e.g. 'v1'). Specify this value to use an endpoint
    version other than the latest.
  name: api_version
  required: false
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "true"
  display: Allow creating users
  name: create_user_enabled
  required: false
  type: 8
- defaultvalue: "true"
  display: Allow updating users
  name: update_user_enabled
  required: false
  type: 8
- defaultvalue: "true"
  display: Allow enabling users
  name: enable_user_enabled
  required: false
  type: 8
- defaultvalue: "true"
  display: Allow disabling users
  name: disable_user_enabled
  required: false
  type: 8
- defaultvalue: "true"
  display: Automatically create user if not found in update command
  name: create_if_not_exists
  required: false
  type: 8
- defaultvalue: User Profile - ServiceNow (Incoming)
  display: Incoming Mapper
  name: mapper_in
  required: true
  type: 0
- defaultvalue: User Profile - ServiceNow (Outgoing)
  display: Outgoing Mapper
  name: mapper_out
  required: true
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 2.6.9
    packID: ServiceNow
    packName: ServiceNow
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Integrate with ServiceNow's services to execute CRUD operations for employee
  lifecycle processes.
detaileddescription: |-
  ## Prerequisites
  To use ServiceNow in XSOAR, ensure your user account has the `rest_api_explorer`, `web_service_admin` roles or any other role required to permit working with the `sys_user` table. These roles are required in order to make API calls. However, they may not suffice for viewing records in some tables.

  ## Enable/Disable CRUD Commands
  You can select which CRUD commands are enabled in the integration instance configuration settings. By default, all commands are enabled.

  ## Add Custom Indicator Fields
  Follow these steps to add custom fields to the User Profile indicator.

  1. In XSOAR, create the custom indicator and incident field, for example, **Middle Name**.
  2. Duplicate the **User Profile - ServiceNow (Incoming)** mapper and/or the **User Profile - ServiceNow (Outging)** mapper.
  3. Add and map the custom field to the necessary mapper(s).
  4. Go to the ServiceNow IAM integration instance and in the mapper textbox, replace the name of the default mapper with the custom mapper you created.

  ## Automatically create user if not found in update command
  The *create-if-not-exists* parameter specifies if a new user should be created when the User Profile passed was not found in the 3rd-party integration.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/service-now-iam)
display: ServiceNow IAM
image: data:image/png;base64,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
name: ServiceNow IAM
script:
  commands:
  - arguments:
    - description: User Profile indicator details.
      name: user-profile
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: When set to true, after the command execution the status of the
        user in the 3rd-party integration will be active.
      name: allow-enable
      predefined:
      - "true"
      - "false"
    description: Creates a user in ServiceNow.
    execution: true
    name: iam-create-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: When set to true, after the command execution the status of the
        user in the 3rd-party integration will be active.
      name: allow-enable
      predefined:
      - "true"
      - "false"
    description: Updates an existing user with the data passed in the user-profile
      argument.
    execution: true
    name: iam-update-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    description: Retrieves a single user resource.
    name: iam-get-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments:
    - description: A User Profile indicator.
      name: user-profile
      required: true
    description: Disable an active user.
    execution: true
    name: iam-disable-user
    outputs:
    - contextPath: IAM.Vendor.active
      description: When true, indicates that the employee's status is active in the
        3rd-party integration.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: Name of the integration.
      type: String
    - contextPath: IAM.Vendor.details
      description: Provides the raw data from the 3rd-party integration.
      type: string
    - contextPath: IAM.Vendor.email
      description: The employee's email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: Reason why the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee's user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: Name of the integration instance.
      type: string
    - contextPath: IAM.Vendor.success
      description: When true, indicates that the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee's username in the app.
      type: String
  - arguments: []
    description: Retrieves a User Profile schema, which holds all of the user fields
      within the application. Used for outgoing-mapping through the Get Schema option.
    name: get-mapping-fields
  dockerimage: demisto/python3:3.10.13.89873
  ismappable: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('ServiceNow IAM', 'start', __line__())
    demisto.debug('pack name = ServiceNow, pack version = 2.6.9')


    # noqa: F401
    # noqa: F401
    # noqa: F401
    # noqa: F401


    import traceback
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    IAM_GET_USER_ATTRIBUTES = ['id', 'user_name', 'email']
    '''CLIENT CLASS'''


    class Client(BaseClient):
        """
        ServiceNow IAM Client class that implements logic to authenticate with ServiceNow.
        """

        def test(self):
            uri = '/table/sys_user?sysparm_limit=1'
            self._http_request(method='GET', url_suffix=uri)

        def get_user(self, filter_name: str, filter_value: str):
            uri = 'table/sys_user'
            query_params = {
                filter_name: filter_value
            }

            res = self._http_request(
                method='GET',
                url_suffix=uri,
                params=query_params
            )

            if res and len(res.get('result', [])) > 0:
                return res.get('result')[0]
            return None

        def create_user(self, user_data):
            uri = 'table/sys_user'
            res = self._http_request(
                method='POST',
                url_suffix=uri,
                json_data=user_data
            )
            return res.get('result')

        def update_user(self, user_id, user_data):
            uri = f'/table/sys_user/{user_id}'
            res = self._http_request(
                method='PATCH',
                url_suffix=uri,
                json_data=user_data
            )
            return res.get('result')

        def get_service_now_fields(self):
            service_now_fields = {}
            uri = 'table/sys_dictionary?sysparm_query=name=sys_user'
            res = self._http_request(
                method='GET',
                url_suffix=uri
            )

            elements = res.get('result', [])
            for elem in elements:
                if elem.get('element'):
                    field_name = elem.get('element')
                    description = elem.get('sys_name')
                    service_now_fields[field_name] = description

            return service_now_fields


    '''HELPER FUNCTIONS'''


    def handle_exception(user_profile, e, action):
        """ Handles failed responses from ServiceNow API by setting the User Profile object with the results.

        Args:
            user_profile (IAMUserProfile): The User Profile object.
            e (Exception): The exception error. If DemistoException, holds the response json.
            action (IAMActions): An enum represents the current action (get, update, create, etc).
        """
        if e.__class__ is DemistoException and hasattr(e, 'res') and e.res is not None:
            error_code = e.res.status_code
            try:
                resp = e.res.json()
                error_message = get_error_details(resp)
            except ValueError:
                error_message = str(e)
        else:
            error_code = ''
            error_message = str(e)

        user_profile.set_result(action=action,
                                success=False,
                                error_code=error_code,
                                error_message=error_message)

        demisto.error(traceback.format_exc())


    def get_error_details(res):
        """ Parses the error details retrieved from ServiceNow and outputs the resulted string.

        Args:
            res (dict): The data retrieved from ServiceNow.

        Returns:
            (str) The parsed error details.
        """
        message = res.get('error', {}).get('message')
        details = res.get('error', {}).get('detail')
        return f'{message}: {details}'


    '''COMMAND FUNCTIONS'''


    def test_module(client):
        client.test()
        return_results('ok')


    def get_mapping_fields_command(client):
        service_now_fields = client.get_service_now_fields()
        incident_type_scheme = SchemeTypeMapping(type_name=IAMUserProfile.DEFAULT_INCIDENT_TYPE)

        for field, description in service_now_fields.items():
            incident_type_scheme.add_field(field, description)

        return GetMappingFieldsResponse([incident_type_scheme])


    def get_user_command(client, args, mapper_in, mapper_out):
        user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=mapper_out,
                                      incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        try:
            iam_attr, iam_attr_value = user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
            service_now_filter_name: str = 'sys_id' if iam_attr == 'id' else iam_attr
            service_now_user = client.get_user(service_now_filter_name, iam_attr_value)
            if not service_now_user:
                error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                user_profile.set_result(action=IAMActions.GET_USER,
                                        success=False,
                                        error_code=error_code,
                                        error_message=error_message)
            else:
                user_profile.update_with_app_data(service_now_user, mapper_in)
                user_profile.set_result(
                    action=IAMActions.GET_USER,
                    success=True,
                    active=service_now_user.get('active') == 'true',
                    iden=service_now_user.get('sys_id'),
                    email=service_now_user.get('email'),
                    username=service_now_user.get('user_name'),
                    details=service_now_user
                )

        except Exception as e:
            handle_exception(user_profile, e, IAMActions.GET_USER)

        return user_profile


    def disable_user_command(client, args, is_command_enabled, mapper_out):
        user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=mapper_out,
                                      incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        if not is_command_enabled:
            user_profile.set_result(action=IAMActions.DISABLE_USER,
                                    skip=True,
                                    skip_reason='Command is disabled.')
        else:
            try:
                iam_attr, iam_attr_value = user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                service_now_filter_name: str = 'sys_id' if iam_attr == 'id' else iam_attr
                service_now_user = client.get_user(service_now_filter_name, iam_attr_value)
                if not service_now_user:
                    _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    user_profile.set_result(action=IAMActions.DISABLE_USER,
                                            skip=True,
                                            skip_reason=error_message)
                else:
                    if service_now_user.get('active', 'true') == 'false':
                        user_profile.set_user_is_already_disabled(service_now_user)
                    else:
                        user_id = service_now_user.get('sys_id')
                        user_data = {'active': False}
                        updated_user = client.update_user(user_id, user_data)
                        user_profile.set_result(
                            action=IAMActions.DISABLE_USER,
                            success=True,
                            active=False,
                            iden=updated_user.get('sys_id'),
                            email=updated_user.get('email'),
                            username=updated_user.get('user_name'),
                            details=updated_user
                        )

            except Exception as e:
                handle_exception(user_profile, e, IAMActions.DISABLE_USER)

        return user_profile


    def create_user_command(client, args, mapper_out, is_command_enabled, is_update_enabled, is_enable_enabled):
        user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=mapper_out,
                                      incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)

        if not is_command_enabled:
            user_profile.set_result(action=IAMActions.CREATE_USER,
                                    skip=True,
                                    skip_reason='Command is disabled.')
        else:
            try:
                iam_attr, iam_attr_value = user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                service_now_filter_name: str = 'sys_id' if iam_attr == 'id' else iam_attr
                service_now_user = client.get_user(service_now_filter_name, iam_attr_value)
                if service_now_user:
                    # if user exists, update it
                    user_profile = update_user_command(client, args, mapper_out, is_update_enabled,
                                                       is_enable_enabled, False, False)

                else:
                    service_now_profile = user_profile.map_object(mapper_out,
                                                                  incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
                    created_user = client.create_user(service_now_profile)
                    user_profile.set_result(
                        action=IAMActions.CREATE_USER,
                        success=True,
                        active=created_user.get('active') == 'true',
                        iden=created_user.get('sys_id'),
                        email=created_user.get('email'),
                        username=created_user.get('user_name'),
                        details=created_user
                    )

            except Exception as e:
                handle_exception(user_profile, e, IAMActions.CREATE_USER)

        return user_profile


    def update_user_command(client, args, mapper_out, is_command_enabled, is_enable_enabled,
                            is_create_user_enabled, create_if_not_exists):
        user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=mapper_out,
                                      incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        allow_enable = args.get('allow-enable') == 'true'
        if not is_command_enabled:
            user_profile.set_result(action=IAMActions.UPDATE_USER,
                                    skip=True,
                                    skip_reason='Command is disabled.')
        else:
            try:
                iam_attr, iam_attr_value = user_profile.get_first_available_iam_user_attr(IAM_GET_USER_ATTRIBUTES)
                service_now_filter_name: str = 'sys_id' if iam_attr == 'id' else iam_attr
                service_now_user = client.get_user(service_now_filter_name, iam_attr_value)
                if service_now_user:
                    user_id = service_now_user.get('sys_id')
                    service_now_profile = user_profile.map_object(mapper_out,
                                                                  incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)

                    if allow_enable and is_enable_enabled:
                        service_now_profile['active'] = True
                        service_now_profile['locked_out'] = False

                    updated_user = client.update_user(user_id, service_now_profile)
                    user_profile.set_result(
                        action=IAMActions.UPDATE_USER,
                        success=True,
                        active=updated_user.get('active') == 'true',
                        iden=updated_user.get('sys_id'),
                        email=updated_user.get('email'),
                        username=updated_user.get('user_name'),
                        details=updated_user
                    )
                else:
                    if create_if_not_exists:
                        user_profile = create_user_command(client, args, mapper_out, is_create_user_enabled,
                                                           False, False)
                    else:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                skip=True,
                                                skip_reason=error_message)

            except Exception as e:
                handle_exception(user_profile, e, IAMActions.UPDATE_USER)

        return user_profile


    def main():
        user_profile = None
        params = demisto.params()
        api_version = params.get('api_version', '')
        base_url = urljoin(params['url'].strip('/'), '/api/now/')
        if api_version:
            base_url += api_version
        username = params.get('credentials', {}).get('identifier')
        password = params.get('credentials', {}).get('password')
        mapper_in = params.get('mapper_in')
        mapper_out = params.get('mapper_out')
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        command = demisto.command()
        args = demisto.args()

        is_create_enabled = params.get("create_user_enabled")
        is_disable_enabled = params.get("disable_user_enabled")
        is_enable_enabled = params.get("enable_user_enabled")
        is_update_enabled = demisto.params().get("update_user_enabled")
        create_if_not_exists = demisto.params().get("create_if_not_exists")

        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }

        client = Client(
            base_url=base_url,
            verify=verify_certificate,
            proxy=proxy,
            headers=headers,
            ok_codes=(200, 201),
            auth=(username, password)
        )

        demisto.debug(f'Command being called is {command}')

        if command == 'iam-get-user':
            user_profile = get_user_command(client, args, mapper_in, mapper_out)

        elif command == 'iam-create-user':
            user_profile = create_user_command(client, args, mapper_out, is_create_enabled, is_update_enabled,
                                               is_enable_enabled)

        elif command == 'iam-update-user':
            user_profile = update_user_command(client, args, mapper_out, is_update_enabled, is_enable_enabled,
                                               is_create_enabled, create_if_not_exists)

        elif command == 'iam-disable-user':
            user_profile = disable_user_command(client, args, is_disable_enabled, mapper_out)

        if user_profile:
            return_results(user_profile)

        try:
            if command == 'test-module':
                test_module(client)

            elif command == 'get-mapping-fields':
                return_results(get_mapping_fields_command(client))

        except Exception as e:
            # For any other integration command exception, return an error
            return_error(f'Failed to execute {command} command. Error: {str(e)}')



    ### GENERATED CODE ###: from IAMApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('IAMApiModule', 'start', __line__(), wrapper=-3)





    class IAMErrors(object):
        """
        An enum class to manually handle errors in IAM integrations
        :return: None
        :rtype: ``None``
        """
        BAD_REQUEST = 400, 'Bad request - failed to perform operation'
        USER_DOES_NOT_EXIST = 404, 'User does not exist'
        USER_ALREADY_EXISTS = 409, 'User already exists'


    class IAMActions(object):
        """
        Enum: contains all the IAM actions (e.g. get, update, create, etc.)
        :return: None
        :rtype: ``None``
        """
        GET_USER = 'get'
        UPDATE_USER = 'update'
        CREATE_USER = 'create'
        DISABLE_USER = 'disable'
        ENABLE_USER = 'enable'


    class IAMVendorActionResult:
        """ This class is used in IAMUserProfile class to represent actions data.
        :return: None
        :rtype: ``None``
        """

        def __init__(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                     error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            self._brand = demisto.callingContext.get('context', {}).get('IntegrationBrand')
            self._instance_name = demisto.callingContext.get('context', {}).get('IntegrationInstance')
            self._success = success
            self._active = active
            self._iden = iden
            self._username = username
            self._email = email
            self._error_code = error_code
            self._error_message = error_message
            self._details = details
            self._skip = skip
            self._skip_reason = skip_reason
            self._action = action
            self._return_error = return_error

        def should_return_error(self):
            return self._return_error

        def create_outputs(self):
            """ Sets the outputs in `_outputs` attribute.
            """
            outputs = {
                'brand': self._brand,
                'instanceName': self._instance_name,
                'action': self._action,
                'success': self._success,
                'active': self._active,
                'id': self._iden,
                'username': self._username,
                'email': self._email,
                'errorCode': self._error_code,
                'errorMessage': self._error_message,
                'details': self._details,
                'skipped': self._skip,
                'reason': self._skip_reason
            }
            return outputs

        def create_readable_outputs(self, outputs):
            """ Sets the human readable output in `_readable_output` attribute.

            :param outputs: (dict) the command outputs.
            """
            title = self._action.title() + ' User Results ({})'.format(self._brand)

            if not self._skip:
                headers = ["brand", "instanceName", "success", "active", "id", "username",
                           "email", "errorCode", "errorMessage", "details"]
            else:
                headers = ["brand", "instanceName", "skipped", "reason"]

            readable_output = tableToMarkdown(
                name=title,
                t=outputs,
                headers=headers,
                removeNull=True
            )

            return readable_output


    class IAMUserProfile:
        """ A User Profile object class for IAM integrations.

        :type _user_profile: ``str``
        :param _user_profile: The user profile information.

        :type _user_profile_delta: ``str``
        :param _user_profile_delta: The user profile delta.

        :type _vendor_action_results: ``list``
        :param _vendor_action_results: A List of data returned from the vendor.

        :return: None
        :rtype: ``None``
        """

        DEFAULT_INCIDENT_TYPE = 'User Profile'
        CREATE_INCIDENT_TYPE = 'User Profile - Create'
        UPDATE_INCIDENT_TYPE = 'User Profile - Update'
        DISABLE_INCIDENT_TYPE = 'User Profile - Disable'
        ENABLE_INCIDENT_TYPE = 'User Profile - Enable'

        def __init__(self, user_profile, mapper: str, incident_type: str, user_profile_delta=None):
            self._user_profile = safe_load_json(user_profile)
            # Mapping is added here for GET USER commands, where we need to map Cortex XSOAR fields to the given app fields.
            self.mapped_user_profile = None
            self.mapped_user_profile = self.map_object(mapper, incident_type, map_old_data=True) if \
                mapper else self._user_profile
            self._user_profile_delta = safe_load_json(user_profile_delta) if user_profile_delta else {}
            self._vendor_action_results: List = []

        def get_attribute(self, item, use_old_user_data=False, user_profile_data: Optional[Dict] = None):
            user_profile = user_profile_data if user_profile_data else self._user_profile
            if use_old_user_data and user_profile.get('olduserdata', {}).get(item):
                return user_profile.get('olduserdata', {}).get(item)
            return user_profile.get(item)

        def to_entry(self):
            """ Generates a XSOAR IAM entry from the data in _vendor_action_results.
            Note: Currently we are using only the first element of the list, in the future we will support multiple results.

            :return: A XSOAR entry.
            :rtype: ``dict``
            """

            outputs = self._vendor_action_results[0].create_outputs()
            readable_output = self._vendor_action_results[0].create_readable_outputs(outputs)

            entry_context = {
                'IAM.UserProfile(val.email && val.email == obj.email)': self._user_profile,
                'IAM.Vendor(val.instanceName && val.instanceName == obj.instanceName && '
                'val.email && val.email == obj.email)': outputs
            }

            return_entry = {
                'ContentsFormat': EntryFormat.JSON,
                'Contents': outputs,
                'EntryContext': entry_context
            }

            if self._vendor_action_results[0].should_return_error():
                return_entry['Type'] = EntryType.ERROR
            else:
                return_entry['Type'] = EntryType.NOTE
                return_entry['HumanReadable'] = readable_output

            return return_entry

        def return_outputs(self):
            return_results(self.to_entry())

        def set_result(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                       error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            if not email:
                email = self.get_attribute('email')

            if not details:
                details = self.mapped_user_profile

            vendor_action_result = IAMVendorActionResult(
                success=success,
                active=active,
                iden=iden,
                username=username,
                email=email,
                error_code=error_code,
                error_message=error_message if error_message else '',
                details=details,
                skip=skip,
                skip_reason=skip_reason if skip_reason else '',
                action=action,
                return_error=return_error
            )

            self._vendor_action_results.append(vendor_action_result)

        def map_object(self, mapper_name, incident_type, map_old_data: bool = False):
            """ Returns the user data, in an application data format.

            :type mapper_name: ``str``
            :param mapper_name: The outgoing mapper from XSOAR to the application.

            :type incident_type: ``str``
            :param incident_type: The incident type used.

            :type map_old_data ``bool``
            :param map_old_data: Whether to map old data as well.

            :return: the user data, in the app data format.
            :rtype: ``dict``
            """
            if self.mapped_user_profile:
                if not map_old_data:
                    return {k: v for k, v in self.mapped_user_profile.items() if k != 'olduserdata'}
                return self.mapped_user_profile
            if incident_type not in [IAMUserProfile.CREATE_INCIDENT_TYPE, IAMUserProfile.UPDATE_INCIDENT_TYPE,
                                     IAMUserProfile.DISABLE_INCIDENT_TYPE,
                                     IAMUserProfile.ENABLE_INCIDENT_TYPE]:
                raise DemistoException('You must provide a valid incident type to the map_object function.')
            if not self._user_profile:
                raise DemistoException('You must provide the user profile data.')
            app_data = demisto.mapObject(self._user_profile, mapper_name, incident_type)
            if map_old_data and 'olduserdata' in self._user_profile:
                app_data['olduserdata'] = demisto.mapObject(self._user_profile.get('olduserdata', {}), mapper_name,
                                                            incident_type)
            return app_data

        def update_with_app_data(self, app_data, mapper_name, incident_type=None):
            """ updates the user_profile attribute according to the given app_data

            :type app_data: ``dict``
            :param app_data: The user data in app

            :type mapper_name: ``str``
            :param mapper_name: Incoming mapper name

            :type incident_type: ``str``
            :param incident_type: Optional - incident type
            """
            if not incident_type:
                incident_type = IAMUserProfile.DEFAULT_INCIDENT_TYPE
            if not isinstance(app_data, dict):
                app_data = safe_load_json(app_data)
            self._user_profile = demisto.mapObject(app_data, mapper_name, incident_type)

        def get_first_available_iam_user_attr(self, iam_attrs: List[str], use_old_user_data: bool = False):
            # Special treatment for ID field, because he is not included in outgoing mappers.
            for iam_attr in iam_attrs:
                # Special treatment for ID field, because he is not included in outgoing mappers.
                if iam_attr == 'id':
                    if attr_value := self.get_attribute(iam_attr, use_old_user_data):
                        return iam_attr, attr_value
                if attr_value := self.get_attribute(iam_attr, use_old_user_data, self.mapped_user_profile):
                    # Special treatment for emails, as mapper maps it to a list object.
                    if iam_attr == 'emails' and not isinstance(attr_value, str):
                        if isinstance(attr_value, dict):
                            attr_value = attr_value.get('value')
                        elif isinstance(attr_value, list):
                            if not attr_value:
                                continue
                            attr_value = next((email.get('value') for email in attr_value if email.get('primary', False)),
                                              attr_value[0].get('value', ''))
                    return iam_attr, attr_value

            raise DemistoException('Your user profile argument must contain at least one attribute that is mapped into one'
                                   f' of the following attributes in the outgoing mapper: {iam_attrs}')

        def set_user_is_already_disabled(self, details):
            self.set_result(
                action=IAMActions.DISABLE_USER,
                skip=True,
                skip_reason='User is already disabled.',
                details=details
            )

        def set_user_is_already_enabled(self, details):
            self.set_result(
                action=IAMActions.ENABLE_USER,
                skip=True,
                skip_reason='User is already enabled.',
                details=details
            )


    class IAMUserAppData:
        """ Holds user attributes retrieved from an application.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, user_id, username, is_active, app_data, email=None):
            self.id = user_id
            self.username = username
            self.is_active = is_active
            self.full_data = app_data
            self.email = email


    class IAMCommand:
        """ A class that implements the IAM CRUD commands - should be used.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, is_create_enabled=True, is_enable_enabled=True, is_disable_enabled=True, is_update_enabled=True,
                     create_if_not_exists=True, mapper_in=None, mapper_out=None, get_user_iam_attrs=None):
            """ The IAMCommand c'tor

            :param is_create_enabled: (bool) Whether or not to allow creating users in the application.
            :param is_enable_enabled: (bool) Whether or not to allow enabling users in the application.
            :param is_disable_enabled: (bool) Whether or not to allow disabling users in the application.
            :param is_update_enabled: (bool) Whether or not to allow updating users in the application.
            :param create_if_not_exists: (bool) Whether or not to create a user if does not exist in the application.
            :param mapper_in: (str) Incoming mapper from the application to Cortex XSOAR
            :param mapper_out: (str) Outgoing mapper from the Cortex XSOAR to the application
            :param get_user_iam_attrs (List[str]): List of IAM attributes supported by integration by precedence
                                                            order to get user details.
            """
            if get_user_iam_attrs is None:
                get_user_iam_attrs = ['email']
            self.is_create_enabled = is_create_enabled
            self.is_enable_enabled = is_enable_enabled
            self.is_disable_enabled = is_disable_enabled
            self.is_update_enabled = is_update_enabled
            self.create_if_not_exists = create_if_not_exists
            self.mapper_in = mapper_in
            self.mapper_out = mapper_out
            self.get_user_iam_attrs = get_user_iam_attrs

        def get_user(self, client, args):
            """ Searches a user in the application and updates the user profile object with the data.
                If not found, the error details will be resulted instead.
            :param client: (Client) The integration Client object that implements a get_user() method
            :param args: (dict) The `iam-get-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            try:
                iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(self.get_user_iam_attrs)
                user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                if not user_app_data:
                    error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    user_profile.set_result(action=IAMActions.GET_USER,
                                            success=False,
                                            error_code=error_code,
                                            error_message=error_message)
                else:
                    user_profile.update_with_app_data(user_app_data.full_data, self.mapper_in)
                    user_profile.set_result(
                        action=IAMActions.GET_USER,
                        active=user_app_data.is_active,
                        iden=user_app_data.id,
                        email=user_profile.get_attribute('email') or user_app_data.email,
                        username=user_app_data.username,
                        details=user_app_data.full_data
                    )

            except Exception as e:
                client.handle_exception(user_profile, e, IAMActions.GET_USER)

            return user_profile

        def disable_user(self, client, args):
            """ Disables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user() and disable_user() methods
            :param args: (dict) The `iam-disable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_disable_enabled:
                user_profile.set_result(action=IAMActions.DISABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.DISABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if user_app_data.is_active:
                            disabled_user = client.disable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.DISABLE_USER,
                                active=False,
                                iden=disabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=disabled_user.username,
                                details=disabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_disabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.DISABLE_USER)

            return user_profile

        def enable_user(self, client, args):
            """ Enables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user(),
                                    enable_user() and handle_exception methods
            :param args: (dict) The `iam-enable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_enable_enabled:
                user_profile.set_result(action=IAMActions.ENABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.ENABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if not user_app_data.is_active:
                            enabled_user = client.enable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.ENABLE_USER,
                                active=True,
                                iden=enabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=enabled_user.username,
                                details=enabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_enabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.ENABLE_USER)

            return user_profile

        def create_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If a user in the app already holds the email in the given user profile, updates
                its data with the given data.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-create-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
            if not self.is_create_enabled:
                user_profile.set_result(action=IAMActions.CREATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        # if user exists, update it
                        user_profile = self.update_user(client, args)

                    else:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.CREATE_INCIDENT_TYPE)
                        created_user = client.create_user(app_profile)
                        user_profile.set_result(
                            action=IAMActions.CREATE_USER,
                            active=created_user.is_active,
                            iden=created_user.id,
                            email=user_profile.get_attribute('email') or created_user.email,
                            username=created_user.username,
                            details=created_user.full_data
                        )

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.CREATE_USER)

            return user_profile

        def update_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If the user is disabled and `allow-enable` argument is `true`, also enables the user.
                If the user does not exist in the app and the `create-if-not-exist` parameter is checked, creates the user.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-update-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            allow_enable = args.get('allow-enable') == 'true' and self.is_enable_enabled
            if not self.is_update_enabled:
                user_profile.set_result(action=IAMActions.UPDATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs, use_old_user_data=True)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.UPDATE_INCIDENT_TYPE)

                        if allow_enable and not user_app_data.is_active:
                            client.enable_user(user_app_data.id)

                        updated_user = client.update_user(user_app_data.id, app_profile)

                        if updated_user.is_active is None:
                            updated_user.is_active = True if allow_enable else user_app_data.is_active

                        user_profile.set_result(
                            action=IAMActions.UPDATE_USER,
                            active=updated_user.is_active,
                            iden=updated_user.id,
                            email=user_profile.get_attribute('email') or updated_user.email or user_app_data.email,
                            username=updated_user.username,
                            details=updated_user.full_data
                        )
                    else:
                        if self.create_if_not_exists:
                            user_profile = self.create_user(client, args)
                        else:
                            _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                            user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                    skip=True,
                                                    skip_reason=error_message)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.UPDATE_USER)

            return user_profile


    def get_first_primary_email_by_scim_schema(res: Dict):
        return next((email.get('value') for email in res.get('emails', []) if email.get('primary')), None)

    register_module_line('IAMApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###  # noqa E402

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('ServiceNow IAM', 'end', __line__())
  subtype: python3
  type: python
system: true
